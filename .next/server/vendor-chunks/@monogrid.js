/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@monogrid";
exports.ids = ["vendor-chunks/@monogrid"];
exports.modules = {

/***/ "(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.umd.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@monogrid/gainmap-js/dist/decode.umd.cjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("/**\n * @monogrid/gainmap-js v3.1.0\n * With ‚ù§Ô∏è, by MONOGRID <rnd@monogrid.com>\n */\n\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\")) :\n    0;\n})(this, (function (exports, three) { 'use strict';\n\n    const getBufferForType = (type, width, height) => {\n        let out;\n        switch (type) {\n            case three.UnsignedByteType:\n                out = new Uint8ClampedArray(width * height * 4);\n                break;\n            case three.HalfFloatType:\n                out = new Uint16Array(width * height * 4);\n                break;\n            case three.UnsignedIntType:\n                out = new Uint32Array(width * height * 4);\n                break;\n            case three.ByteType:\n                out = new Int8Array(width * height * 4);\n                break;\n            case three.ShortType:\n                out = new Int16Array(width * height * 4);\n                break;\n            case three.IntType:\n                out = new Int32Array(width * height * 4);\n                break;\n            case three.FloatType:\n                out = new Float32Array(width * height * 4);\n                break;\n            default:\n                throw new Error('Unsupported data type');\n        }\n        return out;\n    };\n    let _canReadPixelsResult;\n    /**\n     * Test if this browser implementation can correctly read pixels from the specified\n     * Render target type.\n     *\n     * Runs only once\n     *\n     * @param type\n     * @param renderer\n     * @param camera\n     * @param renderTargetOptions\n     * @returns\n     */\n    const canReadPixels = (type, renderer, camera, renderTargetOptions) => {\n        if (_canReadPixelsResult !== undefined)\n            return _canReadPixelsResult;\n        const testRT = new three.WebGLRenderTarget(1, 1, renderTargetOptions);\n        renderer.setRenderTarget(testRT);\n        const mesh = new three.Mesh(new three.PlaneGeometry(), new three.MeshBasicMaterial({ color: 0xffffff }));\n        renderer.render(mesh, camera);\n        renderer.setRenderTarget(null);\n        const out = getBufferForType(type, testRT.width, testRT.height);\n        renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);\n        testRT.dispose();\n        mesh.geometry.dispose();\n        mesh.material.dispose();\n        _canReadPixelsResult = out[0] !== 0;\n        return _canReadPixelsResult;\n    };\n    /**\n     * Utility class used for rendering a texture with a material\n     *\n     * @category Core\n     * @group Core\n     */\n    class QuadRenderer {\n        /**\n         * Constructs a new QuadRenderer\n         *\n         * @param options Parameters for this QuadRenderer\n         */\n        constructor(options) {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n            this._rendererIsDisposable = false;\n            this._supportsReadPixels = true;\n            /**\n             * Renders the input texture using the specified material\n             */\n            this.render = () => {\n                this._renderer.setRenderTarget(this._renderTarget);\n                try {\n                    this._renderer.render(this._scene, this._camera);\n                }\n                catch (e) {\n                    this._renderer.setRenderTarget(null);\n                    throw e;\n                }\n                this._renderer.setRenderTarget(null);\n            };\n            this._width = options.width;\n            this._height = options.height;\n            this._type = options.type;\n            this._colorSpace = options.colorSpace;\n            const rtOptions = {\n                // fixed options\n                format: three.RGBAFormat,\n                depthBuffer: false,\n                stencilBuffer: false,\n                // user options\n                type: this._type, // set in class property\n                colorSpace: this._colorSpace, // set in class property\n                anisotropy: ((_a = options.renderTargetOptions) === null || _a === void 0 ? void 0 : _a.anisotropy) !== undefined ? (_b = options.renderTargetOptions) === null || _b === void 0 ? void 0 : _b.anisotropy : 1,\n                generateMipmaps: ((_c = options.renderTargetOptions) === null || _c === void 0 ? void 0 : _c.generateMipmaps) !== undefined ? (_d = options.renderTargetOptions) === null || _d === void 0 ? void 0 : _d.generateMipmaps : false,\n                magFilter: ((_e = options.renderTargetOptions) === null || _e === void 0 ? void 0 : _e.magFilter) !== undefined ? (_f = options.renderTargetOptions) === null || _f === void 0 ? void 0 : _f.magFilter : three.LinearFilter,\n                minFilter: ((_g = options.renderTargetOptions) === null || _g === void 0 ? void 0 : _g.minFilter) !== undefined ? (_h = options.renderTargetOptions) === null || _h === void 0 ? void 0 : _h.minFilter : three.LinearFilter,\n                samples: ((_j = options.renderTargetOptions) === null || _j === void 0 ? void 0 : _j.samples) !== undefined ? (_k = options.renderTargetOptions) === null || _k === void 0 ? void 0 : _k.samples : undefined,\n                wrapS: ((_l = options.renderTargetOptions) === null || _l === void 0 ? void 0 : _l.wrapS) !== undefined ? (_m = options.renderTargetOptions) === null || _m === void 0 ? void 0 : _m.wrapS : three.ClampToEdgeWrapping,\n                wrapT: ((_o = options.renderTargetOptions) === null || _o === void 0 ? void 0 : _o.wrapT) !== undefined ? (_p = options.renderTargetOptions) === null || _p === void 0 ? void 0 : _p.wrapT : three.ClampToEdgeWrapping\n            };\n            this._material = options.material;\n            if (options.renderer) {\n                this._renderer = options.renderer;\n            }\n            else {\n                this._renderer = QuadRenderer.instantiateRenderer();\n                this._rendererIsDisposable = true;\n            }\n            this._scene = new three.Scene();\n            this._camera = new three.OrthographicCamera();\n            this._camera.position.set(0, 0, 10);\n            this._camera.left = -0.5;\n            this._camera.right = 0.5;\n            this._camera.top = 0.5;\n            this._camera.bottom = -0.5;\n            this._camera.updateProjectionMatrix();\n            if (!canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {\n                let alternativeType;\n                switch (this._type) {\n                    case three.HalfFloatType:\n                        alternativeType = this._renderer.extensions.has('EXT_color_buffer_float') ? three.FloatType : undefined;\n                        break;\n                }\n                if (alternativeType !== undefined) {\n                    console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${three.FloatType}`);\n                    this._type = alternativeType;\n                }\n                else {\n                    this._supportsReadPixels = false;\n                    console.warn('This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown');\n                }\n            }\n            this._quad = new three.Mesh(new three.PlaneGeometry(), this._material);\n            this._quad.geometry.computeBoundingBox();\n            this._scene.add(this._quad);\n            this._renderTarget = new three.WebGLRenderTarget(this.width, this.height, rtOptions);\n            this._renderTarget.texture.mapping = ((_q = options.renderTargetOptions) === null || _q === void 0 ? void 0 : _q.mapping) !== undefined ? (_r = options.renderTargetOptions) === null || _r === void 0 ? void 0 : _r.mapping : three.UVMapping;\n        }\n        /**\n         * Instantiates a temporary renderer\n         *\n         * @returns\n         */\n        static instantiateRenderer() {\n            const renderer = new three.WebGLRenderer();\n            renderer.setSize(128, 128);\n            // renderer.outputColorSpace = SRGBColorSpace\n            // renderer.toneMapping = LinearToneMapping\n            // renderer.debug.checkShaderErrors = false\n            // this._rendererIsDisposable = true\n            return renderer;\n        }\n        /**\n         * Obtains a Buffer containing the rendered texture.\n         *\n         * @throws Error if the browser cannot read pixels from this RenderTarget type.\n         * @returns a TypedArray containing RGBA values from this renderer\n         */\n        toArray() {\n            if (!this._supportsReadPixels)\n                throw new Error('Can\\'t read pixels in this browser');\n            const out = getBufferForType(this._type, this._width, this._height);\n            this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);\n            return out;\n        }\n        /**\n         * Performs a readPixel operation in the renderTarget\n         * and returns a DataTexture containing the read data\n         *\n         * @param options options\n         * @returns\n         */\n        toDataTexture(options) {\n            const returnValue = new three.DataTexture(\n            // fixed values\n            this.toArray(), this.width, this.height, three.RGBAFormat, this._type, \n            // user values\n            (options === null || options === void 0 ? void 0 : options.mapping) || three.UVMapping, (options === null || options === void 0 ? void 0 : options.wrapS) || three.ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.wrapT) || three.ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.magFilter) || three.LinearFilter, (options === null || options === void 0 ? void 0 : options.minFilter) || three.LinearFilter, (options === null || options === void 0 ? void 0 : options.anisotropy) || 1, \n            // fixed value\n            three.LinearSRGBColorSpace);\n            // set this afterwards, we can't set it in constructor\n            returnValue.generateMipmaps = (options === null || options === void 0 ? void 0 : options.generateMipmaps) !== undefined ? options === null || options === void 0 ? void 0 : options.generateMipmaps : false;\n            return returnValue;\n        }\n        /**\n         * If using a disposable renderer, it will dispose it.\n         */\n        disposeOnDemandRenderer() {\n            this._renderer.setRenderTarget(null);\n            if (this._rendererIsDisposable) {\n                this._renderer.dispose();\n                this._renderer.forceContextLoss();\n            }\n        }\n        /**\n         * Will dispose of **all** assets used by this renderer.\n         *\n         *\n         * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later\n         * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`\n         * or are otherwise done with it.\n         *\n         * @example\n         * ```js\n         * const loader = new HDRJPGLoader(renderer)\n         * const result = await loader.loadAsync('gainmap.jpeg')\n         * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )\n         * // DO NOT dispose the renderTarget here,\n         * // it is used directly in the material\n         * result.dispose()\n         * ```\n         *\n         * @example\n         * ```js\n         * const loader = new HDRJPGLoader(renderer)\n         * const pmremGenerator = new PMREMGenerator( renderer );\n         * const result = await loader.loadAsync('gainmap.jpeg')\n         * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)\n         * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )\n         * // renderTarget can be disposed here\n         * // because it was used to generate a PMREM texture\n         * result.dispose(true)\n         * ```\n         */\n        dispose(disposeRenderTarget) {\n            this.disposeOnDemandRenderer();\n            if (disposeRenderTarget) {\n                this.renderTarget.dispose();\n            }\n            // dispose shader material texture uniforms\n            if (this.material instanceof three.ShaderMaterial) {\n                Object.values(this.material.uniforms).forEach(v => {\n                    if (v.value instanceof three.Texture)\n                        v.value.dispose();\n                });\n            }\n            // dispose other material properties\n            Object.values(this.material).forEach(value => {\n                if (value instanceof three.Texture)\n                    value.dispose();\n            });\n            this.material.dispose();\n            this._quad.geometry.dispose();\n        }\n        /**\n         * Width of the texture\n         */\n        get width() { return this._width; }\n        set width(value) {\n            this._width = value;\n            this._renderTarget.setSize(this._width, this._height);\n        }\n        /**\n         * Height of the texture\n         */\n        get height() { return this._height; }\n        set height(value) {\n            this._height = value;\n            this._renderTarget.setSize(this._width, this._height);\n        }\n        /**\n         * The renderer used\n         */\n        get renderer() { return this._renderer; }\n        /**\n         * The `WebGLRenderTarget` used.\n         */\n        get renderTarget() { return this._renderTarget; }\n        set renderTarget(value) {\n            this._renderTarget = value;\n            this._width = value.width;\n            this._height = value.height;\n            // this._type = value.texture.type\n        }\n        /**\n         * The `Material` used.\n         */\n        get material() { return this._material; }\n        /**\n         *\n         */\n        get type() { return this._type; }\n        get colorSpace() { return this._colorSpace; }\n    }\n\n    const vertexShader = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n    const fragmentShader = /* glsl */ `\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n`;\n    /**\n     * A Material which is able to decode the Gainmap into a full HDR Representation\n     *\n     * @category Materials\n     * @group Materials\n     */\n    class GainMapDecoderMaterial extends three.ShaderMaterial {\n        /**\n         *\n         * @param params\n         */\n        constructor({ gamma, offsetHdr, offsetSdr, gainMapMin, gainMapMax, maxDisplayBoost, hdrCapacityMin, hdrCapacityMax, sdr, gainMap }) {\n            super({\n                name: 'GainMapDecoderMaterial',\n                vertexShader,\n                fragmentShader,\n                uniforms: {\n                    sdr: { value: sdr },\n                    gainMap: { value: gainMap },\n                    gamma: { value: new three.Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2]) },\n                    offsetHdr: { value: new three.Vector3().fromArray(offsetHdr) },\n                    offsetSdr: { value: new three.Vector3().fromArray(offsetSdr) },\n                    gainMapMin: { value: new three.Vector3().fromArray(gainMapMin) },\n                    gainMapMax: { value: new three.Vector3().fromArray(gainMapMax) },\n                    weightFactor: {\n                        value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n                    }\n                },\n                blending: three.NoBlending,\n                depthTest: false,\n                depthWrite: false\n            });\n            this._maxDisplayBoost = maxDisplayBoost;\n            this._hdrCapacityMin = hdrCapacityMin;\n            this._hdrCapacityMax = hdrCapacityMax;\n            this.needsUpdate = true;\n            this.uniformsNeedUpdate = true;\n        }\n        get sdr() { return this.uniforms.sdr.value; }\n        set sdr(value) { this.uniforms.sdr.value = value; }\n        get gainMap() { return this.uniforms.gainMap.value; }\n        set gainMap(value) { this.uniforms.gainMap.value = value; }\n        /**\n         * @see {@link GainMapMetadata.offsetHdr}\n         */\n        get offsetHdr() { return this.uniforms.offsetHdr.value.toArray(); }\n        set offsetHdr(value) { this.uniforms.offsetHdr.value.fromArray(value); }\n        /**\n         * @see {@link GainMapMetadata.offsetSdr}\n         */\n        get offsetSdr() { return this.uniforms.offsetSdr.value.toArray(); }\n        set offsetSdr(value) { this.uniforms.offsetSdr.value.fromArray(value); }\n        /**\n         * @see {@link GainMapMetadata.gainMapMin}\n         */\n        get gainMapMin() { return this.uniforms.gainMapMin.value.toArray(); }\n        set gainMapMin(value) { this.uniforms.gainMapMin.value.fromArray(value); }\n        /**\n         * @see {@link GainMapMetadata.gainMapMax}\n         */\n        get gainMapMax() { return this.uniforms.gainMapMax.value.toArray(); }\n        set gainMapMax(value) { this.uniforms.gainMapMax.value.fromArray(value); }\n        /**\n         * @see {@link GainMapMetadata.gamma}\n         */\n        get gamma() {\n            const g = this.uniforms.gamma.value;\n            return [1 / g.x, 1 / g.y, 1 / g.z];\n        }\n        set gamma(value) {\n            const g = this.uniforms.gamma.value;\n            g.x = 1.0 / value[0];\n            g.y = 1.0 / value[1];\n            g.z = 1.0 / value[2];\n        }\n        /**\n         * @see {@link GainMapMetadata.hdrCapacityMin}\n         * @remarks Logarithmic space\n         */\n        get hdrCapacityMin() { return this._hdrCapacityMin; }\n        set hdrCapacityMin(value) {\n            this._hdrCapacityMin = value;\n            this.calculateWeight();\n        }\n        /**\n         * @see {@link GainMapMetadata.hdrCapacityMin}\n         * @remarks Logarithmic space\n         */\n        get hdrCapacityMax() { return this._hdrCapacityMax; }\n        set hdrCapacityMax(value) {\n            this._hdrCapacityMax = value;\n            this.calculateWeight();\n        }\n        /**\n         * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n         * @remarks Non Logarithmic space\n         */\n        get maxDisplayBoost() { return this._maxDisplayBoost; }\n        set maxDisplayBoost(value) {\n            this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n            this.calculateWeight();\n        }\n        calculateWeight() {\n            const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n            this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n        }\n    }\n\n    /**\n     * Decodes a gain map using a WebGLRenderTarget\n     *\n     * @category Decoding Functions\n     * @group Decoding Functions\n     * @example\n     * import { decode } from '@monogrid/gainmap-js'\n     * import {\n     *   Mesh,\n     *   MeshBasicMaterial,\n     *   PerspectiveCamera,\n     *   PlaneGeometry,\n     *   Scene,\n     *   TextureLoader,\n     *   WebGLRenderer\n     * } from 'three'\n     *\n     * const renderer = new WebGLRenderer()\n     *\n     * const textureLoader = new TextureLoader()\n     *\n     * // load SDR Representation\n     * const sdr = await textureLoader.loadAsync('sdr.jpg')\n     * // load Gain map recovery image\n     * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n     * // load metadata\n     * const metadata = await (await fetch('metadata.json')).json()\n     *\n     * const result = await decode({\n     *   sdr,\n     *   gainMap,\n     *   // this allows to use `result.renderTarget.texture` directly\n     *   renderer,\n     *   // this will restore the full HDR range\n     *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n     *   ...metadata\n     * })\n     *\n     * const scene = new Scene()\n     * // `result` can be used to populate a Texture\n     * const mesh = new Mesh(\n     *   new PlaneGeometry(),\n     *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n     * )\n     * scene.add(mesh)\n     * renderer.render(scene, new PerspectiveCamera())\n     *\n     * // result must be manually disposed\n     * // when you are done using it\n     * result.dispose()\n     *\n     * @param params\n     * @returns\n     * @throws {Error} if the WebGLRenderer fails to render the gain map\n     */\n    const decode = (params) => {\n        const { sdr, gainMap, renderer } = params;\n        if (sdr.colorSpace !== three.SRGBColorSpace) {\n            console.warn('SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically');\n            sdr.colorSpace = three.SRGBColorSpace;\n        }\n        sdr.needsUpdate = true;\n        if (gainMap.colorSpace !== three.LinearSRGBColorSpace) {\n            console.warn('Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically');\n            gainMap.colorSpace = three.LinearSRGBColorSpace;\n        }\n        gainMap.needsUpdate = true;\n        const material = new GainMapDecoderMaterial({\n            ...params,\n            sdr,\n            gainMap\n        });\n        const quadRenderer = new QuadRenderer({\n            // TODO: three types are generic, eslint complains here, see how we can solve\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n            width: sdr.image.width,\n            // TODO: three types are generic, eslint complains here, see how we can solve\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n            height: sdr.image.height,\n            type: three.HalfFloatType,\n            colorSpace: three.LinearSRGBColorSpace,\n            material,\n            renderer,\n            renderTargetOptions: params.renderTargetOptions\n        });\n        try {\n            quadRenderer.render();\n        }\n        catch (e) {\n            quadRenderer.disposeOnDemandRenderer();\n            throw e;\n        }\n        return quadRenderer;\n    };\n\n    class GainMapNotFoundError extends Error {\n    }\n\n    class XMPMetadataNotFoundError extends Error {\n    }\n\n    const getXMLValue = (xml, tag, defaultValue) => {\n        // Check for attribute format first: tag=\"value\"\n        const attributeMatch = new RegExp(`${tag}=\"([^\"]*)\"`, 'i').exec(xml);\n        if (attributeMatch)\n            return attributeMatch[1];\n        // Check for tag format: <tag>value</tag> or <tag><rdf:li>value</rdf:li>...</tag>\n        const tagMatch = new RegExp(`<${tag}[^>]*>([\\\\s\\\\S]*?)</${tag}>`, 'i').exec(xml);\n        if (tagMatch) {\n            // Check if it contains rdf:li elements\n            const liValues = tagMatch[1].match(/<rdf:li>([^<]*)<\\/rdf:li>/g);\n            if (liValues && liValues.length === 3) {\n                return liValues.map(v => v.replace(/<\\/?rdf:li>/g, ''));\n            }\n            return tagMatch[1].trim();\n        }\n        if (defaultValue !== undefined)\n            return defaultValue;\n        throw new Error(`Can't find ${tag} in gainmap metadata`);\n    };\n    const extractXMP = (input) => {\n        let str;\n        // support node test environment\n        if (typeof TextDecoder !== 'undefined')\n            str = new TextDecoder().decode(input);\n        else\n            str = input.toString();\n        let start = str.indexOf('<x:xmpmeta');\n        while (start !== -1) {\n            const end = str.indexOf('x:xmpmeta>', start);\n            const xmpBlock = str.slice(start, end + 10);\n            try {\n                const gainMapMin = getXMLValue(xmpBlock, 'hdrgm:GainMapMin', '0');\n                const gainMapMax = getXMLValue(xmpBlock, 'hdrgm:GainMapMax');\n                const gamma = getXMLValue(xmpBlock, 'hdrgm:Gamma', '1');\n                const offsetSDR = getXMLValue(xmpBlock, 'hdrgm:OffsetSDR', '0.015625');\n                const offsetHDR = getXMLValue(xmpBlock, 'hdrgm:OffsetHDR', '0.015625');\n                // These are always attributes, so we can use a simpler regex\n                const hdrCapacityMinMatch = /hdrgm:HDRCapacityMin=\"([^\"]*)\"/.exec(xmpBlock);\n                const hdrCapacityMin = hdrCapacityMinMatch ? hdrCapacityMinMatch[1] : '0';\n                const hdrCapacityMaxMatch = /hdrgm:HDRCapacityMax=\"([^\"]*)\"/.exec(xmpBlock);\n                if (!hdrCapacityMaxMatch)\n                    throw new Error('Incomplete gainmap metadata');\n                const hdrCapacityMax = hdrCapacityMaxMatch[1];\n                return {\n                    gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(v => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],\n                    gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(v => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],\n                    gamma: Array.isArray(gamma) ? gamma.map(v => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],\n                    offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(v => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],\n                    offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(v => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],\n                    hdrCapacityMin: parseFloat(hdrCapacityMin),\n                    hdrCapacityMax: parseFloat(hdrCapacityMax)\n                };\n            }\n            catch (e) {\n                // Continue searching for another xmpmeta block if this one fails\n            }\n            start = str.indexOf('<x:xmpmeta', end);\n        }\n    };\n\n    /**\n     * MPF Extractor (Multi Picture Format Extractor)\n     * By Henrik S Nilsson 2019\n     *\n     * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\n     * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\n     *\n     * Overly commented, and without intention of being complete or production ready.\n     * Created to extract depth maps from iPhone images, and to learn about image metadata.\n     * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\n     */\n    class MPFExtractor {\n        constructor(options) {\n            this.options = {\n                debug: options && options.debug !== undefined ? options.debug : false,\n                extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n                extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n            };\n        }\n        extract(imageArrayBuffer) {\n            return new Promise((resolve, reject) => {\n                const debug = this.options.debug;\n                const dataView = new DataView(imageArrayBuffer.buffer);\n                // If you're executing this line on a big endian machine, it'll be reversed.\n                // bigEnd further down though, refers to the endianness of the image itself.\n                if (dataView.getUint16(0) !== 0xffd8) {\n                    reject(new Error('Not a valid jpeg'));\n                    return;\n                }\n                const length = dataView.byteLength;\n                let offset = 2;\n                let loops = 0;\n                let marker; // APP# marker\n                while (offset < length) {\n                    if (++loops > 250) {\n                        reject(new Error(`Found no marker after ${loops} loops üòµ`));\n                        return;\n                    }\n                    if (dataView.getUint8(offset) !== 0xff) {\n                        reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));\n                        return;\n                    }\n                    marker = dataView.getUint8(offset + 1);\n                    if (debug)\n                        console.log(`Marker: ${marker.toString(16)}`);\n                    if (marker === 0xe2) {\n                        if (debug)\n                            console.log('Found APP2 marker (0xffe2)');\n                        // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n                        // Great way to visualize image information in html is using Exiftool. E.g.:\n                        // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n                        const formatPt = offset + 4;\n                        /*\n                         *  Structure of the MP Format Identifier\n                         *\n                         *  Offset Addr.  | Code (Hex)  | Description\n                         *  +00             ff            Marker Prefix      <-- offset\n                         *  +01             e2            APP2\n                         *  +02             #n            APP2 Field Length\n                         *  +03             #n            APP2 Field Length\n                         *  +04             4d            'M'                <-- formatPt\n                         *  +05             50            'P'\n                         *  +06             46            'F'\n                         *  +07             00            NULL\n                         *                                                   <-- tiffOffset\n                         */\n                        if (dataView.getUint32(formatPt) === 0x4d504600) {\n                            // Found MPF tag, so we start dig out sub images\n                            const tiffOffset = formatPt + 4;\n                            let bigEnd; // Endianness from TIFF header\n                            // Test for TIFF validity and endianness\n                            // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n                            if (dataView.getUint16(tiffOffset) === 0x4949) {\n                                bigEnd = false;\n                            }\n                            else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n                                bigEnd = true;\n                            }\n                            else {\n                                reject(new Error('No valid endianness marker found in TIFF header'));\n                                return;\n                            }\n                            if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n                                reject(new Error('Not valid TIFF data! (no 0x002A marker)'));\n                                return;\n                            }\n                            // 32 bit number stating the offset from the start of the 8 Byte MP Header\n                            // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n                            const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n                            if (firstIFDOffset < 0x00000008) {\n                                reject(new Error('Not valid TIFF data! (First offset less than 8)'));\n                                return;\n                            }\n                            // Move ahead to MP Index IFD\n                            // Assume we're at the first IFD, so firstIFDOffset points to\n                            // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n                            // we fail silently here due to this assumption)\n                            // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n                            const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n                            const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n                            // Extract info from MPEntries (starting after Count)\n                            const entriesStart = dirStart + 2;\n                            let numberOfImages = 0;\n                            for (let i = entriesStart; i < entriesStart + 12 * count; i += 12) {\n                                // Each entry is 12 Bytes long\n                                // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n                                if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                                    // stored in Last 4 bytes of its 12 Byte entry.\n                                    numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n                                }\n                            }\n                            const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n                            const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n                            const images = [];\n                            for (let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16) {\n                                const image = {\n                                    MPType: dataView.getUint32(i, !bigEnd),\n                                    size: dataView.getUint32(i + 4, !bigEnd),\n                                    // This offset is specified relative to the address of the MP Endian\n                                    // field in the MP Header, unless the image is a First Individual Image,\n                                    // in which case the value of the offset shall be NULL (0x00000000).\n                                    dataOffset: dataView.getUint32(i + 8, !bigEnd),\n                                    dependantImages: dataView.getUint32(i + 12, !bigEnd),\n                                    start: -1,\n                                    end: -1,\n                                    isFII: false\n                                };\n                                if (!image.dataOffset) {\n                                    // dataOffset is 0x00000000 for First Individual Image\n                                    image.start = 0;\n                                    image.isFII = true;\n                                }\n                                else {\n                                    image.start = tiffOffset + image.dataOffset;\n                                    image.isFII = false;\n                                }\n                                image.end = image.start + image.size;\n                                images.push(image);\n                            }\n                            if (this.options.extractNonFII && images.length) {\n                                const bufferBlob = new Blob([dataView]);\n                                const imgs = [];\n                                for (const image of images) {\n                                    if (image.isFII && !this.options.extractFII) {\n                                        continue; // Skip FII\n                                    }\n                                    const imageBlob = bufferBlob.slice(image.start, image.end + 1, 'image/jpeg');\n                                    // we don't need this\n                                    // const imageUrl = URL.createObjectURL(imageBlob)\n                                    // image.img = document.createElement('img')\n                                    // image.img.src = imageUrl\n                                    imgs.push(imageBlob);\n                                }\n                                resolve(imgs);\n                            }\n                        }\n                    }\n                    offset += 2 + dataView.getUint16(offset + 2);\n                }\n            });\n        }\n    }\n\n    /**\n     * Extracts XMP Metadata and the gain map recovery image\n     * from a single JPEG file.\n     *\n     * @category Decoding Functions\n     * @group Decoding Functions\n     * @param jpegFile an `Uint8Array` containing and encoded JPEG file\n     * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\n     * @throws Error if XMP Metadata is not found\n     * @throws Error if Gain map image is not found\n     * @example\n     * import { FileLoader } from 'three'\n     * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\n     *\n     * const jpegFile = await new FileLoader()\n     *  .setResponseType('arraybuffer')\n     *  .loadAsync('image.jpg')\n     *\n     * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\n     */\n    const extractGainmapFromJPEG = async (jpegFile) => {\n        const metadata = extractXMP(jpegFile);\n        if (!metadata)\n            throw new XMPMetadataNotFoundError('Gain map XMP metadata not found');\n        const mpfExtractor = new MPFExtractor({ extractFII: true, extractNonFII: true });\n        const images = await mpfExtractor.extract(jpegFile);\n        if (images.length !== 2)\n            throw new GainMapNotFoundError('Gain map recovery image not found');\n        return {\n            sdr: new Uint8Array(await images[0].arrayBuffer()),\n            gainMap: new Uint8Array(await images[1].arrayBuffer()),\n            metadata\n        };\n    };\n\n    /**\n     * private function, async get image from blob\n     *\n     * @param blob\n     * @returns\n     */\n    const getHTMLImageFromBlob = (blob) => {\n        return new Promise((resolve, reject) => {\n            const img = document.createElement('img');\n            img.onload = () => { resolve(img); };\n            img.onerror = (e) => { reject(e); };\n            img.src = URL.createObjectURL(blob);\n        });\n    };\n\n    class LoaderBase extends three.Loader {\n        /**\n         *\n         * @param renderer\n         * @param manager\n         */\n        constructor(renderer, manager) {\n            super(manager);\n            if (renderer)\n                this._renderer = renderer;\n            this._internalLoadingManager = new three.LoadingManager();\n        }\n        /**\n         * Specify the renderer to use when rendering the gain map\n         *\n         * @param renderer\n         * @returns\n         */\n        setRenderer(renderer) {\n            this._renderer = renderer;\n            return this;\n        }\n        /**\n         * Specify the renderTarget options to use when rendering the gain map\n         *\n         * @param options\n         * @returns\n         */\n        setRenderTargetOptions(options) {\n            this._renderTargetOptions = options;\n            return this;\n        }\n        /**\n         * @private\n         * @returns\n         */\n        prepareQuadRenderer() {\n            if (!this._renderer)\n                console.warn('WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.');\n            // temporary values\n            const material = new GainMapDecoderMaterial({\n                gainMapMax: [1, 1, 1],\n                gainMapMin: [0, 0, 0],\n                gamma: [1, 1, 1],\n                offsetHdr: [1, 1, 1],\n                offsetSdr: [1, 1, 1],\n                hdrCapacityMax: 1,\n                hdrCapacityMin: 0,\n                maxDisplayBoost: 1,\n                gainMap: new three.Texture(),\n                sdr: new three.Texture()\n            });\n            return new QuadRenderer({\n                width: 16,\n                height: 16,\n                type: three.HalfFloatType,\n                colorSpace: three.LinearSRGBColorSpace,\n                material,\n                renderer: this._renderer,\n                renderTargetOptions: this._renderTargetOptions\n            });\n        }\n        /**\n       * @private\n       * @param quadRenderer\n       * @param metadata\n       * @param sdrBuffer\n       * @param gainMapBuffer\n       */\n        async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n            // this is optional, will render a black gain-map if not present\n            const gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], { type: 'image/jpeg' }) : undefined;\n            const sdrBlob = new Blob([sdrBuffer], { type: 'image/jpeg' });\n            let sdrImage;\n            let gainMapImage;\n            let needsFlip = false;\n            if (typeof createImageBitmap === 'undefined') {\n                const res = await Promise.all([\n                    gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined),\n                    getHTMLImageFromBlob(sdrBlob)\n                ]);\n                gainMapImage = res[0];\n                sdrImage = res[1];\n                needsFlip = true;\n            }\n            else {\n                const res = await Promise.all([\n                    gainMapBlob ? createImageBitmap(gainMapBlob, { imageOrientation: 'flipY' }) : Promise.resolve(undefined),\n                    createImageBitmap(sdrBlob, { imageOrientation: 'flipY' })\n                ]);\n                gainMapImage = res[0];\n                sdrImage = res[1];\n            }\n            const gainMap = new three.Texture(gainMapImage || new ImageData(2, 2), three.UVMapping, three.ClampToEdgeWrapping, three.ClampToEdgeWrapping, three.LinearFilter, three.LinearMipMapLinearFilter, three.RGBAFormat, three.UnsignedByteType, 1, three.LinearSRGBColorSpace);\n            gainMap.flipY = needsFlip;\n            gainMap.needsUpdate = true;\n            const sdr = new three.Texture(sdrImage, three.UVMapping, three.ClampToEdgeWrapping, three.ClampToEdgeWrapping, three.LinearFilter, three.LinearMipMapLinearFilter, three.RGBAFormat, three.UnsignedByteType, 1, three.SRGBColorSpace);\n            sdr.flipY = needsFlip;\n            sdr.needsUpdate = true;\n            quadRenderer.width = sdrImage.width;\n            quadRenderer.height = sdrImage.height;\n            quadRenderer.material.gainMap = gainMap;\n            quadRenderer.material.sdr = sdr;\n            quadRenderer.material.gainMapMin = metadata.gainMapMin;\n            quadRenderer.material.gainMapMax = metadata.gainMapMax;\n            quadRenderer.material.offsetHdr = metadata.offsetHdr;\n            quadRenderer.material.offsetSdr = metadata.offsetSdr;\n            quadRenderer.material.gamma = metadata.gamma;\n            quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n            quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n            quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n            quadRenderer.material.needsUpdate = true;\n            quadRenderer.render();\n        }\n    }\n\n    /**\n     * A Three.js Loader for the gain map format.\n     *\n     * @category Loaders\n     * @group Loaders\n     *\n     * @example\n     * import { GainMapLoader } from '@monogrid/gainmap-js'\n     * import {\n     *   EquirectangularReflectionMapping,\n     *   LinearFilter,\n     *   Mesh,\n     *   MeshBasicMaterial,\n     *   PerspectiveCamera,\n     *   PlaneGeometry,\n     *   Scene,\n     *   WebGLRenderer\n     * } from 'three'\n     *\n     * const renderer = new WebGLRenderer()\n     *\n     * const loader = new GainMapLoader(renderer)\n     *\n     * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n     * // `result` can be used to populate a Texture\n     *\n     * const scene = new Scene()\n     * const mesh = new Mesh(\n     *   new PlaneGeometry(),\n     *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n     * )\n     * scene.add(mesh)\n     * renderer.render(scene, new PerspectiveCamera())\n     *\n     * // Starting from three.js r159\n     * // `result.renderTarget.texture` can\n     * // also be used as Equirectangular scene background\n     * //\n     * // it was previously needed to convert it\n     * // to a DataTexture with `result.toDataTexture()`\n     * scene.background = result.renderTarget.texture\n     * scene.background.mapping = EquirectangularReflectionMapping\n     *\n     * // result must be manually disposed\n     * // when you are done using it\n     * result.dispose()\n     *\n     */\n    class GainMapLoader extends LoaderBase {\n        /**\n         * Loads a gainmap using separate data\n         * * sdr image\n         * * gain map image\n         * * metadata json\n         *\n         * useful for webp gain maps\n         *\n         * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n         * @param onLoad Load complete callback, will receive the result\n         * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n         * @param onError Error callback\n         * @returns\n         */\n        load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {\n            const quadRenderer = this.prepareQuadRenderer();\n            let sdr;\n            let gainMap;\n            let metadata;\n            const loadCheck = async () => {\n                if (sdr && gainMap && metadata) {\n                    // solves #16\n                    try {\n                        await this.render(quadRenderer, metadata, sdr, gainMap);\n                    }\n                    catch (error) {\n                        this.manager.itemError(sdrUrl);\n                        this.manager.itemError(gainMapUrl);\n                        this.manager.itemError(metadataUrl);\n                        if (typeof onError === 'function')\n                            onError(error);\n                        quadRenderer.disposeOnDemandRenderer();\n                        return;\n                    }\n                    if (typeof onLoad === 'function')\n                        onLoad(quadRenderer);\n                    this.manager.itemEnd(sdrUrl);\n                    this.manager.itemEnd(gainMapUrl);\n                    this.manager.itemEnd(metadataUrl);\n                    quadRenderer.disposeOnDemandRenderer();\n                }\n            };\n            let sdrLengthComputable = true;\n            let sdrTotal = 0;\n            let sdrLoaded = 0;\n            let gainMapLengthComputable = true;\n            let gainMapTotal = 0;\n            let gainMapLoaded = 0;\n            let metadataLengthComputable = true;\n            let metadataTotal = 0;\n            let metadataLoaded = 0;\n            const progressHandler = () => {\n                if (typeof onProgress === 'function') {\n                    const total = sdrTotal + gainMapTotal + metadataTotal;\n                    const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n                    const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n                    onProgress(new ProgressEvent('progress', { lengthComputable, loaded, total }));\n                }\n            };\n            this.manager.itemStart(sdrUrl);\n            this.manager.itemStart(gainMapUrl);\n            this.manager.itemStart(metadataUrl);\n            const sdrLoader = new three.FileLoader(this._internalLoadingManager);\n            sdrLoader.setResponseType('arraybuffer');\n            sdrLoader.setRequestHeader(this.requestHeader);\n            sdrLoader.setPath(this.path);\n            sdrLoader.setWithCredentials(this.withCredentials);\n            sdrLoader.load(sdrUrl, async (buffer) => {\n                /* istanbul ignore if\n                 this condition exists only because of three.js types + strict mode\n                */\n                if (typeof buffer === 'string')\n                    throw new Error('Invalid sdr buffer');\n                sdr = buffer;\n                await loadCheck();\n            }, (e) => {\n                sdrLengthComputable = e.lengthComputable;\n                sdrLoaded = e.loaded;\n                sdrTotal = e.total;\n                progressHandler();\n            }, (error) => {\n                this.manager.itemError(sdrUrl);\n                if (typeof onError === 'function')\n                    onError(error);\n            });\n            const gainMapLoader = new three.FileLoader(this._internalLoadingManager);\n            gainMapLoader.setResponseType('arraybuffer');\n            gainMapLoader.setRequestHeader(this.requestHeader);\n            gainMapLoader.setPath(this.path);\n            gainMapLoader.setWithCredentials(this.withCredentials);\n            gainMapLoader.load(gainMapUrl, async (buffer) => {\n                /* istanbul ignore if\n                 this condition exists only because of three.js types + strict mode\n                */\n                if (typeof buffer === 'string')\n                    throw new Error('Invalid gainmap buffer');\n                gainMap = buffer;\n                await loadCheck();\n            }, (e) => {\n                gainMapLengthComputable = e.lengthComputable;\n                gainMapLoaded = e.loaded;\n                gainMapTotal = e.total;\n                progressHandler();\n            }, (error) => {\n                this.manager.itemError(gainMapUrl);\n                if (typeof onError === 'function')\n                    onError(error);\n            });\n            const metadataLoader = new three.FileLoader(this._internalLoadingManager);\n            // metadataLoader.setResponseType('json')\n            metadataLoader.setRequestHeader(this.requestHeader);\n            metadataLoader.setPath(this.path);\n            metadataLoader.setWithCredentials(this.withCredentials);\n            metadataLoader.load(metadataUrl, async (json) => {\n                /* istanbul ignore if\n                 this condition exists only because of three.js types + strict mode\n                */\n                if (typeof json !== 'string')\n                    throw new Error('Invalid metadata string');\n                // TODO: implement check on JSON file and remove this eslint disable\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                metadata = JSON.parse(json);\n                await loadCheck();\n            }, (e) => {\n                metadataLengthComputable = e.lengthComputable;\n                metadataLoaded = e.loaded;\n                metadataTotal = e.total;\n                progressHandler();\n            }, (error) => {\n                this.manager.itemError(metadataUrl);\n                if (typeof onError === 'function')\n                    onError(error);\n            });\n            return quadRenderer;\n        }\n    }\n\n    /**\n     * A Three.js Loader for a JPEG with embedded gainmap metadata.\n     *\n     * @category Loaders\n     * @group Loaders\n     *\n     * @example\n     * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n     * import {\n     *   EquirectangularReflectionMapping,\n     *   LinearFilter,\n     *   Mesh,\n     *   MeshBasicMaterial,\n     *   PerspectiveCamera,\n     *   PlaneGeometry,\n     *   Scene,\n     *   WebGLRenderer\n     * } from 'three'\n     *\n     * const renderer = new WebGLRenderer()\n     *\n     * const loader = new HDRJPGLoader(renderer)\n     *\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * // `result` can be used to populate a Texture\n     *\n     * const scene = new Scene()\n     * const mesh = new Mesh(\n     *   new PlaneGeometry(),\n     *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n     * )\n     * scene.add(mesh)\n     * renderer.render(scene, new PerspectiveCamera())\n     *\n     * // Starting from three.js r159\n     * // `result.renderTarget.texture` can\n     * // also be used as Equirectangular scene background\n     * //\n     * // it was previously needed to convert it\n     * // to a DataTexture with `result.toDataTexture()`\n     * scene.background = result.renderTarget.texture\n     * scene.background.mapping = EquirectangularReflectionMapping\n     *\n     * // result must be manually disposed\n     * // when you are done using it\n     * result.dispose()\n     *\n     */\n    class HDRJPGLoader extends LoaderBase {\n        /**\n         * Loads a JPEG containing gain map metadata\n         * Renders a normal SDR image if gainmap data is not found\n         *\n         * @param url An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n         * @param onLoad Load complete callback, will receive the result\n         * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n         * @param onError Error callback\n         * @returns\n         */\n        load(url, onLoad, onProgress, onError) {\n            const quadRenderer = this.prepareQuadRenderer();\n            const loader = new three.FileLoader(this._internalLoadingManager);\n            loader.setResponseType('arraybuffer');\n            loader.setRequestHeader(this.requestHeader);\n            loader.setPath(this.path);\n            loader.setWithCredentials(this.withCredentials);\n            this.manager.itemStart(url);\n            loader.load(url, async (jpeg) => {\n                /* istanbul ignore if\n                 this condition exists only because of three.js types + strict mode\n                */\n                if (typeof jpeg === 'string')\n                    throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');\n                const jpegBuffer = new Uint8Array(jpeg);\n                let sdrJPEG;\n                let gainMapJPEG;\n                let metadata;\n                try {\n                    const extractionResult = await extractGainmapFromJPEG(jpegBuffer);\n                    // gain map is successfully reconstructed\n                    sdrJPEG = extractionResult.sdr;\n                    gainMapJPEG = extractionResult.gainMap;\n                    metadata = extractionResult.metadata;\n                }\n                catch (e) {\n                    // render the SDR version if this is not a gainmap\n                    if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {\n                        console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);\n                        metadata = {\n                            gainMapMin: [0, 0, 0],\n                            gainMapMax: [1, 1, 1],\n                            gamma: [1, 1, 1],\n                            hdrCapacityMin: 0,\n                            hdrCapacityMax: 1,\n                            offsetHdr: [0, 0, 0],\n                            offsetSdr: [0, 0, 0]\n                        };\n                        sdrJPEG = jpegBuffer;\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n                // solves #16\n                try {\n                    await this.render(quadRenderer, metadata, sdrJPEG, gainMapJPEG);\n                }\n                catch (error) {\n                    this.manager.itemError(url);\n                    if (typeof onError === 'function')\n                        onError(error);\n                    quadRenderer.disposeOnDemandRenderer();\n                    return;\n                }\n                if (typeof onLoad === 'function')\n                    onLoad(quadRenderer);\n                this.manager.itemEnd(url);\n                quadRenderer.disposeOnDemandRenderer();\n            }, onProgress, (error) => {\n                this.manager.itemError(url);\n                if (typeof onError === 'function')\n                    onError(error);\n            });\n            return quadRenderer;\n        }\n    }\n\n    exports.GainMapDecoderMaterial = GainMapDecoderMaterial;\n    exports.GainMapLoader = GainMapLoader;\n    exports.HDRJPGLoader = HDRJPGLoader;\n    exports.JPEGRLoader = HDRJPGLoader;\n    exports.MPFExtractor = MPFExtractor;\n    exports.QuadRenderer = QuadRenderer;\n    exports.decode = decode;\n    exports.extractGainmapFromJPEG = extractGainmapFromJPEG;\n    exports.extractXMP = extractXMP;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9kZWNvZGUudW1kLmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBNEQsb0JBQW9CLG1CQUFPLENBQUMseURBQU87QUFDbkcsSUFBSSxDQUNzSTtBQUMxSSxDQUFDLHFDQUFxQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixpQkFBaUI7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLFlBQVksOEJBQThCLGdC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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0NBQWtDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLElBQUk7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtc3RhcnRlci1wcmlzbWljLW1pbmltYWwvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9kZWNvZGUudW1kLmNqcz83ZjJhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vbm9ncmlkL2dhaW5tYXAtanMgdjMuMS4wXG4gKiBXaXRoIOKdpO+4jywgYnkgTU9OT0dSSUQgPHJuZEBtb25vZ3JpZC5jb20+XG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ3RocmVlJykpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ3RocmVlJ10sIGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbFtcIkBtb25vZ3JpZC9nYWlubWFwLWpzXCJdID0ge30sIGdsb2JhbC50aHJlZSkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCB0aHJlZSkgeyAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCBnZXRCdWZmZXJGb3JUeXBlID0gKHR5cGUsIHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICAgICAgbGV0IG91dDtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIHRocmVlLlVuc2lnbmVkQnl0ZVR5cGU6XG4gICAgICAgICAgICAgICAgb3V0ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRocmVlLkhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgICAgICAgb3V0ID0gbmV3IFVpbnQxNkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRocmVlLlVuc2lnbmVkSW50VHlwZTpcbiAgICAgICAgICAgICAgICBvdXQgPSBuZXcgVWludDMyQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhyZWUuQnl0ZVR5cGU6XG4gICAgICAgICAgICAgICAgb3V0ID0gbmV3IEludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0aHJlZS5TaG9ydFR5cGU6XG4gICAgICAgICAgICAgICAgb3V0ID0gbmV3IEludDE2QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhyZWUuSW50VHlwZTpcbiAgICAgICAgICAgICAgICBvdXQgPSBuZXcgSW50MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0aHJlZS5GbG9hdFR5cGU6XG4gICAgICAgICAgICAgICAgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGRhdGEgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBsZXQgX2NhblJlYWRQaXhlbHNSZXN1bHQ7XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiB0aGlzIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gY2FuIGNvcnJlY3RseSByZWFkIHBpeGVscyBmcm9tIHRoZSBzcGVjaWZpZWRcbiAgICAgKiBSZW5kZXIgdGFyZ2V0IHR5cGUuXG4gICAgICpcbiAgICAgKiBSdW5zIG9ubHkgb25jZVxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGVcbiAgICAgKiBAcGFyYW0gcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gY2FtZXJhXG4gICAgICogQHBhcmFtIHJlbmRlclRhcmdldE9wdGlvbnNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGNvbnN0IGNhblJlYWRQaXhlbHMgPSAodHlwZSwgcmVuZGVyZXIsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0T3B0aW9ucykgPT4ge1xuICAgICAgICBpZiAoX2NhblJlYWRQaXhlbHNSZXN1bHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBfY2FuUmVhZFBpeGVsc1Jlc3VsdDtcbiAgICAgICAgY29uc3QgdGVzdFJUID0gbmV3IHRocmVlLldlYkdMUmVuZGVyVGFyZ2V0KDEsIDEsIHJlbmRlclRhcmdldE9wdGlvbnMpO1xuICAgICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGVzdFJUKTtcbiAgICAgICAgY29uc3QgbWVzaCA9IG5ldyB0aHJlZS5NZXNoKG5ldyB0aHJlZS5QbGFuZUdlb21ldHJ5KCksIG5ldyB0aHJlZS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiAweGZmZmZmZiB9KSk7XG4gICAgICAgIHJlbmRlcmVyLnJlbmRlcihtZXNoLCBjYW1lcmEpO1xuICAgICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgICAgIGNvbnN0IG91dCA9IGdldEJ1ZmZlckZvclR5cGUodHlwZSwgdGVzdFJULndpZHRoLCB0ZXN0UlQuaGVpZ2h0KTtcbiAgICAgICAgcmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVscyh0ZXN0UlQsIDAsIDAsIHRlc3RSVC53aWR0aCwgdGVzdFJULmhlaWdodCwgb3V0KTtcbiAgICAgICAgdGVzdFJULmRpc3Bvc2UoKTtcbiAgICAgICAgbWVzaC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgIG1lc2gubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICBfY2FuUmVhZFBpeGVsc1Jlc3VsdCA9IG91dFswXSAhPT0gMDtcbiAgICAgICAgcmV0dXJuIF9jYW5SZWFkUGl4ZWxzUmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXRpbGl0eSBjbGFzcyB1c2VkIGZvciByZW5kZXJpbmcgYSB0ZXh0dXJlIHdpdGggYSBtYXRlcmlhbFxuICAgICAqXG4gICAgICogQGNhdGVnb3J5IENvcmVcbiAgICAgKiBAZ3JvdXAgQ29yZVxuICAgICAqL1xuICAgIGNsYXNzIFF1YWRSZW5kZXJlciB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFF1YWRSZW5kZXJlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyBQYXJhbWV0ZXJzIGZvciB0aGlzIFF1YWRSZW5kZXJlclxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX20sIF9vLCBfcCwgX3EsIF9yO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXJJc0Rpc3Bvc2FibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3N1cHBvcnRzUmVhZFBpeGVscyA9IHRydWU7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlbmRlcnMgdGhlIGlucHV0IHRleHR1cmUgdXNpbmcgdGhlIHNwZWNpZmllZCBtYXRlcmlhbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnJlbmRlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5fcmVuZGVyVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXIodGhpcy5fc2NlbmUsIHRoaXMuX2NhbWVyYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFJlbmRlclRhcmdldChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KG51bGwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gb3B0aW9ucy53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IG9wdGlvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5fdHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yU3BhY2UgPSBvcHRpb25zLmNvbG9yU3BhY2U7XG4gICAgICAgICAgICBjb25zdCBydE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgLy8gZml4ZWQgb3B0aW9uc1xuICAgICAgICAgICAgICAgIGZvcm1hdDogdGhyZWUuUkdCQUZvcm1hdCxcbiAgICAgICAgICAgICAgICBkZXB0aEJ1ZmZlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgc3RlbmNpbEJ1ZmZlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgLy8gdXNlciBvcHRpb25zXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy5fdHlwZSwgLy8gc2V0IGluIGNsYXNzIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgY29sb3JTcGFjZTogdGhpcy5fY29sb3JTcGFjZSwgLy8gc2V0IGluIGNsYXNzIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgYW5pc290cm9weTogKChfYSA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFuaXNvdHJvcHkpICE9PSB1bmRlZmluZWQgPyAoX2IgPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hbmlzb3Ryb3B5IDogMSxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZU1pcG1hcHM6ICgoX2MgPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZW5lcmF0ZU1pcG1hcHMpICE9PSB1bmRlZmluZWQgPyAoX2QgPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5nZW5lcmF0ZU1pcG1hcHMgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtYWdGaWx0ZXI6ICgoX2UgPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5tYWdGaWx0ZXIpICE9PSB1bmRlZmluZWQgPyAoX2YgPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5tYWdGaWx0ZXIgOiB0aHJlZS5MaW5lYXJGaWx0ZXIsXG4gICAgICAgICAgICAgICAgbWluRmlsdGVyOiAoKF9nID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cubWluRmlsdGVyKSAhPT0gdW5kZWZpbmVkID8gKF9oID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2gubWluRmlsdGVyIDogdGhyZWUuTGluZWFyRmlsdGVyLFxuICAgICAgICAgICAgICAgIHNhbXBsZXM6ICgoX2ogPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5zYW1wbGVzKSAhPT0gdW5kZWZpbmVkID8gKF9rID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2suc2FtcGxlcyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB3cmFwUzogKChfbCA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucykgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLndyYXBTKSAhPT0gdW5kZWZpbmVkID8gKF9tID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX20ud3JhcFMgOiB0aHJlZS5DbGFtcFRvRWRnZVdyYXBwaW5nLFxuICAgICAgICAgICAgICAgIHdyYXBUOiAoKF9vID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX28ud3JhcFQpICE9PSB1bmRlZmluZWQgPyAoX3AgPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcC53cmFwVCA6IHRocmVlLkNsYW1wVG9FZGdlV3JhcHBpbmdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9tYXRlcmlhbCA9IG9wdGlvbnMubWF0ZXJpYWw7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yZW5kZXJlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gb3B0aW9ucy5yZW5kZXJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gUXVhZFJlbmRlcmVyLmluc3RhbnRpYXRlUmVuZGVyZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlcklzRGlzcG9zYWJsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zY2VuZSA9IG5ldyB0aHJlZS5TY2VuZSgpO1xuICAgICAgICAgICAgdGhpcy5fY2FtZXJhID0gbmV3IHRocmVlLk9ydGhvZ3JhcGhpY0NhbWVyYSgpO1xuICAgICAgICAgICAgdGhpcy5fY2FtZXJhLnBvc2l0aW9uLnNldCgwLCAwLCAxMCk7XG4gICAgICAgICAgICB0aGlzLl9jYW1lcmEubGVmdCA9IC0wLjU7XG4gICAgICAgICAgICB0aGlzLl9jYW1lcmEucmlnaHQgPSAwLjU7XG4gICAgICAgICAgICB0aGlzLl9jYW1lcmEudG9wID0gMC41O1xuICAgICAgICAgICAgdGhpcy5fY2FtZXJhLmJvdHRvbSA9IC0wLjU7XG4gICAgICAgICAgICB0aGlzLl9jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgICAgICAgaWYgKCFjYW5SZWFkUGl4ZWxzKHRoaXMuX3R5cGUsIHRoaXMuX3JlbmRlcmVyLCB0aGlzLl9jYW1lcmEsIHJ0T3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWx0ZXJuYXRpdmVUeXBlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHRocmVlLkhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZVR5cGUgPSB0aGlzLl9yZW5kZXJlci5leHRlbnNpb25zLmhhcygnRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpID8gdGhyZWUuRmxvYXRUeXBlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhbHRlcm5hdGl2ZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHJlYWRpbmcgcGl4ZWxzIGZyb20gJHt0aGlzLl90eXBlfSBSZW5kZXJUYXJnZXRzLCBzd2l0Y2hpbmcgdG8gJHt0aHJlZS5GbG9hdFR5cGV9YCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3R5cGUgPSBhbHRlcm5hdGl2ZVR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdXBwb3J0c1JlYWRQaXhlbHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGlzIGJyb3dzZXIgZG9zIG5vdCBzdXBwb3J0IHRvQXJyYXkgb3IgdG9EYXRhVGV4dHVyZSwgY2FsbHMgdG8gdGhvc2UgbWV0aG9kcyB3aWxsIHJlc3VsdCBpbiBhbiBlcnJvciB0aHJvd24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9xdWFkID0gbmV3IHRocmVlLk1lc2gobmV3IHRocmVlLlBsYW5lR2VvbWV0cnkoKSwgdGhpcy5fbWF0ZXJpYWwpO1xuICAgICAgICAgICAgdGhpcy5fcXVhZC5nZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgIHRoaXMuX3NjZW5lLmFkZCh0aGlzLl9xdWFkKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRhcmdldCA9IG5ldyB0aHJlZS5XZWJHTFJlbmRlclRhcmdldCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgcnRPcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRhcmdldC50ZXh0dXJlLm1hcHBpbmcgPSAoKF9xID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfcSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3EubWFwcGluZykgIT09IHVuZGVmaW5lZCA/IChfciA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucykgPT09IG51bGwgfHwgX3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yLm1hcHBpbmcgOiB0aHJlZS5VVk1hcHBpbmc7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc3RhbnRpYXRlcyBhIHRlbXBvcmFyeSByZW5kZXJlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGluc3RhbnRpYXRlUmVuZGVyZXIoKSB7XG4gICAgICAgICAgICBjb25zdCByZW5kZXJlciA9IG5ldyB0aHJlZS5XZWJHTFJlbmRlcmVyKCk7XG4gICAgICAgICAgICByZW5kZXJlci5zZXRTaXplKDEyOCwgMTI4KTtcbiAgICAgICAgICAgIC8vIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZVxuICAgICAgICAgICAgLy8gcmVuZGVyZXIudG9uZU1hcHBpbmcgPSBMaW5lYXJUb25lTWFwcGluZ1xuICAgICAgICAgICAgLy8gcmVuZGVyZXIuZGVidWcuY2hlY2tTaGFkZXJFcnJvcnMgPSBmYWxzZVxuICAgICAgICAgICAgLy8gdGhpcy5fcmVuZGVyZXJJc0Rpc3Bvc2FibGUgPSB0cnVlXG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyZXI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9idGFpbnMgYSBCdWZmZXIgY29udGFpbmluZyB0aGUgcmVuZGVyZWQgdGV4dHVyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyBFcnJvciBpZiB0aGUgYnJvd3NlciBjYW5ub3QgcmVhZCBwaXhlbHMgZnJvbSB0aGlzIFJlbmRlclRhcmdldCB0eXBlLlxuICAgICAgICAgKiBAcmV0dXJucyBhIFR5cGVkQXJyYXkgY29udGFpbmluZyBSR0JBIHZhbHVlcyBmcm9tIHRoaXMgcmVuZGVyZXJcbiAgICAgICAgICovXG4gICAgICAgIHRvQXJyYXkoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N1cHBvcnRzUmVhZFBpeGVscylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgcmVhZCBwaXhlbHMgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgICAgICAgICBjb25zdCBvdXQgPSBnZXRCdWZmZXJGb3JUeXBlKHRoaXMuX3R5cGUsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVscyh0aGlzLl9yZW5kZXJUYXJnZXQsIDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIG91dCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtcyBhIHJlYWRQaXhlbCBvcGVyYXRpb24gaW4gdGhlIHJlbmRlclRhcmdldFxuICAgICAgICAgKiBhbmQgcmV0dXJucyBhIERhdGFUZXh0dXJlIGNvbnRhaW5pbmcgdGhlIHJlYWQgZGF0YVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zXG4gICAgICAgICAqL1xuICAgICAgICB0b0RhdGFUZXh0dXJlKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gbmV3IHRocmVlLkRhdGFUZXh0dXJlKFxuICAgICAgICAgICAgLy8gZml4ZWQgdmFsdWVzXG4gICAgICAgICAgICB0aGlzLnRvQXJyYXkoKSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRocmVlLlJHQkFGb3JtYXQsIHRoaXMuX3R5cGUsIFxuICAgICAgICAgICAgLy8gdXNlciB2YWx1ZXNcbiAgICAgICAgICAgIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWFwcGluZykgfHwgdGhyZWUuVVZNYXBwaW5nLCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndyYXBTKSB8fCB0aHJlZS5DbGFtcFRvRWRnZVdyYXBwaW5nLCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndyYXBUKSB8fCB0aHJlZS5DbGFtcFRvRWRnZVdyYXBwaW5nLCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1hZ0ZpbHRlcikgfHwgdGhyZWUuTGluZWFyRmlsdGVyLCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1pbkZpbHRlcikgfHwgdGhyZWUuTGluZWFyRmlsdGVyLCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFuaXNvdHJvcHkpIHx8IDEsIFxuICAgICAgICAgICAgLy8gZml4ZWQgdmFsdWVcbiAgICAgICAgICAgIHRocmVlLkxpbmVhclNSR0JDb2xvclNwYWNlKTtcbiAgICAgICAgICAgIC8vIHNldCB0aGlzIGFmdGVyd2FyZHMsIHdlIGNhbid0IHNldCBpdCBpbiBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgcmV0dXJuVmFsdWUuZ2VuZXJhdGVNaXBtYXBzID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5nZW5lcmF0ZU1pcG1hcHMpICE9PSB1bmRlZmluZWQgPyBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2VuZXJhdGVNaXBtYXBzIDogZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHVzaW5nIGEgZGlzcG9zYWJsZSByZW5kZXJlciwgaXQgd2lsbCBkaXNwb3NlIGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVuZGVyZXJJc0Rpc3Bvc2FibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZm9yY2VDb250ZXh0TG9zcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaWxsIGRpc3Bvc2Ugb2YgKiphbGwqKiBhc3NldHMgdXNlZCBieSB0aGlzIHJlbmRlcmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGlzcG9zZVJlbmRlclRhcmdldCB3aWxsIGRpc3Bvc2Ugb2YgdGhlIHJlbmRlclRhcmdldCB3aGljaCB3aWxsIG5vdCBiZSB1c2FibGUgbGF0ZXJcbiAgICAgICAgICogc2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3UgcGFzc2VkIHRoZSBgcmVuZGVyVGFyZ2V0LnRleHR1cmVgIHRvIGEgYFBNUkVNR2VuZXJhdG9yYFxuICAgICAgICAgKiBvciBhcmUgb3RoZXJ3aXNlIGRvbmUgd2l0aCBpdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBganNcbiAgICAgICAgICogY29uc3QgbG9hZGVyID0gbmV3IEhEUkpQR0xvYWRlcihyZW5kZXJlcilcbiAgICAgICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9hZGVyLmxvYWRBc3luYygnZ2Fpbm1hcC5qcGVnJylcbiAgICAgICAgICogY29uc3QgbWVzaCA9IG5ldyBNZXNoKGdlb21ldHJ5LCBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoeyBtYXA6IHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZSB9KSApXG4gICAgICAgICAqIC8vIERPIE5PVCBkaXNwb3NlIHRoZSByZW5kZXJUYXJnZXQgaGVyZSxcbiAgICAgICAgICogLy8gaXQgaXMgdXNlZCBkaXJlY3RseSBpbiB0aGUgbWF0ZXJpYWxcbiAgICAgICAgICogcmVzdWx0LmRpc3Bvc2UoKVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBganNcbiAgICAgICAgICogY29uc3QgbG9hZGVyID0gbmV3IEhEUkpQR0xvYWRlcihyZW5kZXJlcilcbiAgICAgICAgICogY29uc3QgcG1yZW1HZW5lcmF0b3IgPSBuZXcgUE1SRU1HZW5lcmF0b3IoIHJlbmRlcmVyICk7XG4gICAgICAgICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvYWRlci5sb2FkQXN5bmMoJ2dhaW5tYXAuanBlZycpXG4gICAgICAgICAqIGNvbnN0IGVudk1hcCA9IHBtcmVtR2VuZXJhdG9yLmZyb21FcXVpcmVjdGFuZ3VsYXIocmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlKVxuICAgICAgICAgKiBjb25zdCBtZXNoID0gbmV3IE1lc2goZ2VvbWV0cnksIG5ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7IGVudk1hcCB9KSApXG4gICAgICAgICAqIC8vIHJlbmRlclRhcmdldCBjYW4gYmUgZGlzcG9zZWQgaGVyZVxuICAgICAgICAgKiAvLyBiZWNhdXNlIGl0IHdhcyB1c2VkIHRvIGdlbmVyYXRlIGEgUE1SRU0gdGV4dHVyZVxuICAgICAgICAgKiByZXN1bHQuZGlzcG9zZSh0cnVlKVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2UoZGlzcG9zZVJlbmRlclRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlT25EZW1hbmRSZW5kZXJlcigpO1xuICAgICAgICAgICAgaWYgKGRpc3Bvc2VSZW5kZXJUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRhcmdldC5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkaXNwb3NlIHNoYWRlciBtYXRlcmlhbCB0ZXh0dXJlIHVuaWZvcm1zXG4gICAgICAgICAgICBpZiAodGhpcy5tYXRlcmlhbCBpbnN0YW5jZW9mIHRocmVlLlNoYWRlck1hdGVyaWFsKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLm1hdGVyaWFsLnVuaWZvcm1zKS5mb3JFYWNoKHYgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodi52YWx1ZSBpbnN0YW5jZW9mIHRocmVlLlRleHR1cmUpXG4gICAgICAgICAgICAgICAgICAgICAgICB2LnZhbHVlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRpc3Bvc2Ugb3RoZXIgbWF0ZXJpYWwgcHJvcGVydGllc1xuICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLm1hdGVyaWFsKS5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiB0aHJlZS5UZXh0dXJlKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fcXVhZC5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpZHRoIG9mIHRoZSB0ZXh0dXJlXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLl93aWR0aDsgfVxuICAgICAgICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQuc2V0U2l6ZSh0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSGVpZ2h0IG9mIHRoZSB0ZXh0dXJlXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgaGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5faGVpZ2h0OyB9XG4gICAgICAgIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0LnNldFNpemUodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZW5kZXJlciB1c2VkXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgcmVuZGVyZXIoKSB7IHJldHVybiB0aGlzLl9yZW5kZXJlcjsgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGBXZWJHTFJlbmRlclRhcmdldGAgdXNlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldCByZW5kZXJUYXJnZXQoKSB7IHJldHVybiB0aGlzLl9yZW5kZXJUYXJnZXQ7IH1cbiAgICAgICAgc2V0IHJlbmRlclRhcmdldCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHZhbHVlLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWUuaGVpZ2h0O1xuICAgICAgICAgICAgLy8gdGhpcy5fdHlwZSA9IHZhbHVlLnRleHR1cmUudHlwZVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYE1hdGVyaWFsYCB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IG1hdGVyaWFsKCkgeyByZXR1cm4gdGhpcy5fbWF0ZXJpYWw7IH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMuX3R5cGU7IH1cbiAgICAgICAgZ2V0IGNvbG9yU3BhY2UoKSB7IHJldHVybiB0aGlzLl9jb2xvclNwYWNlOyB9XG4gICAgfVxuXG4gICAgY29uc3QgdmVydGV4U2hhZGVyID0gLyogZ2xzbCAqLyBgXG52YXJ5aW5nIHZlYzIgdlV2O1xuXG52b2lkIG1haW4oKSB7XG4gIHZVdiA9IHV2O1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xufVxuYDtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IC8qIGdsc2wgKi8gYFxuLy8gbWluIGhhbGYgZmxvYXQgdmFsdWVcbiNkZWZpbmUgSEFMRl9GTE9BVF9NSU4gdmVjMyggLTY1NTA0LCAtNjU1MDQsIC02NTUwNCApXG4vLyBtYXggaGFsZiBmbG9hdCB2YWx1ZVxuI2RlZmluZSBIQUxGX0ZMT0FUX01BWCB2ZWMzKCA2NTUwNCwgNjU1MDQsIDY1NTA0IClcblxudW5pZm9ybSBzYW1wbGVyMkQgc2RyO1xudW5pZm9ybSBzYW1wbGVyMkQgZ2Fpbk1hcDtcbnVuaWZvcm0gdmVjMyBnYW1tYTtcbnVuaWZvcm0gdmVjMyBvZmZzZXRIZHI7XG51bmlmb3JtIHZlYzMgb2Zmc2V0U2RyO1xudW5pZm9ybSB2ZWMzIGdhaW5NYXBNaW47XG51bmlmb3JtIHZlYzMgZ2Fpbk1hcE1heDtcbnVuaWZvcm0gZmxvYXQgd2VpZ2h0RmFjdG9yO1xuXG52YXJ5aW5nIHZlYzIgdlV2O1xuXG52b2lkIG1haW4oKSB7XG4gIHZlYzMgcmdiID0gdGV4dHVyZTJEKCBzZHIsIHZVdiApLnJnYjtcbiAgdmVjMyByZWNvdmVyeSA9IHRleHR1cmUyRCggZ2Fpbk1hcCwgdlV2ICkucmdiO1xuICB2ZWMzIGxvZ1JlY292ZXJ5ID0gcG93KCByZWNvdmVyeSwgZ2FtbWEgKTtcbiAgdmVjMyBsb2dCb29zdCA9IGdhaW5NYXBNaW4gKiAoIDEuMCAtIGxvZ1JlY292ZXJ5ICkgKyBnYWluTWFwTWF4ICogbG9nUmVjb3Zlcnk7XG4gIHZlYzMgaGRyQ29sb3IgPSAocmdiICsgb2Zmc2V0U2RyKSAqIGV4cDIoIGxvZ0Jvb3N0ICogd2VpZ2h0RmFjdG9yICkgLSBvZmZzZXRIZHI7XG4gIHZlYzMgY2xhbXBlZEhkckNvbG9yID0gbWF4KCBIQUxGX0ZMT0FUX01JTiwgbWluKCBIQUxGX0ZMT0FUX01BWCwgaGRyQ29sb3IgKSk7XG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNsYW1wZWRIZHJDb2xvciAsIDEuMCApO1xufVxuYDtcbiAgICAvKipcbiAgICAgKiBBIE1hdGVyaWFsIHdoaWNoIGlzIGFibGUgdG8gZGVjb2RlIHRoZSBHYWlubWFwIGludG8gYSBmdWxsIEhEUiBSZXByZXNlbnRhdGlvblxuICAgICAqXG4gICAgICogQGNhdGVnb3J5IE1hdGVyaWFsc1xuICAgICAqIEBncm91cCBNYXRlcmlhbHNcbiAgICAgKi9cbiAgICBjbGFzcyBHYWluTWFwRGVjb2Rlck1hdGVyaWFsIGV4dGVuZHMgdGhyZWUuU2hhZGVyTWF0ZXJpYWwge1xuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IoeyBnYW1tYSwgb2Zmc2V0SGRyLCBvZmZzZXRTZHIsIGdhaW5NYXBNaW4sIGdhaW5NYXBNYXgsIG1heERpc3BsYXlCb29zdCwgaGRyQ2FwYWNpdHlNaW4sIGhkckNhcGFjaXR5TWF4LCBzZHIsIGdhaW5NYXAgfSkge1xuICAgICAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdHYWluTWFwRGVjb2Rlck1hdGVyaWFsJyxcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICAgICAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICAgICAgICAgICAgc2RyOiB7IHZhbHVlOiBzZHIgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2Fpbk1hcDogeyB2YWx1ZTogZ2Fpbk1hcCB9LFxuICAgICAgICAgICAgICAgICAgICBnYW1tYTogeyB2YWx1ZTogbmV3IHRocmVlLlZlY3RvcjMoMS4wIC8gZ2FtbWFbMF0sIDEuMCAvIGdhbW1hWzFdLCAxLjAgLyBnYW1tYVsyXSkgfSxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0SGRyOiB7IHZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yMygpLmZyb21BcnJheShvZmZzZXRIZHIpIH0sXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFNkcjogeyB2YWx1ZTogbmV3IHRocmVlLlZlY3RvcjMoKS5mcm9tQXJyYXkob2Zmc2V0U2RyKSB9LFxuICAgICAgICAgICAgICAgICAgICBnYWluTWFwTWluOiB7IHZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yMygpLmZyb21BcnJheShnYWluTWFwTWluKSB9LFxuICAgICAgICAgICAgICAgICAgICBnYWluTWFwTWF4OiB7IHZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yMygpLmZyb21BcnJheShnYWluTWFwTWF4KSB9LFxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHRGYWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAoTWF0aC5sb2cyKG1heERpc3BsYXlCb29zdCkgLSBoZHJDYXBhY2l0eU1pbikgLyAoaGRyQ2FwYWNpdHlNYXggLSBoZHJDYXBhY2l0eU1pbilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYmxlbmRpbmc6IHRocmVlLk5vQmxlbmRpbmcsXG4gICAgICAgICAgICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkZXB0aFdyaXRlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9tYXhEaXNwbGF5Qm9vc3QgPSBtYXhEaXNwbGF5Qm9vc3Q7XG4gICAgICAgICAgICB0aGlzLl9oZHJDYXBhY2l0eU1pbiA9IGhkckNhcGFjaXR5TWluO1xuICAgICAgICAgICAgdGhpcy5faGRyQ2FwYWNpdHlNYXggPSBoZHJDYXBhY2l0eU1heDtcbiAgICAgICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtc05lZWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGdldCBzZHIoKSB7IHJldHVybiB0aGlzLnVuaWZvcm1zLnNkci52YWx1ZTsgfVxuICAgICAgICBzZXQgc2RyKHZhbHVlKSB7IHRoaXMudW5pZm9ybXMuc2RyLnZhbHVlID0gdmFsdWU7IH1cbiAgICAgICAgZ2V0IGdhaW5NYXAoKSB7IHJldHVybiB0aGlzLnVuaWZvcm1zLmdhaW5NYXAudmFsdWU7IH1cbiAgICAgICAgc2V0IGdhaW5NYXAodmFsdWUpIHsgdGhpcy51bmlmb3Jtcy5nYWluTWFwLnZhbHVlID0gdmFsdWU7IH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzZWUge0BsaW5rIEdhaW5NYXBNZXRhZGF0YS5vZmZzZXRIZHJ9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQgb2Zmc2V0SGRyKCkgeyByZXR1cm4gdGhpcy51bmlmb3Jtcy5vZmZzZXRIZHIudmFsdWUudG9BcnJheSgpOyB9XG4gICAgICAgIHNldCBvZmZzZXRIZHIodmFsdWUpIHsgdGhpcy51bmlmb3Jtcy5vZmZzZXRIZHIudmFsdWUuZnJvbUFycmF5KHZhbHVlKTsgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHNlZSB7QGxpbmsgR2Fpbk1hcE1ldGFkYXRhLm9mZnNldFNkcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldCBvZmZzZXRTZHIoKSB7IHJldHVybiB0aGlzLnVuaWZvcm1zLm9mZnNldFNkci52YWx1ZS50b0FycmF5KCk7IH1cbiAgICAgICAgc2V0IG9mZnNldFNkcih2YWx1ZSkgeyB0aGlzLnVuaWZvcm1zLm9mZnNldFNkci52YWx1ZS5mcm9tQXJyYXkodmFsdWUpOyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc2VlIHtAbGluayBHYWluTWFwTWV0YWRhdGEuZ2Fpbk1hcE1pbn1cbiAgICAgICAgICovXG4gICAgICAgIGdldCBnYWluTWFwTWluKCkgeyByZXR1cm4gdGhpcy51bmlmb3Jtcy5nYWluTWFwTWluLnZhbHVlLnRvQXJyYXkoKTsgfVxuICAgICAgICBzZXQgZ2Fpbk1hcE1pbih2YWx1ZSkgeyB0aGlzLnVuaWZvcm1zLmdhaW5NYXBNaW4udmFsdWUuZnJvbUFycmF5KHZhbHVlKTsgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHNlZSB7QGxpbmsgR2Fpbk1hcE1ldGFkYXRhLmdhaW5NYXBNYXh9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQgZ2Fpbk1hcE1heCgpIHsgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2Fpbk1hcE1heC52YWx1ZS50b0FycmF5KCk7IH1cbiAgICAgICAgc2V0IGdhaW5NYXBNYXgodmFsdWUpIHsgdGhpcy51bmlmb3Jtcy5nYWluTWFwTWF4LnZhbHVlLmZyb21BcnJheSh2YWx1ZSk7IH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzZWUge0BsaW5rIEdhaW5NYXBNZXRhZGF0YS5nYW1tYX1cbiAgICAgICAgICovXG4gICAgICAgIGdldCBnYW1tYSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGcgPSB0aGlzLnVuaWZvcm1zLmdhbW1hLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIFsxIC8gZy54LCAxIC8gZy55LCAxIC8gZy56XTtcbiAgICAgICAgfVxuICAgICAgICBzZXQgZ2FtbWEodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGcgPSB0aGlzLnVuaWZvcm1zLmdhbW1hLnZhbHVlO1xuICAgICAgICAgICAgZy54ID0gMS4wIC8gdmFsdWVbMF07XG4gICAgICAgICAgICBnLnkgPSAxLjAgLyB2YWx1ZVsxXTtcbiAgICAgICAgICAgIGcueiA9IDEuMCAvIHZhbHVlWzJdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc2VlIHtAbGluayBHYWluTWFwTWV0YWRhdGEuaGRyQ2FwYWNpdHlNaW59XG4gICAgICAgICAqIEByZW1hcmtzIExvZ2FyaXRobWljIHNwYWNlXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgaGRyQ2FwYWNpdHlNaW4oKSB7IHJldHVybiB0aGlzLl9oZHJDYXBhY2l0eU1pbjsgfVxuICAgICAgICBzZXQgaGRyQ2FwYWNpdHlNaW4odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2hkckNhcGFjaXR5TWluID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVdlaWdodCgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc2VlIHtAbGluayBHYWluTWFwTWV0YWRhdGEuaGRyQ2FwYWNpdHlNaW59XG4gICAgICAgICAqIEByZW1hcmtzIExvZ2FyaXRobWljIHNwYWNlXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgaGRyQ2FwYWNpdHlNYXgoKSB7IHJldHVybiB0aGlzLl9oZHJDYXBhY2l0eU1heDsgfVxuICAgICAgICBzZXQgaGRyQ2FwYWNpdHlNYXgodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2hkckNhcGFjaXR5TWF4ID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVdlaWdodCgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc2VlIHtAbGluayBHYWlubWFwRGVjb2RpbmdQYXJhbWV0ZXJzLm1heERpc3BsYXlCb29zdH1cbiAgICAgICAgICogQHJlbWFya3MgTm9uIExvZ2FyaXRobWljIHNwYWNlXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgbWF4RGlzcGxheUJvb3N0KCkgeyByZXR1cm4gdGhpcy5fbWF4RGlzcGxheUJvb3N0OyB9XG4gICAgICAgIHNldCBtYXhEaXNwbGF5Qm9vc3QodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX21heERpc3BsYXlCb29zdCA9IE1hdGgubWF4KDEsIE1hdGgubWluKDY1NTA0LCB2YWx1ZSkpO1xuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVXZWlnaHQoKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxjdWxhdGVXZWlnaHQoKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSAoTWF0aC5sb2cyKHRoaXMuX21heERpc3BsYXlCb29zdCkgLSB0aGlzLl9oZHJDYXBhY2l0eU1pbikgLyAodGhpcy5faGRyQ2FwYWNpdHlNYXggLSB0aGlzLl9oZHJDYXBhY2l0eU1pbik7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLndlaWdodEZhY3Rvci52YWx1ZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHZhbCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIGdhaW4gbWFwIHVzaW5nIGEgV2ViR0xSZW5kZXJUYXJnZXRcbiAgICAgKlxuICAgICAqIEBjYXRlZ29yeSBEZWNvZGluZyBGdW5jdGlvbnNcbiAgICAgKiBAZ3JvdXAgRGVjb2RpbmcgRnVuY3Rpb25zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpbXBvcnQgeyBkZWNvZGUgfSBmcm9tICdAbW9ub2dyaWQvZ2Fpbm1hcC1qcydcbiAgICAgKiBpbXBvcnQge1xuICAgICAqICAgTWVzaCxcbiAgICAgKiAgIE1lc2hCYXNpY01hdGVyaWFsLFxuICAgICAqICAgUGVyc3BlY3RpdmVDYW1lcmEsXG4gICAgICogICBQbGFuZUdlb21ldHJ5LFxuICAgICAqICAgU2NlbmUsXG4gICAgICogICBUZXh0dXJlTG9hZGVyLFxuICAgICAqICAgV2ViR0xSZW5kZXJlclxuICAgICAqIH0gZnJvbSAndGhyZWUnXG4gICAgICpcbiAgICAgKiBjb25zdCByZW5kZXJlciA9IG5ldyBXZWJHTFJlbmRlcmVyKClcbiAgICAgKlxuICAgICAqIGNvbnN0IHRleHR1cmVMb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlcigpXG4gICAgICpcbiAgICAgKiAvLyBsb2FkIFNEUiBSZXByZXNlbnRhdGlvblxuICAgICAqIGNvbnN0IHNkciA9IGF3YWl0IHRleHR1cmVMb2FkZXIubG9hZEFzeW5jKCdzZHIuanBnJylcbiAgICAgKiAvLyBsb2FkIEdhaW4gbWFwIHJlY292ZXJ5IGltYWdlXG4gICAgICogY29uc3QgZ2Fpbk1hcCA9IGF3YWl0IHRleHR1cmVMb2FkZXIubG9hZEFzeW5jKCdnYWlubWFwLmpwZycpXG4gICAgICogLy8gbG9hZCBtZXRhZGF0YVxuICAgICAqIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgKGF3YWl0IGZldGNoKCdtZXRhZGF0YS5qc29uJykpLmpzb24oKVxuICAgICAqXG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZGVjb2RlKHtcbiAgICAgKiAgIHNkcixcbiAgICAgKiAgIGdhaW5NYXAsXG4gICAgICogICAvLyB0aGlzIGFsbG93cyB0byB1c2UgYHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZWAgZGlyZWN0bHlcbiAgICAgKiAgIHJlbmRlcmVyLFxuICAgICAqICAgLy8gdGhpcyB3aWxsIHJlc3RvcmUgdGhlIGZ1bGwgSERSIHJhbmdlXG4gICAgICogICBtYXhEaXNwbGF5Qm9vc3Q6IE1hdGgucG93KDIsIG1ldGFkYXRhLmhkckNhcGFjaXR5TWF4KSxcbiAgICAgKiAgIC4uLm1ldGFkYXRhXG4gICAgICogfSlcbiAgICAgKlxuICAgICAqIGNvbnN0IHNjZW5lID0gbmV3IFNjZW5lKClcbiAgICAgKiAvLyBgcmVzdWx0YCBjYW4gYmUgdXNlZCB0byBwb3B1bGF0ZSBhIFRleHR1cmVcbiAgICAgKiBjb25zdCBtZXNoID0gbmV3IE1lc2goXG4gICAgICogICBuZXcgUGxhbmVHZW9tZXRyeSgpLFxuICAgICAqICAgbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgbWFwOiByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmUgfSlcbiAgICAgKiApXG4gICAgICogc2NlbmUuYWRkKG1lc2gpXG4gICAgICogcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKSlcbiAgICAgKlxuICAgICAqIC8vIHJlc3VsdCBtdXN0IGJlIG1hbnVhbGx5IGRpc3Bvc2VkXG4gICAgICogLy8gd2hlbiB5b3UgYXJlIGRvbmUgdXNpbmcgaXRcbiAgICAgKiByZXN1bHQuZGlzcG9zZSgpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICogQHJldHVybnNcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIFdlYkdMUmVuZGVyZXIgZmFpbHMgdG8gcmVuZGVyIHRoZSBnYWluIG1hcFxuICAgICAqL1xuICAgIGNvbnN0IGRlY29kZSA9IChwYXJhbXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBzZHIsIGdhaW5NYXAsIHJlbmRlcmVyIH0gPSBwYXJhbXM7XG4gICAgICAgIGlmIChzZHIuY29sb3JTcGFjZSAhPT0gdGhyZWUuU1JHQkNvbG9yU3BhY2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignU0RSIENvbG9yc3BhY2UgbmVlZHMgdG8gYmUgKlNSR0JDb2xvclNwYWNlKiwgc2V0dGluZyBpdCBhdXRvbWF0aWNhbGx5Jyk7XG4gICAgICAgICAgICBzZHIuY29sb3JTcGFjZSA9IHRocmVlLlNSR0JDb2xvclNwYWNlO1xuICAgICAgICB9XG4gICAgICAgIHNkci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIGlmIChnYWluTWFwLmNvbG9yU3BhY2UgIT09IHRocmVlLkxpbmVhclNSR0JDb2xvclNwYWNlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0dhaW5tYXAgQ29sb3JzcGFjZSBuZWVkcyB0byBiZSAqTGluZWFyU1JHQkNvbG9yU3BhY2UqLCBzZXR0aW5nIGl0IGF1dG9tYXRpY2FsbHknKTtcbiAgICAgICAgICAgIGdhaW5NYXAuY29sb3JTcGFjZSA9IHRocmVlLkxpbmVhclNSR0JDb2xvclNwYWNlO1xuICAgICAgICB9XG4gICAgICAgIGdhaW5NYXAubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBHYWluTWFwRGVjb2Rlck1hdGVyaWFsKHtcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgIHNkcixcbiAgICAgICAgICAgIGdhaW5NYXBcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHF1YWRSZW5kZXJlciA9IG5ldyBRdWFkUmVuZGVyZXIoe1xuICAgICAgICAgICAgLy8gVE9ETzogdGhyZWUgdHlwZXMgYXJlIGdlbmVyaWMsIGVzbGludCBjb21wbGFpbnMgaGVyZSwgc2VlIGhvdyB3ZSBjYW4gc29sdmVcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgd2lkdGg6IHNkci5pbWFnZS53aWR0aCxcbiAgICAgICAgICAgIC8vIFRPRE86IHRocmVlIHR5cGVzIGFyZSBnZW5lcmljLCBlc2xpbnQgY29tcGxhaW5zIGhlcmUsIHNlZSBob3cgd2UgY2FuIHNvbHZlXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgIGhlaWdodDogc2RyLmltYWdlLmhlaWdodCxcbiAgICAgICAgICAgIHR5cGU6IHRocmVlLkhhbGZGbG9hdFR5cGUsXG4gICAgICAgICAgICBjb2xvclNwYWNlOiB0aHJlZS5MaW5lYXJTUkdCQ29sb3JTcGFjZSxcbiAgICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgICAgcmVuZGVyZXIsXG4gICAgICAgICAgICByZW5kZXJUYXJnZXRPcHRpb25zOiBwYXJhbXMucmVuZGVyVGFyZ2V0T3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHF1YWRSZW5kZXJlci5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcXVhZFJlbmRlcmVyLmRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdWFkUmVuZGVyZXI7XG4gICAgfTtcblxuICAgIGNsYXNzIEdhaW5NYXBOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIH1cblxuICAgIGNsYXNzIFhNUE1ldGFkYXRhTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICB9XG5cbiAgICBjb25zdCBnZXRYTUxWYWx1ZSA9ICh4bWwsIHRhZywgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgICAgIC8vIENoZWNrIGZvciBhdHRyaWJ1dGUgZm9ybWF0IGZpcnN0OiB0YWc9XCJ2YWx1ZVwiXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZU1hdGNoID0gbmV3IFJlZ0V4cChgJHt0YWd9PVwiKFteXCJdKilcImAsICdpJykuZXhlYyh4bWwpO1xuICAgICAgICBpZiAoYXR0cmlidXRlTWF0Y2gpXG4gICAgICAgICAgICByZXR1cm4gYXR0cmlidXRlTWF0Y2hbMV07XG4gICAgICAgIC8vIENoZWNrIGZvciB0YWcgZm9ybWF0OiA8dGFnPnZhbHVlPC90YWc+IG9yIDx0YWc+PHJkZjpsaT52YWx1ZTwvcmRmOmxpPi4uLjwvdGFnPlxuICAgICAgICBjb25zdCB0YWdNYXRjaCA9IG5ldyBSZWdFeHAoYDwke3RhZ31bXj5dKj4oW1xcXFxzXFxcXFNdKj8pPC8ke3RhZ30+YCwgJ2knKS5leGVjKHhtbCk7XG4gICAgICAgIGlmICh0YWdNYXRjaCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQgY29udGFpbnMgcmRmOmxpIGVsZW1lbnRzXG4gICAgICAgICAgICBjb25zdCBsaVZhbHVlcyA9IHRhZ01hdGNoWzFdLm1hdGNoKC88cmRmOmxpPihbXjxdKik8XFwvcmRmOmxpPi9nKTtcbiAgICAgICAgICAgIGlmIChsaVZhbHVlcyAmJiBsaVZhbHVlcy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlWYWx1ZXMubWFwKHYgPT4gdi5yZXBsYWNlKC88XFwvP3JkZjpsaT4vZywgJycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWdNYXRjaFsxXS50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBmaW5kICR7dGFnfSBpbiBnYWlubWFwIG1ldGFkYXRhYCk7XG4gICAgfTtcbiAgICBjb25zdCBleHRyYWN0WE1QID0gKGlucHV0KSA9PiB7XG4gICAgICAgIGxldCBzdHI7XG4gICAgICAgIC8vIHN1cHBvcnQgbm9kZSB0ZXN0IGVudmlyb25tZW50XG4gICAgICAgIGlmICh0eXBlb2YgVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgc3RyID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGlucHV0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3RyID0gaW5wdXQudG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RyLmluZGV4T2YoJzx4OnhtcG1ldGEnKTtcbiAgICAgICAgd2hpbGUgKHN0YXJ0ICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgZW5kID0gc3RyLmluZGV4T2YoJ3g6eG1wbWV0YT4nLCBzdGFydCk7XG4gICAgICAgICAgICBjb25zdCB4bXBCbG9jayA9IHN0ci5zbGljZShzdGFydCwgZW5kICsgMTApO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBnYWluTWFwTWluID0gZ2V0WE1MVmFsdWUoeG1wQmxvY2ssICdoZHJnbTpHYWluTWFwTWluJywgJzAnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnYWluTWFwTWF4ID0gZ2V0WE1MVmFsdWUoeG1wQmxvY2ssICdoZHJnbTpHYWluTWFwTWF4Jyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2FtbWEgPSBnZXRYTUxWYWx1ZSh4bXBCbG9jaywgJ2hkcmdtOkdhbW1hJywgJzEnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXRTRFIgPSBnZXRYTUxWYWx1ZSh4bXBCbG9jaywgJ2hkcmdtOk9mZnNldFNEUicsICcwLjAxNTYyNScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldEhEUiA9IGdldFhNTFZhbHVlKHhtcEJsb2NrLCAnaGRyZ206T2Zmc2V0SERSJywgJzAuMDE1NjI1Jyk7XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgYXJlIGFsd2F5cyBhdHRyaWJ1dGVzLCBzbyB3ZSBjYW4gdXNlIGEgc2ltcGxlciByZWdleFxuICAgICAgICAgICAgICAgIGNvbnN0IGhkckNhcGFjaXR5TWluTWF0Y2ggPSAvaGRyZ206SERSQ2FwYWNpdHlNaW49XCIoW15cIl0qKVwiLy5leGVjKHhtcEJsb2NrKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoZHJDYXBhY2l0eU1pbiA9IGhkckNhcGFjaXR5TWluTWF0Y2ggPyBoZHJDYXBhY2l0eU1pbk1hdGNoWzFdIDogJzAnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhkckNhcGFjaXR5TWF4TWF0Y2ggPSAvaGRyZ206SERSQ2FwYWNpdHlNYXg9XCIoW15cIl0qKVwiLy5leGVjKHhtcEJsb2NrKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhkckNhcGFjaXR5TWF4TWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wbGV0ZSBnYWlubWFwIG1ldGFkYXRhJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGRyQ2FwYWNpdHlNYXggPSBoZHJDYXBhY2l0eU1heE1hdGNoWzFdO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGdhaW5NYXBNaW46IEFycmF5LmlzQXJyYXkoZ2Fpbk1hcE1pbikgPyBnYWluTWFwTWluLm1hcCh2ID0+IHBhcnNlRmxvYXQodikpIDogW3BhcnNlRmxvYXQoZ2Fpbk1hcE1pbiksIHBhcnNlRmxvYXQoZ2Fpbk1hcE1pbiksIHBhcnNlRmxvYXQoZ2Fpbk1hcE1pbildLFxuICAgICAgICAgICAgICAgICAgICBnYWluTWFwTWF4OiBBcnJheS5pc0FycmF5KGdhaW5NYXBNYXgpID8gZ2Fpbk1hcE1heC5tYXAodiA9PiBwYXJzZUZsb2F0KHYpKSA6IFtwYXJzZUZsb2F0KGdhaW5NYXBNYXgpLCBwYXJzZUZsb2F0KGdhaW5NYXBNYXgpLCBwYXJzZUZsb2F0KGdhaW5NYXBNYXgpXSxcbiAgICAgICAgICAgICAgICAgICAgZ2FtbWE6IEFycmF5LmlzQXJyYXkoZ2FtbWEpID8gZ2FtbWEubWFwKHYgPT4gcGFyc2VGbG9hdCh2KSkgOiBbcGFyc2VGbG9hdChnYW1tYSksIHBhcnNlRmxvYXQoZ2FtbWEpLCBwYXJzZUZsb2F0KGdhbW1hKV0sXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFNkcjogQXJyYXkuaXNBcnJheShvZmZzZXRTRFIpID8gb2Zmc2V0U0RSLm1hcCh2ID0+IHBhcnNlRmxvYXQodikpIDogW3BhcnNlRmxvYXQob2Zmc2V0U0RSKSwgcGFyc2VGbG9hdChvZmZzZXRTRFIpLCBwYXJzZUZsb2F0KG9mZnNldFNEUildLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRIZHI6IEFycmF5LmlzQXJyYXkob2Zmc2V0SERSKSA/IG9mZnNldEhEUi5tYXAodiA9PiBwYXJzZUZsb2F0KHYpKSA6IFtwYXJzZUZsb2F0KG9mZnNldEhEUiksIHBhcnNlRmxvYXQob2Zmc2V0SERSKSwgcGFyc2VGbG9hdChvZmZzZXRIRFIpXSxcbiAgICAgICAgICAgICAgICAgICAgaGRyQ2FwYWNpdHlNaW46IHBhcnNlRmxvYXQoaGRyQ2FwYWNpdHlNaW4pLFxuICAgICAgICAgICAgICAgICAgICBoZHJDYXBhY2l0eU1heDogcGFyc2VGbG9hdChoZHJDYXBhY2l0eU1heClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBDb250aW51ZSBzZWFyY2hpbmcgZm9yIGFub3RoZXIgeG1wbWV0YSBibG9jayBpZiB0aGlzIG9uZSBmYWlsc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBzdHIuaW5kZXhPZignPHg6eG1wbWV0YScsIGVuZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTVBGIEV4dHJhY3RvciAoTXVsdGkgUGljdHVyZSBGb3JtYXQgRXh0cmFjdG9yKVxuICAgICAqIEJ5IEhlbnJpayBTIE5pbHNzb24gMjAxOVxuICAgICAqXG4gICAgICogRXh0cmFjdHMgaW1hZ2VzIHN0b3JlZCBpbiBpbWFnZXMgYmFzZWQgb24gdGhlIE1QRiBmb3JtYXQgKGZvdW5kIGhlcmU6IGh0dHBzOi8vd3d3LmNpcGEuanAvZS9zdGQvc3RkLXNlYy5odG1sXG4gICAgICogdW5kZXIgXCJDSVBBIERDLTAwNy1UcmFuc2xhdGlvbi0yMDIxIE11bHRpLVBpY3R1cmUgRm9ybWF0XCJcbiAgICAgKlxuICAgICAqIE92ZXJseSBjb21tZW50ZWQsIGFuZCB3aXRob3V0IGludGVudGlvbiBvZiBiZWluZyBjb21wbGV0ZSBvciBwcm9kdWN0aW9uIHJlYWR5LlxuICAgICAqIENyZWF0ZWQgdG8gZXh0cmFjdCBkZXB0aCBtYXBzIGZyb20gaVBob25lIGltYWdlcywgYW5kIHRvIGxlYXJuIGFib3V0IGltYWdlIG1ldGFkYXRhLlxuICAgICAqIEt1ZG9zIHRvOiBQaGlsIEhhcnZleSAoZXhpZnRvb2wpLCBKYXVtZSBTYW5jaGV6IChhbmRyb2lkLWxlbnMtYmx1ci1kZXB0aC1leHRyYWN0b3IpXG4gICAgICovXG4gICAgY2xhc3MgTVBGRXh0cmFjdG9yIHtcbiAgICAgICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGRlYnVnOiBvcHRpb25zICYmIG9wdGlvbnMuZGVidWcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVidWcgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBleHRyYWN0RklJOiBvcHRpb25zICYmIG9wdGlvbnMuZXh0cmFjdEZJSSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5leHRyYWN0RklJIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBleHRyYWN0Tm9uRklJOiBvcHRpb25zICYmIG9wdGlvbnMuZXh0cmFjdE5vbkZJSSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5leHRyYWN0Tm9uRklJIDogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBleHRyYWN0KGltYWdlQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVidWcgPSB0aGlzLm9wdGlvbnMuZGVidWc7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoaW1hZ2VBcnJheUJ1ZmZlci5idWZmZXIpO1xuICAgICAgICAgICAgICAgIC8vIElmIHlvdSdyZSBleGVjdXRpbmcgdGhpcyBsaW5lIG9uIGEgYmlnIGVuZGlhbiBtYWNoaW5lLCBpdCdsbCBiZSByZXZlcnNlZC5cbiAgICAgICAgICAgICAgICAvLyBiaWdFbmQgZnVydGhlciBkb3duIHRob3VnaCwgcmVmZXJzIHRvIHRoZSBlbmRpYW5uZXNzIG9mIHRoZSBpbWFnZSBpdHNlbGYuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNigwKSAhPT0gMHhmZmQ4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ05vdCBhIHZhbGlkIGpwZWcnKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVZpZXcuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMjtcbiAgICAgICAgICAgICAgICBsZXQgbG9vcHMgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBtYXJrZXI7IC8vIEFQUCMgbWFya2VyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKytsb29wcyA+IDI1MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgRm91bmQgbm8gbWFya2VyIGFmdGVyICR7bG9vcHN9IGxvb3BzIPCfmLVgKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCkgIT09IDB4ZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYE5vdCBhIHZhbGlkIG1hcmtlciBhdCBvZmZzZXQgMHgke29mZnNldC50b1N0cmluZygxNil9LCBmb3VuZDogMHgke2RhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCkudG9TdHJpbmcoMTYpfWApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXJrZXIgPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlYnVnKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYE1hcmtlcjogJHttYXJrZXIudG9TdHJpbmcoMTYpfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFya2VyID09PSAweGUyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVidWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIEFQUDIgbWFya2VyICgweGZmZTIpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXb3JrcyBmb3IgaVBob25lIDggUGx1cywgWCwgYW5kIFhTTWF4LiBPciBhbnkgcGhvdG9zIG9mIE1QRiBmb3JtYXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHcmVhdCB3YXkgdG8gdmlzdWFsaXplIGltYWdlIGluZm9ybWF0aW9uIGluIGh0bWwgaXMgdXNpbmcgRXhpZnRvb2wuIEUuZy46XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuL2V4aWZ0b29sLmV4ZSAtaHRtbGR1bXAgLXdhbnRUcmFpbGVyIHBob3RvLmpwZyA+IHBob3RvLmh0bWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdFB0ID0gb2Zmc2V0ICsgNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgU3RydWN0dXJlIG9mIHRoZSBNUCBGb3JtYXQgSWRlbnRpZmllclxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICBPZmZzZXQgQWRkci4gIHwgQ29kZSAoSGV4KSAgfCBEZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICogICswMCAgICAgICAgICAgICBmZiAgICAgICAgICAgIE1hcmtlciBQcmVmaXggICAgICA8LS0gb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgKzAxICAgICAgICAgICAgIGUyICAgICAgICAgICAgQVBQMlxuICAgICAgICAgICAgICAgICAgICAgICAgICogICswMiAgICAgICAgICAgICAjbiAgICAgICAgICAgIEFQUDIgRmllbGQgTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgKzAzICAgICAgICAgICAgICNuICAgICAgICAgICAgQVBQMiBGaWVsZCBMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAqICArMDQgICAgICAgICAgICAgNGQgICAgICAgICAgICAnTScgICAgICAgICAgICAgICAgPC0tIGZvcm1hdFB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgKzA1ICAgICAgICAgICAgIDUwICAgICAgICAgICAgJ1AnXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgKzA2ICAgICAgICAgICAgIDQ2ICAgICAgICAgICAgJ0YnXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgKzA3ICAgICAgICAgICAgIDAwICAgICAgICAgICAgTlVMTFxuICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8LS0gdGlmZk9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDMyKGZvcm1hdFB0KSA9PT0gMHg0ZDUwNDYwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIE1QRiB0YWcsIHNvIHdlIHN0YXJ0IGRpZyBvdXQgc3ViIGltYWdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpZmZPZmZzZXQgPSBmb3JtYXRQdCArIDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJpZ0VuZDsgLy8gRW5kaWFubmVzcyBmcm9tIFRJRkYgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGVzdCBmb3IgVElGRiB2YWxpZGl0eSBhbmQgZW5kaWFubmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDB4NDk0OSBhbmQgMHg0RDREICgnSUknIGFuZCAnTU0nKSBtYXJrcyBMaXR0bGUgRW5kaWFuIGFuZCBCaWcgRW5kaWFuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNih0aWZmT2Zmc2V0KSA9PT0gMHg0OTQ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpZ0VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhVmlldy5nZXRVaW50MTYodGlmZk9mZnNldCkgPT09IDB4NGQ0ZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaWdFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTm8gdmFsaWQgZW5kaWFubmVzcyBtYXJrZXIgZm91bmQgaW4gVElGRiBoZWFkZXInKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNih0aWZmT2Zmc2V0ICsgMiwgIWJpZ0VuZCkgIT09IDB4MDAyYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdOb3QgdmFsaWQgVElGRiBkYXRhISAobm8gMHgwMDJBIG1hcmtlciknKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMzIgYml0IG51bWJlciBzdGF0aW5nIHRoZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIDggQnl0ZSBNUCBIZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBNUCBJbmRleCBJRkQgTGVhc3QgcG9zc2libGUgdmFsdWUgaXMgdGh1cyA4IChtZWFucyAwIG9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdElGRE9mZnNldCA9IGRhdGFWaWV3LmdldFVpbnQzMih0aWZmT2Zmc2V0ICsgNCwgIWJpZ0VuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0SUZET2Zmc2V0IDwgMHgwMDAwMDAwOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdOb3QgdmFsaWQgVElGRiBkYXRhISAoRmlyc3Qgb2Zmc2V0IGxlc3MgdGhhbiA4KScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIGFoZWFkIHRvIE1QIEluZGV4IElGRFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc3VtZSB3ZSdyZSBhdCB0aGUgZmlyc3QgSUZELCBzbyBmaXJzdElGRE9mZnNldCBwb2ludHMgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNUCBJbmRleCBJRkQgYW5kIG5vdCBNUCBBdHRyaWJ1dGVzIElGRC4gKElmIHdlIHRyeSBleHRyYWN0IGZyb20gYSBzdWIgaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZmFpbCBzaWxlbnRseSBoZXJlIGR1ZSB0byB0aGlzIGFzc3VtcHRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ291bnQgKDIgQnl0ZSkgfCBNUCBJbmRleCBGaWVsZHMgYS5rLmEuIE1QIEVudHJpZXMgKGNvdW50ICogMTIgQnl0ZSkgfCBPZmZzZXQgb2YgTmV4dCBJRkQgKDQgQnl0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJTdGFydCA9IHRpZmZPZmZzZXQgKyBmaXJzdElGRE9mZnNldDsgLy8gU3RhcnQgb2YgSUZEIChJbWFnZSBGaWxlIERpcmVjdG9yeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IGRhdGFWaWV3LmdldFVpbnQxNihkaXJTdGFydCwgIWJpZ0VuZCk7IC8vIENvdW50IG9mIE1QRW50cmllcyAoMiBCeXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgaW5mbyBmcm9tIE1QRW50cmllcyAoc3RhcnRpbmcgYWZ0ZXIgQ291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cmllc1N0YXJ0ID0gZGlyU3RhcnQgKyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBudW1iZXJPZkltYWdlcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGVudHJpZXNTdGFydDsgaSA8IGVudHJpZXNTdGFydCArIDEyICogY291bnQ7IGkgKz0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBlbnRyeSBpcyAxMiBCeXRlcyBsb25nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIE1QIEluZGV4IElGRCB0YWdzLCBoZXJlIHdlIG9ubHkgdGFrZSB0YWcgMHhiMDAxID0gTnVtYmVyIG9mIGltYWdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KGksICFiaWdFbmQpID09PSAweGIwMDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlZCBpbiBMYXN0IDQgYnl0ZXMgb2YgaXRzIDEyIEJ5dGUgZW50cnkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJPZkltYWdlcyA9IGRhdGFWaWV3LmdldFVpbnQzMihpICsgOCwgIWJpZ0VuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dElGRE9mZnNldExlbiA9IDQ7IC8vIDQgQnl0ZSBvZmZzZXQgZmllbGQgdGhhdCBhcHBlYXJzIGFmdGVyIE1QIEluZGV4IElGRCB0YWdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgTVBJbWFnZUxpc3RWYWxQdCA9IGRpclN0YXJ0ICsgMiArIGNvdW50ICogMTIgKyBuZXh0SUZET2Zmc2V0TGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBNUEltYWdlTGlzdFZhbFB0OyBpIDwgTVBJbWFnZUxpc3RWYWxQdCArIG51bWJlck9mSW1hZ2VzICogMTY7IGkgKz0gMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNUFR5cGU6IGRhdGFWaWV3LmdldFVpbnQzMihpLCAhYmlnRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGRhdGFWaWV3LmdldFVpbnQzMihpICsgNCwgIWJpZ0VuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG9mZnNldCBpcyBzcGVjaWZpZWQgcmVsYXRpdmUgdG8gdGhlIGFkZHJlc3Mgb2YgdGhlIE1QIEVuZGlhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmllbGQgaW4gdGhlIE1QIEhlYWRlciwgdW5sZXNzIHRoZSBpbWFnZSBpcyBhIEZpcnN0IEluZGl2aWR1YWwgSW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB3aGljaCBjYXNlIHRoZSB2YWx1ZSBvZiB0aGUgb2Zmc2V0IHNoYWxsIGJlIE5VTEwgKDB4MDAwMDAwMDApLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YU9mZnNldDogZGF0YVZpZXcuZ2V0VWludDMyKGkgKyA4LCAhYmlnRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGFudEltYWdlczogZGF0YVZpZXcuZ2V0VWludDMyKGkgKyAxMiwgIWJpZ0VuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogLTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGSUk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW1hZ2UuZGF0YU9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YU9mZnNldCBpcyAweDAwMDAwMDAwIGZvciBGaXJzdCBJbmRpdmlkdWFsIEltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5zdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5pc0ZJSSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5zdGFydCA9IHRpZmZPZmZzZXQgKyBpbWFnZS5kYXRhT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UuaXNGSUkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5lbmQgPSBpbWFnZS5zdGFydCArIGltYWdlLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlcy5wdXNoKGltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRyYWN0Tm9uRklJICYmIGltYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyQmxvYiA9IG5ldyBCbG9iKFtkYXRhVmlld10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWdzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW1hZ2Ugb2YgaW1hZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuaXNGSUkgJiYgIXRoaXMub3B0aW9ucy5leHRyYWN0RklJKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIFNraXAgRklJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZUJsb2IgPSBidWZmZXJCbG9iLnNsaWNlKGltYWdlLnN0YXJ0LCBpbWFnZS5lbmQgKyAxLCAnaW1hZ2UvanBlZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBpbWFnZVVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoaW1hZ2VCbG9iKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1hZ2UuaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltYWdlLmltZy5zcmMgPSBpbWFnZVVybFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1ncy5wdXNoKGltYWdlQmxvYik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpbWdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDIgKyBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyBYTVAgTWV0YWRhdGEgYW5kIHRoZSBnYWluIG1hcCByZWNvdmVyeSBpbWFnZVxuICAgICAqIGZyb20gYSBzaW5nbGUgSlBFRyBmaWxlLlxuICAgICAqXG4gICAgICogQGNhdGVnb3J5IERlY29kaW5nIEZ1bmN0aW9uc1xuICAgICAqIEBncm91cCBEZWNvZGluZyBGdW5jdGlvbnNcbiAgICAgKiBAcGFyYW0ganBlZ0ZpbGUgYW4gYFVpbnQ4QXJyYXlgIGNvbnRhaW5pbmcgYW5kIGVuY29kZWQgSlBFRyBmaWxlXG4gICAgICogQHJldHVybnMgYW4gc2RyIGBVaW50OEFycmF5YCBjb21wcmVzc2VkIGluIEpQRUcsIGEgZ2Fpbk1hcCBgVWludDhBcnJheWAgY29tcHJlc3NlZCBpbiBKUEVHIGFuZCB0aGUgWE1QIHBhcnNlZCBYTVAgbWV0YWRhdGFcbiAgICAgKiBAdGhyb3dzIEVycm9yIGlmIFhNUCBNZXRhZGF0YSBpcyBub3QgZm91bmRcbiAgICAgKiBAdGhyb3dzIEVycm9yIGlmIEdhaW4gbWFwIGltYWdlIGlzIG5vdCBmb3VuZFxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW1wb3J0IHsgRmlsZUxvYWRlciB9IGZyb20gJ3RocmVlJ1xuICAgICAqIGltcG9ydCB7IGV4dHJhY3RHYWlubWFwRnJvbUpQRUcgfSBmcm9tICdAbW9ub2dyaWQvZ2Fpbm1hcC1qcydcbiAgICAgKlxuICAgICAqIGNvbnN0IGpwZWdGaWxlID0gYXdhaXQgbmV3IEZpbGVMb2FkZXIoKVxuICAgICAqICAuc2V0UmVzcG9uc2VUeXBlKCdhcnJheWJ1ZmZlcicpXG4gICAgICogIC5sb2FkQXN5bmMoJ2ltYWdlLmpwZycpXG4gICAgICpcbiAgICAgKiBjb25zdCB7IHNkciwgZ2Fpbk1hcCwgbWV0YWRhdGEgfSA9IGV4dHJhY3RHYWlubWFwRnJvbUpQRUcoanBlZ0ZpbGUpXG4gICAgICovXG4gICAgY29uc3QgZXh0cmFjdEdhaW5tYXBGcm9tSlBFRyA9IGFzeW5jIChqcGVnRmlsZSkgPT4ge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGV4dHJhY3RYTVAoanBlZ0ZpbGUpO1xuICAgICAgICBpZiAoIW1ldGFkYXRhKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFhNUE1ldGFkYXRhTm90Rm91bmRFcnJvcignR2FpbiBtYXAgWE1QIG1ldGFkYXRhIG5vdCBmb3VuZCcpO1xuICAgICAgICBjb25zdCBtcGZFeHRyYWN0b3IgPSBuZXcgTVBGRXh0cmFjdG9yKHsgZXh0cmFjdEZJSTogdHJ1ZSwgZXh0cmFjdE5vbkZJSTogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgaW1hZ2VzID0gYXdhaXQgbXBmRXh0cmFjdG9yLmV4dHJhY3QoanBlZ0ZpbGUpO1xuICAgICAgICBpZiAoaW1hZ2VzLmxlbmd0aCAhPT0gMilcbiAgICAgICAgICAgIHRocm93IG5ldyBHYWluTWFwTm90Rm91bmRFcnJvcignR2FpbiBtYXAgcmVjb3ZlcnkgaW1hZ2Ugbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZHI6IG5ldyBVaW50OEFycmF5KGF3YWl0IGltYWdlc1swXS5hcnJheUJ1ZmZlcigpKSxcbiAgICAgICAgICAgIGdhaW5NYXA6IG5ldyBVaW50OEFycmF5KGF3YWl0IGltYWdlc1sxXS5hcnJheUJ1ZmZlcigpKSxcbiAgICAgICAgICAgIG1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHByaXZhdGUgZnVuY3Rpb24sIGFzeW5jIGdldCBpbWFnZSBmcm9tIGJsb2JcbiAgICAgKlxuICAgICAqIEBwYXJhbSBibG9iXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBjb25zdCBnZXRIVE1MSW1hZ2VGcm9tQmxvYiA9IChibG9iKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7IHJlc29sdmUoaW1nKTsgfTtcbiAgICAgICAgICAgIGltZy5vbmVycm9yID0gKGUpID0+IHsgcmVqZWN0KGUpOyB9O1xuICAgICAgICAgICAgaW1nLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjbGFzcyBMb2FkZXJCYXNlIGV4dGVuZHMgdGhyZWUuTG9hZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByZW5kZXJlclxuICAgICAgICAgKiBAcGFyYW0gbWFuYWdlclxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3RydWN0b3IocmVuZGVyZXIsIG1hbmFnZXIpIHtcbiAgICAgICAgICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVyKVxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbExvYWRpbmdNYW5hZ2VyID0gbmV3IHRocmVlLkxvYWRpbmdNYW5hZ2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZnkgdGhlIHJlbmRlcmVyIHRvIHVzZSB3aGVuIHJlbmRlcmluZyB0aGUgZ2FpbiBtYXBcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJlbmRlcmVyXG4gICAgICAgICAqIEByZXR1cm5zXG4gICAgICAgICAqL1xuICAgICAgICBzZXRSZW5kZXJlcihyZW5kZXJlcikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IHRoZSByZW5kZXJUYXJnZXQgb3B0aW9ucyB0byB1c2Ugd2hlbiByZW5kZXJpbmcgdGhlIGdhaW4gbWFwXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zXG4gICAgICAgICAqL1xuICAgICAgICBzZXRSZW5kZXJUYXJnZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRhcmdldE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEByZXR1cm5zXG4gICAgICAgICAqL1xuICAgICAgICBwcmVwYXJlUXVhZFJlbmRlcmVyKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlcilcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IEFuIGV4aXN0aW5nIFdlYkdMIFJlbmRlcmVyIHdhcyBub3QgcGFzc2VkIHRvIHRoaXMgTG9hZGVyIGNvbnN0cnVjdG9yIG9yIGluIHNldFJlbmRlcmVyLCB0aGUgcmVzdWx0IG9mIHRoaXMgTG9hZGVyIHdpbGwgbmVlZCB0byBiZSBjb252ZXJ0ZWQgdG8gYSBEYXRhIFRleHR1cmUgd2l0aCB0b0RhdGFUZXh0dXJlKCkgYmVmb3JlIHlvdSBjYW4gdXNlIGl0IGluIHlvdXIgcmVuZGVyZXIuJyk7XG4gICAgICAgICAgICAvLyB0ZW1wb3JhcnkgdmFsdWVzXG4gICAgICAgICAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBHYWluTWFwRGVjb2Rlck1hdGVyaWFsKHtcbiAgICAgICAgICAgICAgICBnYWluTWFwTWF4OiBbMSwgMSwgMV0sXG4gICAgICAgICAgICAgICAgZ2Fpbk1hcE1pbjogWzAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIGdhbW1hOiBbMSwgMSwgMV0sXG4gICAgICAgICAgICAgICAgb2Zmc2V0SGRyOiBbMSwgMSwgMV0sXG4gICAgICAgICAgICAgICAgb2Zmc2V0U2RyOiBbMSwgMSwgMV0sXG4gICAgICAgICAgICAgICAgaGRyQ2FwYWNpdHlNYXg6IDEsXG4gICAgICAgICAgICAgICAgaGRyQ2FwYWNpdHlNaW46IDAsXG4gICAgICAgICAgICAgICAgbWF4RGlzcGxheUJvb3N0OiAxLFxuICAgICAgICAgICAgICAgIGdhaW5NYXA6IG5ldyB0aHJlZS5UZXh0dXJlKCksXG4gICAgICAgICAgICAgICAgc2RyOiBuZXcgdGhyZWUuVGV4dHVyZSgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUXVhZFJlbmRlcmVyKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMTYsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxNixcbiAgICAgICAgICAgICAgICB0eXBlOiB0aHJlZS5IYWxmRmxvYXRUeXBlLFxuICAgICAgICAgICAgICAgIGNvbG9yU3BhY2U6IHRocmVlLkxpbmVhclNSR0JDb2xvclNwYWNlLFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiB0aGlzLl9yZW5kZXJlcixcbiAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXRPcHRpb25zOiB0aGlzLl9yZW5kZXJUYXJnZXRPcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAcGFyYW0gcXVhZFJlbmRlcmVyXG4gICAgICAgKiBAcGFyYW0gbWV0YWRhdGFcbiAgICAgICAqIEBwYXJhbSBzZHJCdWZmZXJcbiAgICAgICAqIEBwYXJhbSBnYWluTWFwQnVmZmVyXG4gICAgICAgKi9cbiAgICAgICAgYXN5bmMgcmVuZGVyKHF1YWRSZW5kZXJlciwgbWV0YWRhdGEsIHNkckJ1ZmZlciwgZ2Fpbk1hcEJ1ZmZlcikge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBvcHRpb25hbCwgd2lsbCByZW5kZXIgYSBibGFjayBnYWluLW1hcCBpZiBub3QgcHJlc2VudFxuICAgICAgICAgICAgY29uc3QgZ2Fpbk1hcEJsb2IgPSBnYWluTWFwQnVmZmVyID8gbmV3IEJsb2IoW2dhaW5NYXBCdWZmZXJdLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHNkckJsb2IgPSBuZXcgQmxvYihbc2RyQnVmZmVyXSwgeyB0eXBlOiAnaW1hZ2UvanBlZycgfSk7XG4gICAgICAgICAgICBsZXQgc2RySW1hZ2U7XG4gICAgICAgICAgICBsZXQgZ2Fpbk1hcEltYWdlO1xuICAgICAgICAgICAgbGV0IG5lZWRzRmxpcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIGdhaW5NYXBCbG9iID8gZ2V0SFRNTEltYWdlRnJvbUJsb2IoZ2Fpbk1hcEJsb2IpIDogUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIGdldEhUTUxJbWFnZUZyb21CbG9iKHNkckJsb2IpXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgZ2Fpbk1hcEltYWdlID0gcmVzWzBdO1xuICAgICAgICAgICAgICAgIHNkckltYWdlID0gcmVzWzFdO1xuICAgICAgICAgICAgICAgIG5lZWRzRmxpcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIGdhaW5NYXBCbG9iID8gY3JlYXRlSW1hZ2VCaXRtYXAoZ2Fpbk1hcEJsb2IsIHsgaW1hZ2VPcmllbnRhdGlvbjogJ2ZsaXBZJyB9KSA6IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVJbWFnZUJpdG1hcChzZHJCbG9iLCB7IGltYWdlT3JpZW50YXRpb246ICdmbGlwWScgfSlcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBnYWluTWFwSW1hZ2UgPSByZXNbMF07XG4gICAgICAgICAgICAgICAgc2RySW1hZ2UgPSByZXNbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBnYWluTWFwID0gbmV3IHRocmVlLlRleHR1cmUoZ2Fpbk1hcEltYWdlIHx8IG5ldyBJbWFnZURhdGEoMiwgMiksIHRocmVlLlVWTWFwcGluZywgdGhyZWUuQ2xhbXBUb0VkZ2VXcmFwcGluZywgdGhyZWUuQ2xhbXBUb0VkZ2VXcmFwcGluZywgdGhyZWUuTGluZWFyRmlsdGVyLCB0aHJlZS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIsIHRocmVlLlJHQkFGb3JtYXQsIHRocmVlLlVuc2lnbmVkQnl0ZVR5cGUsIDEsIHRocmVlLkxpbmVhclNSR0JDb2xvclNwYWNlKTtcbiAgICAgICAgICAgIGdhaW5NYXAuZmxpcFkgPSBuZWVkc0ZsaXA7XG4gICAgICAgICAgICBnYWluTWFwLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHNkciA9IG5ldyB0aHJlZS5UZXh0dXJlKHNkckltYWdlLCB0aHJlZS5VVk1hcHBpbmcsIHRocmVlLkNsYW1wVG9FZGdlV3JhcHBpbmcsIHRocmVlLkNsYW1wVG9FZGdlV3JhcHBpbmcsIHRocmVlLkxpbmVhckZpbHRlciwgdGhyZWUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyLCB0aHJlZS5SR0JBRm9ybWF0LCB0aHJlZS5VbnNpZ25lZEJ5dGVUeXBlLCAxLCB0aHJlZS5TUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgICAgICBzZHIuZmxpcFkgPSBuZWVkc0ZsaXA7XG4gICAgICAgICAgICBzZHIubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgcXVhZFJlbmRlcmVyLndpZHRoID0gc2RySW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICBxdWFkUmVuZGVyZXIuaGVpZ2h0ID0gc2RySW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLmdhaW5NYXAgPSBnYWluTWFwO1xuICAgICAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLnNkciA9IHNkcjtcbiAgICAgICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5nYWluTWFwTWluID0gbWV0YWRhdGEuZ2Fpbk1hcE1pbjtcbiAgICAgICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5nYWluTWFwTWF4ID0gbWV0YWRhdGEuZ2Fpbk1hcE1heDtcbiAgICAgICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5vZmZzZXRIZHIgPSBtZXRhZGF0YS5vZmZzZXRIZHI7XG4gICAgICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwub2Zmc2V0U2RyID0gbWV0YWRhdGEub2Zmc2V0U2RyO1xuICAgICAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLmdhbW1hID0gbWV0YWRhdGEuZ2FtbWE7XG4gICAgICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwuaGRyQ2FwYWNpdHlNaW4gPSBtZXRhZGF0YS5oZHJDYXBhY2l0eU1pbjtcbiAgICAgICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5oZHJDYXBhY2l0eU1heCA9IG1ldGFkYXRhLmhkckNhcGFjaXR5TWF4O1xuICAgICAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLm1heERpc3BsYXlCb29zdCA9IE1hdGgucG93KDIsIG1ldGFkYXRhLmhkckNhcGFjaXR5TWF4KTtcbiAgICAgICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICBxdWFkUmVuZGVyZXIucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIFRocmVlLmpzIExvYWRlciBmb3IgdGhlIGdhaW4gbWFwIGZvcm1hdC5cbiAgICAgKlxuICAgICAqIEBjYXRlZ29yeSBMb2FkZXJzXG4gICAgICogQGdyb3VwIExvYWRlcnNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogaW1wb3J0IHsgR2Fpbk1hcExvYWRlciB9IGZyb20gJ0Btb25vZ3JpZC9nYWlubWFwLWpzJ1xuICAgICAqIGltcG9ydCB7XG4gICAgICogICBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyxcbiAgICAgKiAgIExpbmVhckZpbHRlcixcbiAgICAgKiAgIE1lc2gsXG4gICAgICogICBNZXNoQmFzaWNNYXRlcmlhbCxcbiAgICAgKiAgIFBlcnNwZWN0aXZlQ2FtZXJhLFxuICAgICAqICAgUGxhbmVHZW9tZXRyeSxcbiAgICAgKiAgIFNjZW5lLFxuICAgICAqICAgV2ViR0xSZW5kZXJlclxuICAgICAqIH0gZnJvbSAndGhyZWUnXG4gICAgICpcbiAgICAgKiBjb25zdCByZW5kZXJlciA9IG5ldyBXZWJHTFJlbmRlcmVyKClcbiAgICAgKlxuICAgICAqIGNvbnN0IGxvYWRlciA9IG5ldyBHYWluTWFwTG9hZGVyKHJlbmRlcmVyKVxuICAgICAqXG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9hZGVyLmxvYWRBc3luYyhbJ3Nkci5qcGVnJywgJ2dhaW5tYXAuanBlZycsICdtZXRhZGF0YS5qc29uJ10pXG4gICAgICogLy8gYHJlc3VsdGAgY2FuIGJlIHVzZWQgdG8gcG9wdWxhdGUgYSBUZXh0dXJlXG4gICAgICpcbiAgICAgKiBjb25zdCBzY2VuZSA9IG5ldyBTY2VuZSgpXG4gICAgICogY29uc3QgbWVzaCA9IG5ldyBNZXNoKFxuICAgICAqICAgbmV3IFBsYW5lR2VvbWV0cnkoKSxcbiAgICAgKiAgIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7IG1hcDogcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlIH0pXG4gICAgICogKVxuICAgICAqIHNjZW5lLmFkZChtZXNoKVxuICAgICAqIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCkpXG4gICAgICpcbiAgICAgKiAvLyBTdGFydGluZyBmcm9tIHRocmVlLmpzIHIxNTlcbiAgICAgKiAvLyBgcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlYCBjYW5cbiAgICAgKiAvLyBhbHNvIGJlIHVzZWQgYXMgRXF1aXJlY3Rhbmd1bGFyIHNjZW5lIGJhY2tncm91bmRcbiAgICAgKiAvL1xuICAgICAqIC8vIGl0IHdhcyBwcmV2aW91c2x5IG5lZWRlZCB0byBjb252ZXJ0IGl0XG4gICAgICogLy8gdG8gYSBEYXRhVGV4dHVyZSB3aXRoIGByZXN1bHQudG9EYXRhVGV4dHVyZSgpYFxuICAgICAqIHNjZW5lLmJhY2tncm91bmQgPSByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmVcbiAgICAgKiBzY2VuZS5iYWNrZ3JvdW5kLm1hcHBpbmcgPSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZ1xuICAgICAqXG4gICAgICogLy8gcmVzdWx0IG11c3QgYmUgbWFudWFsbHkgZGlzcG9zZWRcbiAgICAgKiAvLyB3aGVuIHlvdSBhcmUgZG9uZSB1c2luZyBpdFxuICAgICAqIHJlc3VsdC5kaXNwb3NlKClcbiAgICAgKlxuICAgICAqL1xuICAgIGNsYXNzIEdhaW5NYXBMb2FkZXIgZXh0ZW5kcyBMb2FkZXJCYXNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvYWRzIGEgZ2Fpbm1hcCB1c2luZyBzZXBhcmF0ZSBkYXRhXG4gICAgICAgICAqICogc2RyIGltYWdlXG4gICAgICAgICAqICogZ2FpbiBtYXAgaW1hZ2VcbiAgICAgICAgICogKiBtZXRhZGF0YSBqc29uXG4gICAgICAgICAqXG4gICAgICAgICAqIHVzZWZ1bCBmb3Igd2VicCBnYWluIG1hcHNcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHVybHMgQW4gYXJyYXkgaW4gdGhlIGZvcm0gb2YgW3Nkci5qcGcsIGdhaW5tYXAuanBnLCBtZXRhZGF0YS5qc29uXVxuICAgICAgICAgKiBAcGFyYW0gb25Mb2FkIExvYWQgY29tcGxldGUgY2FsbGJhY2ssIHdpbGwgcmVjZWl2ZSB0aGUgcmVzdWx0XG4gICAgICAgICAqIEBwYXJhbSBvblByb2dyZXNzIFByb2dyZXNzIGNhbGxiYWNrLCB3aWxsIHJlY2VpdmUgYSB7QGxpbmsgUHJvZ3Jlc3NFdmVudH1cbiAgICAgICAgICogQHBhcmFtIG9uRXJyb3IgRXJyb3IgY2FsbGJhY2tcbiAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICovXG4gICAgICAgIGxvYWQoW3NkclVybCwgZ2Fpbk1hcFVybCwgbWV0YWRhdGFVcmxdLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1YWRSZW5kZXJlciA9IHRoaXMucHJlcGFyZVF1YWRSZW5kZXJlcigpO1xuICAgICAgICAgICAgbGV0IHNkcjtcbiAgICAgICAgICAgIGxldCBnYWluTWFwO1xuICAgICAgICAgICAgbGV0IG1ldGFkYXRhO1xuICAgICAgICAgICAgY29uc3QgbG9hZENoZWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzZHIgJiYgZ2Fpbk1hcCAmJiBtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzb2x2ZXMgIzE2XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbmRlcihxdWFkUmVuZGVyZXIsIG1ldGFkYXRhLCBzZHIsIGdhaW5NYXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcihzZHJVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcihnYWluTWFwVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3IobWV0YWRhdGFVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVhZFJlbmRlcmVyLmRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkxvYWQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkxvYWQocXVhZFJlbmRlcmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FbmQoc2RyVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FbmQoZ2Fpbk1hcFVybCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRW5kKG1ldGFkYXRhVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgcXVhZFJlbmRlcmVyLmRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBzZHJMZW5ndGhDb21wdXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBzZHJUb3RhbCA9IDA7XG4gICAgICAgICAgICBsZXQgc2RyTG9hZGVkID0gMDtcbiAgICAgICAgICAgIGxldCBnYWluTWFwTGVuZ3RoQ29tcHV0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZ2Fpbk1hcFRvdGFsID0gMDtcbiAgICAgICAgICAgIGxldCBnYWluTWFwTG9hZGVkID0gMDtcbiAgICAgICAgICAgIGxldCBtZXRhZGF0YUxlbmd0aENvbXB1dGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IG1ldGFkYXRhVG90YWwgPSAwO1xuICAgICAgICAgICAgbGV0IG1ldGFkYXRhTG9hZGVkID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHByb2dyZXNzSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG90YWwgPSBzZHJUb3RhbCArIGdhaW5NYXBUb3RhbCArIG1ldGFkYXRhVG90YWw7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRlZCA9IHNkckxvYWRlZCArIGdhaW5NYXBMb2FkZWQgKyBtZXRhZGF0YUxvYWRlZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoQ29tcHV0YWJsZSA9IHNkckxlbmd0aENvbXB1dGFibGUgJiYgZ2Fpbk1hcExlbmd0aENvbXB1dGFibGUgJiYgbWV0YWRhdGFMZW5ndGhDb21wdXRhYmxlO1xuICAgICAgICAgICAgICAgICAgICBvblByb2dyZXNzKG5ldyBQcm9ncmVzc0V2ZW50KCdwcm9ncmVzcycsIHsgbGVuZ3RoQ29tcHV0YWJsZSwgbG9hZGVkLCB0b3RhbCB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtU3RhcnQoc2RyVXJsKTtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtU3RhcnQoZ2Fpbk1hcFVybCk7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KG1ldGFkYXRhVXJsKTtcbiAgICAgICAgICAgIGNvbnN0IHNkckxvYWRlciA9IG5ldyB0aHJlZS5GaWxlTG9hZGVyKHRoaXMuX2ludGVybmFsTG9hZGluZ01hbmFnZXIpO1xuICAgICAgICAgICAgc2RyTG9hZGVyLnNldFJlc3BvbnNlVHlwZSgnYXJyYXlidWZmZXInKTtcbiAgICAgICAgICAgIHNkckxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgICAgICAgICBzZHJMb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgICAgICAgICAgc2RyTG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgICAgICAgICBzZHJMb2FkZXIubG9hZChzZHJVcmwsIGFzeW5jIChidWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgICAgICAgICAgICAgICAgdGhpcyBjb25kaXRpb24gZXhpc3RzIG9ubHkgYmVjYXVzZSBvZiB0aHJlZS5qcyB0eXBlcyArIHN0cmljdCBtb2RlXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZHIgYnVmZmVyJyk7XG4gICAgICAgICAgICAgICAgc2RyID0gYnVmZmVyO1xuICAgICAgICAgICAgICAgIGF3YWl0IGxvYWRDaGVjaygpO1xuICAgICAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBzZHJMZW5ndGhDb21wdXRhYmxlID0gZS5sZW5ndGhDb21wdXRhYmxlO1xuICAgICAgICAgICAgICAgIHNkckxvYWRlZCA9IGUubG9hZGVkO1xuICAgICAgICAgICAgICAgIHNkclRvdGFsID0gZS50b3RhbDtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0hhbmRsZXIoKTtcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3Ioc2RyVXJsKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBnYWluTWFwTG9hZGVyID0gbmV3IHRocmVlLkZpbGVMb2FkZXIodGhpcy5faW50ZXJuYWxMb2FkaW5nTWFuYWdlcik7XG4gICAgICAgICAgICBnYWluTWFwTG9hZGVyLnNldFJlc3BvbnNlVHlwZSgnYXJyYXlidWZmZXInKTtcbiAgICAgICAgICAgIGdhaW5NYXBMb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgICAgICAgICAgZ2Fpbk1hcExvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgICAgICAgICBnYWluTWFwTG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgICAgICAgICBnYWluTWFwTG9hZGVyLmxvYWQoZ2Fpbk1hcFVybCwgYXN5bmMgKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZlxuICAgICAgICAgICAgICAgICB0aGlzIGNvbmRpdGlvbiBleGlzdHMgb25seSBiZWNhdXNlIG9mIHRocmVlLmpzIHR5cGVzICsgc3RyaWN0IG1vZGVcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGdhaW5tYXAgYnVmZmVyJyk7XG4gICAgICAgICAgICAgICAgZ2Fpbk1hcCA9IGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkQ2hlY2soKTtcbiAgICAgICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2Fpbk1hcExlbmd0aENvbXB1dGFibGUgPSBlLmxlbmd0aENvbXB1dGFibGU7XG4gICAgICAgICAgICAgICAgZ2Fpbk1hcExvYWRlZCA9IGUubG9hZGVkO1xuICAgICAgICAgICAgICAgIGdhaW5NYXBUb3RhbCA9IGUudG90YWw7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NIYW5kbGVyKCk7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKGdhaW5NYXBVcmwpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhTG9hZGVyID0gbmV3IHRocmVlLkZpbGVMb2FkZXIodGhpcy5faW50ZXJuYWxMb2FkaW5nTWFuYWdlcik7XG4gICAgICAgICAgICAvLyBtZXRhZGF0YUxvYWRlci5zZXRSZXNwb25zZVR5cGUoJ2pzb24nKVxuICAgICAgICAgICAgbWV0YWRhdGFMb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgICAgICAgICAgbWV0YWRhdGFMb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgICAgICAgICAgbWV0YWRhdGFMb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgIG1ldGFkYXRhTG9hZGVyLmxvYWQobWV0YWRhdGFVcmwsIGFzeW5jIChqc29uKSA9PiB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmXG4gICAgICAgICAgICAgICAgIHRoaXMgY29uZGl0aW9uIGV4aXN0cyBvbmx5IGJlY2F1c2Ugb2YgdGhyZWUuanMgdHlwZXMgKyBzdHJpY3QgbW9kZVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGFkYXRhIHN0cmluZycpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGltcGxlbWVudCBjaGVjayBvbiBKU09OIGZpbGUgYW5kIHJlbW92ZSB0aGlzIGVzbGludCBkaXNhYmxlXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBsb2FkQ2hlY2soKTtcbiAgICAgICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGFMZW5ndGhDb21wdXRhYmxlID0gZS5sZW5ndGhDb21wdXRhYmxlO1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhTG9hZGVkID0gZS5sb2FkZWQ7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGFUb3RhbCA9IGUudG90YWw7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NIYW5kbGVyKCk7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKG1ldGFkYXRhVXJsKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcXVhZFJlbmRlcmVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBUaHJlZS5qcyBMb2FkZXIgZm9yIGEgSlBFRyB3aXRoIGVtYmVkZGVkIGdhaW5tYXAgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAY2F0ZWdvcnkgTG9hZGVyc1xuICAgICAqIEBncm91cCBMb2FkZXJzXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGltcG9ydCB7IEhEUkpQR0xvYWRlciB9IGZyb20gJ0Btb25vZ3JpZC9nYWlubWFwLWpzJ1xuICAgICAqIGltcG9ydCB7XG4gICAgICogICBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyxcbiAgICAgKiAgIExpbmVhckZpbHRlcixcbiAgICAgKiAgIE1lc2gsXG4gICAgICogICBNZXNoQmFzaWNNYXRlcmlhbCxcbiAgICAgKiAgIFBlcnNwZWN0aXZlQ2FtZXJhLFxuICAgICAqICAgUGxhbmVHZW9tZXRyeSxcbiAgICAgKiAgIFNjZW5lLFxuICAgICAqICAgV2ViR0xSZW5kZXJlclxuICAgICAqIH0gZnJvbSAndGhyZWUnXG4gICAgICpcbiAgICAgKiBjb25zdCByZW5kZXJlciA9IG5ldyBXZWJHTFJlbmRlcmVyKClcbiAgICAgKlxuICAgICAqIGNvbnN0IGxvYWRlciA9IG5ldyBIRFJKUEdMb2FkZXIocmVuZGVyZXIpXG4gICAgICpcbiAgICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKCdnYWlubWFwLmpwZWcnKVxuICAgICAqIC8vIGByZXN1bHRgIGNhbiBiZSB1c2VkIHRvIHBvcHVsYXRlIGEgVGV4dHVyZVxuICAgICAqXG4gICAgICogY29uc3Qgc2NlbmUgPSBuZXcgU2NlbmUoKVxuICAgICAqIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChcbiAgICAgKiAgIG5ldyBQbGFuZUdlb21ldHJ5KCksXG4gICAgICogICBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoeyBtYXA6IHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZSB9KVxuICAgICAqIClcbiAgICAgKiBzY2VuZS5hZGQobWVzaClcbiAgICAgKiByZW5kZXJlci5yZW5kZXIoc2NlbmUsIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpKVxuICAgICAqXG4gICAgICogLy8gU3RhcnRpbmcgZnJvbSB0aHJlZS5qcyByMTU5XG4gICAgICogLy8gYHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZWAgY2FuXG4gICAgICogLy8gYWxzbyBiZSB1c2VkIGFzIEVxdWlyZWN0YW5ndWxhciBzY2VuZSBiYWNrZ3JvdW5kXG4gICAgICogLy9cbiAgICAgKiAvLyBpdCB3YXMgcHJldmlvdXNseSBuZWVkZWQgdG8gY29udmVydCBpdFxuICAgICAqIC8vIHRvIGEgRGF0YVRleHR1cmUgd2l0aCBgcmVzdWx0LnRvRGF0YVRleHR1cmUoKWBcbiAgICAgKiBzY2VuZS5iYWNrZ3JvdW5kID0gcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlXG4gICAgICogc2NlbmUuYmFja2dyb3VuZC5tYXBwaW5nID0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmdcbiAgICAgKlxuICAgICAqIC8vIHJlc3VsdCBtdXN0IGJlIG1hbnVhbGx5IGRpc3Bvc2VkXG4gICAgICogLy8gd2hlbiB5b3UgYXJlIGRvbmUgdXNpbmcgaXRcbiAgICAgKiByZXN1bHQuZGlzcG9zZSgpXG4gICAgICpcbiAgICAgKi9cbiAgICBjbGFzcyBIRFJKUEdMb2FkZXIgZXh0ZW5kcyBMb2FkZXJCYXNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvYWRzIGEgSlBFRyBjb250YWluaW5nIGdhaW4gbWFwIG1ldGFkYXRhXG4gICAgICAgICAqIFJlbmRlcnMgYSBub3JtYWwgU0RSIGltYWdlIGlmIGdhaW5tYXAgZGF0YSBpcyBub3QgZm91bmRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHVybCBBbiBhcnJheSBpbiB0aGUgZm9ybSBvZiBbc2RyLmpwZywgZ2Fpbm1hcC5qcGcsIG1ldGFkYXRhLmpzb25dXG4gICAgICAgICAqIEBwYXJhbSBvbkxvYWQgTG9hZCBjb21wbGV0ZSBjYWxsYmFjaywgd2lsbCByZWNlaXZlIHRoZSByZXN1bHRcbiAgICAgICAgICogQHBhcmFtIG9uUHJvZ3Jlc3MgUHJvZ3Jlc3MgY2FsbGJhY2ssIHdpbGwgcmVjZWl2ZSBhIHtAbGluayBQcm9ncmVzc0V2ZW50fVxuICAgICAgICAgKiBAcGFyYW0gb25FcnJvciBFcnJvciBjYWxsYmFja1xuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgICAgICAgICAgY29uc3QgcXVhZFJlbmRlcmVyID0gdGhpcy5wcmVwYXJlUXVhZFJlbmRlcmVyKCk7XG4gICAgICAgICAgICBjb25zdCBsb2FkZXIgPSBuZXcgdGhyZWUuRmlsZUxvYWRlcih0aGlzLl9pbnRlcm5hbExvYWRpbmdNYW5hZ2VyKTtcbiAgICAgICAgICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoJ2FycmF5YnVmZmVyJyk7XG4gICAgICAgICAgICBsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgICAgICAgICAgbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICAgICAgICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1TdGFydCh1cmwpO1xuICAgICAgICAgICAgbG9hZGVyLmxvYWQodXJsLCBhc3luYyAoanBlZykgPT4ge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZlxuICAgICAgICAgICAgICAgICB0aGlzIGNvbmRpdGlvbiBleGlzdHMgb25seSBiZWNhdXNlIG9mIHRocmVlLmpzIHR5cGVzICsgc3RyaWN0IG1vZGVcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YganBlZyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBidWZmZXIsIHJlY2VpdmVkIFtzdHJpbmddLCB3YXMgZXhwZWN0aW5nIFtBcnJheUJ1ZmZlcl0nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBqcGVnQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoanBlZyk7XG4gICAgICAgICAgICAgICAgbGV0IHNkckpQRUc7XG4gICAgICAgICAgICAgICAgbGV0IGdhaW5NYXBKUEVHO1xuICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRyYWN0aW9uUmVzdWx0ID0gYXdhaXQgZXh0cmFjdEdhaW5tYXBGcm9tSlBFRyhqcGVnQnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2FpbiBtYXAgaXMgc3VjY2Vzc2Z1bGx5IHJlY29uc3RydWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgc2RySlBFRyA9IGV4dHJhY3Rpb25SZXN1bHQuc2RyO1xuICAgICAgICAgICAgICAgICAgICBnYWluTWFwSlBFRyA9IGV4dHJhY3Rpb25SZXN1bHQuZ2Fpbk1hcDtcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSBleHRyYWN0aW9uUmVzdWx0Lm1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW5kZXIgdGhlIFNEUiB2ZXJzaW9uIGlmIHRoaXMgaXMgbm90IGEgZ2Fpbm1hcFxuICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFhNUE1ldGFkYXRhTm90Rm91bmRFcnJvciB8fCBlIGluc3RhbmNlb2YgR2Fpbk1hcE5vdEZvdW5kRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmFpbHVyZSB0byByZWNvbnN0cnVjdCBhbiBIRFIgaW1hZ2UgZnJvbSAke3VybH06IEdhaW4gbWFwIG1ldGFkYXRhIG5vdCBmb3VuZCBpbiB0aGUgZmlsZSwgSERSSlBHTG9hZGVyIHdpbGwgcmVuZGVyIHRoZSBTRFIganBlZ2ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2Fpbk1hcE1pbjogWzAsIDAsIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhaW5NYXBNYXg6IFsxLCAxLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYW1tYTogWzEsIDEsIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhkckNhcGFjaXR5TWluOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhkckNhcGFjaXR5TWF4OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldEhkcjogWzAsIDAsIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFNkcjogWzAsIDAsIDBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2RySlBFRyA9IGpwZWdCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNvbHZlcyAjMTZcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbmRlcihxdWFkUmVuZGVyZXIsIG1ldGFkYXRhLCBzZHJKUEVHLCBnYWluTWFwSlBFRyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBxdWFkUmVuZGVyZXIuZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uTG9hZCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgb25Mb2FkKHF1YWRSZW5kZXJlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcbiAgICAgICAgICAgICAgICBxdWFkUmVuZGVyZXIuZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKTtcbiAgICAgICAgICAgIH0sIG9uUHJvZ3Jlc3MsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcXVhZFJlbmRlcmVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0cy5HYWluTWFwRGVjb2Rlck1hdGVyaWFsID0gR2Fpbk1hcERlY29kZXJNYXRlcmlhbDtcbiAgICBleHBvcnRzLkdhaW5NYXBMb2FkZXIgPSBHYWluTWFwTG9hZGVyO1xuICAgIGV4cG9ydHMuSERSSlBHTG9hZGVyID0gSERSSlBHTG9hZGVyO1xuICAgIGV4cG9ydHMuSlBFR1JMb2FkZXIgPSBIRFJKUEdMb2FkZXI7XG4gICAgZXhwb3J0cy5NUEZFeHRyYWN0b3IgPSBNUEZFeHRyYWN0b3I7XG4gICAgZXhwb3J0cy5RdWFkUmVuZGVyZXIgPSBRdWFkUmVuZGVyZXI7XG4gICAgZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4gICAgZXhwb3J0cy5leHRyYWN0R2Fpbm1hcEZyb21KUEVHID0gZXh0cmFjdEdhaW5tYXBGcm9tSlBFRztcbiAgICBleHBvcnRzLmV4dHJhY3RYTVAgPSBleHRyYWN0WE1QO1xuXG59KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.umd.cjs\n");

/***/ })

};
;