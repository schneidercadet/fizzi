"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-stdlib";
exports.ids = ["vendor-chunks/three-stdlib"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-stdlib/_polyfill/LoaderUtils.js":
/*!************************************************************!*\
  !*** ./node_modules/three-stdlib/_polyfill/LoaderUtils.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeText: () => (/* binding */ decodeText)\n/* harmony export */ });\nfunction decodeText(array) {\n  if (typeof TextDecoder !== \"undefined\") {\n    return new TextDecoder().decode(array);\n  }\n  let s = \"\";\n  for (let i = 0, il = array.length; i < il; i++) {\n    s += String.fromCharCode(array[i]);\n  }\n  try {\n    return decodeURIComponent(escape(s));\n  } catch (e) {\n    return s;\n  }\n}\n\n//# sourceMappingURL=LoaderUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9Mb2FkZXJVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2huZWlkZXJjYWRldC9EZXNrdG9wL2ZpenppL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvX3BvbHlmaWxsL0xvYWRlclV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGRlY29kZVRleHQoYXJyYXkpIHtcbiAgaWYgKHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYXJyYXkpO1xuICB9XG4gIGxldCBzID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuZXhwb3J0IHtcbiAgZGVjb2RlVGV4dFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvYWRlclV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/_polyfill/LoaderUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/_polyfill/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/_polyfill/constants.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst version = /* @__PURE__ */ (() => parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\")))();\n\n//# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUM7QUFDakMsZ0RBQWdELDJDQUFRO0FBR3REO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2huZWlkZXJjYWRldC9EZXNrdG9wL2ZpenppL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvX3BvbHlmaWxsL2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSRVZJU0lPTiB9IGZyb20gXCJ0aHJlZVwiO1xuY29uc3QgdmVyc2lvbiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gcGFyc2VJbnQoUkVWSVNJT04ucmVwbGFjZSgvXFxEKy9nLCBcIlwiKSkpKCk7XG5leHBvcnQge1xuICB2ZXJzaW9uXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/libs/MeshoptDecoder.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshoptDecoder: () => (/* binding */ MeshoptDecoder)\n/* harmony export */ });\nlet generated;\nconst MeshoptDecoder = () => {\n  if (generated)\n    return generated;\n  const wasm_base = \"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\";\n  const wasm_simd = \"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\";\n  const detector = new Uint8Array([\n    0,\n    97,\n    115,\n    109,\n    1,\n    0,\n    0,\n    0,\n    1,\n    4,\n    1,\n    96,\n    0,\n    0,\n    3,\n    3,\n    2,\n    0,\n    0,\n    5,\n    3,\n    1,\n    0,\n    1,\n    12,\n    1,\n    0,\n    10,\n    22,\n    2,\n    12,\n    0,\n    65,\n    0,\n    65,\n    0,\n    65,\n    0,\n    252,\n    10,\n    0,\n    0,\n    11,\n    7,\n    0,\n    65,\n    0,\n    253,\n    15,\n    26,\n    11\n  ]);\n  const wasmpack = new Uint8Array([\n    32,\n    0,\n    65,\n    253,\n    3,\n    1,\n    2,\n    34,\n    4,\n    106,\n    6,\n    5,\n    11,\n    8,\n    7,\n    20,\n    13,\n    33,\n    12,\n    16,\n    128,\n    9,\n    116,\n    64,\n    19,\n    113,\n    127,\n    15,\n    10,\n    21,\n    22,\n    14,\n    255,\n    66,\n    24,\n    54,\n    136,\n    107,\n    18,\n    23,\n    192,\n    26,\n    114,\n    118,\n    132,\n    17,\n    77,\n    101,\n    130,\n    144,\n    27,\n    87,\n    131,\n    44,\n    45,\n    74,\n    156,\n    154,\n    70,\n    167\n  ]);\n  if (typeof WebAssembly !== \"object\") {\n    return {\n      supported: false\n    };\n  }\n  let wasm = wasm_base;\n  if (WebAssembly.validate(detector)) {\n    wasm = wasm_simd;\n  }\n  let instance;\n  const promise = WebAssembly.instantiate(unpack(wasm), {}).then((result) => {\n    instance = result.instance;\n    instance.exports.__wasm_call_ctors();\n  });\n  function unpack(data) {\n    const result = new Uint8Array(data.length);\n    for (let i = 0; i < data.length; ++i) {\n      const ch = data.charCodeAt(i);\n      result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;\n    }\n    let write = 0;\n    for (let i = 0; i < data.length; ++i) {\n      result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];\n    }\n    return result.buffer.slice(0, write);\n  }\n  function decode(fun, target, count, size, source, filter) {\n    const sbrk = instance.exports.sbrk;\n    const count4 = count + 3 & ~3;\n    const tp = sbrk(count4 * size);\n    const sp = sbrk(source.length);\n    const heap = new Uint8Array(instance.exports.memory.buffer);\n    heap.set(source, sp);\n    const res = fun(tp, count, size, sp, source.length);\n    if (res === 0 && filter) {\n      filter(tp, count4, size);\n    }\n    target.set(heap.subarray(tp, tp + count * size));\n    sbrk(tp - sbrk(0));\n    if (res !== 0) {\n      throw new Error(`Malformed buffer data: ${res}`);\n    }\n  }\n  const filters = {\n    // legacy index-based enums for glTF\n    0: \"\",\n    1: \"meshopt_decodeFilterOct\",\n    2: \"meshopt_decodeFilterQuat\",\n    3: \"meshopt_decodeFilterExp\",\n    // string-based enums for glTF\n    NONE: \"\",\n    OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n    QUATERNION: \"meshopt_decodeFilterQuat\",\n    EXPONENTIAL: \"meshopt_decodeFilterExp\"\n  };\n  const decoders = {\n    // legacy index-based enums for glTF\n    0: \"meshopt_decodeVertexBuffer\",\n    1: \"meshopt_decodeIndexBuffer\",\n    2: \"meshopt_decodeIndexSequence\",\n    // string-based enums for glTF\n    ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n    TRIANGLES: \"meshopt_decodeIndexBuffer\",\n    INDICES: \"meshopt_decodeIndexSequence\"\n  };\n  generated = {\n    ready: promise,\n    supported: true,\n    decodeVertexBuffer(target, count, size, source, filter) {\n      decode(\n        instance.exports.meshopt_decodeVertexBuffer,\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter]]\n      );\n    },\n    decodeIndexBuffer(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);\n    },\n    decodeIndexSequence(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source);\n    },\n    decodeGltfBuffer(target, count, size, source, mode, filter) {\n      decode(\n        instance.exports[decoders[mode]],\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter]]\n      );\n    }\n  };\n  return generated;\n};\n\n//# sourceMappingURL=MeshoptDecoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpYnMvTWVzaG9wdERlY29kZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELElBQUk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2huZWlkZXJjYWRldC9EZXNrdG9wL2ZpenppL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbGlicy9NZXNob3B0RGVjb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgZ2VuZXJhdGVkO1xuY29uc3QgTWVzaG9wdERlY29kZXIgPSAoKSA9PiB7XG4gIGlmIChnZW5lcmF0ZWQpXG4gICAgcmV0dXJuIGdlbmVyYXRlZDtcbiAgY29uc3Qgd2FzbV9iYXNlID0gXCJCOWg5ejl0RkJCQkY4Zkw5Z0JCOWdMYWFhYWFGYTlnRWFhYUI5Z0ZhRmE5Z0VhYWFGYUVNY0JGRkZHR0dFSUlJTEY5d0ZGRkxFRkJGS05GYUZDeC9JRk1PL0xGVks5dHY5dDl2cTk1R0J0OWY5ZjkzOWg5ejl0OWY5ajloOXM5czlmOWpXOXZxOXpCQnA5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5V3ZxV3Y5NGg5MTltOW12cUJGOFo5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTRoOTE5bTltdnFCR3k5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTQ5VHZaOTF2OXU5anZCRW45dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlQOWpXQklpOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5UjkxOWhXQkxuOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5Rjk0OXdCS0k5ejlpcWxCT2MreDh5Y0dCTS9xUUZUYThqVVVVVUJDVS9FQmxITDhrVVVVVUJDOStSS0dYQUdDRkpBSTlMUUJDYVJLQUUyQkJDK2dGOUhRQkFMQUVBSUpIT0FHbEFHVGtVVVVCUk5DVW9CQUc5dUMvd2dCWkhLQ1VHQUtDVUc5SnlSVkFFQ0ZKUklDQlJjR1hFWEFjQUY5UFFGQVZBRkFjbEFjQVZKQUY5SnlSTUdYR1hBRzlGUUJBTUNiSkhLQzl3WlJTQUtDSXJDRUpDR3JSUUFOQ1VHSlJmQ0JSYkFJUlRFWEdYQU9BVGxBUTlQUUJDQlJJU0VNQVRBUUpSSUdYQVM5RlFCQ0JSdENCUkVFWEdYQU9BSWxDaTlQUUJDQlJJU0xNQU5DVS9DQkpBRUpSS0dYR1hHWEdYR1hBVEFFQ0tySjJCQkF0Q0tackNFWmZJQkZHRUJNQUtoQjgzRUJBS0NOSmhCODNFQlNFTUFLQUkyQklBSTJCQkhtQ0tySFlBWUNFNkhZeTg2QkJBS0NGSkFJQ0lKQVlKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDR0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ0VKQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NJSkFZQW1KSFkyQkJBSTJCRkhtQ0tySFBBUENFNkhQeTg2QkJBS0NMSkFZQVBKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDS0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ09KQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NOSkFZQW1KSFkyQkJBSTJCR0htQ0tySFBBUENFNkhQeTg2QkJBS0NWSkFZQVBKSFkyQkJBbUNJckNFWkhQQVBDRTZIUHk4NkJCQUtDY0pBWUFQSkhZMkJCQW1DR3JDRVpIUEFQQ0U2SFB5ODZCQkFLQ01KQVlBUEpIWTJCQkFtQ0VaSG1BbUNFNkhteTg2QkJBS0NTSkFZQW1KSG0yQkJBSTJCRUhJQ0tySFlBWUNFNkhZeTg2QkJBS0NRSkFtQVlKSG0yQkJBSUNJckNFWkhZQVlDRTZIWXk4NkJCQUtDZkpBbUFZSkhtMkJCQUlDR3JDRVpIWUFZQ0U2SFl5ODZCQkFLQ2JKQW1BWUpISzJCQkFJQ0VaSElBSUNFNkhJeTg2QkJBS0FJSlJJU0dNQUtBSTJCTkFJMkJCSG1DSXJIWUFZQ2I2SFl5ODZCQkFLQ0ZKQUlDTkpBWUpIWTJCQkFtQ2JaSG1BbUNiNkhteTg2QkJBS0NHSkFZQW1KSG0yQkJBSTJCRkhZQ0lySFBBUENiNkhQeTg2QkJBS0NFSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDSUpBbUFZSkhtMkJCQUkyQkdIWUNJckhQQVBDYjZIUHk4NkJCQUtDTEpBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ0tKQW1BWUpIbTJCQkFJMkJFSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ09KQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NOSkFtQVlKSG0yQkJBSTJCSUhZQ0lySFBBUENiNkhQeTg2QkJBS0NWSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDY0pBbUFZSkhtMkJCQUkyQkxIWUNJckhQQVBDYjZIUHk4NkJCQUtDTUpBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ1NKQW1BWUpIbTJCQkFJMkJLSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ1FKQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NmSkFtQVlKSG0yQkJBSTJCT0hJQ0lySFlBWUNiNkhZeTg2QkJBS0NiSkFtQVlKSEsyQkJBSUNiWkhJQUlDYjZISXk4NkJCQUtBSUpSSVNGTUFLQUk4cEJCODNCQkFLQ05KQUlDTko4cEJCODNCQkFJQ1RKUklNQXRDR0pSdEFFQ1RKSEVBUzlKUUJNTUdYQUlRQkNCUklTRU1HWEFNOUZRQkFOQWJKMkJCUnRDQlJLQWZSRUVYQUVBTkNVL0NCSkFLSjJCQkhUQ0ZyQ0JBVENGWmw5ekF0Skh0ODZCQkFFQUdKUkVBS0NGSkhLQU05SFFCTU1BZkNGSlJmQUlSVEFiQ0ZKSGJBRzlIUUJNTUFCQWNBRzlzSkFOQ1VHSkFNQUc5c1RrVVVVQnBBTkFOQ1VHSkFNQ2FKQUc5c0pBR1RrVVVVQnBNQU1DQkFJeUFjSlJjQUlRQk1DOStSS1NGTUNCQzk5QU9BSWxBR0NBQUdDQTlMeTZ5UktNQUxDVS9FQko4a1VVVVVCQUtNK09tRlRhOGpVVVVVQkNvRmxITDhrVVVVVUJDOStSS0dYQUZDRTl1SE9DdEpBSTlMUUJDYVJLQUUyQkJITkMvd0ZaQy9nRjlIUUJBTkNiWkhWQ0Y5TFFCQUxDb0JKQ2dGQ1VGVCtKVVVVQnBBTEM4NEpoYTgzRUJBTEM4d0poYTgzRUJBTEM4b0poYTgzRUJBTENBSmhhODNFQkFMQ2lKaGE4M0VCQUxDVEpoYTgzRUJBTGhhODNFTkFMaGE4M0VCQUVBSUpDOXdKUmNBRUNGSkhOQU9KUk1HWEFGOUZRQkNRQ2JBVkNGNnlSU0FCUkVDQlJWQ0JSUUNCUmZDQlJJQ0JSS0VYR1hBTUFjdVFCQzkrUktTRU1HWEdYQU4yQkJIT0MvdkY5TFFCQUxDb0JKQU9DSXJDYTl6QUtKQ2JaQ0VXSkhiOG9HSVJUQWI4b0dCUnRHWEFPQ2JaSGJBUzlQUUJBTEFPQ2E5ekFJSkNiWkNHV0o4b0dCQVZBYnlST0FiOUZSYkdYR1hBR0NHOUhRQkFCQXQ4N0ZCQUJDSUpBTzg3RkJBQkNHSkFUODdGQlNGTUFFQXRqR0JBRUNOSkFPakdCQUVDSUpBVGpHQk1BVkFiSlJWQUxDb0JKQUtDRVdKSG1BT2pHQkFtQVRqR0lBTEFJQ0dXSkFPakdCQUxDb0JKQUtDRkpDYlpIS0NFV0pIVEF0akdCQVRBT2pHSUFJQWJKUklBS0NGSlJLU0dNR1hHWEFiQ2I2UUJBUUFiSkFiQzk4OXpKQ0ZKUlFTRk1BTTFCQkhiQ2dGWlJPR1hHWEFiQ2E5TVFCQU1DRkpSTVNGTUFNMUJGSGJDZ0JaQ09XQU9DZ0JacVJPR1hBYkNhOU1RQkFNQ0dKUk1TRk1BTTFCR0hiQ2dCWkNmV0FPcVJPR1hBYkNhOU1RQkFNQ0VKUk1TRk1BTTFCRUhiQ2dCWkNkV0FPcVJPR1hBYkNhOU1RQkFNQ0lKUk1TRk1BTTJCSUM4Y1dBT3FST0FNQ0xKUk1NQU9DRnJDQkFPQ0ZabDl6QVFKUlFNR1hHWEFHQ0c5SFFCQUJBdDg3RkJBQkNJSkFRODdGQkFCQ0dKQVQ4N0ZCU0ZNQUVBdGpHQkFFQ05KQVFqR0JBRUNJSkFUakdCTUFMQ29CSkFLQ0VXSkhPQVFqR0JBT0FUakdJQUxBSUNHV0pBUWpHQkFMQ29CSkFLQ0ZKQ2JaSEtDRVdKSE9BdGpHQkFPQVFqR0lBSUNGSlJJQUtDRkpSS1NGTUdYQU9DREY5TFFCQUxBSUFjQU9DYlpKMkJCSGJDSXJIVGxDYlpDR1dKOG9HQkFWQ0ZKSHRBVHlST0FMQUlBYmxDYlpDR1dKOG9HQkF0QVQ5RkhtSkh0QWJDYlpIVHlSYkFUOUZSVEdYR1hBR0NHOUhRQkFCQVY4N0ZCQUJDSUpBYjg3RkJBQkNHSkFPODdGQlNGTUFFQVZqR0JBRUNOSkFiakdCQUVDSUpBT2pHQk1BTEFJQ0dXSkFWakdCQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVZqR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NGSkNiWkNFV0pIWUFiakdCQVlBT2pHSUFMQUlBbUpDYlpISUNHV0pBYmpHQkFMQ29CSkFLQ0dKQ2JaSEtDRVdKSE9BVmpHQkFPQWJqR0lBS0NGSlJLQUlBVEpSSUF0QVRKUlZTRk1BVkNCQU0yQkJIWXlIVEFPQy8rRjZIUEpST0FZQ2JaUnRHWEdYQVlDSXJIbVFCQU9DRkpSYlNGTUFPUmJBTEFJQW1sQ2JaQ0dXSjhvR0JST01HWEdYQXRRQkFiQ0ZKUlZTRk1BYlJWQUxBSUFZbENiWkNHV0o4b0dCUmJNR1hHWEFQOUZRQkFNQ0ZKUllTRk1BTTFCRkhZQ2dGWlJUR1hHWEFZQ2E5TVFCQU1DR0pSWVNGTUFNMUJHSFlDZ0JaQ09XQVRDZ0JacVJUR1hBWUNhOU1RQkFNQ0VKUllTRk1BTTFCRUhZQ2dCWkNmV0FUcVJUR1hBWUNhOU1RQkFNQ0lKUllTRk1BTTFCSUhZQ2dCWkNkV0FUcVJUR1hBWUNhOU1RQkFNQ0xKUllTRk1BTUNLSlJZQU0yQkxDOGNXQVRxUlRNQVRDRnJDQkFUQ0ZabDl6QVFKSFFSVE1HWEdYQW1DYjZRQkFZUlBTRk1BWTFCQkhNQ2dGWlJPR1hHWEFNQ2E5TVFCQVlDRkpSUFNGTUFZMUJGSE1DZ0JaQ09XQU9DZ0JacVJPR1hBTUNhOU1RQkFZQ0dKUlBTRk1BWTFCR0hNQ2dCWkNmV0FPcVJPR1hBTUNhOU1RQkFZQ0VKUlBTRk1BWTFCRUhNQ2dCWkNkV0FPcVJPR1hBTUNhOU1RQkFZQ0lKUlBTRk1BWUNMSlJQQVkyQklDOGNXQU9xUk9NQU9DRnJDQkFPQ0ZabDl6QVFKSFFST01HWEdYQXRDYjZRQkFQUk1TRk1BUDFCQkhNQ2dGWlJiR1hHWEFNQ2E5TVFCQVBDRkpSTVNGTUFQMUJGSE1DZ0JaQ09XQWJDZ0JacVJiR1hBTUNhOU1RQkFQQ0dKUk1TRk1BUDFCR0hNQ2dCWkNmV0FicVJiR1hBTUNhOU1RQkFQQ0VKUk1TRk1BUDFCRUhNQ2dCWkNkV0FicVJiR1hBTUNhOU1RQkFQQ0lKUk1TRk1BUENMSlJNQVAyQklDOGNXQWJxUmJNQWJDRnJDQkFiQ0ZabDl6QVFKSFFSYk1HWEdYQUdDRzlIUUJBQkFUODdGQkFCQ0lKQWI4N0ZCQUJDR0pBTzg3RkJTRk1BRUFUakdCQUVDTkpBYmpHQkFFQ0lKQU9qR0JNQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVRqR0lBTEFJQ0dXSkFUakdCQUxDb0JKQUtDRkpDYlpDRVdKSFlBYmpHQkFZQU9qR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NHSkNiWkNFV0pIT0FUakdCQU9BYmpHSUFMQUlBbTlGQW1DYjZxSkhJQ2JaQ0dXSkFiakdCQUlBdDlGQXRDYjZxSlJJQUtDRUpSS01BTkNGSlJOQUJDS0pSQkFFQ1NKUkVBS0NiWlJLQUlDYlpSSUFmQ0VKSGZBRjlKUUJNTUNCQzk5QU1BYzZ5UktNQUxDb0ZKOGtVVVVVQkFLTS90SUZHYThqVVVVVUJDVGxSTEM5K1JLR1hBRkNMSkFJOUxRQkNhUktBRTJCQkMvK0ZaQy9RRjlIUUJBTGhCODNFTkFFQ0ZKUktBRUFJSkM5OEpSRUdYQUY5RlFCR1hBR0NHNlFCRVhHWEFLQUU5SlFCQzkrYk1BSzFCQkhHQ2dGWlJJR1hHWEFHQ2E5TVFCQUtDRkpSS1NGTUFLMUJGSEdDZ0JaQ09XQUlDZ0JacVJJR1hBR0NhOU1RQkFLQ0dKUktTRk1BSzFCR0hHQ2dCWkNmV0FJcVJJR1hBR0NhOU1RQkFLQ0VKUktTRk1BSzFCRUhHQ2dCWkNkV0FJcVJJR1hBR0NhOU1RQkFLQ0lKUktTRk1BSzJCSUM4Y1dBSXFSSUFLQ0xKUktNQUxDTkpBSUNGWkNHV3FIR0FJQ0dyQ0JBSUNGckNGWmw5ekFHOG9HQkpISWpHQkFCQUlqR0JBQkNJSlJCQUZDYUpIRlFCU0dNTUVYR1hBS0FFOUpRQkM5K2JNQUsxQkJIR0NnRlpSSUdYR1hBR0NhOU1RQkFLQ0ZKUktTRk1BSzFCRkhHQ2dCWkNPV0FJQ2dCWnFSSUdYQUdDYTlNUUJBS0NHSlJLU0ZNQUsxQkdIR0NnQlpDZldBSXFSSUdYQUdDYTlNUUJBS0NFSlJLU0ZNQUsxQkVIR0NnQlpDZFdBSXFSSUdYQUdDYTlNUUJBS0NJSlJLU0ZNQUsyQklDOGNXQUlxUklBS0NMSlJLTUFCQUlDR3JDQkFJQ0ZyQ0ZabDl6QUxDTkpBSUNGWkNHV3FISThvR0JKSEc4N0ZCQUlBR2pHQkFCQ0dKUkJBRkNhSkhGUUJNTUNCQzk5QUtBRTZ5UktNQUtNK2xMS0ZhRjk5R2FHOTlGYUc5OUdYR1hBR0NJOUhRQkFGOUZRRkVYR1hHWDlEQkJCOC85REJCQisvQUJDR0pIRzFCQit5QUIxQkJIRSt5SEkrTCtUQUJDRkpITDFCQkhLK3lITytMK1RITjlEQkJCQjlnSFZ5QU45REJCLytoQU5BTitVOURCQkJCQU5BVnlIY0FjK01ITUFFQ2EzeUFJK1NISUFJK1VBY0FNQUtDYTN5QU8rU0hjQWMrVStTK1MrUitWSE8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkVTRk1DVVVVVTk0UkVNQUdBRTg2QkJHWEdYOURCQkI4LzlEQkJCKy9BYzlEQkJCQjlneUFjQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUxBRzg2QkJHWEdYOURCQkI4LzlEQkJCKy9BSTlEQkJCQjlneUFJQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUJBRzg2QkJBQkNJSlJCQUZDYUpIRlFCU0dNTUFGOUZRQkVYR1hHWDlEQkJCOC85REJCQisvQUJDSUpIRzh1RkIreUFCOHVGQkhFK3lISStMK1RBQkNHSkhMOHVGQkhLK3lITytMK1RITjlEQkJCQjlnSFZ5QU45REIvK2c2QU5BTitVOURCQkJCQU5BVnlIY0FjK01ITUFFQ2EzeUFJK1NISUFJK1VBY0FNQUtDYTN5QU8rU0hjQWMrVStTK1MrUitWSE8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkVTRk1DVVVVVTk0UkVNQUdBRTg3RkJHWEdYOURCQkI4LzlEQkJCKy9BYzlEQkJCQjlneUFjQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUxBRzg3RkJHWEdYOURCQkI4LzlEQkJCKy9BSTlEQkJCQjlneUFJQU8rVStTSE4rTDlEQkJCOVA5ZDlGUUJBTitvUkdTRk1DVVVVVTk0UkdNQUJBRzg3RkJBQkNOSlJCQUZDYUpIRlFCTU1NL1NFSUVhRTk5RWFGOTlHWEFGOUZRQkNCUkVBQlJJRVhHWEdYOUQvekk4MTgvQUlDS0o4dUZCSExDRXEreStWSEtBSTh1RkIreStVSE85REIvK2c2K1U5REJCQjgvOURCQkIrL0FPOURCQkJCOWd5K1NITitMOURCQkI5UDlkOUZRQkFOK29SVlNGTUNVVVVVOTRSVk1BSUNJSjh1RkJSY0FJQ0dKOHVGQlJNQUJBTENGSkNFWkFFcUNGV0pBVjg3RkJHWEdYQUtBTSt5K1VITjlEQi8rZzYrVTlEQkJCOC85REJCQisvQU45REJCQkI5Z3krU0hTK0w5REJCQjlQOWQ5RlFCQVMrb1JNU0ZNQ1VVVVU5NFJNTUFCQUxDR0pDRVpBRXFDRldKQU04N0ZCR1hHWEFLQWMreStVSEs5REIvK2c2K1U5REJCQjgvOURCQkIrL0FLOURCQkJCOWd5K1NIUytMOURCQkI5UDlkOUZRQkFTK29SY1NGTUNVVVVVOTRSY01BQkFMQ2FKQ0VaQUVxQ0ZXSkFjODdGQkdYR1g5REJCVTgvQU9BTytVK1RBTkFOK1UrVEFLQUsrVStUSE85REJCQkJBTzlEQkJCQjlneStSOURCLytnNitVOURCQkI4LytTSE8rTDlEQkJCOVA5ZDlGUUJBTytvUmNTRk1DVVVVVTk0UmNNQUJBTENFWkFFcUNGV0pBYzg3RkJBSUNOSlJJQUVDSUpSRUFGQ2FKSEZRQk1NTTlKQkdYQUdDR3JBRjlzSEY5RlFCRVhBQkFCOG9HQkhHQ05XQ045MSt5QUdDaTkxQ25XQ1VVVS84RUorKytVODRHQkFCQ0lKUkJBRkNhSkhGUUJNTU05VEZFYUNCQ0I4b0dVa1VVQkhGQUJDRUpDOThaSkhCakdVa1VVQkdYR1hBQjgvQkNUV0hHdVFCQ2FSRUFCQUdsQ2dnRUpDVHJYQkNhNlFGTUFGUkVNQUVNL2xGRkZhR1hHWEFGQUJxQ0VaOUZRQkFCUkVTRk1HWEdYQUdDVDlQUUJBQlJFU0ZNQUJSRUVYQUVBRjhvR0JqR0JBRUNJSkFGQ0lKOG9HQmpHQkFFQ05KQUZDTko4b0dCakdCQUVDU0pBRkNTSjhvR0JqR0JBRUNUSlJFQUZDVEpSRkFHQzl3SkhHQ2I5TFFCTU1BR0NJOUpRQkVYQUVBRjhvR0JqR0JBRkNJSlJGQUVDSUpSRUFHQzk4SkhHQ0U5TFFCTU1HWEFHOUZRQkVYQUVBRjJCQjg2QkJBRUNGSlJFQUZDRkpSRkFHQ2FKSEdRQk1NQUJNb0ZGR2FHWEdYQUJDRVo5RlFCQUJSRVNGTUFGQ2dGWkMrQndzTjlzUklHWEdYQUdDVDlQUUJBQlJFU0ZNQUJSRUVYQUVBSWpHQkFFQ1NKQUlqR0JBRUNOSkFJakdCQUVDSUpBSWpHQkFFQ1RKUkVBR0M5d0pIR0NiOUxRQk1NQUdDSTlKUUJFWEFFQUlqR0JBRUNJSlJFQUdDOThKSEdDRTlMUUJNTUdYQUc5RlFCRVhBRUFGODZCQkFFQ0ZKUkVBR0NhSkhHUUJNTUFCTU1NRkJDVU5NSVQ5a0JCXCI7XG4gIGNvbnN0IHdhc21fc2ltZCA9IFwiQjloOXo5dEZCQkJGaUk5Z0JCOWdMYWFhYWFGYTlnRWFhYUI5Z0ZhRmFFTWNCQkZCRkZHR0dFSUxGOXdGRkZMRUZCRktORmFGQ3gvYUZNTy9MRlZLOXR2OXQ5dnE5NUdCdDlmOWY5MzloOXo5dDlmOWo5aDlzOXM5ZjlqVzl2cTl6QkJwOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OVd2cVd2OTRoOTE5bTltdnFCRzhaOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OUo5dTlrdjk0aDkxOW05bXZxQkl5OXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2OUo5dTlrdjk0OVR2Wjkxdjl1OWp2QkxuOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5UDlqV0JLaTl0djl6OW85djl3VzlmOWt2OWo5djlrdjY5cDlzV3ZxOVI5MTloV0JPbjl0djl6OW85djl3VzlmOWt2OWo5djlrdjY5cDlzV3ZxOUY5NDl3Qk5JOXo5aXFsQlZjK045SWNJQlRFTTkrRkxhOGpVVVVVQkNUbFJCQ0JSRkVYQ0JSR0NCUkVFWEFCQ05KQUdKQUVDVWFBRkFHckNGWkhJeTg2QkJBRUFJSlJFQUdDRkpIR0NOOUhRQk1BRkN4K1lVVUJKQUU4NkJCQUZDRVdDeGtVVUJKQUI4cEVOODNFQkFGQ0ZKSEZDVUc5SFFCTU1rOGxMYmFFOTdGOStGYUw5NzhqVVVVVUJDVS9LQmxITDhrVVVVVUJDOStSS0dYQUdDRkpBSTlMUUJDYVJLQUUyQkJDK2dGOUhRQkFMQUVBSUpIT0FHbEFHLzhjQkJDVW9CQUc5dUMvd2dCWkhLQ1VHQUtDVUc5SnlSTkFFQ0ZKUktDQlJWR1hFWEFWQUY5UFFGQU5BRkFWbEFWQU5KQUY5SnlSY0dYR1hBRzlGUUJBY0NiSkhJQzl3WkhNQ0U5c1JTQU1DRldSUUFJQ0lyQ0VKQ0dyUmZDQlJiRVhBS1JUQ0JSdEdYRVhHWEFPQVRsQWY5UFFCQ0JSS1NMTUFMQ1UvQ0JKQXRBTTlzSlJtQVRBZkpSS0NCUkVHWEFNQ29COUpRQkFPQUtsQy9nQjlKUUJDQlJJRVhBbUFJSlJFR1hHWEdYR1hHWEFUQUlDS3JKMkJCSFlDRVpmSUJGR0VCTUFFQ0JEdERNSUJTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlCQUtDSUpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0dNQUVBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlCQUtDTkpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUlCQUtDVEpSS01HWEdYR1hHWEdYQVlDR3JDRVpmSUJGR0VCTUFFQ0JEdERNSVRTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlUQUtDSUpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0dNQUVBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlUQUtDTkpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUlUQUtDVEpSS01HWEdYR1hHWEdYQVlDSXJDRVpmSUJGR0VCTUFFQ0JEdERNSUFTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlBQUtDSUpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0dNQUVBS0RCQk5BS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQytQK2UrOC80QkR0RDlPSGRDYkRiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIaUNFV0N4a1VVQkpEQkVCQWlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUlBQUtDTkpBZURlQkpBaUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUlBQUtDVEpSS01HWEdYR1hHWEdYQVlDS3JmSUJGR0VCTUFFQ0JEdERNSTh3U0VNQUVBS0RCQklBS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uSFBDR0QrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMwK0crTWlEdEQ5T0hkQ0VEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSFlDRVdDeGtVVUJKREJFQkFZQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIWUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JOHdBS0NJSkFlRGVCSkFZQ3grWVVVQkoyQkJKUktTR01BRUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhZQ0VXQ3hrVVVCSkRCRUJBWUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSFlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSTh3QUtDTkpBZURlQkpBWUN4K1lVVUJKMkJCSlJLU0ZNQUVBS0RCQkJETUk4d0FLQ1RKUktNQUlDb0JKUkVBSUNVRkpBTTlMUUZBRVJJQU9BS2xDL2ZCOUxRQk1NR1hBRUFNOVBRQkFFQ0VyUklFWEdYQU9BS2xDaTlQUUJDQlJLU09NQW1BRUpSWUdYR1hHWEdYR1hBVEFFQ0tySjJCQkFJQ0tackNFWmZJQkZHRUJNQVlDQkR0RE1JQlNFTUFZQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NJSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTR01BWUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NOSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTRk1BWUFLREJCQkRNSUJBS0NUSlJLTUFJQ0dKUklBRUNUSkhFQU05SlFCTU1HWEFLOUZRQkFLUlRBdENGSkh0Q0k2UUdTRk1NQ0JSS1NFTUdYQU05RlFCQUxDVUdKQWJKUkVBTEFiSkRCR0JSZUNCUllFWEFFQUxDVS9DQkpBWUpISURCSUJIZENGRDl0QWRDRkRiSFBEOU9EOWhEOVJIZEFJQU1KREJJQkg4WkNGRDl0QThaQVBEOU9EOWhEOVJIOFpEUUJURnRHbUVZSVBMZEtlT25IcEFJQVFKREJJQkh5Q0ZEOXRBeUFQRDlPRDloRDlSSHlBSUFTSkRCSUJIOGNDRkQ5dEE4Y0FQRDlPRDloRDlSSDhjRFFCVEZ0R21FWUlQTGRLZU9uSDhkRFFCRlR0R0VtWUlMUGRLT2VuSFBBUERRQkZHRUJGR0VCRkdFQkZHRUFlRDl1SGVEeUJqR0JBRUFHSkhJQWVBUEFQRFFJTEtPSUxLT0lMS09JTEtPRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFOVmNNTlZjTU5WY01OVmNNRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFTUWZiU1FmYlNRZmJTUWZiRDl1SGVEeUJqR0JBSUFHSkhJQWVBcEE4ZERRTlZpOFpjTXB5U1E4YzhkZmI4ZThmSFBBUERRQkZHRUJGR0VCRkdFQkZHRUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRSUxLT0lMS09JTEtPSUxLT0Q5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRTlZjTU5WY01OVmNNTlZjTUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRU1FmYlNRZmJTUWZiU1FmYkQ5dUhlRHlCakdCQUlBR0pISUFlQWRBOFpEUU5pVjhaY3BNeVM4Y1E4ZGY4ZWI4ZkhkQXlBOGNEUU5pVjhaY3BNeVM4Y1E4ZGY4ZWI4Zkg4WkRRQkZUdEdFbVlJTFBkS09lbkhQQVBEUUJGR0VCRkdFQkZHRUJGR0VEOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUUlMS09JTEtPSUxLT0lMS09EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUU5WY01OVmNNTlZjTU5WY01EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUVNRZmJTUWZiU1FmYlNRZmJEOXVIZUR5QmpHQkFJQUdKSElBZUFkQThaRFFOVmk4WmNNcHlTUThjOGRmYjhlOGZIUEFQRFFCRkdFQkZHRUJGR0VCRkdFRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFJTEtPSUxLT0lMS09JTEtPRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFOVmNNTlZjTU5WY01OVmNNRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFTUWZiU1FmYlNRZmJTUWZiRDl1SGVEeUJqR0JBSUFHSlJFQVlDVEpIWUFNOUpRQk1NQWJDSUpIYkFHOUpRQk1NQUJBVkFHOXNKQUxDVUdKQWNBRzlzLzhjQkJBTEFMQ1VHSkFjQ2FKQUc5c0pBRy84Y0JCTUFjQ0JBS3lBVkpSVkFLUUJNQzkrUktTRk1DQkM5OUFPQUtsQUdDQUFHQ0E5THk2eVJLTUFMQ1UvS0JKOGtVVVVVQkFLTU5CVCtCVVVVQk0rS21GVGE4alVVVVVCQ29GbEhMOGtVVVVVQkM5K1JLR1hBRkNFOXVIT0N0SkFJOUxRQkNhUktBRTJCQkhOQy93RlpDL2dGOUhRQkFOQ2JaSFZDRjlMUUJBTENvQkpDZ0ZDVUYvOE1CQUxDODRKaGE4M0VCQUxDOHdKaGE4M0VCQUxDOG9KaGE4M0VCQUxDQUpoYTgzRUJBTENpSmhhODNFQkFMQ1RKaGE4M0VCQUxoYTgzRU5BTGhhODNFQkFFQUlKQzl3SlJjQUVDRkpITkFPSlJNR1hBRjlGUUJDUUNiQVZDRjZ5UlNBQlJFQ0JSVkNCUlFDQlJmQ0JSSUNCUktFWEdYQU1BY3VRQkM5K1JLU0VNR1hHWEFOMkJCSE9DL3ZGOUxRQkFMQ29CSkFPQ0lyQ2E5ekFLSkNiWkNFV0pIYjhvR0lSVEFiOG9HQlJ0R1hBT0NiWkhiQVM5UFFCQUxBT0NhOXpBSUpDYlpDR1dKOG9HQkFWQWJ5Uk9BYjlGUmJHWEdYQUdDRzlIUUJBQkF0ODdGQkFCQ0lKQU84N0ZCQUJDR0pBVDg3RkJTRk1BRUF0akdCQUVDTkpBT2pHQkFFQ0lKQVRqR0JNQVZBYkpSVkFMQ29CSkFLQ0VXSkhtQU9qR0JBbUFUakdJQUxBSUNHV0pBT2pHQkFMQ29CSkFLQ0ZKQ2JaSEtDRVdKSFRBdGpHQkFUQU9qR0lBSUFiSlJJQUtDRkpSS1NHTUdYR1hBYkNiNlFCQVFBYkpBYkM5ODl6SkNGSlJRU0ZNQU0xQkJIYkNnRlpST0dYR1hBYkNhOU1RQkFNQ0ZKUk1TRk1BTTFCRkhiQ2dCWkNPV0FPQ2dCWnFST0dYQWJDYTlNUUJBTUNHSlJNU0ZNQU0xQkdIYkNnQlpDZldBT3FST0dYQWJDYTlNUUJBTUNFSlJNU0ZNQU0xQkVIYkNnQlpDZFdBT3FST0dYQWJDYTlNUUJBTUNJSlJNU0ZNQU0yQklDOGNXQU9xUk9BTUNMSlJNTUFPQ0ZyQ0JBT0NGWmw5ekFRSlJRTUdYR1hBR0NHOUhRQkFCQXQ4N0ZCQUJDSUpBUTg3RkJBQkNHSkFUODdGQlNGTUFFQXRqR0JBRUNOSkFRakdCQUVDSUpBVGpHQk1BTENvQkpBS0NFV0pIT0FRakdCQU9BVGpHSUFMQUlDR1dKQVFqR0JBTENvQkpBS0NGSkNiWkhLQ0VXSkhPQXRqR0JBT0FRakdJQUlDRkpSSUFLQ0ZKUktTRk1HWEFPQ0RGOUxRQkFMQUlBY0FPQ2JaSjJCQkhiQ0lySFRsQ2JaQ0dXSjhvR0JBVkNGSkh0QVR5Uk9BTEFJQWJsQ2JaQ0dXSjhvR0JBdEFUOUZIbUpIdEFiQ2JaSFR5UmJBVDlGUlRHWEdYQUdDRzlIUUJBQkFWODdGQkFCQ0lKQWI4N0ZCQUJDR0pBTzg3RkJTRk1BRUFWakdCQUVDTkpBYmpHQkFFQ0lKQU9qR0JNQUxBSUNHV0pBVmpHQkFMQ29CSkFLQ0VXSkhZQU9qR0JBWUFWakdJQUxBSUNGSkhJQ2JaQ0dXSkFPakdCQUxDb0JKQUtDRkpDYlpDRVdKSFlBYmpHQkFZQU9qR0lBTEFJQW1KQ2JaSElDR1dKQWJqR0JBTENvQkpBS0NHSkNiWkhLQ0VXSkhPQVZqR0JBT0FiakdJQUtDRkpSS0FJQVRKUklBdEFUSlJWU0ZNQVZDQkFNMkJCSFl5SFRBT0MvK0Y2SFBKUk9BWUNiWlJ0R1hHWEFZQ0lySG1RQkFPQ0ZKUmJTRk1BT1JiQUxBSUFtbENiWkNHV0o4b0dCUk9NR1hHWEF0UUJBYkNGSlJWU0ZNQWJSVkFMQUlBWWxDYlpDR1dKOG9HQlJiTUdYR1hBUDlGUUJBTUNGSlJZU0ZNQU0xQkZIWUNnRlpSVEdYR1hBWUNhOU1RQkFNQ0dKUllTRk1BTTFCR0hZQ2dCWkNPV0FUQ2dCWnFSVEdYQVlDYTlNUUJBTUNFSlJZU0ZNQU0xQkVIWUNnQlpDZldBVHFSVEdYQVlDYTlNUUJBTUNJSlJZU0ZNQU0xQklIWUNnQlpDZFdBVHFSVEdYQVlDYTlNUUJBTUNMSlJZU0ZNQU1DS0pSWUFNMkJMQzhjV0FUcVJUTUFUQ0ZyQ0JBVENGWmw5ekFRSkhRUlRNR1hHWEFtQ2I2UUJBWVJQU0ZNQVkxQkJITUNnRlpST0dYR1hBTUNhOU1RQkFZQ0ZKUlBTRk1BWTFCRkhNQ2dCWkNPV0FPQ2dCWnFST0dYQU1DYTlNUUJBWUNHSlJQU0ZNQVkxQkdITUNnQlpDZldBT3FST0dYQU1DYTlNUUJBWUNFSlJQU0ZNQVkxQkVITUNnQlpDZFdBT3FST0dYQU1DYTlNUUJBWUNJSlJQU0ZNQVlDTEpSUEFZMkJJQzhjV0FPcVJPTUFPQ0ZyQ0JBT0NGWmw5ekFRSkhRUk9NR1hHWEF0Q2I2UUJBUFJNU0ZNQVAxQkJITUNnRlpSYkdYR1hBTUNhOU1RQkFQQ0ZKUk1TRk1BUDFCRkhNQ2dCWkNPV0FiQ2dCWnFSYkdYQU1DYTlNUUJBUENHSlJNU0ZNQVAxQkdITUNnQlpDZldBYnFSYkdYQU1DYTlNUUJBUENFSlJNU0ZNQVAxQkVITUNnQlpDZFdBYnFSYkdYQU1DYTlNUUJBUENJSlJNU0ZNQVBDTEpSTUFQMkJJQzhjV0FicVJiTUFiQ0ZyQ0JBYkNGWmw5ekFRSkhRUmJNR1hHWEFHQ0c5SFFCQUJBVDg3RkJBQkNJSkFiODdGQkFCQ0dKQU84N0ZCU0ZNQUVBVGpHQkFFQ05KQWJqR0JBRUNJSkFPakdCTUFMQ29CSkFLQ0VXSkhZQU9qR0JBWUFUakdJQUxBSUNHV0pBVGpHQkFMQ29CSkFLQ0ZKQ2JaQ0VXSkhZQWJqR0JBWUFPakdJQUxBSUNGSkhJQ2JaQ0dXSkFPakdCQUxDb0JKQUtDR0pDYlpDRVdKSE9BVGpHQkFPQWJqR0lBTEFJQW05RkFtQ2I2cUpISUNiWkNHV0pBYmpHQkFJQXQ5RkF0Q2I2cUpSSUFLQ0VKUktNQU5DRkpSTkFCQ0tKUkJBRUNTSlJFQUtDYlpSS0FJQ2JaUklBZkNFSkhmQUY5SlFCTU1DQkM5OUFNQWM2eVJLTUFMQ29GSjhrVVVVVUJBS00vdElGR2E4alVVVVVCQ1RsUkxDOStSS0dYQUZDTEpBSTlMUUJDYVJLQUUyQkJDLytGWkMvUUY5SFFCQUxoQjgzRU5BRUNGSlJLQUVBSUpDOThKUkVHWEFGOUZRQkdYQUdDRzZRQkVYR1hBS0FFOUpRQkM5K2JNQUsxQkJIR0NnRlpSSUdYR1hBR0NhOU1RQkFLQ0ZKUktTRk1BSzFCRkhHQ2dCWkNPV0FJQ2dCWnFSSUdYQUdDYTlNUUJBS0NHSlJLU0ZNQUsxQkdIR0NnQlpDZldBSXFSSUdYQUdDYTlNUUJBS0NFSlJLU0ZNQUsxQkVIR0NnQlpDZFdBSXFSSUdYQUdDYTlNUUJBS0NJSlJLU0ZNQUsyQklDOGNXQUlxUklBS0NMSlJLTUFMQ05KQUlDRlpDR1dxSEdBSUNHckNCQUlDRnJDRlpsOXpBRzhvR0JKSElqR0JBQkFJakdCQUJDSUpSQkFGQ2FKSEZRQlNHTU1FWEdYQUtBRTlKUUJDOStiTUFLMUJCSEdDZ0ZaUklHWEdYQUdDYTlNUUJBS0NGSlJLU0ZNQUsxQkZIR0NnQlpDT1dBSUNnQlpxUklHWEFHQ2E5TVFCQUtDR0pSS1NGTUFLMUJHSEdDZ0JaQ2ZXQUlxUklHWEFHQ2E5TVFCQUtDRUpSS1NGTUFLMUJFSEdDZ0JaQ2RXQUlxUklHWEFHQ2E5TVFCQUtDSUpSS1NGTUFLMkJJQzhjV0FJcVJJQUtDTEpSS01BQkFJQ0dyQ0JBSUNGckNGWmw5ekFMQ05KQUlDRlpDR1dxSEk4b0dCSkhHODdGQkFJQUdqR0JBQkNHSlJCQUZDYUpIRlFCTU1DQkM5OUFLQUU2eVJLTUFLTS9kTEVLOTdGYUY5N0dYR1hBR0NJOUhRQkFGOUZRRkNCUkdFWEFCQUJEQkJCSEVDaUQrckZDaUQrc0ZELzZGSElBRUNORCtyRkNpRCtzRkQvNkZBSUQvZ0ZBRUNURCtyRkNpRCtzRkQvNkZITEQvZ0ZEL2tGRC9sRkhLQ0JEdEQrMkZIT0FJQ1VVVVU5NER0SE5EOU9EOVJEL2tGSEk5REJCLytoRFlBSUFJRC9tRkFLQUtEL21GQUxBT0FMQU5EOU9EOVJEL2tGSElBSUQvbUZEL2tGRC9rRkQvakZEL25GSExEL21GOURCQlg5TERZSE9EL2tGQ2dGRHREOU9BRUNVVVU5NER0RDlPRDlRQUlBTEQvbUZBT0Qva0ZDTkQrckZDVS8rRUR0RDlPRDlRQUtBTEQvbUZBT0Qva0ZDVEQrckZDVVUvOE9EdEQ5T0Q5UURNQkJBQkNUSlJCQUdDSUpIR0FGOUpRQlNHTU1BRjlGUUJDQlJHRVhBQkNUSkhWQVZEQkJCSEVDQkR0SE9DVVU5OEQ4Y0ZDVVU5OEQ4Y0VITkQ5T0FCREJCQkhLQUVEUUlMS09TUWZiUGRlbjhjOGQ4ZThmQ2dnRkR0RDlPRC82RkFLQUVEUUJGR0VOVmNNVHRtWWk4WnB5SEVDVEQrc0ZELzZGSElEL2dGQUVDVEQrckZDVEQrc0ZELzZGSExEL2dGRC9rRkQvbEZIRTlEQi8rZzZEWUFMQUVBT0QrMkZIT0FMQ1VVVVU5NER0SGNEOU9EOVJEL2tGSExBTEQvbUZBRUFFRC9tRkFJQU9BSUFjRDlPRDlSRC9rRkhFQUVEL21GRC9rRkQva0ZEL2pGRC9uRkhJRC9tRjlEQkJYOUxEWUhPRC9rRkNURCtyRkFMQUlEL21GQU9EL2tGQ2dnRUR0RDlPRDlRSExBRUFJRC9tRkFPRC9rRkNhRGJDQkRuR0NCRG5FQ0JEbktDQkRuT0NCRG5jQ0JEbk1DQkRuZkNCRG5iRDlPSEVEUU5WaThaY01weVNROGM4ZGZiOGU4ZkQ5UURNQkJBQkFLQU5EOU9BTEFFRFFCRlR0R0VtWUlMUGRLT2VuRDlRRE1CQkFCQ0FKUkJBR0NJSkhHQUY5SlFCTU1NL2hFSUdhRjk3RmFMOTc4alVVVVVCQ1RsUkVHWEFGOUZRQkNCUklFWEFFQUJEQkJCSExBQkNUSkhLREJCQkhPRFFJTEtPU1FmYlBkZW44YzhkOGU4ZkhOQ1REK3NGSFZDSUQrckZETUlCQUI5REJCVTgvRFk5RC96STgxOC9EWUFWQ0VEdEQ5UUQvNkZEL25GSFZBTEFPRFFCRkdFTlZjTVR0bVlpOFpweUhMQ1REK3JGQ1REK3NGRC82RkQvbUZIT0FPRC9tRkFWQUxDVEQrc0ZELzZGRC9tRkhjQWNEL21GQVZBTkNURCtyRkNURCtzRkQvNkZEL21GSE5BTkQvbUZEL2tGRC9rRkQvbEZDQkR0RCs0RkQvakY5REIvK2c2RFlIVkQvbUY5REJCWDlMRFlITEQva0ZDZ2dFRHRITUQ5T0FjQVZEL21GQUxEL2tGQ1REK3JGRDlRSGNBTkFWRC9tRkFMRC9rRkNURCtyRkFPQVZEL21GQUxEL2tGQU1EOU9EOVFIVkRRQkZUdEdFbVlJTFBkS09lbkhMRDhkQkFFREJJQkR5Qit0K0o4M0VCQUJDTkpBTEQ4ZEZBRURCSUJEeUYrdCtKODNFQkFLQWNBVkRRTlZpOFpjTXB5U1E4YzhkZmI4ZThmSFZEOGRCQUVEQklCRHlHK3QrSjgzRUJBQkNpSkFWRDhkRkFFREJJQkR5RSt0K0o4M0VCQUJDQUpSQkFJQ0lKSElBRjlKUUJNTU05akZGOTdHWEFHQ0dyQUY5c0hHOUZRQkNCUkZFWEFCQUJEQkJCSEVDTkQrckZDTkQrc0ZELzZGQUVDaUQrc0ZDbkQrckZDVVVVLzhFRHREK3VGRC9tRkRNQkJBQkNUSlJCQUZDSUpIRkFHOUpRQk1NTTlURkVhQ0JDQjhvR1VrVVVCSEZBQkNFSkM5OFpKSEJqR1VrVVVCR1hHWEFCOC9CQ1RXSEd1UUJDYVJFQUJBR2xDZ2dFSkNUclhCQ2E2UUZNQUZSRU1BRU1NTUZCQ1VOTUlUOXRCQlwiO1xuICBjb25zdCBkZXRlY3RvciA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAwLFxuICAgIDk3LFxuICAgIDExNSxcbiAgICAxMDksXG4gICAgMSxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICAxLFxuICAgIDQsXG4gICAgMSxcbiAgICA5NixcbiAgICAwLFxuICAgIDAsXG4gICAgMyxcbiAgICAzLFxuICAgIDIsXG4gICAgMCxcbiAgICAwLFxuICAgIDUsXG4gICAgMyxcbiAgICAxLFxuICAgIDAsXG4gICAgMSxcbiAgICAxMixcbiAgICAxLFxuICAgIDAsXG4gICAgMTAsXG4gICAgMjIsXG4gICAgMixcbiAgICAxMixcbiAgICAwLFxuICAgIDY1LFxuICAgIDAsXG4gICAgNjUsXG4gICAgMCxcbiAgICA2NSxcbiAgICAwLFxuICAgIDI1MixcbiAgICAxMCxcbiAgICAwLFxuICAgIDAsXG4gICAgMTEsXG4gICAgNyxcbiAgICAwLFxuICAgIDY1LFxuICAgIDAsXG4gICAgMjUzLFxuICAgIDE1LFxuICAgIDI2LFxuICAgIDExXG4gIF0pO1xuICBjb25zdCB3YXNtcGFjayA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAzMixcbiAgICAwLFxuICAgIDY1LFxuICAgIDI1MyxcbiAgICAzLFxuICAgIDEsXG4gICAgMixcbiAgICAzNCxcbiAgICA0LFxuICAgIDEwNixcbiAgICA2LFxuICAgIDUsXG4gICAgMTEsXG4gICAgOCxcbiAgICA3LFxuICAgIDIwLFxuICAgIDEzLFxuICAgIDMzLFxuICAgIDEyLFxuICAgIDE2LFxuICAgIDEyOCxcbiAgICA5LFxuICAgIDExNixcbiAgICA2NCxcbiAgICAxOSxcbiAgICAxMTMsXG4gICAgMTI3LFxuICAgIDE1LFxuICAgIDEwLFxuICAgIDIxLFxuICAgIDIyLFxuICAgIDE0LFxuICAgIDI1NSxcbiAgICA2NixcbiAgICAyNCxcbiAgICA1NCxcbiAgICAxMzYsXG4gICAgMTA3LFxuICAgIDE4LFxuICAgIDIzLFxuICAgIDE5MixcbiAgICAyNixcbiAgICAxMTQsXG4gICAgMTE4LFxuICAgIDEzMixcbiAgICAxNyxcbiAgICA3NyxcbiAgICAxMDEsXG4gICAgMTMwLFxuICAgIDE0NCxcbiAgICAyNyxcbiAgICA4NyxcbiAgICAxMzEsXG4gICAgNDQsXG4gICAgNDUsXG4gICAgNzQsXG4gICAgMTU2LFxuICAgIDE1NCxcbiAgICA3MCxcbiAgICAxNjdcbiAgXSk7XG4gIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VwcG9ydGVkOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgbGV0IHdhc20gPSB3YXNtX2Jhc2U7XG4gIGlmIChXZWJBc3NlbWJseS52YWxpZGF0ZShkZXRlY3RvcikpIHtcbiAgICB3YXNtID0gd2FzbV9zaW1kO1xuICB9XG4gIGxldCBpbnN0YW5jZTtcbiAgY29uc3QgcHJvbWlzZSA9IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHVucGFjayh3YXNtKSwge30pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgIGluc3RhbmNlID0gcmVzdWx0Lmluc3RhbmNlO1xuICAgIGluc3RhbmNlLmV4cG9ydHMuX193YXNtX2NhbGxfY3RvcnMoKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIHVucGFjayhkYXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgY2ggPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICByZXN1bHRbaV0gPSBjaCA+IDk2ID8gY2ggLSA3MSA6IGNoID4gNjQgPyBjaCAtIDY1IDogY2ggPiA0NyA/IGNoICsgNCA6IGNoID4gNDYgPyA2MyA6IDYyO1xuICAgIH1cbiAgICBsZXQgd3JpdGUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgcmVzdWx0W3dyaXRlKytdID0gcmVzdWx0W2ldIDwgNjAgPyB3YXNtcGFja1tyZXN1bHRbaV1dIDogKHJlc3VsdFtpXSAtIDYwKSAqIDY0ICsgcmVzdWx0WysraV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuYnVmZmVyLnNsaWNlKDAsIHdyaXRlKTtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUoZnVuLCB0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UsIGZpbHRlcikge1xuICAgIGNvbnN0IHNicmsgPSBpbnN0YW5jZS5leHBvcnRzLnNicms7XG4gICAgY29uc3QgY291bnQ0ID0gY291bnQgKyAzICYgfjM7XG4gICAgY29uc3QgdHAgPSBzYnJrKGNvdW50NCAqIHNpemUpO1xuICAgIGNvbnN0IHNwID0gc2Jyayhzb3VyY2UubGVuZ3RoKTtcbiAgICBjb25zdCBoZWFwID0gbmV3IFVpbnQ4QXJyYXkoaW5zdGFuY2UuZXhwb3J0cy5tZW1vcnkuYnVmZmVyKTtcbiAgICBoZWFwLnNldChzb3VyY2UsIHNwKTtcbiAgICBjb25zdCByZXMgPSBmdW4odHAsIGNvdW50LCBzaXplLCBzcCwgc291cmNlLmxlbmd0aCk7XG4gICAgaWYgKHJlcyA9PT0gMCAmJiBmaWx0ZXIpIHtcbiAgICAgIGZpbHRlcih0cCwgY291bnQ0LCBzaXplKTtcbiAgICB9XG4gICAgdGFyZ2V0LnNldChoZWFwLnN1YmFycmF5KHRwLCB0cCArIGNvdW50ICogc2l6ZSkpO1xuICAgIHNicmsodHAgLSBzYnJrKDApKTtcbiAgICBpZiAocmVzICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCBidWZmZXIgZGF0YTogJHtyZXN9YCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGZpbHRlcnMgPSB7XG4gICAgLy8gbGVnYWN5IGluZGV4LWJhc2VkIGVudW1zIGZvciBnbFRGXG4gICAgMDogXCJcIixcbiAgICAxOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyT2N0XCIsXG4gICAgMjogXCJtZXNob3B0X2RlY29kZUZpbHRlclF1YXRcIixcbiAgICAzOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyRXhwXCIsXG4gICAgLy8gc3RyaW5nLWJhc2VkIGVudW1zIGZvciBnbFRGXG4gICAgTk9ORTogXCJcIixcbiAgICBPQ1RBSEVEUkFMOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyT2N0XCIsXG4gICAgUVVBVEVSTklPTjogXCJtZXNob3B0X2RlY29kZUZpbHRlclF1YXRcIixcbiAgICBFWFBPTkVOVElBTDogXCJtZXNob3B0X2RlY29kZUZpbHRlckV4cFwiXG4gIH07XG4gIGNvbnN0IGRlY29kZXJzID0ge1xuICAgIC8vIGxlZ2FjeSBpbmRleC1iYXNlZCBlbnVtcyBmb3IgZ2xURlxuICAgIDA6IFwibWVzaG9wdF9kZWNvZGVWZXJ0ZXhCdWZmZXJcIixcbiAgICAxOiBcIm1lc2hvcHRfZGVjb2RlSW5kZXhCdWZmZXJcIixcbiAgICAyOiBcIm1lc2hvcHRfZGVjb2RlSW5kZXhTZXF1ZW5jZVwiLFxuICAgIC8vIHN0cmluZy1iYXNlZCBlbnVtcyBmb3IgZ2xURlxuICAgIEFUVFJJQlVURVM6IFwibWVzaG9wdF9kZWNvZGVWZXJ0ZXhCdWZmZXJcIixcbiAgICBUUklBTkdMRVM6IFwibWVzaG9wdF9kZWNvZGVJbmRleEJ1ZmZlclwiLFxuICAgIElORElDRVM6IFwibWVzaG9wdF9kZWNvZGVJbmRleFNlcXVlbmNlXCJcbiAgfTtcbiAgZ2VuZXJhdGVkID0ge1xuICAgIHJlYWR5OiBwcm9taXNlLFxuICAgIHN1cHBvcnRlZDogdHJ1ZSxcbiAgICBkZWNvZGVWZXJ0ZXhCdWZmZXIodGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlLCBmaWx0ZXIpIHtcbiAgICAgIGRlY29kZShcbiAgICAgICAgaW5zdGFuY2UuZXhwb3J0cy5tZXNob3B0X2RlY29kZVZlcnRleEJ1ZmZlcixcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBjb3VudCxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW2ZpbHRlcnNbZmlsdGVyXV1cbiAgICAgICk7XG4gICAgfSxcbiAgICBkZWNvZGVJbmRleEJ1ZmZlcih0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UpIHtcbiAgICAgIGRlY29kZShpbnN0YW5jZS5leHBvcnRzLm1lc2hvcHRfZGVjb2RlSW5kZXhCdWZmZXIsIHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSk7XG4gICAgfSxcbiAgICBkZWNvZGVJbmRleFNlcXVlbmNlKHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSkge1xuICAgICAgZGVjb2RlKGluc3RhbmNlLmV4cG9ydHMubWVzaG9wdF9kZWNvZGVJbmRleFNlcXVlbmNlLCB0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UpO1xuICAgIH0sXG4gICAgZGVjb2RlR2x0ZkJ1ZmZlcih0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UsIG1vZGUsIGZpbHRlcikge1xuICAgICAgZGVjb2RlKFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW2RlY29kZXJzW21vZGVdXSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBjb3VudCxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzW2ZpbHRlcnNbZmlsdGVyXV1cbiAgICAgICk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZ2VuZXJhdGVkO1xufTtcbmV4cG9ydCB7XG4gIE1lc2hvcHREZWNvZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzaG9wdERlY29kZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/DRACOLoader.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DRACOLoader: () => (/* binding */ DRACOLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst _taskCache = /* @__PURE__ */ new WeakMap();\nclass DRACOLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  constructor(manager) {\n    super(manager);\n    this.decoderPath = \"\";\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = \"\";\n    this.defaultAttributeIDs = {\n      position: \"POSITION\",\n      normal: \"NORMAL\",\n      color: \"COLOR\",\n      uv: \"TEX_COORD\"\n    };\n    this.defaultAttributeTypes = {\n      position: \"Float32Array\",\n      normal: \"Float32Array\",\n      color: \"Float32Array\",\n      uv: \"Float32Array\"\n    };\n  }\n  setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  }\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  }\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      (buffer) => {\n        const taskConfig = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: false\n        };\n        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n      },\n      onProgress,\n      onError\n    );\n  }\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n  decodeGeometry(buffer, taskConfig) {\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute];\n      if (type.BYTES_PER_ELEMENT !== void 0) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    }\n    const taskKey = JSON.stringify(taskConfig);\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        throw new Error(\n          \"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\"\n        );\n      }\n    }\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength;\n    const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = { resolve, reject };\n        worker.postMessage({ type: \"decode\", id: taskID, taskConfig, buffer }, [buffer]);\n      });\n    }).then((message) => this._createGeometry(message.geometry));\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID);\n      }\n    });\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n    return geometryPending;\n  }\n  _createGeometry(geometryData) {\n    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n    if (geometryData.index) {\n      geometry.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(geometryData.index.array, 1));\n    }\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i];\n      const name = attribute.name;\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize));\n    }\n    return geometry;\n  }\n  _loadLibrary(url, responseType) {\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, void 0, reject);\n    });\n  }\n  preload() {\n    this._initDecoder();\n    return this;\n  }\n  _initDecoder() {\n    if (this.decoderPending)\n      return this.decoderPending;\n    const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n    const librariesPending = [];\n    if (useJS) {\n      librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n    } else {\n      librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n      librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n    }\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0];\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n      const fn = DRACOWorker.toString();\n      const body = [\n        \"/* draco decoder */\",\n        jsContent,\n        \"\",\n        \"/* worker */\",\n        fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n      ].join(\"\\n\");\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  }\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker2 = new Worker(this.workerSourceURL);\n        worker2._callbacks = {};\n        worker2._taskCosts = {};\n        worker2._taskLoad = 0;\n        worker2.postMessage({ type: \"init\", decoderConfig: this.decoderConfig });\n        worker2.onmessage = function(e) {\n          const message = e.data;\n          switch (message.type) {\n            case \"decode\":\n              worker2._callbacks[message.id].resolve(message);\n              break;\n            case \"error\":\n              worker2._callbacks[message.id].reject(message);\n              break;\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n        this.workerPool.push(worker2);\n      } else {\n        this.workerPool.sort(function(a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n  debug() {\n    console.log(\n      \"Task load: \",\n      this.workerPool.map((worker) => worker._taskLoad)\n    );\n  }\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n    this.workerPool.length = 0;\n    return this;\n  }\n}\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n  onmessage = function(e) {\n    const message = e.data;\n    switch (message.type) {\n      case \"init\":\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function(resolve) {\n          decoderConfig.onModuleLoaded = function(draco) {\n            resolve({ draco });\n          };\n          DracoDecoderModule(decoderConfig);\n        });\n        break;\n      case \"decode\":\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then((module) => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          const decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            const buffers = geometry.attributes.map((attr) => attr.array.buffer);\n            if (geometry.index)\n              buffers.push(geometry.index.array.buffer);\n            self.postMessage({ type: \"decode\", id: message.id, geometry }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({ type: \"error\", id: message.id, error: error.message });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n    let dracoGeometry;\n    let decodingStatus;\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n    }\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n    }\n    const geometry = { index: null, attributes: [] };\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n      let attribute;\n      let attributeID;\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1)\n          continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    }\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n    const ptr = draco._malloc(byteLength);\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n    draco._free(ptr);\n    return { array: index, itemSize: 1 };\n  }\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n    const ptr = draco._malloc(byteLength);\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n    draco._free(ptr);\n    return {\n      name: attributeName,\n      array,\n      itemSize: numComponents\n    };\n  }\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n      case Int8Array:\n        return draco.DT_INT8;\n      case Int16Array:\n        return draco.DT_INT16;\n      case Int32Array:\n        return draco.DT_INT32;\n      case Uint8Array:\n        return draco.DT_UINT8;\n      case Uint16Array:\n        return draco.DT_UINT16;\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\n\n//# sourceMappingURL=DRACOLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRFJBQ09Mb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEU7QUFDNUU7QUFDQSwwQkFBMEIseUNBQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZDQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsNkJBQTZCLGdEQUFnRDtBQUM3RSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaURBQWM7QUFDdkM7QUFDQSw0QkFBNEIsa0RBQWU7QUFDM0M7QUFDQSxvQkFBb0Isb0NBQW9DO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtEQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZDQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseUJBQXlCO0FBQzNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlEQUFpRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMENBQTBDO0FBQ3pFLFlBQVk7QUFDWjtBQUNBLCtCQUErQixxREFBcUQ7QUFDcEYsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvc2NobmVpZGVyY2FkZXQvRGVza3RvcC9maXp6aS9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRFJBQ09Mb2FkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9hZGVyLCBGaWxlTG9hZGVyLCBCdWZmZXJHZW9tZXRyeSwgQnVmZmVyQXR0cmlidXRlIH0gZnJvbSBcInRocmVlXCI7XG5jb25zdCBfdGFza0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jbGFzcyBEUkFDT0xvYWRlciBleHRlbmRzIExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICBzdXBlcihtYW5hZ2VyKTtcbiAgICB0aGlzLmRlY29kZXJQYXRoID0gXCJcIjtcbiAgICB0aGlzLmRlY29kZXJDb25maWcgPSB7fTtcbiAgICB0aGlzLmRlY29kZXJCaW5hcnkgPSBudWxsO1xuICAgIHRoaXMuZGVjb2RlclBlbmRpbmcgPSBudWxsO1xuICAgIHRoaXMud29ya2VyTGltaXQgPSA0O1xuICAgIHRoaXMud29ya2VyUG9vbCA9IFtdO1xuICAgIHRoaXMud29ya2VyTmV4dFRhc2tJRCA9IDE7XG4gICAgdGhpcy53b3JrZXJTb3VyY2VVUkwgPSBcIlwiO1xuICAgIHRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcyA9IHtcbiAgICAgIHBvc2l0aW9uOiBcIlBPU0lUSU9OXCIsXG4gICAgICBub3JtYWw6IFwiTk9STUFMXCIsXG4gICAgICBjb2xvcjogXCJDT0xPUlwiLFxuICAgICAgdXY6IFwiVEVYX0NPT1JEXCJcbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVR5cGVzID0ge1xuICAgICAgcG9zaXRpb246IFwiRmxvYXQzMkFycmF5XCIsXG4gICAgICBub3JtYWw6IFwiRmxvYXQzMkFycmF5XCIsXG4gICAgICBjb2xvcjogXCJGbG9hdDMyQXJyYXlcIixcbiAgICAgIHV2OiBcIkZsb2F0MzJBcnJheVwiXG4gICAgfTtcbiAgfVxuICBzZXREZWNvZGVyUGF0aChwYXRoKSB7XG4gICAgdGhpcy5kZWNvZGVyUGF0aCA9IHBhdGg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0RGVjb2RlckNvbmZpZyhjb25maWcpIHtcbiAgICB0aGlzLmRlY29kZXJDb25maWcgPSBjb25maWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0V29ya2VyTGltaXQod29ya2VyTGltaXQpIHtcbiAgICB0aGlzLndvcmtlckxpbWl0ID0gd29ya2VyTGltaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG4gICAgbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XG4gICAgbG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICBsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICBsb2FkZXIubG9hZChcbiAgICAgIHVybCxcbiAgICAgIChidWZmZXIpID0+IHtcbiAgICAgICAgY29uc3QgdGFza0NvbmZpZyA9IHtcbiAgICAgICAgICBhdHRyaWJ1dGVJRHM6IHRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcyxcbiAgICAgICAgICBhdHRyaWJ1dGVUeXBlczogdGhpcy5kZWZhdWx0QXR0cmlidXRlVHlwZXMsXG4gICAgICAgICAgdXNlVW5pcXVlSURzOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlY29kZUdlb21ldHJ5KGJ1ZmZlciwgdGFza0NvbmZpZykudGhlbihvbkxvYWQpLmNhdGNoKG9uRXJyb3IpO1xuICAgICAgfSxcbiAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICBvbkVycm9yXG4gICAgKTtcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgS2VwdCBmb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eSB3aXRoIHByZXZpb3VzIERSQUNPTG9hZGVyIHZlcnNpb25zLiAqL1xuICBkZWNvZGVEcmFjb0ZpbGUoYnVmZmVyLCBjYWxsYmFjaywgYXR0cmlidXRlSURzLCBhdHRyaWJ1dGVUeXBlcykge1xuICAgIGNvbnN0IHRhc2tDb25maWcgPSB7XG4gICAgICBhdHRyaWJ1dGVJRHM6IGF0dHJpYnV0ZUlEcyB8fCB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVJRHMsXG4gICAgICBhdHRyaWJ1dGVUeXBlczogYXR0cmlidXRlVHlwZXMgfHwgdGhpcy5kZWZhdWx0QXR0cmlidXRlVHlwZXMsXG4gICAgICB1c2VVbmlxdWVJRHM6ICEhYXR0cmlidXRlSURzXG4gICAgfTtcbiAgICB0aGlzLmRlY29kZUdlb21ldHJ5KGJ1ZmZlciwgdGFza0NvbmZpZykudGhlbihjYWxsYmFjayk7XG4gIH1cbiAgZGVjb2RlR2VvbWV0cnkoYnVmZmVyLCB0YXNrQ29uZmlnKSB7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgaW4gdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlcykge1xuICAgICAgY29uc3QgdHlwZSA9IHRhc2tDb25maWcuYXR0cmlidXRlVHlwZXNbYXR0cmlidXRlXTtcbiAgICAgIGlmICh0eXBlLkJZVEVTX1BFUl9FTEVNRU5UICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlc1thdHRyaWJ1dGVdID0gdHlwZS5uYW1lO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0YXNrS2V5ID0gSlNPTi5zdHJpbmdpZnkodGFza0NvbmZpZyk7XG4gICAgaWYgKF90YXNrQ2FjaGUuaGFzKGJ1ZmZlcikpIHtcbiAgICAgIGNvbnN0IGNhY2hlZFRhc2sgPSBfdGFza0NhY2hlLmdldChidWZmZXIpO1xuICAgICAgaWYgKGNhY2hlZFRhc2sua2V5ID09PSB0YXNrS2V5KSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRUYXNrLnByb21pc2U7XG4gICAgICB9IGVsc2UgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkRSQUNPTG9hZGVyOiBVbmFibGUgdG8gcmUtZGVjb2RlIGEgYnVmZmVyIHdpdGggZGlmZmVyZW50IHNldHRpbmdzLiBCdWZmZXIgaGFzIGFscmVhZHkgYmVlbiB0cmFuc2ZlcnJlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgd29ya2VyO1xuICAgIGNvbnN0IHRhc2tJRCA9IHRoaXMud29ya2VyTmV4dFRhc2tJRCsrO1xuICAgIGNvbnN0IHRhc2tDb3N0ID0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgZ2VvbWV0cnlQZW5kaW5nID0gdGhpcy5fZ2V0V29ya2VyKHRhc2tJRCwgdGFza0Nvc3QpLnRoZW4oKF93b3JrZXIpID0+IHtcbiAgICAgIHdvcmtlciA9IF93b3JrZXI7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB3b3JrZXIuX2NhbGxiYWNrc1t0YXNrSURdID0geyByZXNvbHZlLCByZWplY3QgfTtcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgdHlwZTogXCJkZWNvZGVcIiwgaWQ6IHRhc2tJRCwgdGFza0NvbmZpZywgYnVmZmVyIH0sIFtidWZmZXJdKTtcbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oKG1lc3NhZ2UpID0+IHRoaXMuX2NyZWF0ZUdlb21ldHJ5KG1lc3NhZ2UuZ2VvbWV0cnkpKTtcbiAgICBnZW9tZXRyeVBlbmRpbmcuY2F0Y2goKCkgPT4gdHJ1ZSkudGhlbigoKSA9PiB7XG4gICAgICBpZiAod29ya2VyICYmIHRhc2tJRCkge1xuICAgICAgICB0aGlzLl9yZWxlYXNlVGFzayh3b3JrZXIsIHRhc2tJRCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3Rhc2tDYWNoZS5zZXQoYnVmZmVyLCB7XG4gICAgICBrZXk6IHRhc2tLZXksXG4gICAgICBwcm9taXNlOiBnZW9tZXRyeVBlbmRpbmdcbiAgICB9KTtcbiAgICByZXR1cm4gZ2VvbWV0cnlQZW5kaW5nO1xuICB9XG4gIF9jcmVhdGVHZW9tZXRyeShnZW9tZXRyeURhdGEpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeURhdGEuaW5kZXgpIHtcbiAgICAgIGdlb21ldHJ5LnNldEluZGV4KG5ldyBCdWZmZXJBdHRyaWJ1dGUoZ2VvbWV0cnlEYXRhLmluZGV4LmFycmF5LCAxKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cnlEYXRhLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5RGF0YS5hdHRyaWJ1dGVzW2ldO1xuICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZS5uYW1lO1xuICAgICAgY29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShuYW1lLCBuZXcgQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbiAgX2xvYWRMaWJyYXJ5KHVybCwgcmVzcG9uc2VUeXBlKSB7XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5tYW5hZ2VyKTtcbiAgICBsb2FkZXIuc2V0UGF0aCh0aGlzLmRlY29kZXJQYXRoKTtcbiAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKHJlc3BvbnNlVHlwZSk7XG4gICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxvYWRlci5sb2FkKHVybCwgcmVzb2x2ZSwgdm9pZCAwLCByZWplY3QpO1xuICAgIH0pO1xuICB9XG4gIHByZWxvYWQoKSB7XG4gICAgdGhpcy5faW5pdERlY29kZXIoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfaW5pdERlY29kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGVjb2RlclBlbmRpbmcpXG4gICAgICByZXR1cm4gdGhpcy5kZWNvZGVyUGVuZGluZztcbiAgICBjb25zdCB1c2VKUyA9IHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gXCJvYmplY3RcIiB8fCB0aGlzLmRlY29kZXJDb25maWcudHlwZSA9PT0gXCJqc1wiO1xuICAgIGNvbnN0IGxpYnJhcmllc1BlbmRpbmcgPSBbXTtcbiAgICBpZiAodXNlSlMpIHtcbiAgICAgIGxpYnJhcmllc1BlbmRpbmcucHVzaCh0aGlzLl9sb2FkTGlicmFyeShcImRyYWNvX2RlY29kZXIuanNcIiwgXCJ0ZXh0XCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlicmFyaWVzUGVuZGluZy5wdXNoKHRoaXMuX2xvYWRMaWJyYXJ5KFwiZHJhY29fd2FzbV93cmFwcGVyLmpzXCIsIFwidGV4dFwiKSk7XG4gICAgICBsaWJyYXJpZXNQZW5kaW5nLnB1c2godGhpcy5fbG9hZExpYnJhcnkoXCJkcmFjb19kZWNvZGVyLndhc21cIiwgXCJhcnJheWJ1ZmZlclwiKSk7XG4gICAgfVxuICAgIHRoaXMuZGVjb2RlclBlbmRpbmcgPSBQcm9taXNlLmFsbChsaWJyYXJpZXNQZW5kaW5nKS50aGVuKChsaWJyYXJpZXMpID0+IHtcbiAgICAgIGNvbnN0IGpzQ29udGVudCA9IGxpYnJhcmllc1swXTtcbiAgICAgIGlmICghdXNlSlMpIHtcbiAgICAgICAgdGhpcy5kZWNvZGVyQ29uZmlnLndhc21CaW5hcnkgPSBsaWJyYXJpZXNbMV07XG4gICAgICB9XG4gICAgICBjb25zdCBmbiA9IERSQUNPV29ya2VyLnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCBib2R5ID0gW1xuICAgICAgICBcIi8qIGRyYWNvIGRlY29kZXIgKi9cIixcbiAgICAgICAganNDb250ZW50LFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIi8qIHdvcmtlciAqL1wiLFxuICAgICAgICBmbi5zdWJzdHJpbmcoZm4uaW5kZXhPZihcIntcIikgKyAxLCBmbi5sYXN0SW5kZXhPZihcIn1cIikpXG4gICAgICBdLmpvaW4oXCJcXG5cIik7XG4gICAgICB0aGlzLndvcmtlclNvdXJjZVVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2JvZHldKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlclBlbmRpbmc7XG4gIH1cbiAgX2dldFdvcmtlcih0YXNrSUQsIHRhc2tDb3N0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2luaXREZWNvZGVyKCkudGhlbigoKSA9PiB7XG4gICAgICBpZiAodGhpcy53b3JrZXJQb29sLmxlbmd0aCA8IHRoaXMud29ya2VyTGltaXQpIHtcbiAgICAgICAgY29uc3Qgd29ya2VyMiA9IG5ldyBXb3JrZXIodGhpcy53b3JrZXJTb3VyY2VVUkwpO1xuICAgICAgICB3b3JrZXIyLl9jYWxsYmFja3MgPSB7fTtcbiAgICAgICAgd29ya2VyMi5fdGFza0Nvc3RzID0ge307XG4gICAgICAgIHdvcmtlcjIuX3Rhc2tMb2FkID0gMDtcbiAgICAgICAgd29ya2VyMi5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiaW5pdFwiLCBkZWNvZGVyQ29uZmlnOiB0aGlzLmRlY29kZXJDb25maWcgfSk7XG4gICAgICAgIHdvcmtlcjIub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlLmRhdGE7XG4gICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkZWNvZGVcIjpcbiAgICAgICAgICAgICAgd29ya2VyMi5fY2FsbGJhY2tzW21lc3NhZ2UuaWRdLnJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgIHdvcmtlcjIuX2NhbGxiYWNrc1ttZXNzYWdlLmlkXS5yZWplY3QobWVzc2FnZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuRFJBQ09Mb2FkZXI6IFVuZXhwZWN0ZWQgbWVzc2FnZSwgXCInICsgbWVzc2FnZS50eXBlICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtlclBvb2wucHVzaCh3b3JrZXIyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29ya2VyUG9vbC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS5fdGFza0xvYWQgPiBiLl90YXNrTG9hZCA/IC0xIDogMTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB3b3JrZXIgPSB0aGlzLndvcmtlclBvb2xbdGhpcy53b3JrZXJQb29sLmxlbmd0aCAtIDFdO1xuICAgICAgd29ya2VyLl90YXNrQ29zdHNbdGFza0lEXSA9IHRhc2tDb3N0O1xuICAgICAgd29ya2VyLl90YXNrTG9hZCArPSB0YXNrQ29zdDtcbiAgICAgIHJldHVybiB3b3JrZXI7XG4gICAgfSk7XG4gIH1cbiAgX3JlbGVhc2VUYXNrKHdvcmtlciwgdGFza0lEKSB7XG4gICAgd29ya2VyLl90YXNrTG9hZCAtPSB3b3JrZXIuX3Rhc2tDb3N0c1t0YXNrSURdO1xuICAgIGRlbGV0ZSB3b3JrZXIuX2NhbGxiYWNrc1t0YXNrSURdO1xuICAgIGRlbGV0ZSB3b3JrZXIuX3Rhc2tDb3N0c1t0YXNrSURdO1xuICB9XG4gIGRlYnVnKCkge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgXCJUYXNrIGxvYWQ6IFwiLFxuICAgICAgdGhpcy53b3JrZXJQb29sLm1hcCgod29ya2VyKSA9PiB3b3JrZXIuX3Rhc2tMb2FkKVxuICAgICk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMud29ya2VyUG9vbC5sZW5ndGg7ICsraSkge1xuICAgICAgdGhpcy53b3JrZXJQb29sW2ldLnRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgICB0aGlzLndvcmtlclBvb2wubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuZnVuY3Rpb24gRFJBQ09Xb3JrZXIoKSB7XG4gIGxldCBkZWNvZGVyQ29uZmlnO1xuICBsZXQgZGVjb2RlclBlbmRpbmc7XG4gIG9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZS5kYXRhO1xuICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICBjYXNlIFwiaW5pdFwiOlxuICAgICAgICBkZWNvZGVyQ29uZmlnID0gbWVzc2FnZS5kZWNvZGVyQ29uZmlnO1xuICAgICAgICBkZWNvZGVyUGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICBkZWNvZGVyQ29uZmlnLm9uTW9kdWxlTG9hZGVkID0gZnVuY3Rpb24oZHJhY28pIHtcbiAgICAgICAgICAgIHJlc29sdmUoeyBkcmFjbyB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIERyYWNvRGVjb2Rlck1vZHVsZShkZWNvZGVyQ29uZmlnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRlY29kZVwiOlxuICAgICAgICBjb25zdCBidWZmZXIgPSBtZXNzYWdlLmJ1ZmZlcjtcbiAgICAgICAgY29uc3QgdGFza0NvbmZpZyA9IG1lc3NhZ2UudGFza0NvbmZpZztcbiAgICAgICAgZGVjb2RlclBlbmRpbmcudGhlbigobW9kdWxlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZHJhY28gPSBtb2R1bGUuZHJhY287XG4gICAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBkcmFjby5EZWNvZGVyKCk7XG4gICAgICAgICAgY29uc3QgZGVjb2RlckJ1ZmZlciA9IG5ldyBkcmFjby5EZWNvZGVyQnVmZmVyKCk7XG4gICAgICAgICAgZGVjb2RlckJ1ZmZlci5Jbml0KG5ldyBJbnQ4QXJyYXkoYnVmZmVyKSwgYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IGRlY29kZUdlb21ldHJ5KGRyYWNvLCBkZWNvZGVyLCBkZWNvZGVyQnVmZmVyLCB0YXNrQ29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLm1hcCgoYXR0cikgPT4gYXR0ci5hcnJheS5idWZmZXIpO1xuICAgICAgICAgICAgaWYgKGdlb21ldHJ5LmluZGV4KVxuICAgICAgICAgICAgICBidWZmZXJzLnB1c2goZ2VvbWV0cnkuaW5kZXguYXJyYXkuYnVmZmVyKTtcbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImRlY29kZVwiLCBpZDogbWVzc2FnZS5pZCwgZ2VvbWV0cnkgfSwgYnVmZmVycyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiZXJyb3JcIiwgaWQ6IG1lc3NhZ2UuaWQsIGVycm9yOiBlcnJvci5tZXNzYWdlIH0pO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBkcmFjby5kZXN0cm95KGRlY29kZXJCdWZmZXIpO1xuICAgICAgICAgICAgZHJhY28uZGVzdHJveShkZWNvZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGRlY29kZUdlb21ldHJ5KGRyYWNvLCBkZWNvZGVyLCBkZWNvZGVyQnVmZmVyLCB0YXNrQ29uZmlnKSB7XG4gICAgY29uc3QgYXR0cmlidXRlSURzID0gdGFza0NvbmZpZy5hdHRyaWJ1dGVJRHM7XG4gICAgY29uc3QgYXR0cmlidXRlVHlwZXMgPSB0YXNrQ29uZmlnLmF0dHJpYnV0ZVR5cGVzO1xuICAgIGxldCBkcmFjb0dlb21ldHJ5O1xuICAgIGxldCBkZWNvZGluZ1N0YXR1cztcbiAgICBjb25zdCBnZW9tZXRyeVR5cGUgPSBkZWNvZGVyLkdldEVuY29kZWRHZW9tZXRyeVR5cGUoZGVjb2RlckJ1ZmZlcik7XG4gICAgaWYgKGdlb21ldHJ5VHlwZSA9PT0gZHJhY28uVFJJQU5HVUxBUl9NRVNIKSB7XG4gICAgICBkcmFjb0dlb21ldHJ5ID0gbmV3IGRyYWNvLk1lc2goKTtcbiAgICAgIGRlY29kaW5nU3RhdHVzID0gZGVjb2Rlci5EZWNvZGVCdWZmZXJUb01lc2goZGVjb2RlckJ1ZmZlciwgZHJhY29HZW9tZXRyeSk7XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeVR5cGUgPT09IGRyYWNvLlBPSU5UX0NMT1VEKSB7XG4gICAgICBkcmFjb0dlb21ldHJ5ID0gbmV3IGRyYWNvLlBvaW50Q2xvdWQoKTtcbiAgICAgIGRlY29kaW5nU3RhdHVzID0gZGVjb2Rlci5EZWNvZGVCdWZmZXJUb1BvaW50Q2xvdWQoZGVjb2RlckJ1ZmZlciwgZHJhY29HZW9tZXRyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkRSQUNPTG9hZGVyOiBVbmV4cGVjdGVkIGdlb21ldHJ5IHR5cGUuXCIpO1xuICAgIH1cbiAgICBpZiAoIWRlY29kaW5nU3RhdHVzLm9rKCkgfHwgZHJhY29HZW9tZXRyeS5wdHIgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkRSQUNPTG9hZGVyOiBEZWNvZGluZyBmYWlsZWQ6IFwiICsgZGVjb2RpbmdTdGF0dXMuZXJyb3JfbXNnKCkpO1xuICAgIH1cbiAgICBjb25zdCBnZW9tZXRyeSA9IHsgaW5kZXg6IG51bGwsIGF0dHJpYnV0ZXM6IFtdIH07XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZUlEcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlVHlwZSA9IHNlbGZbYXR0cmlidXRlVHlwZXNbYXR0cmlidXRlTmFtZV1dO1xuICAgICAgbGV0IGF0dHJpYnV0ZTtcbiAgICAgIGxldCBhdHRyaWJ1dGVJRDtcbiAgICAgIGlmICh0YXNrQ29uZmlnLnVzZVVuaXF1ZUlEcykge1xuICAgICAgICBhdHRyaWJ1dGVJRCA9IGF0dHJpYnV0ZUlEc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgYXR0cmlidXRlID0gZGVjb2Rlci5HZXRBdHRyaWJ1dGVCeVVuaXF1ZUlkKGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZUlEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJpYnV0ZUlEID0gZGVjb2Rlci5HZXRBdHRyaWJ1dGVJZChkcmFjb0dlb21ldHJ5LCBkcmFjb1thdHRyaWJ1dGVJRHNbYXR0cmlidXRlTmFtZV1dKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZUlEID09PSAtMSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXR0cmlidXRlID0gZGVjb2Rlci5HZXRBdHRyaWJ1dGUoZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlSUQpO1xuICAgICAgfVxuICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wdXNoKGRlY29kZUF0dHJpYnV0ZShkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgYXR0cmlidXRlKSk7XG4gICAgfVxuICAgIGlmIChnZW9tZXRyeVR5cGUgPT09IGRyYWNvLlRSSUFOR1VMQVJfTUVTSCkge1xuICAgICAgZ2VvbWV0cnkuaW5kZXggPSBkZWNvZGVJbmRleChkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSk7XG4gICAgfVxuICAgIGRyYWNvLmRlc3Ryb3koZHJhY29HZW9tZXRyeSk7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZUluZGV4KGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5KSB7XG4gICAgY29uc3QgbnVtRmFjZXMgPSBkcmFjb0dlb21ldHJ5Lm51bV9mYWNlcygpO1xuICAgIGNvbnN0IG51bUluZGljZXMgPSBudW1GYWNlcyAqIDM7XG4gICAgY29uc3QgYnl0ZUxlbmd0aCA9IG51bUluZGljZXMgKiA0O1xuICAgIGNvbnN0IHB0ciA9IGRyYWNvLl9tYWxsb2MoYnl0ZUxlbmd0aCk7XG4gICAgZGVjb2Rlci5HZXRUcmlhbmdsZXNVSW50MzJBcnJheShkcmFjb0dlb21ldHJ5LCBieXRlTGVuZ3RoLCBwdHIpO1xuICAgIGNvbnN0IGluZGV4ID0gbmV3IFVpbnQzMkFycmF5KGRyYWNvLkhFQVBGMzIuYnVmZmVyLCBwdHIsIG51bUluZGljZXMpLnNsaWNlKCk7XG4gICAgZHJhY28uX2ZyZWUocHRyKTtcbiAgICByZXR1cm4geyBhcnJheTogaW5kZXgsIGl0ZW1TaXplOiAxIH07XG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlQXR0cmlidXRlKGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCBudW1Db21wb25lbnRzID0gYXR0cmlidXRlLm51bV9jb21wb25lbnRzKCk7XG4gICAgY29uc3QgbnVtUG9pbnRzID0gZHJhY29HZW9tZXRyeS5udW1fcG9pbnRzKCk7XG4gICAgY29uc3QgbnVtVmFsdWVzID0gbnVtUG9pbnRzICogbnVtQ29tcG9uZW50cztcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gbnVtVmFsdWVzICogYXR0cmlidXRlVHlwZS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGdldERyYWNvRGF0YVR5cGUoZHJhY28sIGF0dHJpYnV0ZVR5cGUpO1xuICAgIGNvbnN0IHB0ciA9IGRyYWNvLl9tYWxsb2MoYnl0ZUxlbmd0aCk7XG4gICAgZGVjb2Rlci5HZXRBdHRyaWJ1dGVEYXRhQXJyYXlGb3JBbGxQb2ludHMoZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlLCBkYXRhVHlwZSwgYnl0ZUxlbmd0aCwgcHRyKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBhdHRyaWJ1dGVUeXBlKGRyYWNvLkhFQVBGMzIuYnVmZmVyLCBwdHIsIG51bVZhbHVlcykuc2xpY2UoKTtcbiAgICBkcmFjby5fZnJlZShwdHIpO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBhdHRyaWJ1dGVOYW1lLFxuICAgICAgYXJyYXksXG4gICAgICBpdGVtU2l6ZTogbnVtQ29tcG9uZW50c1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RHJhY29EYXRhVHlwZShkcmFjbywgYXR0cmlidXRlVHlwZSkge1xuICAgIHN3aXRjaCAoYXR0cmlidXRlVHlwZSkge1xuICAgICAgY2FzZSBGbG9hdDMyQXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9GTE9BVDMyO1xuICAgICAgY2FzZSBJbnQ4QXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9JTlQ4O1xuICAgICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfSU5UMTY7XG4gICAgICBjYXNlIEludDMyQXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9JTlQzMjtcbiAgICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX1VJTlQ4O1xuICAgICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX1VJTlQxNjtcbiAgICAgIGNhc2UgVWludDMyQXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9VSU5UMzI7XG4gICAgfVxuICB9XG59XG5leHBvcnQge1xuICBEUkFDT0xvYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURSQUNPTG9hZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/EXRLoader.js":
/*!********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/EXRLoader.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXRLoader: () => (/* binding */ EXRLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fflate */ \"(ssr)/./node_modules/fflate/esm/index.mjs\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\");\n\n\n\nconst hasColorSpace = _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_0__.version >= 152;\nclass EXRLoader extends three__WEBPACK_IMPORTED_MODULE_1__.DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = three__WEBPACK_IMPORTED_MODULE_1__.HalfFloatType;\n  }\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16;\n    const BITMAP_SIZE = USHORT_RANGE >> 3;\n    const HUF_ENCBITS = 16;\n    const HUF_DECBITS = 14;\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\n    const HUF_DECSIZE = 1 << HUF_DECBITS;\n    const HUF_DECMASK = HUF_DECSIZE - 1;\n    const NBITS = 16;\n    const A_OFFSET = 1 << NBITS - 1;\n    const MOD_MASK = (1 << NBITS) - 1;\n    const SHORT_ZEROCODE_RUN = 59;\n    const LONG_ZEROCODE_RUN = 63;\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n    const ULONG_SIZE = 8;\n    const FLOAT32_SIZE = 4;\n    const INT32_SIZE = 4;\n    const INT16_SIZE = 2;\n    const INT8_SIZE = 1;\n    const STATIC_HUFFMAN = 0;\n    const DEFLATE = 1;\n    const UNKNOWN = 0;\n    const LOSSY_DCT = 1;\n    const RLE = 2;\n    const logBase = Math.pow(2.7182818, 2.2);\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0;\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n          lut[k++] = i;\n        }\n      }\n      var n = k - 1;\n      while (k < USHORT_RANGE)\n        lut[k++] = 0;\n      return n;\n    }\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {};\n        hdec[i].len = 0;\n        hdec[i].lit = 0;\n        hdec[i].p = null;\n      }\n    }\n    const getBitsReturn = { l: 0, c: 0, lc: 0 };\n    function getBits(nBits, c, lc, uInt8Array2, inOffset) {\n      while (lc < nBits) {\n        c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n        lc += 8;\n      }\n      lc -= nBits;\n      getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n      getBitsReturn.c = c;\n      getBitsReturn.lc = lc;\n    }\n    const hufTableBuffer = new Array(59);\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i)\n        hufTableBuffer[i] = 0;\n      for (var i = 0; i < HUF_ENCSIZE; ++i)\n        hufTableBuffer[hcode[i]] += 1;\n      var c = 0;\n      for (var i = 58; i > 0; --i) {\n        var nc = c + hufTableBuffer[i] >> 1;\n        hufTableBuffer[i] = c;\n        c = nc;\n      }\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i];\n        if (l > 0)\n          hcode[i] = l | hufTableBuffer[l]++ << 6;\n      }\n    }\n    function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset;\n      var c = 0;\n      var lc = 0;\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni)\n          return false;\n        getBits(6, c, lc, uInt8Array2, p);\n        var l = getBitsReturn.l;\n        c = getBitsReturn.c;\n        lc = getBitsReturn.lc;\n        hcode[im] = l;\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          getBits(8, c, lc, uInt8Array2, p);\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n          c = getBitsReturn.c;\n          lc = getBitsReturn.lc;\n          if (im + zerun > iM + 1) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          while (zerun--)\n            hcode[im++] = 0;\n          im--;\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2;\n          if (im + zerun > iM + 1) {\n            throw \"Something wrong with hufUnpackEncTable\";\n          }\n          while (zerun--)\n            hcode[im++] = 0;\n          im--;\n        }\n      }\n      hufCanonicalCodeTable(hcode);\n    }\n    function hufLength(code) {\n      return code & 63;\n    }\n    function hufCode(code) {\n      return code >> 6;\n    }\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im]);\n        var l = hufLength(hcode[im]);\n        if (c >> l) {\n          throw \"Invalid table entry\";\n        }\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> l - HUF_DECBITS];\n          if (pl.len) {\n            throw \"Invalid table entry\";\n          }\n          pl.lit++;\n          if (pl.p) {\n            var p = pl.p;\n            pl.p = new Array(pl.lit);\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i];\n            }\n          } else {\n            pl.p = new Array(1);\n          }\n          pl.p[pl.lit - 1] = im;\n        } else if (l) {\n          var plOffset = 0;\n          for (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n            var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n            if (pl.len || pl.p) {\n              throw \"Invalid table entry\";\n            }\n            pl.len = l;\n            pl.lit = im;\n            plOffset++;\n          }\n        }\n      }\n      return true;\n    }\n    const getCharReturn = { c: 0, lc: 0 };\n    function getChar(c, lc, uInt8Array2, inOffset) {\n      c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n      lc += 8;\n      getCharReturn.c = c;\n      getCharReturn.lc = lc;\n    }\n    const getCodeReturn = { c: 0, lc: 0 };\n    function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array2, inOffset);\n          c = getCharReturn.c;\n          lc = getCharReturn.lc;\n        }\n        lc -= 8;\n        var cs = c >> lc;\n        var cs = new Uint8Array([cs])[0];\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false;\n        }\n        var s = outBuffer[outBufferOffset.value - 1];\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s;\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po;\n      } else {\n        return false;\n      }\n      getCodeReturn.c = c;\n      getCodeReturn.lc = lc;\n    }\n    function UInt16(value) {\n      return value & 65535;\n    }\n    function Int16(value) {\n      var ref = UInt16(value);\n      return ref > 32767 ? ref - 65536 : ref;\n    }\n    const wdec14Return = { a: 0, b: 0 };\n    function wdec14(l, h) {\n      var ls = Int16(l);\n      var hs = Int16(h);\n      var hi = hs;\n      var ai = ls + (hi & 1) + (hi >> 1);\n      var as = ai;\n      var bs = ai - hi;\n      wdec14Return.a = as;\n      wdec14Return.b = bs;\n    }\n    function wdec16(l, h) {\n      var m = UInt16(l);\n      var d = UInt16(h);\n      var bb = m - (d >> 1) & MOD_MASK;\n      var aa = d + bb - A_OFFSET & MOD_MASK;\n      wdec14Return.a = aa;\n      wdec14Return.b = bb;\n    }\n    function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14;\n      var n = nx > ny ? ny : nx;\n      var p = 1;\n      var p2;\n      while (p <= n)\n        p <<= 1;\n      p >>= 1;\n      p2 = p;\n      p >>= 1;\n      while (p >= 1) {\n        var py = 0;\n        var ey = py + oy * (ny - p2);\n        var oy1 = oy * p;\n        var oy2 = oy * p2;\n        var ox1 = ox * p;\n        var ox2 = ox * p2;\n        var i00, i01, i10, i11;\n        for (; py <= ey; py += oy2) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            var p10 = px + oy1;\n            var p11 = p10 + ox1;\n            if (w14) {\n              wdec14(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec14(buffer2[p01 + j], buffer2[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec14(i00, i01);\n              buffer2[px + j] = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              wdec14(i10, i11);\n              buffer2[p10 + j] = wdec14Return.a;\n              buffer2[p11 + j] = wdec14Return.b;\n            } else {\n              wdec16(buffer2[px + j], buffer2[p10 + j]);\n              i00 = wdec14Return.a;\n              i10 = wdec14Return.b;\n              wdec16(buffer2[p01 + j], buffer2[p11 + j]);\n              i01 = wdec14Return.a;\n              i11 = wdec14Return.b;\n              wdec16(i00, i01);\n              buffer2[px + j] = wdec14Return.a;\n              buffer2[p01 + j] = wdec14Return.b;\n              wdec16(i10, i11);\n              buffer2[p10 + j] = wdec14Return.a;\n              buffer2[p11 + j] = wdec14Return.b;\n            }\n          }\n          if (nx & p) {\n            var p10 = px + oy1;\n            if (w14)\n              wdec14(buffer2[px + j], buffer2[p10 + j]);\n            else\n              wdec16(buffer2[px + j], buffer2[p10 + j]);\n            i00 = wdec14Return.a;\n            buffer2[p10 + j] = wdec14Return.b;\n            buffer2[px + j] = i00;\n          }\n        }\n        if (ny & p) {\n          var px = py;\n          var ex = py + ox * (nx - p2);\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1;\n            if (w14)\n              wdec14(buffer2[px + j], buffer2[p01 + j]);\n            else\n              wdec16(buffer2[px + j], buffer2[p01 + j]);\n            i00 = wdec14Return.a;\n            buffer2[p01 + j] = wdec14Return.b;\n            buffer2[px + j] = i00;\n          }\n        }\n        p2 = p;\n        p >>= 1;\n      }\n      return py;\n    }\n    function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n      var c = 0;\n      var lc = 0;\n      var outBufferEndOffset = no;\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array2, inOffset);\n        c = getCharReturn.c;\n        lc = getCharReturn.lc;\n        while (lc >= HUF_DECBITS) {\n          var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n          var pl = decodingTable[index];\n          if (pl.len) {\n            lc -= pl.len;\n            getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n            c = getCodeReturn.c;\n            lc = getCodeReturn.lc;\n          } else {\n            if (!pl.p) {\n              throw \"hufDecode issues\";\n            }\n            var j;\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]]);\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array2, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n              }\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                  lc -= l;\n                  getCode(\n                    pl.p[j],\n                    rlc,\n                    c,\n                    lc,\n                    uInt8Array2,\n                    inDataView,\n                    inOffset,\n                    outBuffer,\n                    outOffset,\n                    outBufferEndOffset\n                  );\n                  c = getCodeReturn.c;\n                  lc = getCodeReturn.lc;\n                  break;\n                }\n              }\n            }\n            if (j == pl.lit) {\n              throw \"hufDecode issues\";\n            }\n          }\n        }\n      }\n      var i = 8 - ni & 7;\n      c >>= i;\n      lc -= i;\n      while (lc > 0) {\n        var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n        if (pl.len) {\n          lc -= pl.len;\n          getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n          c = getCodeReturn.c;\n          lc = getCodeReturn.lc;\n        } else {\n          throw \"hufDecode issues\";\n        }\n      }\n      return true;\n    }\n    function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = { value: 0 };\n      var initialInOffset = inOffset.value;\n      var im = parseUint32(inDataView, inOffset);\n      var iM = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      var nBits = parseUint32(inDataView, inOffset);\n      inOffset.value += 4;\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw \"Something wrong with HUF_ENCSIZE\";\n      }\n      var freq = new Array(HUF_ENCSIZE);\n      var hdec = new Array(HUF_DECSIZE);\n      hufClearDecTable(hdec);\n      var ni = nCompressed - (inOffset.value - initialInOffset);\n      hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw \"Something wrong with hufUncompress\";\n      }\n      hufBuildDecTable(freq, im, iM, hdec);\n      hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n    }\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]];\n      }\n    }\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128;\n        source[t] = d;\n      }\n    }\n    function interleaveScalar(source, out) {\n      var t1 = 0;\n      var t2 = Math.floor((source.length + 1) / 2);\n      var s = 0;\n      var stop = source.length - 1;\n      while (true) {\n        if (s > stop)\n          break;\n        out[s++] = source[t1++];\n        if (s > stop)\n          break;\n        out[s++] = source[t2++];\n      }\n    }\n    function decodeRunLength(source) {\n      var size = source.byteLength;\n      var out = new Array();\n      var p = 0;\n      var reader = new DataView(source);\n      while (size > 0) {\n        var l = reader.getInt8(p++);\n        if (l < 0) {\n          var count = -l;\n          size -= count + 1;\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++));\n          }\n        } else {\n          var count = l;\n          size -= 2;\n          var value = reader.getUint8(p++);\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value);\n          }\n        }\n      }\n      return out;\n    }\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer);\n      var width = channelData[cscSet.idx[0]].width;\n      var height = channelData[cscSet.idx[0]].height;\n      var numComp = 3;\n      var numFullBlocksX = Math.floor(width / 8);\n      var numBlocksX = Math.ceil(width / 8);\n      var numBlocksY = Math.ceil(height / 8);\n      var leftoverX = width - (numBlocksX - 1) * 8;\n      var leftoverY = height - (numBlocksY - 1) * 8;\n      var currAcComp = { value: 0 };\n      var currDcComp = new Array(numComp);\n      var dctData = new Array(numComp);\n      var halfZigBlock = new Array(numComp);\n      var rowBlock = new Array(numComp);\n      var rowOffsets = new Array(numComp);\n      for (let comp2 = 0; comp2 < numComp; ++comp2) {\n        rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];\n        currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;\n        dctData[comp2] = new Float32Array(64);\n        halfZigBlock[comp2] = new Uint16Array(64);\n        rowBlock[comp2] = new Uint16Array(numBlocksX * 64);\n      }\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8;\n        if (blocky == numBlocksY - 1)\n          maxY = leftoverY;\n        var maxX = 8;\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1)\n            maxX = leftoverX;\n          for (let comp2 = 0; comp2 < numComp; ++comp2) {\n            halfZigBlock[comp2].fill(0);\n            halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);\n            unZigZag(halfZigBlock[comp2], dctData[comp2]);\n            dctInverse(dctData[comp2]);\n          }\n          {\n            csc709Inverse(dctData);\n          }\n          for (let comp2 = 0; comp2 < numComp; ++comp2) {\n            convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);\n          }\n        }\n        let offset2 = 0;\n        for (let comp2 = 0; comp2 < numComp; ++comp2) {\n          const type2 = channelData[cscSet.idx[comp2]].type;\n          for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n            offset2 = rowOffsets[comp2][y2];\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y2 & 7) * 8;\n              dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);\n              dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);\n              dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);\n              dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);\n              dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);\n              dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);\n              dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);\n              dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);\n              offset2 += 8 * INT16_SIZE * type2;\n            }\n          }\n          if (numFullBlocksX != numBlocksX) {\n            for (let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2) {\n              const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;\n              const src = numFullBlocksX * 64 + (y2 & 7) * 8;\n              for (let x2 = 0; x2 < maxX; ++x2) {\n                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);\n              }\n            }\n          }\n        }\n      }\n      var halfRow = new Uint16Array(width);\n      var dataView = new DataView(outBuffer.buffer);\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true;\n        var type = channelData[cscSet.idx[comp]].type;\n        if (channelData[comp].type != 2)\n          continue;\n        for (var y = 0; y < height; ++y) {\n          const offset2 = rowOffsets[comp][y];\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);\n          }\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n          }\n        }\n      }\n    }\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue;\n      var dctComp = 1;\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value];\n        if (acValue == 65280) {\n          dctComp = 64;\n        } else if (acValue >> 8 == 255) {\n          dctComp += acValue & 255;\n        } else {\n          halfZigBlock[dctComp] = acValue;\n          dctComp++;\n        }\n        currAcComp.value++;\n      }\n    }\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0]);\n      dst[1] = decodeFloat16(src[1]);\n      dst[2] = decodeFloat16(src[5]);\n      dst[3] = decodeFloat16(src[6]);\n      dst[4] = decodeFloat16(src[14]);\n      dst[5] = decodeFloat16(src[15]);\n      dst[6] = decodeFloat16(src[27]);\n      dst[7] = decodeFloat16(src[28]);\n      dst[8] = decodeFloat16(src[2]);\n      dst[9] = decodeFloat16(src[4]);\n      dst[10] = decodeFloat16(src[7]);\n      dst[11] = decodeFloat16(src[13]);\n      dst[12] = decodeFloat16(src[16]);\n      dst[13] = decodeFloat16(src[26]);\n      dst[14] = decodeFloat16(src[29]);\n      dst[15] = decodeFloat16(src[42]);\n      dst[16] = decodeFloat16(src[3]);\n      dst[17] = decodeFloat16(src[8]);\n      dst[18] = decodeFloat16(src[12]);\n      dst[19] = decodeFloat16(src[17]);\n      dst[20] = decodeFloat16(src[25]);\n      dst[21] = decodeFloat16(src[30]);\n      dst[22] = decodeFloat16(src[41]);\n      dst[23] = decodeFloat16(src[43]);\n      dst[24] = decodeFloat16(src[9]);\n      dst[25] = decodeFloat16(src[11]);\n      dst[26] = decodeFloat16(src[18]);\n      dst[27] = decodeFloat16(src[24]);\n      dst[28] = decodeFloat16(src[31]);\n      dst[29] = decodeFloat16(src[40]);\n      dst[30] = decodeFloat16(src[44]);\n      dst[31] = decodeFloat16(src[53]);\n      dst[32] = decodeFloat16(src[10]);\n      dst[33] = decodeFloat16(src[19]);\n      dst[34] = decodeFloat16(src[23]);\n      dst[35] = decodeFloat16(src[32]);\n      dst[36] = decodeFloat16(src[39]);\n      dst[37] = decodeFloat16(src[45]);\n      dst[38] = decodeFloat16(src[52]);\n      dst[39] = decodeFloat16(src[54]);\n      dst[40] = decodeFloat16(src[20]);\n      dst[41] = decodeFloat16(src[22]);\n      dst[42] = decodeFloat16(src[33]);\n      dst[43] = decodeFloat16(src[38]);\n      dst[44] = decodeFloat16(src[46]);\n      dst[45] = decodeFloat16(src[51]);\n      dst[46] = decodeFloat16(src[55]);\n      dst[47] = decodeFloat16(src[60]);\n      dst[48] = decodeFloat16(src[21]);\n      dst[49] = decodeFloat16(src[34]);\n      dst[50] = decodeFloat16(src[37]);\n      dst[51] = decodeFloat16(src[47]);\n      dst[52] = decodeFloat16(src[50]);\n      dst[53] = decodeFloat16(src[56]);\n      dst[54] = decodeFloat16(src[59]);\n      dst[55] = decodeFloat16(src[61]);\n      dst[56] = decodeFloat16(src[35]);\n      dst[57] = decodeFloat16(src[36]);\n      dst[58] = decodeFloat16(src[48]);\n      dst[59] = decodeFloat16(src[49]);\n      dst[60] = decodeFloat16(src[57]);\n      dst[61] = decodeFloat16(src[58]);\n      dst[62] = decodeFloat16(src[62]);\n      dst[63] = decodeFloat16(src[63]);\n    }\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4);\n      const b = 0.5 * Math.cos(3.14159 / 16);\n      const c = 0.5 * Math.cos(3.14159 / 8);\n      const d = 0.5 * Math.cos(3 * 3.14159 / 16);\n      const e = 0.5 * Math.cos(5 * 3.14159 / 16);\n      const f = 0.5 * Math.cos(3 * 3.14159 / 8);\n      const g = 0.5 * Math.cos(7 * 3.14159 / 16);\n      var alpha = new Array(4);\n      var beta = new Array(4);\n      var theta = new Array(4);\n      var gamma = new Array(4);\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8;\n        alpha[0] = c * data[rowPtr + 2];\n        alpha[1] = f * data[rowPtr + 2];\n        alpha[2] = c * data[rowPtr + 6];\n        alpha[3] = f * data[rowPtr + 6];\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[rowPtr + 0] = gamma[0] + beta[0];\n        data[rowPtr + 1] = gamma[1] + beta[1];\n        data[rowPtr + 2] = gamma[2] + beta[2];\n        data[rowPtr + 3] = gamma[3] + beta[3];\n        data[rowPtr + 4] = gamma[3] - beta[3];\n        data[rowPtr + 5] = gamma[2] - beta[2];\n        data[rowPtr + 6] = gamma[1] - beta[1];\n        data[rowPtr + 7] = gamma[0] - beta[0];\n      }\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column];\n        alpha[1] = f * data[16 + column];\n        alpha[2] = c * data[48 + column];\n        alpha[3] = f * data[48 + column];\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n        theta[0] = a * (data[column] + data[32 + column]);\n        theta[3] = a * (data[column] - data[32 + column]);\n        theta[1] = alpha[0] + alpha[3];\n        theta[2] = alpha[1] - alpha[2];\n        gamma[0] = theta[0] + theta[1];\n        gamma[1] = theta[3] + theta[2];\n        gamma[2] = theta[3] - theta[2];\n        gamma[3] = theta[0] - theta[1];\n        data[0 + column] = gamma[0] + beta[0];\n        data[8 + column] = gamma[1] + beta[1];\n        data[16 + column] = gamma[2] + beta[2];\n        data[24 + column] = gamma[3] + beta[3];\n        data[32 + column] = gamma[3] - beta[3];\n        data[40 + column] = gamma[2] - beta[2];\n        data[48 + column] = gamma[1] - beta[1];\n        data[56 + column] = gamma[0] - beta[0];\n      }\n    }\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i];\n        var cb = data[1][i];\n        var cr = data[2][i];\n        data[0][i] = y + 1.5747 * cr;\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n        data[2][i] = y + 1.8556 * cb;\n      }\n    }\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = three__WEBPACK_IMPORTED_MODULE_1__.DataUtils.toHalfFloat(toLinear(src[i]));\n      }\n    }\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\n      }\n    }\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size);\n    }\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer);\n      interleaveScalar(rawBuffer, tmpBuffer);\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = (0,fflate__WEBPACK_IMPORTED_MODULE_2__.unzlibSync)(compressed);\n      var tmpBuffer = new Uint8Array(rawBuffer.length);\n      predictor(rawBuffer);\n      interleaveScalar(rawBuffer, tmpBuffer);\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer;\n      var inOffset = { value: info.offset.value };\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n      var bitmap = new Uint8Array(BITMAP_SIZE);\n      var outBufferEnd = 0;\n      var pizChannelData = new Array(info.channels);\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {};\n        pizChannelData[i][\"start\"] = outBufferEnd;\n        pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n        pizChannelData[i][\"nx\"] = info.width;\n        pizChannelData[i][\"ny\"] = info.lines;\n        pizChannelData[i][\"size\"] = info.type;\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n      }\n      var minNonZero = parseUint16(inDataView, inOffset);\n      var maxNonZero = parseUint16(inDataView, inOffset);\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw \"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE\";\n      }\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n        }\n      }\n      var lut = new Uint16Array(USHORT_RANGE);\n      var maxValue = reverseLutFromBitmap(bitmap, lut);\n      var length = parseUint32(inDataView, inOffset);\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i];\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n        }\n      }\n      applyLut(lut, outBuffer, outBufferEnd);\n      var tmpOffset2 = 0;\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c];\n          var n = cd.nx * cd.size;\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n          tmpBuffer.set(cp, tmpOffset2);\n          tmpOffset2 += n * INT16_SIZE;\n          cd.end += n;\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n      var rawBuffer = (0,fflate__WEBPACK_IMPORTED_MODULE_2__.unzlibSync)(compressed);\n      const sz = info.lines * info.channels * info.width;\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n      let tmpBufferEnd = 0;\n      let writePtr = 0;\n      const ptr = new Array(4);\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0;\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              tmpBufferEnd = ptr[1] + info.width;\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n              break;\n            case 2:\n              ptr[0] = tmpBufferEnd;\n              ptr[1] = ptr[0] + info.width;\n              ptr[2] = ptr[1] + info.width;\n              tmpBufferEnd = ptr[2] + info.width;\n              for (let j = 0; j < info.width; ++j) {\n                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                pixel += diff;\n                tmpBuffer[writePtr] = pixel;\n                writePtr++;\n              }\n              break;\n          }\n        }\n      }\n      return new DataView(tmpBuffer.buffer);\n    }\n    function uncompressDWA(info) {\n      var inDataView = info.viewer;\n      var inOffset = { value: info.offset.value };\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset)\n      };\n      if (dwaHeader.version < 2) {\n        throw \"EXRLoader.parse: \" + EXRHeader.compression + \" version \" + dwaHeader.version + \" is unsupported\";\n      }\n      var channelRules = new Array();\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n        var value = parseUint8(inDataView, inOffset);\n        var compression = value >> 2 & 3;\n        var csc = (value >> 4) - 1;\n        var index = new Int8Array([csc])[0];\n        var type = parseUint8(inDataView, inOffset);\n        channelRules.push({\n          name,\n          index,\n          type,\n          compression\n        });\n        ruleSize -= name.length + 3;\n      }\n      var channels = EXRHeader.channels;\n      var channelData = new Array(info.channels);\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = channelData[i] = {};\n        var channel = channels[i];\n        cd.name = channel.name;\n        cd.compression = UNKNOWN;\n        cd.decoded = false;\n        cd.type = channel.pixelType;\n        cd.pLinear = channel.pLinear;\n        cd.width = info.width;\n        cd.height = info.lines;\n      }\n      var cscSet = {\n        idx: new Array(3)\n      };\n      for (var offset2 = 0; offset2 < info.channels; ++offset2) {\n        var cd = channelData[offset2];\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i];\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression;\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset2;\n            }\n            cd.offset = offset2;\n          }\n        }\n      }\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n            hufUncompress(\n              info.array,\n              inDataView,\n              inOffset,\n              dwaHeader.acCompressedSize,\n              acBuffer,\n              dwaHeader.totalAcUncompressedCount\n            );\n            break;\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n            var data = (0,fflate__WEBPACK_IMPORTED_MODULE_2__.unzlibSync)(compressed);\n            var acBuffer = new Uint16Array(data.buffer);\n            inOffset.value += dwaHeader.totalAcUncompressedCount;\n            break;\n        }\n      }\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize\n        };\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n        inOffset.value += dwaHeader.dcCompressedSize;\n      }\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n        var data = (0,fflate__WEBPACK_IMPORTED_MODULE_2__.unzlibSync)(compressed);\n        var rleBuffer = decodeRunLength(data.buffer);\n        inOffset.value += dwaHeader.rleCompressedSize;\n      }\n      var outBufferEnd = 0;\n      var rowOffsets = new Array(channelData.length);\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array();\n      }\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd);\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n        }\n      }\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i];\n        if (cd.decoded)\n          continue;\n        switch (cd.compression) {\n          case RLE:\n            var row = 0;\n            var rleOffset = 0;\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row];\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                }\n                rleOffset++;\n              }\n              row++;\n            }\n            break;\n          case LOSSY_DCT:\n          default:\n            throw \"EXRLoader.parse: unsupported channel compression\";\n        }\n      }\n      return new DataView(outBuffer.buffer);\n    }\n    function parseNullTerminatedString(buffer2, offset2) {\n      var uintBuffer = new Uint8Array(buffer2);\n      var endOffset = 0;\n      while (uintBuffer[offset2.value + endOffset] != 0) {\n        endOffset += 1;\n      }\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));\n      offset2.value = offset2.value + endOffset + 1;\n      return stringValue;\n    }\n    function parseFixedLengthString(buffer2, offset2, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));\n      offset2.value = offset2.value + size;\n      return stringValue;\n    }\n    function parseRational(dataView, offset2) {\n      var x = parseInt32(dataView, offset2);\n      var y = parseUint32(dataView, offset2);\n      return [x, y];\n    }\n    function parseTimecode(dataView, offset2) {\n      var x = parseUint32(dataView, offset2);\n      var y = parseUint32(dataView, offset2);\n      return [x, y];\n    }\n    function parseInt32(dataView, offset2) {\n      var Int32 = dataView.getInt32(offset2.value, true);\n      offset2.value = offset2.value + INT32_SIZE;\n      return Int32;\n    }\n    function parseUint32(dataView, offset2) {\n      var Uint32 = dataView.getUint32(offset2.value, true);\n      offset2.value = offset2.value + INT32_SIZE;\n      return Uint32;\n    }\n    function parseUint8Array(uInt8Array2, offset2) {\n      var Uint8 = uInt8Array2[offset2.value];\n      offset2.value = offset2.value + INT8_SIZE;\n      return Uint8;\n    }\n    function parseUint8(dataView, offset2) {\n      var Uint8 = dataView.getUint8(offset2.value);\n      offset2.value = offset2.value + INT8_SIZE;\n      return Uint8;\n    }\n    const parseInt64 = function(dataView, offset2) {\n      let int;\n      if (\"getBigInt64\" in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset2.value, true));\n      } else {\n        int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);\n      }\n      offset2.value += ULONG_SIZE;\n      return int;\n    };\n    function parseFloat32(dataView, offset2) {\n      var float = dataView.getFloat32(offset2.value, true);\n      offset2.value += FLOAT32_SIZE;\n      return float;\n    }\n    function decodeFloat32(dataView, offset2) {\n      return three__WEBPACK_IMPORTED_MODULE_1__.DataUtils.toHalfFloat(parseFloat32(dataView, offset2));\n    }\n    function decodeFloat16(binary) {\n      var exponent = (binary & 31744) >> 10, fraction = binary & 1023;\n      return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));\n    }\n    function parseUint16(dataView, offset2) {\n      var Uint16 = dataView.getUint16(offset2.value, true);\n      offset2.value += INT16_SIZE;\n      return Uint16;\n    }\n    function parseFloat16(buffer2, offset2) {\n      return decodeFloat16(parseUint16(buffer2, offset2));\n    }\n    function parseChlist(dataView, buffer2, offset2, size) {\n      var startOffset = offset2.value;\n      var channels = [];\n      while (offset2.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer2, offset2);\n        var pixelType = parseInt32(dataView, offset2);\n        var pLinear = parseUint8(dataView, offset2);\n        offset2.value += 3;\n        var xSampling = parseInt32(dataView, offset2);\n        var ySampling = parseInt32(dataView, offset2);\n        channels.push({\n          name,\n          pixelType,\n          pLinear,\n          xSampling,\n          ySampling\n        });\n      }\n      offset2.value += 1;\n      return channels;\n    }\n    function parseChromaticities(dataView, offset2) {\n      var redX = parseFloat32(dataView, offset2);\n      var redY = parseFloat32(dataView, offset2);\n      var greenX = parseFloat32(dataView, offset2);\n      var greenY = parseFloat32(dataView, offset2);\n      var blueX = parseFloat32(dataView, offset2);\n      var blueY = parseFloat32(dataView, offset2);\n      var whiteX = parseFloat32(dataView, offset2);\n      var whiteY = parseFloat32(dataView, offset2);\n      return {\n        redX,\n        redY,\n        greenX,\n        greenY,\n        blueX,\n        blueY,\n        whiteX,\n        whiteY\n      };\n    }\n    function parseCompression(dataView, offset2) {\n      var compressionCodes = [\n        \"NO_COMPRESSION\",\n        \"RLE_COMPRESSION\",\n        \"ZIPS_COMPRESSION\",\n        \"ZIP_COMPRESSION\",\n        \"PIZ_COMPRESSION\",\n        \"PXR24_COMPRESSION\",\n        \"B44_COMPRESSION\",\n        \"B44A_COMPRESSION\",\n        \"DWAA_COMPRESSION\",\n        \"DWAB_COMPRESSION\"\n      ];\n      var compression = parseUint8(dataView, offset2);\n      return compressionCodes[compression];\n    }\n    function parseBox2i(dataView, offset2) {\n      var xMin = parseUint32(dataView, offset2);\n      var yMin = parseUint32(dataView, offset2);\n      var xMax = parseUint32(dataView, offset2);\n      var yMax = parseUint32(dataView, offset2);\n      return { xMin, yMin, xMax, yMax };\n    }\n    function parseLineOrder(dataView, offset2) {\n      var lineOrders = [\"INCREASING_Y\"];\n      var lineOrder = parseUint8(dataView, offset2);\n      return lineOrders[lineOrder];\n    }\n    function parseV2f(dataView, offset2) {\n      var x = parseFloat32(dataView, offset2);\n      var y = parseFloat32(dataView, offset2);\n      return [x, y];\n    }\n    function parseV3f(dataView, offset2) {\n      var x = parseFloat32(dataView, offset2);\n      var y = parseFloat32(dataView, offset2);\n      var z = parseFloat32(dataView, offset2);\n      return [x, y, z];\n    }\n    function parseValue(dataView, buffer2, offset2, type, size) {\n      if (type === \"string\" || type === \"stringvector\" || type === \"iccProfile\") {\n        return parseFixedLengthString(buffer2, offset2, size);\n      } else if (type === \"chlist\") {\n        return parseChlist(dataView, buffer2, offset2, size);\n      } else if (type === \"chromaticities\") {\n        return parseChromaticities(dataView, offset2);\n      } else if (type === \"compression\") {\n        return parseCompression(dataView, offset2);\n      } else if (type === \"box2i\") {\n        return parseBox2i(dataView, offset2);\n      } else if (type === \"lineOrder\") {\n        return parseLineOrder(dataView, offset2);\n      } else if (type === \"float\") {\n        return parseFloat32(dataView, offset2);\n      } else if (type === \"v2f\") {\n        return parseV2f(dataView, offset2);\n      } else if (type === \"v3f\") {\n        return parseV3f(dataView, offset2);\n      } else if (type === \"int\") {\n        return parseInt32(dataView, offset2);\n      } else if (type === \"rational\") {\n        return parseRational(dataView, offset2);\n      } else if (type === \"timecode\") {\n        return parseTimecode(dataView, offset2);\n      } else if (type === \"preview\") {\n        offset2.value += size;\n        return \"skipped\";\n      } else {\n        offset2.value += size;\n        return void 0;\n      }\n    }\n    function parseHeader(dataView, buffer2, offset2) {\n      const EXRHeader2 = {};\n      if (dataView.getUint32(0, true) != 20000630) {\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n      }\n      EXRHeader2.version = dataView.getUint8(4);\n      const spec = dataView.getUint8(5);\n      EXRHeader2.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16)\n      };\n      offset2.value = 8;\n      var keepReading = true;\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer2, offset2);\n        if (attributeName == 0) {\n          keepReading = false;\n        } else {\n          var attributeType = parseNullTerminatedString(buffer2, offset2);\n          var attributeSize = parseUint32(dataView, offset2);\n          var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);\n          if (attributeValue === void 0) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);\n          } else {\n            EXRHeader2[attributeName] = attributeValue;\n          }\n        }\n      }\n      if ((spec & ~4) != 0) {\n        console.error(\"EXRHeader:\", EXRHeader2);\n        throw \"THREE.EXRLoader: provided file is currently unsupported.\";\n      }\n      return EXRHeader2;\n    }\n    function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {\n      const EXRDecoder2 = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array2,\n        offset: offset2,\n        width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,\n        height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,\n        channels: EXRHeader2.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader2.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        [hasColorSpace ? \"colorSpace\" : \"encoding\"]: null\n      };\n      switch (EXRHeader2.compression) {\n        case \"NO_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressRAW;\n          break;\n        case \"RLE_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressRLE;\n          break;\n        case \"ZIPS_COMPRESSION\":\n          EXRDecoder2.lines = 1;\n          EXRDecoder2.uncompress = uncompressZIP;\n          break;\n        case \"ZIP_COMPRESSION\":\n          EXRDecoder2.lines = 16;\n          EXRDecoder2.uncompress = uncompressZIP;\n          break;\n        case \"PIZ_COMPRESSION\":\n          EXRDecoder2.lines = 32;\n          EXRDecoder2.uncompress = uncompressPIZ;\n          break;\n        case \"PXR24_COMPRESSION\":\n          EXRDecoder2.lines = 16;\n          EXRDecoder2.uncompress = uncompressPXR;\n          break;\n        case \"DWAA_COMPRESSION\":\n          EXRDecoder2.lines = 32;\n          EXRDecoder2.uncompress = uncompressDWA;\n          break;\n        case \"DWAB_COMPRESSION\":\n          EXRDecoder2.lines = 256;\n          EXRDecoder2.uncompress = uncompressDWA;\n          break;\n        default:\n          throw \"EXRLoader.parse: \" + EXRHeader2.compression + \" is unsupported\";\n      }\n      EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;\n      if (EXRDecoder2.type == 1) {\n        switch (outputType) {\n          case three__WEBPACK_IMPORTED_MODULE_1__.FloatType:\n            EXRDecoder2.getter = parseFloat16;\n            EXRDecoder2.inputSize = INT16_SIZE;\n            break;\n          case three__WEBPACK_IMPORTED_MODULE_1__.HalfFloatType:\n            EXRDecoder2.getter = parseUint16;\n            EXRDecoder2.inputSize = INT16_SIZE;\n            break;\n        }\n      } else if (EXRDecoder2.type == 2) {\n        switch (outputType) {\n          case three__WEBPACK_IMPORTED_MODULE_1__.FloatType:\n            EXRDecoder2.getter = parseFloat32;\n            EXRDecoder2.inputSize = FLOAT32_SIZE;\n            break;\n          case three__WEBPACK_IMPORTED_MODULE_1__.HalfFloatType:\n            EXRDecoder2.getter = decodeFloat32;\n            EXRDecoder2.inputSize = FLOAT32_SIZE;\n        }\n      } else {\n        throw \"EXRLoader.parse: unsupported pixelType \" + EXRDecoder2.type + \" for \" + EXRHeader2.compression + \".\";\n      }\n      EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;\n      for (var i = 0; i < EXRDecoder2.blockCount; i++)\n        parseInt64(dataView, offset2);\n      EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;\n      const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;\n      switch (outputType) {\n        case three__WEBPACK_IMPORTED_MODULE_1__.FloatType:\n          EXRDecoder2.byteArray = new Float32Array(size);\n          if (EXRDecoder2.channels < EXRDecoder2.outputChannels)\n            EXRDecoder2.byteArray.fill(1, 0, size);\n          break;\n        case three__WEBPACK_IMPORTED_MODULE_1__.HalfFloatType:\n          EXRDecoder2.byteArray = new Uint16Array(size);\n          if (EXRDecoder2.channels < EXRDecoder2.outputChannels)\n            EXRDecoder2.byteArray.fill(15360, 0, size);\n          break;\n        default:\n          console.error(\"THREE.EXRLoader: unsupported type: \", outputType);\n          break;\n      }\n      EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;\n      if (EXRDecoder2.outputChannels == 4)\n        EXRDecoder2.format = three__WEBPACK_IMPORTED_MODULE_1__.RGBAFormat;\n      else\n        EXRDecoder2.format = three__WEBPACK_IMPORTED_MODULE_1__.RedFormat;\n      if (hasColorSpace)\n        EXRDecoder2.colorSpace = \"srgb-linear\";\n      else\n        EXRDecoder2.encoding = 3e3;\n      return EXRDecoder2;\n    }\n    const bufferDataView = new DataView(buffer);\n    const uInt8Array = new Uint8Array(buffer);\n    const offset = { value: 0 };\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset);\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n    const tmpOffset = { value: 0 };\n    const channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 };\n    for (let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++) {\n      const line = parseUint32(bufferDataView, offset);\n      EXRDecoder.size = parseUint32(bufferDataView, offset);\n      EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n      offset.value += EXRDecoder.size;\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n        if (true_y >= EXRDecoder.height)\n          break;\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n            const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n          }\n        }\n      }\n    }\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      [hasColorSpace ? \"colorSpace\" : \"encoding\"]: EXRDecoder[hasColorSpace ? \"colorSpace\" : \"encoding\"],\n      type: this.type\n    };\n  }\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      if (hasColorSpace)\n        texture.colorSpace = texData.colorSpace;\n      else\n        texture.encoding = texData.encoding;\n      texture.minFilter = three__WEBPACK_IMPORTED_MODULE_1__.LinearFilter;\n      texture.magFilter = three__WEBPACK_IMPORTED_MODULE_1__.LinearFilter;\n      texture.generateMipmaps = false;\n      texture.flipY = false;\n      if (onLoad)\n        onLoad(texture, texData);\n    }\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n}\n\n//# sourceMappingURL=EXRLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRVhSTG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBb0g7QUFDaEY7QUFDZ0I7QUFDcEQsc0JBQXNCLDJEQUFPO0FBQzdCLHdCQUF3QixvREFBaUI7QUFDekM7QUFDQTtBQUNBLGdCQUFnQixnREFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsY0FBYztBQUNsRyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRDQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxlQUFlLDRDQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDRDQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnREFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2Q0FBVTtBQUN2QztBQUNBLDZCQUE2Qiw0Q0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsNkJBQTZCO0FBQzdCLG1DQUFtQyxxRUFBcUU7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVDQUF1QztBQUNsRTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUNBQWlDO0FBQ2pFO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0NBQVk7QUFDdEMsMEJBQTBCLCtDQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvc2NobmVpZGVyY2FkZXQvRGVza3RvcC9maXp6aS9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRVhSTG9hZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERhdGFUZXh0dXJlTG9hZGVyLCBIYWxmRmxvYXRUeXBlLCBGbG9hdFR5cGUsIFJHQkFGb3JtYXQsIFJlZEZvcm1hdCwgTGluZWFyRmlsdGVyLCBEYXRhVXRpbHMgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IHVuemxpYlN5bmMgfSBmcm9tIFwiZmZsYXRlXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL19wb2x5ZmlsbC9jb25zdGFudHMuanNcIjtcbmNvbnN0IGhhc0NvbG9yU3BhY2UgPSB2ZXJzaW9uID49IDE1MjtcbmNsYXNzIEVYUkxvYWRlciBleHRlbmRzIERhdGFUZXh0dXJlTG9hZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgIHRoaXMudHlwZSA9IEhhbGZGbG9hdFR5cGU7XG4gIH1cbiAgcGFyc2UoYnVmZmVyKSB7XG4gICAgY29uc3QgVVNIT1JUX1JBTkdFID0gMSA8PCAxNjtcbiAgICBjb25zdCBCSVRNQVBfU0laRSA9IFVTSE9SVF9SQU5HRSA+PiAzO1xuICAgIGNvbnN0IEhVRl9FTkNCSVRTID0gMTY7XG4gICAgY29uc3QgSFVGX0RFQ0JJVFMgPSAxNDtcbiAgICBjb25zdCBIVUZfRU5DU0laRSA9ICgxIDw8IEhVRl9FTkNCSVRTKSArIDE7XG4gICAgY29uc3QgSFVGX0RFQ1NJWkUgPSAxIDw8IEhVRl9ERUNCSVRTO1xuICAgIGNvbnN0IEhVRl9ERUNNQVNLID0gSFVGX0RFQ1NJWkUgLSAxO1xuICAgIGNvbnN0IE5CSVRTID0gMTY7XG4gICAgY29uc3QgQV9PRkZTRVQgPSAxIDw8IE5CSVRTIC0gMTtcbiAgICBjb25zdCBNT0RfTUFTSyA9ICgxIDw8IE5CSVRTKSAtIDE7XG4gICAgY29uc3QgU0hPUlRfWkVST0NPREVfUlVOID0gNTk7XG4gICAgY29uc3QgTE9OR19aRVJPQ09ERV9SVU4gPSA2MztcbiAgICBjb25zdCBTSE9SVEVTVF9MT05HX1JVTiA9IDIgKyBMT05HX1pFUk9DT0RFX1JVTiAtIFNIT1JUX1pFUk9DT0RFX1JVTjtcbiAgICBjb25zdCBVTE9OR19TSVpFID0gODtcbiAgICBjb25zdCBGTE9BVDMyX1NJWkUgPSA0O1xuICAgIGNvbnN0IElOVDMyX1NJWkUgPSA0O1xuICAgIGNvbnN0IElOVDE2X1NJWkUgPSAyO1xuICAgIGNvbnN0IElOVDhfU0laRSA9IDE7XG4gICAgY29uc3QgU1RBVElDX0hVRkZNQU4gPSAwO1xuICAgIGNvbnN0IERFRkxBVEUgPSAxO1xuICAgIGNvbnN0IFVOS05PV04gPSAwO1xuICAgIGNvbnN0IExPU1NZX0RDVCA9IDE7XG4gICAgY29uc3QgUkxFID0gMjtcbiAgICBjb25zdCBsb2dCYXNlID0gTWF0aC5wb3coMi43MTgyODE4LCAyLjIpO1xuICAgIGZ1bmN0aW9uIHJldmVyc2VMdXRGcm9tQml0bWFwKGJpdG1hcCwgbHV0KSB7XG4gICAgICB2YXIgayA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFVTSE9SVF9SQU5HRTsgKytpKSB7XG4gICAgICAgIGlmIChpID09IDAgfHwgYml0bWFwW2kgPj4gM10gJiAxIDw8IChpICYgNykpIHtcbiAgICAgICAgICBsdXRbaysrXSA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBuID0gayAtIDE7XG4gICAgICB3aGlsZSAoayA8IFVTSE9SVF9SQU5HRSlcbiAgICAgICAgbHV0W2srK10gPSAwO1xuICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh1ZkNsZWFyRGVjVGFibGUoaGRlYykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBIVUZfREVDU0laRTsgaSsrKSB7XG4gICAgICAgIGhkZWNbaV0gPSB7fTtcbiAgICAgICAgaGRlY1tpXS5sZW4gPSAwO1xuICAgICAgICBoZGVjW2ldLmxpdCA9IDA7XG4gICAgICAgIGhkZWNbaV0ucCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGdldEJpdHNSZXR1cm4gPSB7IGw6IDAsIGM6IDAsIGxjOiAwIH07XG4gICAgZnVuY3Rpb24gZ2V0Qml0cyhuQml0cywgYywgbGMsIHVJbnQ4QXJyYXkyLCBpbk9mZnNldCkge1xuICAgICAgd2hpbGUgKGxjIDwgbkJpdHMpIHtcbiAgICAgICAgYyA9IGMgPDwgOCB8IHBhcnNlVWludDhBcnJheSh1SW50OEFycmF5MiwgaW5PZmZzZXQpO1xuICAgICAgICBsYyArPSA4O1xuICAgICAgfVxuICAgICAgbGMgLT0gbkJpdHM7XG4gICAgICBnZXRCaXRzUmV0dXJuLmwgPSBjID4+IGxjICYgKDEgPDwgbkJpdHMpIC0gMTtcbiAgICAgIGdldEJpdHNSZXR1cm4uYyA9IGM7XG4gICAgICBnZXRCaXRzUmV0dXJuLmxjID0gbGM7XG4gICAgfVxuICAgIGNvbnN0IGh1ZlRhYmxlQnVmZmVyID0gbmV3IEFycmF5KDU5KTtcbiAgICBmdW5jdGlvbiBodWZDYW5vbmljYWxDb2RlVGFibGUoaGNvZGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IDU4OyArK2kpXG4gICAgICAgIGh1ZlRhYmxlQnVmZmVyW2ldID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgSFVGX0VOQ1NJWkU7ICsraSlcbiAgICAgICAgaHVmVGFibGVCdWZmZXJbaGNvZGVbaV1dICs9IDE7XG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gNTg7IGkgPiAwOyAtLWkpIHtcbiAgICAgICAgdmFyIG5jID0gYyArIGh1ZlRhYmxlQnVmZmVyW2ldID4+IDE7XG4gICAgICAgIGh1ZlRhYmxlQnVmZmVyW2ldID0gYztcbiAgICAgICAgYyA9IG5jO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBIVUZfRU5DU0laRTsgKytpKSB7XG4gICAgICAgIHZhciBsID0gaGNvZGVbaV07XG4gICAgICAgIGlmIChsID4gMClcbiAgICAgICAgICBoY29kZVtpXSA9IGwgfCBodWZUYWJsZUJ1ZmZlcltsXSsrIDw8IDY7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh1ZlVucGFja0VuY1RhYmxlKHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbmksIGltLCBpTSwgaGNvZGUpIHtcbiAgICAgIHZhciBwID0gaW5PZmZzZXQ7XG4gICAgICB2YXIgYyA9IDA7XG4gICAgICB2YXIgbGMgPSAwO1xuICAgICAgZm9yICg7IGltIDw9IGlNOyBpbSsrKSB7XG4gICAgICAgIGlmIChwLnZhbHVlIC0gaW5PZmZzZXQudmFsdWUgPiBuaSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGdldEJpdHMoNiwgYywgbGMsIHVJbnQ4QXJyYXkyLCBwKTtcbiAgICAgICAgdmFyIGwgPSBnZXRCaXRzUmV0dXJuLmw7XG4gICAgICAgIGMgPSBnZXRCaXRzUmV0dXJuLmM7XG4gICAgICAgIGxjID0gZ2V0Qml0c1JldHVybi5sYztcbiAgICAgICAgaGNvZGVbaW1dID0gbDtcbiAgICAgICAgaWYgKGwgPT0gTE9OR19aRVJPQ09ERV9SVU4pIHtcbiAgICAgICAgICBpZiAocC52YWx1ZSAtIGluT2Zmc2V0LnZhbHVlID4gbmkpIHtcbiAgICAgICAgICAgIHRocm93IFwiU29tZXRoaW5nIHdyb25nIHdpdGggaHVmVW5wYWNrRW5jVGFibGVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ2V0Qml0cyg4LCBjLCBsYywgdUludDhBcnJheTIsIHApO1xuICAgICAgICAgIHZhciB6ZXJ1biA9IGdldEJpdHNSZXR1cm4ubCArIFNIT1JURVNUX0xPTkdfUlVOO1xuICAgICAgICAgIGMgPSBnZXRCaXRzUmV0dXJuLmM7XG4gICAgICAgICAgbGMgPSBnZXRCaXRzUmV0dXJuLmxjO1xuICAgICAgICAgIGlmIChpbSArIHplcnVuID4gaU0gKyAxKSB7XG4gICAgICAgICAgICB0aHJvdyBcIlNvbWV0aGluZyB3cm9uZyB3aXRoIGh1ZlVucGFja0VuY1RhYmxlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlICh6ZXJ1bi0tKVxuICAgICAgICAgICAgaGNvZGVbaW0rK10gPSAwO1xuICAgICAgICAgIGltLS07XG4gICAgICAgIH0gZWxzZSBpZiAobCA+PSBTSE9SVF9aRVJPQ09ERV9SVU4pIHtcbiAgICAgICAgICB2YXIgemVydW4gPSBsIC0gU0hPUlRfWkVST0NPREVfUlVOICsgMjtcbiAgICAgICAgICBpZiAoaW0gKyB6ZXJ1biA+IGlNICsgMSkge1xuICAgICAgICAgICAgdGhyb3cgXCJTb21ldGhpbmcgd3Jvbmcgd2l0aCBodWZVbnBhY2tFbmNUYWJsZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoemVydW4tLSlcbiAgICAgICAgICAgIGhjb2RlW2ltKytdID0gMDtcbiAgICAgICAgICBpbS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBodWZDYW5vbmljYWxDb2RlVGFibGUoaGNvZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBodWZMZW5ndGgoY29kZSkge1xuICAgICAgcmV0dXJuIGNvZGUgJiA2MztcbiAgICB9XG4gICAgZnVuY3Rpb24gaHVmQ29kZShjb2RlKSB7XG4gICAgICByZXR1cm4gY29kZSA+PiA2O1xuICAgIH1cbiAgICBmdW5jdGlvbiBodWZCdWlsZERlY1RhYmxlKGhjb2RlLCBpbSwgaU0sIGhkZWNvZCkge1xuICAgICAgZm9yICg7IGltIDw9IGlNOyBpbSsrKSB7XG4gICAgICAgIHZhciBjID0gaHVmQ29kZShoY29kZVtpbV0pO1xuICAgICAgICB2YXIgbCA9IGh1Zkxlbmd0aChoY29kZVtpbV0pO1xuICAgICAgICBpZiAoYyA+PiBsKSB7XG4gICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHRhYmxlIGVudHJ5XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGwgPiBIVUZfREVDQklUUykge1xuICAgICAgICAgIHZhciBwbCA9IGhkZWNvZFtjID4+IGwgLSBIVUZfREVDQklUU107XG4gICAgICAgICAgaWYgKHBsLmxlbikge1xuICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHRhYmxlIGVudHJ5XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBsLmxpdCsrO1xuICAgICAgICAgIGlmIChwbC5wKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHBsLnA7XG4gICAgICAgICAgICBwbC5wID0gbmV3IEFycmF5KHBsLmxpdCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsLmxpdCAtIDE7ICsraSkge1xuICAgICAgICAgICAgICBwbC5wW2ldID0gcFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGwucCA9IG5ldyBBcnJheSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGwucFtwbC5saXQgLSAxXSA9IGltO1xuICAgICAgICB9IGVsc2UgaWYgKGwpIHtcbiAgICAgICAgICB2YXIgcGxPZmZzZXQgPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxIDw8IEhVRl9ERUNCSVRTIC0gbDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIHBsID0gaGRlY29kWyhjIDw8IEhVRl9ERUNCSVRTIC0gbCkgKyBwbE9mZnNldF07XG4gICAgICAgICAgICBpZiAocGwubGVuIHx8IHBsLnApIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHRhYmxlIGVudHJ5XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbC5sZW4gPSBsO1xuICAgICAgICAgICAgcGwubGl0ID0gaW07XG4gICAgICAgICAgICBwbE9mZnNldCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGdldENoYXJSZXR1cm4gPSB7IGM6IDAsIGxjOiAwIH07XG4gICAgZnVuY3Rpb24gZ2V0Q2hhcihjLCBsYywgdUludDhBcnJheTIsIGluT2Zmc2V0KSB7XG4gICAgICBjID0gYyA8PCA4IHwgcGFyc2VVaW50OEFycmF5KHVJbnQ4QXJyYXkyLCBpbk9mZnNldCk7XG4gICAgICBsYyArPSA4O1xuICAgICAgZ2V0Q2hhclJldHVybi5jID0gYztcbiAgICAgIGdldENoYXJSZXR1cm4ubGMgPSBsYztcbiAgICB9XG4gICAgY29uc3QgZ2V0Q29kZVJldHVybiA9IHsgYzogMCwgbGM6IDAgfTtcbiAgICBmdW5jdGlvbiBnZXRDb2RlKHBvLCBybGMsIGMsIGxjLCB1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG91dEJ1ZmZlciwgb3V0QnVmZmVyT2Zmc2V0LCBvdXRCdWZmZXJFbmRPZmZzZXQpIHtcbiAgICAgIGlmIChwbyA9PSBybGMpIHtcbiAgICAgICAgaWYgKGxjIDwgOCkge1xuICAgICAgICAgIGdldENoYXIoYywgbGMsIHVJbnQ4QXJyYXkyLCBpbk9mZnNldCk7XG4gICAgICAgICAgYyA9IGdldENoYXJSZXR1cm4uYztcbiAgICAgICAgICBsYyA9IGdldENoYXJSZXR1cm4ubGM7XG4gICAgICAgIH1cbiAgICAgICAgbGMgLT0gODtcbiAgICAgICAgdmFyIGNzID0gYyA+PiBsYztcbiAgICAgICAgdmFyIGNzID0gbmV3IFVpbnQ4QXJyYXkoW2NzXSlbMF07XG4gICAgICAgIGlmIChvdXRCdWZmZXJPZmZzZXQudmFsdWUgKyBjcyA+IG91dEJ1ZmZlckVuZE9mZnNldCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcyA9IG91dEJ1ZmZlcltvdXRCdWZmZXJPZmZzZXQudmFsdWUgLSAxXTtcbiAgICAgICAgd2hpbGUgKGNzLS0gPiAwKSB7XG4gICAgICAgICAgb3V0QnVmZmVyW291dEJ1ZmZlck9mZnNldC52YWx1ZSsrXSA9IHM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob3V0QnVmZmVyT2Zmc2V0LnZhbHVlIDwgb3V0QnVmZmVyRW5kT2Zmc2V0KSB7XG4gICAgICAgIG91dEJ1ZmZlcltvdXRCdWZmZXJPZmZzZXQudmFsdWUrK10gPSBwbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGdldENvZGVSZXR1cm4uYyA9IGM7XG4gICAgICBnZXRDb2RlUmV0dXJuLmxjID0gbGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVJbnQxNih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYgNjU1MzU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEludDE2KHZhbHVlKSB7XG4gICAgICB2YXIgcmVmID0gVUludDE2KHZhbHVlKTtcbiAgICAgIHJldHVybiByZWYgPiAzMjc2NyA/IHJlZiAtIDY1NTM2IDogcmVmO1xuICAgIH1cbiAgICBjb25zdCB3ZGVjMTRSZXR1cm4gPSB7IGE6IDAsIGI6IDAgfTtcbiAgICBmdW5jdGlvbiB3ZGVjMTQobCwgaCkge1xuICAgICAgdmFyIGxzID0gSW50MTYobCk7XG4gICAgICB2YXIgaHMgPSBJbnQxNihoKTtcbiAgICAgIHZhciBoaSA9IGhzO1xuICAgICAgdmFyIGFpID0gbHMgKyAoaGkgJiAxKSArIChoaSA+PiAxKTtcbiAgICAgIHZhciBhcyA9IGFpO1xuICAgICAgdmFyIGJzID0gYWkgLSBoaTtcbiAgICAgIHdkZWMxNFJldHVybi5hID0gYXM7XG4gICAgICB3ZGVjMTRSZXR1cm4uYiA9IGJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3ZGVjMTYobCwgaCkge1xuICAgICAgdmFyIG0gPSBVSW50MTYobCk7XG4gICAgICB2YXIgZCA9IFVJbnQxNihoKTtcbiAgICAgIHZhciBiYiA9IG0gLSAoZCA+PiAxKSAmIE1PRF9NQVNLO1xuICAgICAgdmFyIGFhID0gZCArIGJiIC0gQV9PRkZTRVQgJiBNT0RfTUFTSztcbiAgICAgIHdkZWMxNFJldHVybi5hID0gYWE7XG4gICAgICB3ZGVjMTRSZXR1cm4uYiA9IGJiO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXYyRGVjb2RlKGJ1ZmZlcjIsIGosIG54LCBveCwgbnksIG95LCBteCkge1xuICAgICAgdmFyIHcxNCA9IG14IDwgMSA8PCAxNDtcbiAgICAgIHZhciBuID0gbnggPiBueSA/IG55IDogbng7XG4gICAgICB2YXIgcCA9IDE7XG4gICAgICB2YXIgcDI7XG4gICAgICB3aGlsZSAocCA8PSBuKVxuICAgICAgICBwIDw8PSAxO1xuICAgICAgcCA+Pj0gMTtcbiAgICAgIHAyID0gcDtcbiAgICAgIHAgPj49IDE7XG4gICAgICB3aGlsZSAocCA+PSAxKSB7XG4gICAgICAgIHZhciBweSA9IDA7XG4gICAgICAgIHZhciBleSA9IHB5ICsgb3kgKiAobnkgLSBwMik7XG4gICAgICAgIHZhciBveTEgPSBveSAqIHA7XG4gICAgICAgIHZhciBveTIgPSBveSAqIHAyO1xuICAgICAgICB2YXIgb3gxID0gb3ggKiBwO1xuICAgICAgICB2YXIgb3gyID0gb3ggKiBwMjtcbiAgICAgICAgdmFyIGkwMCwgaTAxLCBpMTAsIGkxMTtcbiAgICAgICAgZm9yICg7IHB5IDw9IGV5OyBweSArPSBveTIpIHtcbiAgICAgICAgICB2YXIgcHggPSBweTtcbiAgICAgICAgICB2YXIgZXggPSBweSArIG94ICogKG54IC0gcDIpO1xuICAgICAgICAgIGZvciAoOyBweCA8PSBleDsgcHggKz0gb3gyKSB7XG4gICAgICAgICAgICB2YXIgcDAxID0gcHggKyBveDE7XG4gICAgICAgICAgICB2YXIgcDEwID0gcHggKyBveTE7XG4gICAgICAgICAgICB2YXIgcDExID0gcDEwICsgb3gxO1xuICAgICAgICAgICAgaWYgKHcxNCkge1xuICAgICAgICAgICAgICB3ZGVjMTQoYnVmZmVyMltweCArIGpdLCBidWZmZXIyW3AxMCArIGpdKTtcbiAgICAgICAgICAgICAgaTAwID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGkxMCA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgICB3ZGVjMTQoYnVmZmVyMltwMDEgKyBqXSwgYnVmZmVyMltwMTEgKyBqXSk7XG4gICAgICAgICAgICAgIGkwMSA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBpMTEgPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgICAgd2RlYzE0KGkwMCwgaTAxKTtcbiAgICAgICAgICAgICAgYnVmZmVyMltweCArIGpdID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGJ1ZmZlcjJbcDAxICsgal0gPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgICAgd2RlYzE0KGkxMCwgaTExKTtcbiAgICAgICAgICAgICAgYnVmZmVyMltwMTAgKyBqXSA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBidWZmZXIyW3AxMSArIGpdID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3ZGVjMTYoYnVmZmVyMltweCArIGpdLCBidWZmZXIyW3AxMCArIGpdKTtcbiAgICAgICAgICAgICAgaTAwID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGkxMCA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgICB3ZGVjMTYoYnVmZmVyMltwMDEgKyBqXSwgYnVmZmVyMltwMTEgKyBqXSk7XG4gICAgICAgICAgICAgIGkwMSA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBpMTEgPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgICAgd2RlYzE2KGkwMCwgaTAxKTtcbiAgICAgICAgICAgICAgYnVmZmVyMltweCArIGpdID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGJ1ZmZlcjJbcDAxICsgal0gPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgICAgd2RlYzE2KGkxMCwgaTExKTtcbiAgICAgICAgICAgICAgYnVmZmVyMltwMTAgKyBqXSA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBidWZmZXIyW3AxMSArIGpdID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChueCAmIHApIHtcbiAgICAgICAgICAgIHZhciBwMTAgPSBweCArIG95MTtcbiAgICAgICAgICAgIGlmICh3MTQpXG4gICAgICAgICAgICAgIHdkZWMxNChidWZmZXIyW3B4ICsgal0sIGJ1ZmZlcjJbcDEwICsgal0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB3ZGVjMTYoYnVmZmVyMltweCArIGpdLCBidWZmZXIyW3AxMCArIGpdKTtcbiAgICAgICAgICAgIGkwMCA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgYnVmZmVyMltwMTAgKyBqXSA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgYnVmZmVyMltweCArIGpdID0gaTAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobnkgJiBwKSB7XG4gICAgICAgICAgdmFyIHB4ID0gcHk7XG4gICAgICAgICAgdmFyIGV4ID0gcHkgKyBveCAqIChueCAtIHAyKTtcbiAgICAgICAgICBmb3IgKDsgcHggPD0gZXg7IHB4ICs9IG94Mikge1xuICAgICAgICAgICAgdmFyIHAwMSA9IHB4ICsgb3gxO1xuICAgICAgICAgICAgaWYgKHcxNClcbiAgICAgICAgICAgICAgd2RlYzE0KGJ1ZmZlcjJbcHggKyBqXSwgYnVmZmVyMltwMDEgKyBqXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHdkZWMxNihidWZmZXIyW3B4ICsgal0sIGJ1ZmZlcjJbcDAxICsgal0pO1xuICAgICAgICAgICAgaTAwID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICBidWZmZXIyW3AwMSArIGpdID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICBidWZmZXIyW3B4ICsgal0gPSBpMDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHAyID0gcDtcbiAgICAgICAgcCA+Pj0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBweTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaHVmRGVjb2RlKGVuY29kaW5nVGFibGUsIGRlY29kaW5nVGFibGUsIHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbmksIHJsYywgbm8sIG91dEJ1ZmZlciwgb3V0T2Zmc2V0KSB7XG4gICAgICB2YXIgYyA9IDA7XG4gICAgICB2YXIgbGMgPSAwO1xuICAgICAgdmFyIG91dEJ1ZmZlckVuZE9mZnNldCA9IG5vO1xuICAgICAgdmFyIGluT2Zmc2V0RW5kID0gTWF0aC50cnVuYyhpbk9mZnNldC52YWx1ZSArIChuaSArIDcpIC8gOCk7XG4gICAgICB3aGlsZSAoaW5PZmZzZXQudmFsdWUgPCBpbk9mZnNldEVuZCkge1xuICAgICAgICBnZXRDaGFyKGMsIGxjLCB1SW50OEFycmF5MiwgaW5PZmZzZXQpO1xuICAgICAgICBjID0gZ2V0Q2hhclJldHVybi5jO1xuICAgICAgICBsYyA9IGdldENoYXJSZXR1cm4ubGM7XG4gICAgICAgIHdoaWxlIChsYyA+PSBIVUZfREVDQklUUykge1xuICAgICAgICAgIHZhciBpbmRleCA9IGMgPj4gbGMgLSBIVUZfREVDQklUUyAmIEhVRl9ERUNNQVNLO1xuICAgICAgICAgIHZhciBwbCA9IGRlY29kaW5nVGFibGVbaW5kZXhdO1xuICAgICAgICAgIGlmIChwbC5sZW4pIHtcbiAgICAgICAgICAgIGxjIC09IHBsLmxlbjtcbiAgICAgICAgICAgIGdldENvZGUocGwubGl0LCBybGMsIGMsIGxjLCB1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG91dEJ1ZmZlciwgb3V0T2Zmc2V0LCBvdXRCdWZmZXJFbmRPZmZzZXQpO1xuICAgICAgICAgICAgYyA9IGdldENvZGVSZXR1cm4uYztcbiAgICAgICAgICAgIGxjID0gZ2V0Q29kZVJldHVybi5sYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFwbC5wKSB7XG4gICAgICAgICAgICAgIHRocm93IFwiaHVmRGVjb2RlIGlzc3Vlc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGo7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcGwubGl0OyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIGwgPSBodWZMZW5ndGgoZW5jb2RpbmdUYWJsZVtwbC5wW2pdXSk7XG4gICAgICAgICAgICAgIHdoaWxlIChsYyA8IGwgJiYgaW5PZmZzZXQudmFsdWUgPCBpbk9mZnNldEVuZCkge1xuICAgICAgICAgICAgICAgIGdldENoYXIoYywgbGMsIHVJbnQ4QXJyYXkyLCBpbk9mZnNldCk7XG4gICAgICAgICAgICAgICAgYyA9IGdldENoYXJSZXR1cm4uYztcbiAgICAgICAgICAgICAgICBsYyA9IGdldENoYXJSZXR1cm4ubGM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxjID49IGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaHVmQ29kZShlbmNvZGluZ1RhYmxlW3BsLnBbal1dKSA9PSAoYyA+PiBsYyAtIGwgJiAoMSA8PCBsKSAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICBsYyAtPSBsO1xuICAgICAgICAgICAgICAgICAgZ2V0Q29kZShcbiAgICAgICAgICAgICAgICAgICAgcGwucFtqXSxcbiAgICAgICAgICAgICAgICAgICAgcmxjLFxuICAgICAgICAgICAgICAgICAgICBjLFxuICAgICAgICAgICAgICAgICAgICBsYyxcbiAgICAgICAgICAgICAgICAgICAgdUludDhBcnJheTIsXG4gICAgICAgICAgICAgICAgICAgIGluRGF0YVZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGluT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBvdXRCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIG91dE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgb3V0QnVmZmVyRW5kT2Zmc2V0XG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgYyA9IGdldENvZGVSZXR1cm4uYztcbiAgICAgICAgICAgICAgICAgIGxjID0gZ2V0Q29kZVJldHVybi5sYztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGogPT0gcGwubGl0KSB7XG4gICAgICAgICAgICAgIHRocm93IFwiaHVmRGVjb2RlIGlzc3Vlc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGkgPSA4IC0gbmkgJiA3O1xuICAgICAgYyA+Pj0gaTtcbiAgICAgIGxjIC09IGk7XG4gICAgICB3aGlsZSAobGMgPiAwKSB7XG4gICAgICAgIHZhciBwbCA9IGRlY29kaW5nVGFibGVbYyA8PCBIVUZfREVDQklUUyAtIGxjICYgSFVGX0RFQ01BU0tdO1xuICAgICAgICBpZiAocGwubGVuKSB7XG4gICAgICAgICAgbGMgLT0gcGwubGVuO1xuICAgICAgICAgIGdldENvZGUocGwubGl0LCBybGMsIGMsIGxjLCB1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG91dEJ1ZmZlciwgb3V0T2Zmc2V0LCBvdXRCdWZmZXJFbmRPZmZzZXQpO1xuICAgICAgICAgIGMgPSBnZXRDb2RlUmV0dXJuLmM7XG4gICAgICAgICAgbGMgPSBnZXRDb2RlUmV0dXJuLmxjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IFwiaHVmRGVjb2RlIGlzc3Vlc1wiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaHVmVW5jb21wcmVzcyh1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG5Db21wcmVzc2VkLCBvdXRCdWZmZXIsIG5SYXcpIHtcbiAgICAgIHZhciBvdXRPZmZzZXQgPSB7IHZhbHVlOiAwIH07XG4gICAgICB2YXIgaW5pdGlhbEluT2Zmc2V0ID0gaW5PZmZzZXQudmFsdWU7XG4gICAgICB2YXIgaW0gPSBwYXJzZVVpbnQzMihpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICB2YXIgaU0gPSBwYXJzZVVpbnQzMihpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICBpbk9mZnNldC52YWx1ZSArPSA0O1xuICAgICAgdmFyIG5CaXRzID0gcGFyc2VVaW50MzIoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgaW5PZmZzZXQudmFsdWUgKz0gNDtcbiAgICAgIGlmIChpbSA8IDAgfHwgaW0gPj0gSFVGX0VOQ1NJWkUgfHwgaU0gPCAwIHx8IGlNID49IEhVRl9FTkNTSVpFKSB7XG4gICAgICAgIHRocm93IFwiU29tZXRoaW5nIHdyb25nIHdpdGggSFVGX0VOQ1NJWkVcIjtcbiAgICAgIH1cbiAgICAgIHZhciBmcmVxID0gbmV3IEFycmF5KEhVRl9FTkNTSVpFKTtcbiAgICAgIHZhciBoZGVjID0gbmV3IEFycmF5KEhVRl9ERUNTSVpFKTtcbiAgICAgIGh1ZkNsZWFyRGVjVGFibGUoaGRlYyk7XG4gICAgICB2YXIgbmkgPSBuQ29tcHJlc3NlZCAtIChpbk9mZnNldC52YWx1ZSAtIGluaXRpYWxJbk9mZnNldCk7XG4gICAgICBodWZVbnBhY2tFbmNUYWJsZSh1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG5pLCBpbSwgaU0sIGZyZXEpO1xuICAgICAgaWYgKG5CaXRzID4gOCAqIChuQ29tcHJlc3NlZCAtIChpbk9mZnNldC52YWx1ZSAtIGluaXRpYWxJbk9mZnNldCkpKSB7XG4gICAgICAgIHRocm93IFwiU29tZXRoaW5nIHdyb25nIHdpdGggaHVmVW5jb21wcmVzc1wiO1xuICAgICAgfVxuICAgICAgaHVmQnVpbGREZWNUYWJsZShmcmVxLCBpbSwgaU0sIGhkZWMpO1xuICAgICAgaHVmRGVjb2RlKGZyZXEsIGhkZWMsIHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbkJpdHMsIGlNLCBuUmF3LCBvdXRCdWZmZXIsIG91dE9mZnNldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5THV0KGx1dCwgZGF0YSwgbkRhdGEpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkRhdGE7ICsraSkge1xuICAgICAgICBkYXRhW2ldID0gbHV0W2RhdGFbaV1dO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVkaWN0b3Ioc291cmNlKSB7XG4gICAgICBmb3IgKHZhciB0ID0gMTsgdCA8IHNvdXJjZS5sZW5ndGg7IHQrKykge1xuICAgICAgICB2YXIgZCA9IHNvdXJjZVt0IC0gMV0gKyBzb3VyY2VbdF0gLSAxMjg7XG4gICAgICAgIHNvdXJjZVt0XSA9IGQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVybGVhdmVTY2FsYXIoc291cmNlLCBvdXQpIHtcbiAgICAgIHZhciB0MSA9IDA7XG4gICAgICB2YXIgdDIgPSBNYXRoLmZsb29yKChzb3VyY2UubGVuZ3RoICsgMSkgLyAyKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBzdG9wID0gc291cmNlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAocyA+IHN0b3ApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIG91dFtzKytdID0gc291cmNlW3QxKytdO1xuICAgICAgICBpZiAocyA+IHN0b3ApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIG91dFtzKytdID0gc291cmNlW3QyKytdO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVSdW5MZW5ndGgoc291cmNlKSB7XG4gICAgICB2YXIgc2l6ZSA9IHNvdXJjZS5ieXRlTGVuZ3RoO1xuICAgICAgdmFyIG91dCA9IG5ldyBBcnJheSgpO1xuICAgICAgdmFyIHAgPSAwO1xuICAgICAgdmFyIHJlYWRlciA9IG5ldyBEYXRhVmlldyhzb3VyY2UpO1xuICAgICAgd2hpbGUgKHNpemUgPiAwKSB7XG4gICAgICAgIHZhciBsID0gcmVhZGVyLmdldEludDgocCsrKTtcbiAgICAgICAgaWYgKGwgPCAwKSB7XG4gICAgICAgICAgdmFyIGNvdW50ID0gLWw7XG4gICAgICAgICAgc2l6ZSAtPSBjb3VudCArIDE7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBvdXQucHVzaChyZWFkZXIuZ2V0VWludDgocCsrKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjb3VudCA9IGw7XG4gICAgICAgICAgc2l6ZSAtPSAyO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHJlYWRlci5nZXRVaW50OChwKyspO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgKyAxOyBpKyspIHtcbiAgICAgICAgICAgIG91dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvc3N5RGN0RGVjb2RlKGNzY1NldCwgcm93UHRycywgY2hhbm5lbERhdGEsIGFjQnVmZmVyLCBkY0J1ZmZlciwgb3V0QnVmZmVyKSB7XG4gICAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcob3V0QnVmZmVyLmJ1ZmZlcik7XG4gICAgICB2YXIgd2lkdGggPSBjaGFubmVsRGF0YVtjc2NTZXQuaWR4WzBdXS53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBjaGFubmVsRGF0YVtjc2NTZXQuaWR4WzBdXS5oZWlnaHQ7XG4gICAgICB2YXIgbnVtQ29tcCA9IDM7XG4gICAgICB2YXIgbnVtRnVsbEJsb2Nrc1ggPSBNYXRoLmZsb29yKHdpZHRoIC8gOCk7XG4gICAgICB2YXIgbnVtQmxvY2tzWCA9IE1hdGguY2VpbCh3aWR0aCAvIDgpO1xuICAgICAgdmFyIG51bUJsb2Nrc1kgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gOCk7XG4gICAgICB2YXIgbGVmdG92ZXJYID0gd2lkdGggLSAobnVtQmxvY2tzWCAtIDEpICogODtcbiAgICAgIHZhciBsZWZ0b3ZlclkgPSBoZWlnaHQgLSAobnVtQmxvY2tzWSAtIDEpICogODtcbiAgICAgIHZhciBjdXJyQWNDb21wID0geyB2YWx1ZTogMCB9O1xuICAgICAgdmFyIGN1cnJEY0NvbXAgPSBuZXcgQXJyYXkobnVtQ29tcCk7XG4gICAgICB2YXIgZGN0RGF0YSA9IG5ldyBBcnJheShudW1Db21wKTtcbiAgICAgIHZhciBoYWxmWmlnQmxvY2sgPSBuZXcgQXJyYXkobnVtQ29tcCk7XG4gICAgICB2YXIgcm93QmxvY2sgPSBuZXcgQXJyYXkobnVtQ29tcCk7XG4gICAgICB2YXIgcm93T2Zmc2V0cyA9IG5ldyBBcnJheShudW1Db21wKTtcbiAgICAgIGZvciAobGV0IGNvbXAyID0gMDsgY29tcDIgPCBudW1Db21wOyArK2NvbXAyKSB7XG4gICAgICAgIHJvd09mZnNldHNbY29tcDJdID0gcm93UHRyc1tjc2NTZXQuaWR4W2NvbXAyXV07XG4gICAgICAgIGN1cnJEY0NvbXBbY29tcDJdID0gY29tcDIgPCAxID8gMCA6IGN1cnJEY0NvbXBbY29tcDIgLSAxXSArIG51bUJsb2Nrc1ggKiBudW1CbG9ja3NZO1xuICAgICAgICBkY3REYXRhW2NvbXAyXSA9IG5ldyBGbG9hdDMyQXJyYXkoNjQpO1xuICAgICAgICBoYWxmWmlnQmxvY2tbY29tcDJdID0gbmV3IFVpbnQxNkFycmF5KDY0KTtcbiAgICAgICAgcm93QmxvY2tbY29tcDJdID0gbmV3IFVpbnQxNkFycmF5KG51bUJsb2Nrc1ggKiA2NCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBibG9ja3kgPSAwOyBibG9ja3kgPCBudW1CbG9ja3NZOyArK2Jsb2NreSkge1xuICAgICAgICB2YXIgbWF4WSA9IDg7XG4gICAgICAgIGlmIChibG9ja3kgPT0gbnVtQmxvY2tzWSAtIDEpXG4gICAgICAgICAgbWF4WSA9IGxlZnRvdmVyWTtcbiAgICAgICAgdmFyIG1heFggPSA4O1xuICAgICAgICBmb3IgKGxldCBibG9ja3ggPSAwOyBibG9ja3ggPCBudW1CbG9ja3NYOyArK2Jsb2NreCkge1xuICAgICAgICAgIGlmIChibG9ja3ggPT0gbnVtQmxvY2tzWCAtIDEpXG4gICAgICAgICAgICBtYXhYID0gbGVmdG92ZXJYO1xuICAgICAgICAgIGZvciAobGV0IGNvbXAyID0gMDsgY29tcDIgPCBudW1Db21wOyArK2NvbXAyKSB7XG4gICAgICAgICAgICBoYWxmWmlnQmxvY2tbY29tcDJdLmZpbGwoMCk7XG4gICAgICAgICAgICBoYWxmWmlnQmxvY2tbY29tcDJdWzBdID0gZGNCdWZmZXJbY3VyckRjQ29tcFtjb21wMl0rK107XG4gICAgICAgICAgICB1blJsZUFDKGN1cnJBY0NvbXAsIGFjQnVmZmVyLCBoYWxmWmlnQmxvY2tbY29tcDJdKTtcbiAgICAgICAgICAgIHVuWmlnWmFnKGhhbGZaaWdCbG9ja1tjb21wMl0sIGRjdERhdGFbY29tcDJdKTtcbiAgICAgICAgICAgIGRjdEludmVyc2UoZGN0RGF0YVtjb21wMl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB7XG4gICAgICAgICAgICBjc2M3MDlJbnZlcnNlKGRjdERhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBjb21wMiA9IDA7IGNvbXAyIDwgbnVtQ29tcDsgKytjb21wMikge1xuICAgICAgICAgICAgY29udmVydFRvSGFsZihkY3REYXRhW2NvbXAyXSwgcm93QmxvY2tbY29tcDJdLCBibG9ja3ggKiA2NCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBvZmZzZXQyID0gMDtcbiAgICAgICAgZm9yIChsZXQgY29tcDIgPSAwOyBjb21wMiA8IG51bUNvbXA7ICsrY29tcDIpIHtcbiAgICAgICAgICBjb25zdCB0eXBlMiA9IGNoYW5uZWxEYXRhW2NzY1NldC5pZHhbY29tcDJdXS50eXBlO1xuICAgICAgICAgIGZvciAobGV0IHkyID0gOCAqIGJsb2NreTsgeTIgPCA4ICogYmxvY2t5ICsgbWF4WTsgKyt5Mikge1xuICAgICAgICAgICAgb2Zmc2V0MiA9IHJvd09mZnNldHNbY29tcDJdW3kyXTtcbiAgICAgICAgICAgIGZvciAobGV0IGJsb2NreCA9IDA7IGJsb2NreCA8IG51bUZ1bGxCbG9ja3NYOyArK2Jsb2NreCkge1xuICAgICAgICAgICAgICBjb25zdCBzcmMgPSBibG9ja3ggKiA2NCArICh5MiAmIDcpICogODtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyAwICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgMF0sIHRydWUpO1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDEgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyAxXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQyICsgMiAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIDJdLCB0cnVlKTtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyAzICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgM10sIHRydWUpO1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDQgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyA0XSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQyICsgNSAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIDVdLCB0cnVlKTtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyA2ICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgNl0sIHRydWUpO1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDcgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyA3XSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIG9mZnNldDIgKz0gOCAqIElOVDE2X1NJWkUgKiB0eXBlMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG51bUZ1bGxCbG9ja3NYICE9IG51bUJsb2Nrc1gpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkyID0gOCAqIGJsb2NreTsgeTIgPCA4ICogYmxvY2t5ICsgbWF4WTsgKyt5Mikge1xuICAgICAgICAgICAgICBjb25zdCBvZmZzZXQzID0gcm93T2Zmc2V0c1tjb21wMl1beTJdICsgOCAqIG51bUZ1bGxCbG9ja3NYICogSU5UMTZfU0laRSAqIHR5cGUyO1xuICAgICAgICAgICAgICBjb25zdCBzcmMgPSBudW1GdWxsQmxvY2tzWCAqIDY0ICsgKHkyICYgNykgKiA4O1xuICAgICAgICAgICAgICBmb3IgKGxldCB4MiA9IDA7IHgyIDwgbWF4WDsgKyt4Mikge1xuICAgICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQzICsgeDIgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyB4Ml0sIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaGFsZlJvdyA9IG5ldyBVaW50MTZBcnJheSh3aWR0aCk7XG4gICAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcob3V0QnVmZmVyLmJ1ZmZlcik7XG4gICAgICBmb3IgKHZhciBjb21wID0gMDsgY29tcCA8IG51bUNvbXA7ICsrY29tcCkge1xuICAgICAgICBjaGFubmVsRGF0YVtjc2NTZXQuaWR4W2NvbXBdXS5kZWNvZGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHR5cGUgPSBjaGFubmVsRGF0YVtjc2NTZXQuaWR4W2NvbXBdXS50eXBlO1xuICAgICAgICBpZiAoY2hhbm5lbERhdGFbY29tcF0udHlwZSAhPSAyKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IHJvd09mZnNldHNbY29tcF1beV07XG4gICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgKyt4KSB7XG4gICAgICAgICAgICBoYWxmUm93W3hdID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldDIgKyB4ICogSU5UMTZfU0laRSAqIHR5cGUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyArK3gpIHtcbiAgICAgICAgICAgIGRhdGFWaWV3LnNldEZsb2F0MzIob2Zmc2V0MiArIHggKiBJTlQxNl9TSVpFICogdHlwZSwgZGVjb2RlRmxvYXQxNihoYWxmUm93W3hdKSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuUmxlQUMoY3VyckFjQ29tcCwgYWNCdWZmZXIsIGhhbGZaaWdCbG9jaykge1xuICAgICAgdmFyIGFjVmFsdWU7XG4gICAgICB2YXIgZGN0Q29tcCA9IDE7XG4gICAgICB3aGlsZSAoZGN0Q29tcCA8IDY0KSB7XG4gICAgICAgIGFjVmFsdWUgPSBhY0J1ZmZlcltjdXJyQWNDb21wLnZhbHVlXTtcbiAgICAgICAgaWYgKGFjVmFsdWUgPT0gNjUyODApIHtcbiAgICAgICAgICBkY3RDb21wID0gNjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYWNWYWx1ZSA+PiA4ID09IDI1NSkge1xuICAgICAgICAgIGRjdENvbXAgKz0gYWNWYWx1ZSAmIDI1NTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYWxmWmlnQmxvY2tbZGN0Q29tcF0gPSBhY1ZhbHVlO1xuICAgICAgICAgIGRjdENvbXArKztcbiAgICAgICAgfVxuICAgICAgICBjdXJyQWNDb21wLnZhbHVlKys7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuWmlnWmFnKHNyYywgZHN0KSB7XG4gICAgICBkc3RbMF0gPSBkZWNvZGVGbG9hdDE2KHNyY1swXSk7XG4gICAgICBkc3RbMV0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxXSk7XG4gICAgICBkc3RbMl0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1XSk7XG4gICAgICBkc3RbM10gPSBkZWNvZGVGbG9hdDE2KHNyY1s2XSk7XG4gICAgICBkc3RbNF0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxNF0pO1xuICAgICAgZHN0WzVdID0gZGVjb2RlRmxvYXQxNihzcmNbMTVdKTtcbiAgICAgIGRzdFs2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzI3XSk7XG4gICAgICBkc3RbN10gPSBkZWNvZGVGbG9hdDE2KHNyY1syOF0pO1xuICAgICAgZHN0WzhdID0gZGVjb2RlRmxvYXQxNihzcmNbMl0pO1xuICAgICAgZHN0WzldID0gZGVjb2RlRmxvYXQxNihzcmNbNF0pO1xuICAgICAgZHN0WzEwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzddKTtcbiAgICAgIGRzdFsxMV0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxM10pO1xuICAgICAgZHN0WzEyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzE2XSk7XG4gICAgICBkc3RbMTNdID0gZGVjb2RlRmxvYXQxNihzcmNbMjZdKTtcbiAgICAgIGRzdFsxNF0gPSBkZWNvZGVGbG9hdDE2KHNyY1syOV0pO1xuICAgICAgZHN0WzE1XSA9IGRlY29kZUZsb2F0MTYoc3JjWzQyXSk7XG4gICAgICBkc3RbMTZdID0gZGVjb2RlRmxvYXQxNihzcmNbM10pO1xuICAgICAgZHN0WzE3XSA9IGRlY29kZUZsb2F0MTYoc3JjWzhdKTtcbiAgICAgIGRzdFsxOF0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxMl0pO1xuICAgICAgZHN0WzE5XSA9IGRlY29kZUZsb2F0MTYoc3JjWzE3XSk7XG4gICAgICBkc3RbMjBdID0gZGVjb2RlRmxvYXQxNihzcmNbMjVdKTtcbiAgICAgIGRzdFsyMV0gPSBkZWNvZGVGbG9hdDE2KHNyY1szMF0pO1xuICAgICAgZHN0WzIyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzQxXSk7XG4gICAgICBkc3RbMjNdID0gZGVjb2RlRmxvYXQxNihzcmNbNDNdKTtcbiAgICAgIGRzdFsyNF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s5XSk7XG4gICAgICBkc3RbMjVdID0gZGVjb2RlRmxvYXQxNihzcmNbMTFdKTtcbiAgICAgIGRzdFsyNl0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxOF0pO1xuICAgICAgZHN0WzI3XSA9IGRlY29kZUZsb2F0MTYoc3JjWzI0XSk7XG4gICAgICBkc3RbMjhdID0gZGVjb2RlRmxvYXQxNihzcmNbMzFdKTtcbiAgICAgIGRzdFsyOV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0MF0pO1xuICAgICAgZHN0WzMwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzQ0XSk7XG4gICAgICBkc3RbMzFdID0gZGVjb2RlRmxvYXQxNihzcmNbNTNdKTtcbiAgICAgIGRzdFszMl0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxMF0pO1xuICAgICAgZHN0WzMzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzE5XSk7XG4gICAgICBkc3RbMzRdID0gZGVjb2RlRmxvYXQxNihzcmNbMjNdKTtcbiAgICAgIGRzdFszNV0gPSBkZWNvZGVGbG9hdDE2KHNyY1szMl0pO1xuICAgICAgZHN0WzM2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzM5XSk7XG4gICAgICBkc3RbMzddID0gZGVjb2RlRmxvYXQxNihzcmNbNDVdKTtcbiAgICAgIGRzdFszOF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1Ml0pO1xuICAgICAgZHN0WzM5XSA9IGRlY29kZUZsb2F0MTYoc3JjWzU0XSk7XG4gICAgICBkc3RbNDBdID0gZGVjb2RlRmxvYXQxNihzcmNbMjBdKTtcbiAgICAgIGRzdFs0MV0gPSBkZWNvZGVGbG9hdDE2KHNyY1syMl0pO1xuICAgICAgZHN0WzQyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzMzXSk7XG4gICAgICBkc3RbNDNdID0gZGVjb2RlRmxvYXQxNihzcmNbMzhdKTtcbiAgICAgIGRzdFs0NF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0Nl0pO1xuICAgICAgZHN0WzQ1XSA9IGRlY29kZUZsb2F0MTYoc3JjWzUxXSk7XG4gICAgICBkc3RbNDZdID0gZGVjb2RlRmxvYXQxNihzcmNbNTVdKTtcbiAgICAgIGRzdFs0N10gPSBkZWNvZGVGbG9hdDE2KHNyY1s2MF0pO1xuICAgICAgZHN0WzQ4XSA9IGRlY29kZUZsb2F0MTYoc3JjWzIxXSk7XG4gICAgICBkc3RbNDldID0gZGVjb2RlRmxvYXQxNihzcmNbMzRdKTtcbiAgICAgIGRzdFs1MF0gPSBkZWNvZGVGbG9hdDE2KHNyY1szN10pO1xuICAgICAgZHN0WzUxXSA9IGRlY29kZUZsb2F0MTYoc3JjWzQ3XSk7XG4gICAgICBkc3RbNTJdID0gZGVjb2RlRmxvYXQxNihzcmNbNTBdKTtcbiAgICAgIGRzdFs1M10gPSBkZWNvZGVGbG9hdDE2KHNyY1s1Nl0pO1xuICAgICAgZHN0WzU0XSA9IGRlY29kZUZsb2F0MTYoc3JjWzU5XSk7XG4gICAgICBkc3RbNTVdID0gZGVjb2RlRmxvYXQxNihzcmNbNjFdKTtcbiAgICAgIGRzdFs1Nl0gPSBkZWNvZGVGbG9hdDE2KHNyY1szNV0pO1xuICAgICAgZHN0WzU3XSA9IGRlY29kZUZsb2F0MTYoc3JjWzM2XSk7XG4gICAgICBkc3RbNThdID0gZGVjb2RlRmxvYXQxNihzcmNbNDhdKTtcbiAgICAgIGRzdFs1OV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0OV0pO1xuICAgICAgZHN0WzYwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzU3XSk7XG4gICAgICBkc3RbNjFdID0gZGVjb2RlRmxvYXQxNihzcmNbNThdKTtcbiAgICAgIGRzdFs2Ml0gPSBkZWNvZGVGbG9hdDE2KHNyY1s2Ml0pO1xuICAgICAgZHN0WzYzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzYzXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRjdEludmVyc2UoZGF0YSkge1xuICAgICAgY29uc3QgYSA9IDAuNSAqIE1hdGguY29zKDMuMTQxNTkgLyA0KTtcbiAgICAgIGNvbnN0IGIgPSAwLjUgKiBNYXRoLmNvcygzLjE0MTU5IC8gMTYpO1xuICAgICAgY29uc3QgYyA9IDAuNSAqIE1hdGguY29zKDMuMTQxNTkgLyA4KTtcbiAgICAgIGNvbnN0IGQgPSAwLjUgKiBNYXRoLmNvcygzICogMy4xNDE1OSAvIDE2KTtcbiAgICAgIGNvbnN0IGUgPSAwLjUgKiBNYXRoLmNvcyg1ICogMy4xNDE1OSAvIDE2KTtcbiAgICAgIGNvbnN0IGYgPSAwLjUgKiBNYXRoLmNvcygzICogMy4xNDE1OSAvIDgpO1xuICAgICAgY29uc3QgZyA9IDAuNSAqIE1hdGguY29zKDcgKiAzLjE0MTU5IC8gMTYpO1xuICAgICAgdmFyIGFscGhhID0gbmV3IEFycmF5KDQpO1xuICAgICAgdmFyIGJldGEgPSBuZXcgQXJyYXkoNCk7XG4gICAgICB2YXIgdGhldGEgPSBuZXcgQXJyYXkoNCk7XG4gICAgICB2YXIgZ2FtbWEgPSBuZXcgQXJyYXkoNCk7XG4gICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCA4OyArK3Jvdykge1xuICAgICAgICB2YXIgcm93UHRyID0gcm93ICogODtcbiAgICAgICAgYWxwaGFbMF0gPSBjICogZGF0YVtyb3dQdHIgKyAyXTtcbiAgICAgICAgYWxwaGFbMV0gPSBmICogZGF0YVtyb3dQdHIgKyAyXTtcbiAgICAgICAgYWxwaGFbMl0gPSBjICogZGF0YVtyb3dQdHIgKyA2XTtcbiAgICAgICAgYWxwaGFbM10gPSBmICogZGF0YVtyb3dQdHIgKyA2XTtcbiAgICAgICAgYmV0YVswXSA9IGIgKiBkYXRhW3Jvd1B0ciArIDFdICsgZCAqIGRhdGFbcm93UHRyICsgM10gKyBlICogZGF0YVtyb3dQdHIgKyA1XSArIGcgKiBkYXRhW3Jvd1B0ciArIDddO1xuICAgICAgICBiZXRhWzFdID0gZCAqIGRhdGFbcm93UHRyICsgMV0gLSBnICogZGF0YVtyb3dQdHIgKyAzXSAtIGIgKiBkYXRhW3Jvd1B0ciArIDVdIC0gZSAqIGRhdGFbcm93UHRyICsgN107XG4gICAgICAgIGJldGFbMl0gPSBlICogZGF0YVtyb3dQdHIgKyAxXSAtIGIgKiBkYXRhW3Jvd1B0ciArIDNdICsgZyAqIGRhdGFbcm93UHRyICsgNV0gKyBkICogZGF0YVtyb3dQdHIgKyA3XTtcbiAgICAgICAgYmV0YVszXSA9IGcgKiBkYXRhW3Jvd1B0ciArIDFdIC0gZSAqIGRhdGFbcm93UHRyICsgM10gKyBkICogZGF0YVtyb3dQdHIgKyA1XSAtIGIgKiBkYXRhW3Jvd1B0ciArIDddO1xuICAgICAgICB0aGV0YVswXSA9IGEgKiAoZGF0YVtyb3dQdHIgKyAwXSArIGRhdGFbcm93UHRyICsgNF0pO1xuICAgICAgICB0aGV0YVszXSA9IGEgKiAoZGF0YVtyb3dQdHIgKyAwXSAtIGRhdGFbcm93UHRyICsgNF0pO1xuICAgICAgICB0aGV0YVsxXSA9IGFscGhhWzBdICsgYWxwaGFbM107XG4gICAgICAgIHRoZXRhWzJdID0gYWxwaGFbMV0gLSBhbHBoYVsyXTtcbiAgICAgICAgZ2FtbWFbMF0gPSB0aGV0YVswXSArIHRoZXRhWzFdO1xuICAgICAgICBnYW1tYVsxXSA9IHRoZXRhWzNdICsgdGhldGFbMl07XG4gICAgICAgIGdhbW1hWzJdID0gdGhldGFbM10gLSB0aGV0YVsyXTtcbiAgICAgICAgZ2FtbWFbM10gPSB0aGV0YVswXSAtIHRoZXRhWzFdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDBdID0gZ2FtbWFbMF0gKyBiZXRhWzBdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDFdID0gZ2FtbWFbMV0gKyBiZXRhWzFdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDJdID0gZ2FtbWFbMl0gKyBiZXRhWzJdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDNdID0gZ2FtbWFbM10gKyBiZXRhWzNdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDRdID0gZ2FtbWFbM10gLSBiZXRhWzNdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDVdID0gZ2FtbWFbMl0gLSBiZXRhWzJdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDZdID0gZ2FtbWFbMV0gLSBiZXRhWzFdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDddID0gZ2FtbWFbMF0gLSBiZXRhWzBdO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgY29sdW1uID0gMDsgY29sdW1uIDwgODsgKytjb2x1bW4pIHtcbiAgICAgICAgYWxwaGFbMF0gPSBjICogZGF0YVsxNiArIGNvbHVtbl07XG4gICAgICAgIGFscGhhWzFdID0gZiAqIGRhdGFbMTYgKyBjb2x1bW5dO1xuICAgICAgICBhbHBoYVsyXSA9IGMgKiBkYXRhWzQ4ICsgY29sdW1uXTtcbiAgICAgICAgYWxwaGFbM10gPSBmICogZGF0YVs0OCArIGNvbHVtbl07XG4gICAgICAgIGJldGFbMF0gPSBiICogZGF0YVs4ICsgY29sdW1uXSArIGQgKiBkYXRhWzI0ICsgY29sdW1uXSArIGUgKiBkYXRhWzQwICsgY29sdW1uXSArIGcgKiBkYXRhWzU2ICsgY29sdW1uXTtcbiAgICAgICAgYmV0YVsxXSA9IGQgKiBkYXRhWzggKyBjb2x1bW5dIC0gZyAqIGRhdGFbMjQgKyBjb2x1bW5dIC0gYiAqIGRhdGFbNDAgKyBjb2x1bW5dIC0gZSAqIGRhdGFbNTYgKyBjb2x1bW5dO1xuICAgICAgICBiZXRhWzJdID0gZSAqIGRhdGFbOCArIGNvbHVtbl0gLSBiICogZGF0YVsyNCArIGNvbHVtbl0gKyBnICogZGF0YVs0MCArIGNvbHVtbl0gKyBkICogZGF0YVs1NiArIGNvbHVtbl07XG4gICAgICAgIGJldGFbM10gPSBnICogZGF0YVs4ICsgY29sdW1uXSAtIGUgKiBkYXRhWzI0ICsgY29sdW1uXSArIGQgKiBkYXRhWzQwICsgY29sdW1uXSAtIGIgKiBkYXRhWzU2ICsgY29sdW1uXTtcbiAgICAgICAgdGhldGFbMF0gPSBhICogKGRhdGFbY29sdW1uXSArIGRhdGFbMzIgKyBjb2x1bW5dKTtcbiAgICAgICAgdGhldGFbM10gPSBhICogKGRhdGFbY29sdW1uXSAtIGRhdGFbMzIgKyBjb2x1bW5dKTtcbiAgICAgICAgdGhldGFbMV0gPSBhbHBoYVswXSArIGFscGhhWzNdO1xuICAgICAgICB0aGV0YVsyXSA9IGFscGhhWzFdIC0gYWxwaGFbMl07XG4gICAgICAgIGdhbW1hWzBdID0gdGhldGFbMF0gKyB0aGV0YVsxXTtcbiAgICAgICAgZ2FtbWFbMV0gPSB0aGV0YVszXSArIHRoZXRhWzJdO1xuICAgICAgICBnYW1tYVsyXSA9IHRoZXRhWzNdIC0gdGhldGFbMl07XG4gICAgICAgIGdhbW1hWzNdID0gdGhldGFbMF0gLSB0aGV0YVsxXTtcbiAgICAgICAgZGF0YVswICsgY29sdW1uXSA9IGdhbW1hWzBdICsgYmV0YVswXTtcbiAgICAgICAgZGF0YVs4ICsgY29sdW1uXSA9IGdhbW1hWzFdICsgYmV0YVsxXTtcbiAgICAgICAgZGF0YVsxNiArIGNvbHVtbl0gPSBnYW1tYVsyXSArIGJldGFbMl07XG4gICAgICAgIGRhdGFbMjQgKyBjb2x1bW5dID0gZ2FtbWFbM10gKyBiZXRhWzNdO1xuICAgICAgICBkYXRhWzMyICsgY29sdW1uXSA9IGdhbW1hWzNdIC0gYmV0YVszXTtcbiAgICAgICAgZGF0YVs0MCArIGNvbHVtbl0gPSBnYW1tYVsyXSAtIGJldGFbMl07XG4gICAgICAgIGRhdGFbNDggKyBjb2x1bW5dID0gZ2FtbWFbMV0gLSBiZXRhWzFdO1xuICAgICAgICBkYXRhWzU2ICsgY29sdW1uXSA9IGdhbW1hWzBdIC0gYmV0YVswXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3NjNzA5SW52ZXJzZShkYXRhKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICAgICAgdmFyIHkgPSBkYXRhWzBdW2ldO1xuICAgICAgICB2YXIgY2IgPSBkYXRhWzFdW2ldO1xuICAgICAgICB2YXIgY3IgPSBkYXRhWzJdW2ldO1xuICAgICAgICBkYXRhWzBdW2ldID0geSArIDEuNTc0NyAqIGNyO1xuICAgICAgICBkYXRhWzFdW2ldID0geSAtIDAuMTg3MyAqIGNiIC0gMC40NjgyICogY3I7XG4gICAgICAgIGRhdGFbMl1baV0gPSB5ICsgMS44NTU2ICogY2I7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUb0hhbGYoc3JjLCBkc3QsIGlkeCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICAgIGRzdFtpZHggKyBpXSA9IERhdGFVdGlscy50b0hhbGZGbG9hdCh0b0xpbmVhcihzcmNbaV0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdG9MaW5lYXIoZmxvYXQpIHtcbiAgICAgIGlmIChmbG9hdCA8PSAxKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNpZ24oZmxvYXQpICogTWF0aC5wb3coTWF0aC5hYnMoZmxvYXQpLCAyLjIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc2lnbihmbG9hdCkgKiBNYXRoLnBvdyhsb2dCYXNlLCBNYXRoLmFicyhmbG9hdCkgLSAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jb21wcmVzc1JBVyhpbmZvKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGFWaWV3KGluZm8uYXJyYXkuYnVmZmVyLCBpbmZvLm9mZnNldC52YWx1ZSwgaW5mby5zaXplKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jb21wcmVzc1JMRShpbmZvKSB7XG4gICAgICB2YXIgY29tcHJlc3NlZCA9IGluZm8udmlld2VyLmJ1ZmZlci5zbGljZShpbmZvLm9mZnNldC52YWx1ZSwgaW5mby5vZmZzZXQudmFsdWUgKyBpbmZvLnNpemUpO1xuICAgICAgdmFyIHJhd0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KGRlY29kZVJ1bkxlbmd0aChjb21wcmVzc2VkKSk7XG4gICAgICB2YXIgdG1wQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkocmF3QnVmZmVyLmxlbmd0aCk7XG4gICAgICBwcmVkaWN0b3IocmF3QnVmZmVyKTtcbiAgICAgIGludGVybGVhdmVTY2FsYXIocmF3QnVmZmVyLCB0bXBCdWZmZXIpO1xuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyh0bXBCdWZmZXIuYnVmZmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jb21wcmVzc1pJUChpbmZvKSB7XG4gICAgICB2YXIgY29tcHJlc3NlZCA9IGluZm8uYXJyYXkuc2xpY2UoaW5mby5vZmZzZXQudmFsdWUsIGluZm8ub2Zmc2V0LnZhbHVlICsgaW5mby5zaXplKTtcbiAgICAgIHZhciByYXdCdWZmZXIgPSB1bnpsaWJTeW5jKGNvbXByZXNzZWQpO1xuICAgICAgdmFyIHRtcEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHJhd0J1ZmZlci5sZW5ndGgpO1xuICAgICAgcHJlZGljdG9yKHJhd0J1ZmZlcik7XG4gICAgICBpbnRlcmxlYXZlU2NhbGFyKHJhd0J1ZmZlciwgdG1wQnVmZmVyKTtcbiAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcodG1wQnVmZmVyLmJ1ZmZlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuY29tcHJlc3NQSVooaW5mbykge1xuICAgICAgdmFyIGluRGF0YVZpZXcgPSBpbmZvLnZpZXdlcjtcbiAgICAgIHZhciBpbk9mZnNldCA9IHsgdmFsdWU6IGluZm8ub2Zmc2V0LnZhbHVlIH07XG4gICAgICB2YXIgb3V0QnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KGluZm8ud2lkdGggKiBpbmZvLnNjYW5saW5lQmxvY2tTaXplICogKGluZm8uY2hhbm5lbHMgKiBpbmZvLnR5cGUpKTtcbiAgICAgIHZhciBiaXRtYXAgPSBuZXcgVWludDhBcnJheShCSVRNQVBfU0laRSk7XG4gICAgICB2YXIgb3V0QnVmZmVyRW5kID0gMDtcbiAgICAgIHZhciBwaXpDaGFubmVsRGF0YSA9IG5ldyBBcnJheShpbmZvLmNoYW5uZWxzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5mby5jaGFubmVsczsgaSsrKSB7XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldID0ge307XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldW1wic3RhcnRcIl0gPSBvdXRCdWZmZXJFbmQ7XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldW1wiZW5kXCJdID0gcGl6Q2hhbm5lbERhdGFbaV1bXCJzdGFydFwiXTtcbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV1bXCJueFwiXSA9IGluZm8ud2lkdGg7XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldW1wibnlcIl0gPSBpbmZvLmxpbmVzO1xuICAgICAgICBwaXpDaGFubmVsRGF0YVtpXVtcInNpemVcIl0gPSBpbmZvLnR5cGU7XG4gICAgICAgIG91dEJ1ZmZlckVuZCArPSBwaXpDaGFubmVsRGF0YVtpXS5ueCAqIHBpekNoYW5uZWxEYXRhW2ldLm55ICogcGl6Q2hhbm5lbERhdGFbaV0uc2l6ZTtcbiAgICAgIH1cbiAgICAgIHZhciBtaW5Ob25aZXJvID0gcGFyc2VVaW50MTYoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgdmFyIG1heE5vblplcm8gPSBwYXJzZVVpbnQxNihpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICBpZiAobWF4Tm9uWmVybyA+PSBCSVRNQVBfU0laRSkge1xuICAgICAgICB0aHJvdyBcIlNvbWV0aGluZyBpcyB3cm9uZyB3aXRoIFBJWl9DT01QUkVTU0lPTiBCSVRNQVBfU0laRVwiO1xuICAgICAgfVxuICAgICAgaWYgKG1pbk5vblplcm8gPD0gbWF4Tm9uWmVybykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heE5vblplcm8gLSBtaW5Ob25aZXJvICsgMTsgaSsrKSB7XG4gICAgICAgICAgYml0bWFwW2kgKyBtaW5Ob25aZXJvXSA9IHBhcnNlVWludDgoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbHV0ID0gbmV3IFVpbnQxNkFycmF5KFVTSE9SVF9SQU5HRSk7XG4gICAgICB2YXIgbWF4VmFsdWUgPSByZXZlcnNlTHV0RnJvbUJpdG1hcChiaXRtYXAsIGx1dCk7XG4gICAgICB2YXIgbGVuZ3RoID0gcGFyc2VVaW50MzIoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgaHVmVW5jb21wcmVzcyhpbmZvLmFycmF5LCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbGVuZ3RoLCBvdXRCdWZmZXIsIG91dEJ1ZmZlckVuZCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZm8uY2hhbm5lbHM7ICsraSkge1xuICAgICAgICB2YXIgY2QgPSBwaXpDaGFubmVsRGF0YVtpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwaXpDaGFubmVsRGF0YVtpXS5zaXplOyArK2opIHtcbiAgICAgICAgICB3YXYyRGVjb2RlKG91dEJ1ZmZlciwgY2Quc3RhcnQgKyBqLCBjZC5ueCwgY2Quc2l6ZSwgY2QubnksIGNkLm54ICogY2Quc2l6ZSwgbWF4VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcHBseUx1dChsdXQsIG91dEJ1ZmZlciwgb3V0QnVmZmVyRW5kKTtcbiAgICAgIHZhciB0bXBPZmZzZXQyID0gMDtcbiAgICAgIHZhciB0bXBCdWZmZXIgPSBuZXcgVWludDhBcnJheShvdXRCdWZmZXIuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBpbmZvLmxpbmVzOyB5KyspIHtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBpbmZvLmNoYW5uZWxzOyBjKyspIHtcbiAgICAgICAgICB2YXIgY2QgPSBwaXpDaGFubmVsRGF0YVtjXTtcbiAgICAgICAgICB2YXIgbiA9IGNkLm54ICogY2Quc2l6ZTtcbiAgICAgICAgICB2YXIgY3AgPSBuZXcgVWludDhBcnJheShvdXRCdWZmZXIuYnVmZmVyLCBjZC5lbmQgKiBJTlQxNl9TSVpFLCBuICogSU5UMTZfU0laRSk7XG4gICAgICAgICAgdG1wQnVmZmVyLnNldChjcCwgdG1wT2Zmc2V0Mik7XG4gICAgICAgICAgdG1wT2Zmc2V0MiArPSBuICogSU5UMTZfU0laRTtcbiAgICAgICAgICBjZC5lbmQgKz0gbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyh0bXBCdWZmZXIuYnVmZmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jb21wcmVzc1BYUihpbmZvKSB7XG4gICAgICB2YXIgY29tcHJlc3NlZCA9IGluZm8uYXJyYXkuc2xpY2UoaW5mby5vZmZzZXQudmFsdWUsIGluZm8ub2Zmc2V0LnZhbHVlICsgaW5mby5zaXplKTtcbiAgICAgIHZhciByYXdCdWZmZXIgPSB1bnpsaWJTeW5jKGNvbXByZXNzZWQpO1xuICAgICAgY29uc3Qgc3ogPSBpbmZvLmxpbmVzICogaW5mby5jaGFubmVscyAqIGluZm8ud2lkdGg7XG4gICAgICBjb25zdCB0bXBCdWZmZXIgPSBpbmZvLnR5cGUgPT0gMSA/IG5ldyBVaW50MTZBcnJheShzeikgOiBuZXcgVWludDMyQXJyYXkoc3opO1xuICAgICAgbGV0IHRtcEJ1ZmZlckVuZCA9IDA7XG4gICAgICBsZXQgd3JpdGVQdHIgPSAwO1xuICAgICAgY29uc3QgcHRyID0gbmV3IEFycmF5KDQpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBpbmZvLmxpbmVzOyB5KyspIHtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBpbmZvLmNoYW5uZWxzOyBjKyspIHtcbiAgICAgICAgICBsZXQgcGl4ZWwgPSAwO1xuICAgICAgICAgIHN3aXRjaCAoaW5mby50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHB0clswXSA9IHRtcEJ1ZmZlckVuZDtcbiAgICAgICAgICAgICAgcHRyWzFdID0gcHRyWzBdICsgaW5mby53aWR0aDtcbiAgICAgICAgICAgICAgdG1wQnVmZmVyRW5kID0gcHRyWzFdICsgaW5mby53aWR0aDtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmZvLndpZHRoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gcmF3QnVmZmVyW3B0clswXSsrXSA8PCA4IHwgcmF3QnVmZmVyW3B0clsxXSsrXTtcbiAgICAgICAgICAgICAgICBwaXhlbCArPSBkaWZmO1xuICAgICAgICAgICAgICAgIHRtcEJ1ZmZlclt3cml0ZVB0cl0gPSBwaXhlbDtcbiAgICAgICAgICAgICAgICB3cml0ZVB0cisrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBwdHJbMF0gPSB0bXBCdWZmZXJFbmQ7XG4gICAgICAgICAgICAgIHB0clsxXSA9IHB0clswXSArIGluZm8ud2lkdGg7XG4gICAgICAgICAgICAgIHB0clsyXSA9IHB0clsxXSArIGluZm8ud2lkdGg7XG4gICAgICAgICAgICAgIHRtcEJ1ZmZlckVuZCA9IHB0clsyXSArIGluZm8ud2lkdGg7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5mby53aWR0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZiA9IHJhd0J1ZmZlcltwdHJbMF0rK10gPDwgMjQgfCByYXdCdWZmZXJbcHRyWzFdKytdIDw8IDE2IHwgcmF3QnVmZmVyW3B0clsyXSsrXSA8PCA4O1xuICAgICAgICAgICAgICAgIHBpeGVsICs9IGRpZmY7XG4gICAgICAgICAgICAgICAgdG1wQnVmZmVyW3dyaXRlUHRyXSA9IHBpeGVsO1xuICAgICAgICAgICAgICAgIHdyaXRlUHRyKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IERhdGFWaWV3KHRtcEJ1ZmZlci5idWZmZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bmNvbXByZXNzRFdBKGluZm8pIHtcbiAgICAgIHZhciBpbkRhdGFWaWV3ID0gaW5mby52aWV3ZXI7XG4gICAgICB2YXIgaW5PZmZzZXQgPSB7IHZhbHVlOiBpbmZvLm9mZnNldC52YWx1ZSB9O1xuICAgICAgdmFyIG91dEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGluZm8ud2lkdGggKiBpbmZvLmxpbmVzICogKGluZm8uY2hhbm5lbHMgKiBpbmZvLnR5cGUgKiBJTlQxNl9TSVpFKSk7XG4gICAgICB2YXIgZHdhSGVhZGVyID0ge1xuICAgICAgICB2ZXJzaW9uOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgdW5rbm93blVuY29tcHJlc3NlZFNpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICB1bmtub3duQ29tcHJlc3NlZFNpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICBhY0NvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgZGNDb21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHJsZUNvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgcmxlVW5jb21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHJsZVJhd1NpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICB0b3RhbEFjVW5jb21wcmVzc2VkQ291bnQ6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICB0b3RhbERjVW5jb21wcmVzc2VkQ291bnQ6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICBhY0NvbXByZXNzaW9uOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KVxuICAgICAgfTtcbiAgICAgIGlmIChkd2FIZWFkZXIudmVyc2lvbiA8IDIpIHtcbiAgICAgICAgdGhyb3cgXCJFWFJMb2FkZXIucGFyc2U6IFwiICsgRVhSSGVhZGVyLmNvbXByZXNzaW9uICsgXCIgdmVyc2lvbiBcIiArIGR3YUhlYWRlci52ZXJzaW9uICsgXCIgaXMgdW5zdXBwb3J0ZWRcIjtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFubmVsUnVsZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgIHZhciBydWxlU2l6ZSA9IHBhcnNlVWludDE2KGluRGF0YVZpZXcsIGluT2Zmc2V0KSAtIElOVDE2X1NJWkU7XG4gICAgICB3aGlsZSAocnVsZVNpemUgPiAwKSB7XG4gICAgICAgIHZhciBuYW1lID0gcGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyhpbkRhdGFWaWV3LmJ1ZmZlciwgaW5PZmZzZXQpO1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZVVpbnQ4KGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uID0gdmFsdWUgPj4gMiAmIDM7XG4gICAgICAgIHZhciBjc2MgPSAodmFsdWUgPj4gNCkgLSAxO1xuICAgICAgICB2YXIgaW5kZXggPSBuZXcgSW50OEFycmF5KFtjc2NdKVswXTtcbiAgICAgICAgdmFyIHR5cGUgPSBwYXJzZVVpbnQ4KGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgICAgY2hhbm5lbFJ1bGVzLnB1c2goe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBjb21wcmVzc2lvblxuICAgICAgICB9KTtcbiAgICAgICAgcnVsZVNpemUgLT0gbmFtZS5sZW5ndGggKyAzO1xuICAgICAgfVxuICAgICAgdmFyIGNoYW5uZWxzID0gRVhSSGVhZGVyLmNoYW5uZWxzO1xuICAgICAgdmFyIGNoYW5uZWxEYXRhID0gbmV3IEFycmF5KGluZm8uY2hhbm5lbHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmZvLmNoYW5uZWxzOyArK2kpIHtcbiAgICAgICAgdmFyIGNkID0gY2hhbm5lbERhdGFbaV0gPSB7fTtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBjaGFubmVsc1tpXTtcbiAgICAgICAgY2QubmFtZSA9IGNoYW5uZWwubmFtZTtcbiAgICAgICAgY2QuY29tcHJlc3Npb24gPSBVTktOT1dOO1xuICAgICAgICBjZC5kZWNvZGVkID0gZmFsc2U7XG4gICAgICAgIGNkLnR5cGUgPSBjaGFubmVsLnBpeGVsVHlwZTtcbiAgICAgICAgY2QucExpbmVhciA9IGNoYW5uZWwucExpbmVhcjtcbiAgICAgICAgY2Qud2lkdGggPSBpbmZvLndpZHRoO1xuICAgICAgICBjZC5oZWlnaHQgPSBpbmZvLmxpbmVzO1xuICAgICAgfVxuICAgICAgdmFyIGNzY1NldCA9IHtcbiAgICAgICAgaWR4OiBuZXcgQXJyYXkoMylcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBvZmZzZXQyID0gMDsgb2Zmc2V0MiA8IGluZm8uY2hhbm5lbHM7ICsrb2Zmc2V0Mikge1xuICAgICAgICB2YXIgY2QgPSBjaGFubmVsRGF0YVtvZmZzZXQyXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFubmVsUnVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgcnVsZSA9IGNoYW5uZWxSdWxlc1tpXTtcbiAgICAgICAgICBpZiAoY2QubmFtZSA9PSBydWxlLm5hbWUpIHtcbiAgICAgICAgICAgIGNkLmNvbXByZXNzaW9uID0gcnVsZS5jb21wcmVzc2lvbjtcbiAgICAgICAgICAgIGlmIChydWxlLmluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgY3NjU2V0LmlkeFtydWxlLmluZGV4XSA9IG9mZnNldDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZC5vZmZzZXQgPSBvZmZzZXQyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGR3YUhlYWRlci5hY0NvbXByZXNzZWRTaXplID4gMCkge1xuICAgICAgICBzd2l0Y2ggKGR3YUhlYWRlci5hY0NvbXByZXNzaW9uKSB7XG4gICAgICAgICAgY2FzZSBTVEFUSUNfSFVGRk1BTjpcbiAgICAgICAgICAgIHZhciBhY0J1ZmZlciA9IG5ldyBVaW50MTZBcnJheShkd2FIZWFkZXIudG90YWxBY1VuY29tcHJlc3NlZENvdW50KTtcbiAgICAgICAgICAgIGh1ZlVuY29tcHJlc3MoXG4gICAgICAgICAgICAgIGluZm8uYXJyYXksXG4gICAgICAgICAgICAgIGluRGF0YVZpZXcsXG4gICAgICAgICAgICAgIGluT2Zmc2V0LFxuICAgICAgICAgICAgICBkd2FIZWFkZXIuYWNDb21wcmVzc2VkU2l6ZSxcbiAgICAgICAgICAgICAgYWNCdWZmZXIsXG4gICAgICAgICAgICAgIGR3YUhlYWRlci50b3RhbEFjVW5jb21wcmVzc2VkQ291bnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIERFRkxBVEU6XG4gICAgICAgICAgICB2YXIgY29tcHJlc3NlZCA9IGluZm8uYXJyYXkuc2xpY2UoaW5PZmZzZXQudmFsdWUsIGluT2Zmc2V0LnZhbHVlICsgZHdhSGVhZGVyLnRvdGFsQWNVbmNvbXByZXNzZWRDb3VudCk7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHVuemxpYlN5bmMoY29tcHJlc3NlZCk7XG4gICAgICAgICAgICB2YXIgYWNCdWZmZXIgPSBuZXcgVWludDE2QXJyYXkoZGF0YS5idWZmZXIpO1xuICAgICAgICAgICAgaW5PZmZzZXQudmFsdWUgKz0gZHdhSGVhZGVyLnRvdGFsQWNVbmNvbXByZXNzZWRDb3VudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZHdhSGVhZGVyLmRjQ29tcHJlc3NlZFNpemUgPiAwKSB7XG4gICAgICAgIHZhciB6bGliSW5mbyA9IHtcbiAgICAgICAgICBhcnJheTogaW5mby5hcnJheSxcbiAgICAgICAgICBvZmZzZXQ6IGluT2Zmc2V0LFxuICAgICAgICAgIHNpemU6IGR3YUhlYWRlci5kY0NvbXByZXNzZWRTaXplXG4gICAgICAgIH07XG4gICAgICAgIHZhciBkY0J1ZmZlciA9IG5ldyBVaW50MTZBcnJheSh1bmNvbXByZXNzWklQKHpsaWJJbmZvKS5idWZmZXIpO1xuICAgICAgICBpbk9mZnNldC52YWx1ZSArPSBkd2FIZWFkZXIuZGNDb21wcmVzc2VkU2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkd2FIZWFkZXIucmxlUmF3U2l6ZSA+IDApIHtcbiAgICAgICAgdmFyIGNvbXByZXNzZWQgPSBpbmZvLmFycmF5LnNsaWNlKGluT2Zmc2V0LnZhbHVlLCBpbk9mZnNldC52YWx1ZSArIGR3YUhlYWRlci5ybGVDb21wcmVzc2VkU2l6ZSk7XG4gICAgICAgIHZhciBkYXRhID0gdW56bGliU3luYyhjb21wcmVzc2VkKTtcbiAgICAgICAgdmFyIHJsZUJ1ZmZlciA9IGRlY29kZVJ1bkxlbmd0aChkYXRhLmJ1ZmZlcik7XG4gICAgICAgIGluT2Zmc2V0LnZhbHVlICs9IGR3YUhlYWRlci5ybGVDb21wcmVzc2VkU2l6ZTtcbiAgICAgIH1cbiAgICAgIHZhciBvdXRCdWZmZXJFbmQgPSAwO1xuICAgICAgdmFyIHJvd09mZnNldHMgPSBuZXcgQXJyYXkoY2hhbm5lbERhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93T2Zmc2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICByb3dPZmZzZXRzW2ldID0gbmV3IEFycmF5KCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGluZm8ubGluZXM7ICsreSkge1xuICAgICAgICBmb3IgKHZhciBjaGFuID0gMDsgY2hhbiA8IGNoYW5uZWxEYXRhLmxlbmd0aDsgKytjaGFuKSB7XG4gICAgICAgICAgcm93T2Zmc2V0c1tjaGFuXS5wdXNoKG91dEJ1ZmZlckVuZCk7XG4gICAgICAgICAgb3V0QnVmZmVyRW5kICs9IGNoYW5uZWxEYXRhW2NoYW5dLndpZHRoICogaW5mby50eXBlICogSU5UMTZfU0laRTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbG9zc3lEY3REZWNvZGUoY3NjU2V0LCByb3dPZmZzZXRzLCBjaGFubmVsRGF0YSwgYWNCdWZmZXIsIGRjQnVmZmVyLCBvdXRCdWZmZXIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFubmVsRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY2QgPSBjaGFubmVsRGF0YVtpXTtcbiAgICAgICAgaWYgKGNkLmRlY29kZWQpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHN3aXRjaCAoY2QuY29tcHJlc3Npb24pIHtcbiAgICAgICAgICBjYXNlIFJMRTpcbiAgICAgICAgICAgIHZhciByb3cgPSAwO1xuICAgICAgICAgICAgdmFyIHJsZU9mZnNldCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGluZm8ubGluZXM7ICsreSkge1xuICAgICAgICAgICAgICB2YXIgcm93T2Zmc2V0Qnl0ZXMgPSByb3dPZmZzZXRzW2ldW3Jvd107XG4gICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgY2Qud2lkdGg7ICsreCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGJ5dGUgPSAwOyBieXRlIDwgSU5UMTZfU0laRSAqIGNkLnR5cGU7ICsrYnl0ZSkge1xuICAgICAgICAgICAgICAgICAgb3V0QnVmZmVyW3Jvd09mZnNldEJ5dGVzKytdID0gcmxlQnVmZmVyW3JsZU9mZnNldCArIGJ5dGUgKiBjZC53aWR0aCAqIGNkLmhlaWdodF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJsZU9mZnNldCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJvdysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBMT1NTWV9EQ1Q6XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IFwiRVhSTG9hZGVyLnBhcnNlOiB1bnN1cHBvcnRlZCBjaGFubmVsIGNvbXByZXNzaW9uXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcob3V0QnVmZmVyLmJ1ZmZlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmcoYnVmZmVyMiwgb2Zmc2V0Mikge1xuICAgICAgdmFyIHVpbnRCdWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIyKTtcbiAgICAgIHZhciBlbmRPZmZzZXQgPSAwO1xuICAgICAgd2hpbGUgKHVpbnRCdWZmZXJbb2Zmc2V0Mi52YWx1ZSArIGVuZE9mZnNldF0gIT0gMCkge1xuICAgICAgICBlbmRPZmZzZXQgKz0gMTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh1aW50QnVmZmVyLnNsaWNlKG9mZnNldDIudmFsdWUsIG9mZnNldDIudmFsdWUgKyBlbmRPZmZzZXQpKTtcbiAgICAgIG9mZnNldDIudmFsdWUgPSBvZmZzZXQyLnZhbHVlICsgZW5kT2Zmc2V0ICsgMTtcbiAgICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VGaXhlZExlbmd0aFN0cmluZyhidWZmZXIyLCBvZmZzZXQyLCBzaXplKSB7XG4gICAgICB2YXIgc3RyaW5nVmFsdWUgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyMikuc2xpY2Uob2Zmc2V0Mi52YWx1ZSwgb2Zmc2V0Mi52YWx1ZSArIHNpemUpKTtcbiAgICAgIG9mZnNldDIudmFsdWUgPSBvZmZzZXQyLnZhbHVlICsgc2l6ZTtcbiAgICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VSYXRpb25hbChkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIHggPSBwYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB5ID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VUaW1lY29kZShkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIHggPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgeSA9IHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlSW50MzIoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciBJbnQzMiA9IGRhdGFWaWV3LmdldEludDMyKG9mZnNldDIudmFsdWUsIHRydWUpO1xuICAgICAgb2Zmc2V0Mi52YWx1ZSA9IG9mZnNldDIudmFsdWUgKyBJTlQzMl9TSVpFO1xuICAgICAgcmV0dXJuIEludDMyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIFVpbnQzMiA9IGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQyLnZhbHVlLCB0cnVlKTtcbiAgICAgIG9mZnNldDIudmFsdWUgPSBvZmZzZXQyLnZhbHVlICsgSU5UMzJfU0laRTtcbiAgICAgIHJldHVybiBVaW50MzI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVWludDhBcnJheSh1SW50OEFycmF5Miwgb2Zmc2V0Mikge1xuICAgICAgdmFyIFVpbnQ4ID0gdUludDhBcnJheTJbb2Zmc2V0Mi52YWx1ZV07XG4gICAgICBvZmZzZXQyLnZhbHVlID0gb2Zmc2V0Mi52YWx1ZSArIElOVDhfU0laRTtcbiAgICAgIHJldHVybiBVaW50ODtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VVaW50OChkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIFVpbnQ4ID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0Mi52YWx1ZSk7XG4gICAgICBvZmZzZXQyLnZhbHVlID0gb2Zmc2V0Mi52YWx1ZSArIElOVDhfU0laRTtcbiAgICAgIHJldHVybiBVaW50ODtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VJbnQ2NCA9IGZ1bmN0aW9uKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICBsZXQgaW50O1xuICAgICAgaWYgKFwiZ2V0QmlnSW50NjRcIiBpbiBEYXRhVmlldy5wcm90b3R5cGUpIHtcbiAgICAgICAgaW50ID0gTnVtYmVyKGRhdGFWaWV3LmdldEJpZ0ludDY0KG9mZnNldDIudmFsdWUsIHRydWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludCA9IGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQyLnZhbHVlICsgNCwgdHJ1ZSkgKyBOdW1iZXIoZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldDIudmFsdWUsIHRydWUpIDw8IDMyKTtcbiAgICAgIH1cbiAgICAgIG9mZnNldDIudmFsdWUgKz0gVUxPTkdfU0laRTtcbiAgICAgIHJldHVybiBpbnQ7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciBmbG9hdCA9IGRhdGFWaWV3LmdldEZsb2F0MzIob2Zmc2V0Mi52YWx1ZSwgdHJ1ZSk7XG4gICAgICBvZmZzZXQyLnZhbHVlICs9IEZMT0FUMzJfU0laRTtcbiAgICAgIHJldHVybiBmbG9hdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgcmV0dXJuIERhdGFVdGlscy50b0hhbGZGbG9hdChwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlRmxvYXQxNihiaW5hcnkpIHtcbiAgICAgIHZhciBleHBvbmVudCA9IChiaW5hcnkgJiAzMTc0NCkgPj4gMTAsIGZyYWN0aW9uID0gYmluYXJ5ICYgMTAyMztcbiAgICAgIHJldHVybiAoYmluYXJ5ID4+IDE1ID8gLTEgOiAxKSAqIChleHBvbmVudCA/IGV4cG9uZW50ID09PSAzMSA/IGZyYWN0aW9uID8gTmFOIDogSW5maW5pdHkgOiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDE1KSAqICgxICsgZnJhY3Rpb24gLyAxMDI0KSA6IDYxMDM1MTU2MjVlLTE0ICogKGZyYWN0aW9uIC8gMTAyNCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVVpbnQxNihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIFVpbnQxNiA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQyLnZhbHVlLCB0cnVlKTtcbiAgICAgIG9mZnNldDIudmFsdWUgKz0gSU5UMTZfU0laRTtcbiAgICAgIHJldHVybiBVaW50MTY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlRmxvYXQxNihidWZmZXIyLCBvZmZzZXQyKSB7XG4gICAgICByZXR1cm4gZGVjb2RlRmxvYXQxNihwYXJzZVVpbnQxNihidWZmZXIyLCBvZmZzZXQyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQ2hsaXN0KGRhdGFWaWV3LCBidWZmZXIyLCBvZmZzZXQyLCBzaXplKSB7XG4gICAgICB2YXIgc3RhcnRPZmZzZXQgPSBvZmZzZXQyLnZhbHVlO1xuICAgICAgdmFyIGNoYW5uZWxzID0gW107XG4gICAgICB3aGlsZSAob2Zmc2V0Mi52YWx1ZSA8IHN0YXJ0T2Zmc2V0ICsgc2l6ZSAtIDEpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBwYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKGJ1ZmZlcjIsIG9mZnNldDIpO1xuICAgICAgICB2YXIgcGl4ZWxUeXBlID0gcGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICAgIHZhciBwTGluZWFyID0gcGFyc2VVaW50OChkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICAgIG9mZnNldDIudmFsdWUgKz0gMztcbiAgICAgICAgdmFyIHhTYW1wbGluZyA9IHBhcnNlSW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgICB2YXIgeVNhbXBsaW5nID0gcGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICAgIGNoYW5uZWxzLnB1c2goe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgcGl4ZWxUeXBlLFxuICAgICAgICAgIHBMaW5lYXIsXG4gICAgICAgICAgeFNhbXBsaW5nLFxuICAgICAgICAgIHlTYW1wbGluZ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG9mZnNldDIudmFsdWUgKz0gMTtcbiAgICAgIHJldHVybiBjaGFubmVscztcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VDaHJvbWF0aWNpdGllcyhkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIHJlZFggPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHJlZFkgPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIGdyZWVuWCA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgZ3JlZW5ZID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciBibHVlWCA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgYmx1ZVkgPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHdoaXRlWCA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgd2hpdGVZID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZFgsXG4gICAgICAgIHJlZFksXG4gICAgICAgIGdyZWVuWCxcbiAgICAgICAgZ3JlZW5ZLFxuICAgICAgICBibHVlWCxcbiAgICAgICAgYmx1ZVksXG4gICAgICAgIHdoaXRlWCxcbiAgICAgICAgd2hpdGVZXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUNvbXByZXNzaW9uKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgY29tcHJlc3Npb25Db2RlcyA9IFtcbiAgICAgICAgXCJOT19DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIlJMRV9DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIlpJUFNfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJaSVBfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJQSVpfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJQWFIyNF9DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIkI0NF9DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIkI0NEFfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJEV0FBX0NPTVBSRVNTSU9OXCIsXG4gICAgICAgIFwiRFdBQl9DT01QUkVTU0lPTlwiXG4gICAgICBdO1xuICAgICAgdmFyIGNvbXByZXNzaW9uID0gcGFyc2VVaW50OChkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICByZXR1cm4gY29tcHJlc3Npb25Db2Rlc1tjb21wcmVzc2lvbl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQm94MmkoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciB4TWluID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHlNaW4gPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgeE1heCA9IHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB5TWF4ID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIHsgeE1pbiwgeU1pbiwgeE1heCwgeU1heCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUxpbmVPcmRlcihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIGxpbmVPcmRlcnMgPSBbXCJJTkNSRUFTSU5HX1lcIl07XG4gICAgICB2YXIgbGluZU9yZGVyID0gcGFyc2VVaW50OChkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICByZXR1cm4gbGluZU9yZGVyc1tsaW5lT3JkZXJdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVYyZihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIHggPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHkgPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VWM2YoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciB4ID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB5ID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB6ID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiBbeCwgeSwgel07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVmFsdWUoZGF0YVZpZXcsIGJ1ZmZlcjIsIG9mZnNldDIsIHR5cGUsIHNpemUpIHtcbiAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwic3RyaW5ndmVjdG9yXCIgfHwgdHlwZSA9PT0gXCJpY2NQcm9maWxlXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRml4ZWRMZW5ndGhTdHJpbmcoYnVmZmVyMiwgb2Zmc2V0Miwgc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY2hsaXN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQ2hsaXN0KGRhdGFWaWV3LCBidWZmZXIyLCBvZmZzZXQyLCBzaXplKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjaHJvbWF0aWNpdGllc1wiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUNocm9tYXRpY2l0aWVzKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjb21wcmVzc2lvblwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUNvbXByZXNzaW9uKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJib3gyaVwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUJveDJpKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJsaW5lT3JkZXJcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VMaW5lT3JkZXIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImZsb2F0XCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwidjJmXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVjJmKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ2M2ZcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VWM2YoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImludFwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJyYXRpb25hbFwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVJhdGlvbmFsKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ0aW1lY29kZVwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVRpbWVjb2RlKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJwcmV2aWV3XCIpIHtcbiAgICAgICAgb2Zmc2V0Mi52YWx1ZSArPSBzaXplO1xuICAgICAgICByZXR1cm4gXCJza2lwcGVkXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQyLnZhbHVlICs9IHNpemU7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlSGVhZGVyKGRhdGFWaWV3LCBidWZmZXIyLCBvZmZzZXQyKSB7XG4gICAgICBjb25zdCBFWFJIZWFkZXIyID0ge307XG4gICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDMyKDAsIHRydWUpICE9IDIwMDAwNjMwKSB7XG4gICAgICAgIHRocm93IFwiVEhSRUUuRVhSTG9hZGVyOiBwcm92aWRlZCBmaWxlIGRvZXNuJ3QgYXBwZWFyIHRvIGJlIGluIE9wZW5FWFIgZm9ybWF0LlwiO1xuICAgICAgfVxuICAgICAgRVhSSGVhZGVyMi52ZXJzaW9uID0gZGF0YVZpZXcuZ2V0VWludDgoNCk7XG4gICAgICBjb25zdCBzcGVjID0gZGF0YVZpZXcuZ2V0VWludDgoNSk7XG4gICAgICBFWFJIZWFkZXIyLnNwZWMgPSB7XG4gICAgICAgIHNpbmdsZVRpbGU6ICEhKHNwZWMgJiAyKSxcbiAgICAgICAgbG9uZ05hbWU6ICEhKHNwZWMgJiA0KSxcbiAgICAgICAgZGVlcEZvcm1hdDogISEoc3BlYyAmIDgpLFxuICAgICAgICBtdWx0aVBhcnQ6ICEhKHNwZWMgJiAxNilcbiAgICAgIH07XG4gICAgICBvZmZzZXQyLnZhbHVlID0gODtcbiAgICAgIHZhciBrZWVwUmVhZGluZyA9IHRydWU7XG4gICAgICB3aGlsZSAoa2VlcFJlYWRpbmcpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKGJ1ZmZlcjIsIG9mZnNldDIpO1xuICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PSAwKSB7XG4gICAgICAgICAga2VlcFJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlVHlwZSA9IHBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmcoYnVmZmVyMiwgb2Zmc2V0Mik7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZVNpemUgPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZVZhbHVlID0gcGFyc2VWYWx1ZShkYXRhVmlldywgYnVmZmVyMiwgb2Zmc2V0MiwgYXR0cmlidXRlVHlwZSwgYXR0cmlidXRlU2l6ZSk7XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZVZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRVhSTG9hZGVyLnBhcnNlOiBza2lwcGVkIHVua25vd24gaGVhZGVyIGF0dHJpYnV0ZSB0eXBlICcke2F0dHJpYnV0ZVR5cGV9Jy5gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgRVhSSGVhZGVyMlthdHRyaWJ1dGVOYW1lXSA9IGF0dHJpYnV0ZVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKChzcGVjICYgfjQpICE9IDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVYUkhlYWRlcjpcIiwgRVhSSGVhZGVyMik7XG4gICAgICAgIHRocm93IFwiVEhSRUUuRVhSTG9hZGVyOiBwcm92aWRlZCBmaWxlIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC5cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBFWFJIZWFkZXIyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXR1cERlY29kZXIoRVhSSGVhZGVyMiwgZGF0YVZpZXcsIHVJbnQ4QXJyYXkyLCBvZmZzZXQyLCBvdXRwdXRUeXBlKSB7XG4gICAgICBjb25zdCBFWFJEZWNvZGVyMiA9IHtcbiAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgdmlld2VyOiBkYXRhVmlldyxcbiAgICAgICAgYXJyYXk6IHVJbnQ4QXJyYXkyLFxuICAgICAgICBvZmZzZXQ6IG9mZnNldDIsXG4gICAgICAgIHdpZHRoOiBFWFJIZWFkZXIyLmRhdGFXaW5kb3cueE1heCAtIEVYUkhlYWRlcjIuZGF0YVdpbmRvdy54TWluICsgMSxcbiAgICAgICAgaGVpZ2h0OiBFWFJIZWFkZXIyLmRhdGFXaW5kb3cueU1heCAtIEVYUkhlYWRlcjIuZGF0YVdpbmRvdy55TWluICsgMSxcbiAgICAgICAgY2hhbm5lbHM6IEVYUkhlYWRlcjIuY2hhbm5lbHMubGVuZ3RoLFxuICAgICAgICBieXRlc1BlckxpbmU6IG51bGwsXG4gICAgICAgIGxpbmVzOiBudWxsLFxuICAgICAgICBpbnB1dFNpemU6IG51bGwsXG4gICAgICAgIHR5cGU6IEVYUkhlYWRlcjIuY2hhbm5lbHNbMF0ucGl4ZWxUeXBlLFxuICAgICAgICB1bmNvbXByZXNzOiBudWxsLFxuICAgICAgICBnZXR0ZXI6IG51bGwsXG4gICAgICAgIGZvcm1hdDogbnVsbCxcbiAgICAgICAgW2hhc0NvbG9yU3BhY2UgPyBcImNvbG9yU3BhY2VcIiA6IFwiZW5jb2RpbmdcIl06IG51bGxcbiAgICAgIH07XG4gICAgICBzd2l0Y2ggKEVYUkhlYWRlcjIuY29tcHJlc3Npb24pIHtcbiAgICAgICAgY2FzZSBcIk5PX0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAxO1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzUkFXO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUkxFX0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAxO1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzUkxFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiWklQU19DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMTtcbiAgICAgICAgICBFWFJEZWNvZGVyMi51bmNvbXByZXNzID0gdW5jb21wcmVzc1pJUDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlpJUF9DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMTY7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NaSVA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJQSVpfQ09NUFJFU1NJT05cIjpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5saW5lcyA9IDMyO1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzUElaO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUFhSMjRfQ09NUFJFU1NJT05cIjpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5saW5lcyA9IDE2O1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzUFhSO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRFdBQV9DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMzI7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NEV0E7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJEV0FCX0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAyNTY7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NEV0E7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgXCJFWFJMb2FkZXIucGFyc2U6IFwiICsgRVhSSGVhZGVyMi5jb21wcmVzc2lvbiArIFwiIGlzIHVuc3VwcG9ydGVkXCI7XG4gICAgICB9XG4gICAgICBFWFJEZWNvZGVyMi5zY2FubGluZUJsb2NrU2l6ZSA9IEVYUkRlY29kZXIyLmxpbmVzO1xuICAgICAgaWYgKEVYUkRlY29kZXIyLnR5cGUgPT0gMSkge1xuICAgICAgICBzd2l0Y2ggKG91dHB1dFR5cGUpIHtcbiAgICAgICAgICBjYXNlIEZsb2F0VHlwZTpcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmdldHRlciA9IHBhcnNlRmxvYXQxNjtcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmlucHV0U2l6ZSA9IElOVDE2X1NJWkU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5nZXR0ZXIgPSBwYXJzZVVpbnQxNjtcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmlucHV0U2l6ZSA9IElOVDE2X1NJWkU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChFWFJEZWNvZGVyMi50eXBlID09IDIpIHtcbiAgICAgICAgc3dpdGNoIChvdXRwdXRUeXBlKSB7XG4gICAgICAgICAgY2FzZSBGbG9hdFR5cGU6XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5nZXR0ZXIgPSBwYXJzZUZsb2F0MzI7XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5pbnB1dFNpemUgPSBGTE9BVDMyX1NJWkU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5nZXR0ZXIgPSBkZWNvZGVGbG9hdDMyO1xuICAgICAgICAgICAgRVhSRGVjb2RlcjIuaW5wdXRTaXplID0gRkxPQVQzMl9TSVpFO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBcIkVYUkxvYWRlci5wYXJzZTogdW5zdXBwb3J0ZWQgcGl4ZWxUeXBlIFwiICsgRVhSRGVjb2RlcjIudHlwZSArIFwiIGZvciBcIiArIEVYUkhlYWRlcjIuY29tcHJlc3Npb24gKyBcIi5cIjtcbiAgICAgIH1cbiAgICAgIEVYUkRlY29kZXIyLmJsb2NrQ291bnQgPSAoRVhSSGVhZGVyMi5kYXRhV2luZG93LnlNYXggKyAxKSAvIEVYUkRlY29kZXIyLnNjYW5saW5lQmxvY2tTaXplO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBFWFJEZWNvZGVyMi5ibG9ja0NvdW50OyBpKyspXG4gICAgICAgIHBhcnNlSW50NjQoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgRVhSRGVjb2RlcjIub3V0cHV0Q2hhbm5lbHMgPSBFWFJEZWNvZGVyMi5jaGFubmVscyA9PSAzID8gNCA6IEVYUkRlY29kZXIyLmNoYW5uZWxzO1xuICAgICAgY29uc3Qgc2l6ZSA9IEVYUkRlY29kZXIyLndpZHRoICogRVhSRGVjb2RlcjIuaGVpZ2h0ICogRVhSRGVjb2RlcjIub3V0cHV0Q2hhbm5lbHM7XG4gICAgICBzd2l0Y2ggKG91dHB1dFR5cGUpIHtcbiAgICAgICAgY2FzZSBGbG9hdFR5cGU6XG4gICAgICAgICAgRVhSRGVjb2RlcjIuYnl0ZUFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICAgICAgICBpZiAoRVhSRGVjb2RlcjIuY2hhbm5lbHMgPCBFWFJEZWNvZGVyMi5vdXRwdXRDaGFubmVscylcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmJ5dGVBcnJheS5maWxsKDEsIDAsIHNpemUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgRVhSRGVjb2RlcjIuYnl0ZUFycmF5ID0gbmV3IFVpbnQxNkFycmF5KHNpemUpO1xuICAgICAgICAgIGlmIChFWFJEZWNvZGVyMi5jaGFubmVscyA8IEVYUkRlY29kZXIyLm91dHB1dENoYW5uZWxzKVxuICAgICAgICAgICAgRVhSRGVjb2RlcjIuYnl0ZUFycmF5LmZpbGwoMTUzNjAsIDAsIHNpemUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5FWFJMb2FkZXI6IHVuc3VwcG9ydGVkIHR5cGU6IFwiLCBvdXRwdXRUeXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIEVYUkRlY29kZXIyLmJ5dGVzUGVyTGluZSA9IEVYUkRlY29kZXIyLndpZHRoICogRVhSRGVjb2RlcjIuaW5wdXRTaXplICogRVhSRGVjb2RlcjIuY2hhbm5lbHM7XG4gICAgICBpZiAoRVhSRGVjb2RlcjIub3V0cHV0Q2hhbm5lbHMgPT0gNClcbiAgICAgICAgRVhSRGVjb2RlcjIuZm9ybWF0ID0gUkdCQUZvcm1hdDtcbiAgICAgIGVsc2VcbiAgICAgICAgRVhSRGVjb2RlcjIuZm9ybWF0ID0gUmVkRm9ybWF0O1xuICAgICAgaWYgKGhhc0NvbG9yU3BhY2UpXG4gICAgICAgIEVYUkRlY29kZXIyLmNvbG9yU3BhY2UgPSBcInNyZ2ItbGluZWFyXCI7XG4gICAgICBlbHNlXG4gICAgICAgIEVYUkRlY29kZXIyLmVuY29kaW5nID0gM2UzO1xuICAgICAgcmV0dXJuIEVYUkRlY29kZXIyO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJEYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGNvbnN0IHVJbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGNvbnN0IG9mZnNldCA9IHsgdmFsdWU6IDAgfTtcbiAgICBjb25zdCBFWFJIZWFkZXIgPSBwYXJzZUhlYWRlcihidWZmZXJEYXRhVmlldywgYnVmZmVyLCBvZmZzZXQpO1xuICAgIGNvbnN0IEVYUkRlY29kZXIgPSBzZXR1cERlY29kZXIoRVhSSGVhZGVyLCBidWZmZXJEYXRhVmlldywgdUludDhBcnJheSwgb2Zmc2V0LCB0aGlzLnR5cGUpO1xuICAgIGNvbnN0IHRtcE9mZnNldCA9IHsgdmFsdWU6IDAgfTtcbiAgICBjb25zdCBjaGFubmVsT2Zmc2V0cyA9IHsgUjogMCwgRzogMSwgQjogMiwgQTogMywgWTogMCB9O1xuICAgIGZvciAobGV0IHNjYW5saW5lQmxvY2tJZHggPSAwOyBzY2FubGluZUJsb2NrSWR4IDwgRVhSRGVjb2Rlci5oZWlnaHQgLyBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplOyBzY2FubGluZUJsb2NrSWR4KyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBwYXJzZVVpbnQzMihidWZmZXJEYXRhVmlldywgb2Zmc2V0KTtcbiAgICAgIEVYUkRlY29kZXIuc2l6ZSA9IHBhcnNlVWludDMyKGJ1ZmZlckRhdGFWaWV3LCBvZmZzZXQpO1xuICAgICAgRVhSRGVjb2Rlci5saW5lcyA9IGxpbmUgKyBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplID4gRVhSRGVjb2Rlci5oZWlnaHQgPyBFWFJEZWNvZGVyLmhlaWdodCAtIGxpbmUgOiBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplO1xuICAgICAgY29uc3QgaXNDb21wcmVzc2VkID0gRVhSRGVjb2Rlci5zaXplIDwgRVhSRGVjb2Rlci5saW5lcyAqIEVYUkRlY29kZXIuYnl0ZXNQZXJMaW5lO1xuICAgICAgY29uc3Qgdmlld2VyID0gaXNDb21wcmVzc2VkID8gRVhSRGVjb2Rlci51bmNvbXByZXNzKEVYUkRlY29kZXIpIDogdW5jb21wcmVzc1JBVyhFWFJEZWNvZGVyKTtcbiAgICAgIG9mZnNldC52YWx1ZSArPSBFWFJEZWNvZGVyLnNpemU7XG4gICAgICBmb3IgKGxldCBsaW5lX3kgPSAwOyBsaW5lX3kgPCBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplOyBsaW5lX3krKykge1xuICAgICAgICBjb25zdCB0cnVlX3kgPSBsaW5lX3kgKyBzY2FubGluZUJsb2NrSWR4ICogRVhSRGVjb2Rlci5zY2FubGluZUJsb2NrU2l6ZTtcbiAgICAgICAgaWYgKHRydWVfeSA+PSBFWFJEZWNvZGVyLmhlaWdodClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZm9yIChsZXQgY2hhbm5lbElEID0gMDsgY2hhbm5lbElEIDwgRVhSRGVjb2Rlci5jaGFubmVsczsgY2hhbm5lbElEKyspIHtcbiAgICAgICAgICBjb25zdCBjT2ZmID0gY2hhbm5lbE9mZnNldHNbRVhSSGVhZGVyLmNoYW5uZWxzW2NoYW5uZWxJRF0ubmFtZV07XG4gICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBFWFJEZWNvZGVyLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIHRtcE9mZnNldC52YWx1ZSA9IChsaW5lX3kgKiAoRVhSRGVjb2Rlci5jaGFubmVscyAqIEVYUkRlY29kZXIud2lkdGgpICsgY2hhbm5lbElEICogRVhSRGVjb2Rlci53aWR0aCArIHgpICogRVhSRGVjb2Rlci5pbnB1dFNpemU7XG4gICAgICAgICAgICBjb25zdCBvdXRJbmRleCA9IChFWFJEZWNvZGVyLmhlaWdodCAtIDEgLSB0cnVlX3kpICogKEVYUkRlY29kZXIud2lkdGggKiBFWFJEZWNvZGVyLm91dHB1dENoYW5uZWxzKSArIHggKiBFWFJEZWNvZGVyLm91dHB1dENoYW5uZWxzICsgY09mZjtcbiAgICAgICAgICAgIEVYUkRlY29kZXIuYnl0ZUFycmF5W291dEluZGV4XSA9IEVYUkRlY29kZXIuZ2V0dGVyKHZpZXdlciwgdG1wT2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGhlYWRlcjogRVhSSGVhZGVyLFxuICAgICAgd2lkdGg6IEVYUkRlY29kZXIud2lkdGgsXG4gICAgICBoZWlnaHQ6IEVYUkRlY29kZXIuaGVpZ2h0LFxuICAgICAgZGF0YTogRVhSRGVjb2Rlci5ieXRlQXJyYXksXG4gICAgICBmb3JtYXQ6IEVYUkRlY29kZXIuZm9ybWF0LFxuICAgICAgW2hhc0NvbG9yU3BhY2UgPyBcImNvbG9yU3BhY2VcIiA6IFwiZW5jb2RpbmdcIl06IEVYUkRlY29kZXJbaGFzQ29sb3JTcGFjZSA/IFwiY29sb3JTcGFjZVwiIDogXCJlbmNvZGluZ1wiXSxcbiAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgIH07XG4gIH1cbiAgc2V0RGF0YVR5cGUodmFsdWUpIHtcbiAgICB0aGlzLnR5cGUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgZnVuY3Rpb24gb25Mb2FkQ2FsbGJhY2sodGV4dHVyZSwgdGV4RGF0YSkge1xuICAgICAgaWYgKGhhc0NvbG9yU3BhY2UpXG4gICAgICAgIHRleHR1cmUuY29sb3JTcGFjZSA9IHRleERhdGEuY29sb3JTcGFjZTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGV4dHVyZS5lbmNvZGluZyA9IHRleERhdGEuZW5jb2Rpbmc7XG4gICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcbiAgICAgIHRleHR1cmUubWFnRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICAgIHRleHR1cmUuZmxpcFkgPSBmYWxzZTtcbiAgICAgIGlmIChvbkxvYWQpXG4gICAgICAgIG9uTG9hZCh0ZXh0dXJlLCB0ZXhEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmxvYWQodXJsLCBvbkxvYWRDYWxsYmFjaywgb25Qcm9ncmVzcywgb25FcnJvcik7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEVYUkxvYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVYUkxvYWRlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/EXRLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/GLTFLoader.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTFLoader: () => (/* binding */ GLTFLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/BufferGeometryUtils.js */ \"(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\");\n/* harmony import */ var _polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_polyfill/LoaderUtils.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/LoaderUtils.js\");\n\n\n\n\nconst SRGBColorSpace = \"srgb\";\nconst LinearSRGBColorSpace = \"srgb-linear\";\nconst sRGBEncoding = 3001;\nconst LinearEncoding = 3e3;\nclass GLTFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  constructor(manager) {\n    super(manager);\n    this.dracoLoader = null;\n    this.ktx2Loader = null;\n    this.meshoptDecoder = null;\n    this.pluginCallbacks = [];\n    this.register(function(parser) {\n      return new GLTFMaterialsClearcoatExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsDispersionExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureBasisUExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureWebPExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureAVIFExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsSheenExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsTransmissionExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsVolumeExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsIorExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsSpecularExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsIridescenceExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsAnisotropyExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsBumpExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFLightsExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMeshoptCompression(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMeshGpuInstancing(parser);\n    });\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    let resourcePath;\n    if (this.resourcePath !== \"\") {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== \"\") {\n      const relativeUrl = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n      resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(relativeUrl, this.path);\n    } else {\n      resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n    }\n    this.manager.itemStart(url);\n    const _onError = function(e) {\n      if (onError) {\n        onError(e);\n      } else {\n        console.error(e);\n      }\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    };\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(\n      url,\n      function(data) {\n        try {\n          scope.parse(\n            data,\n            resourcePath,\n            function(gltf) {\n              onLoad(gltf);\n              scope.manager.itemEnd(url);\n            },\n            _onError\n          );\n        } catch (e) {\n          _onError(e);\n        }\n      },\n      onProgress,\n      _onError\n    );\n  }\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader;\n    return this;\n  }\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n  }\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader;\n    return this;\n  }\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder;\n    return this;\n  }\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n    return this;\n  }\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n    return this;\n  }\n  parse(data, path, onLoad, onError) {\n    let json;\n    const extensions = {};\n    const plugins = {};\n    if (typeof data === \"string\") {\n      json = JSON.parse(data);\n    } else if (data instanceof ArrayBuffer) {\n      const magic = (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data.slice(0, 4)));\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n        } catch (error) {\n          if (onError)\n            onError(error);\n          return;\n        }\n        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);\n      } else {\n        json = JSON.parse((0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data)));\n      }\n    } else {\n      json = data;\n    }\n    if (json.asset === void 0 || json.asset.version[0] < 2) {\n      if (onError)\n        onError(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n      return;\n    }\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || \"\",\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder\n    });\n    parser.fileLoader.setRequestHeader(this.requestHeader);\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser);\n      if (!plugin.name)\n        console.error(\"THREE.GLTFLoader: Invalid plugin found: missing name\");\n      plugins[plugin.name] = plugin;\n      extensions[plugin.name] = true;\n    }\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i];\n        const extensionsRequired = json.extensionsRequired || [];\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n            break;\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n            break;\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension();\n            break;\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension();\n            break;\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n            }\n        }\n      }\n    }\n    parser.setExtensions(extensions);\n    parser.setPlugins(plugins);\n    parser.parse(onLoad, onError);\n  }\n  parseAsync(data, path) {\n    const scope = this;\n    return new Promise(function(resolve, reject) {\n      scope.parse(data, path, resolve, reject);\n    });\n  }\n}\nfunction GLTFRegistry() {\n  let objects = {};\n  return {\n    get: function(key) {\n      return objects[key];\n    },\n    add: function(key, object) {\n      objects[key] = object;\n    },\n    remove: function(key) {\n      delete objects[key];\n    },\n    removeAll: function() {\n      objects = {};\n    }\n  };\n}\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n  KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n  KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n  KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n  KHR_MATERIALS_DISPERSION: \"KHR_materials_dispersion\",\n  KHR_MATERIALS_IOR: \"KHR_materials_ior\",\n  KHR_MATERIALS_SHEEN: \"KHR_materials_sheen\",\n  KHR_MATERIALS_SPECULAR: \"KHR_materials_specular\",\n  KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n  KHR_MATERIALS_IRIDESCENCE: \"KHR_materials_iridescence\",\n  KHR_MATERIALS_ANISOTROPY: \"KHR_materials_anisotropy\",\n  KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n  KHR_MATERIALS_VOLUME: \"KHR_materials_volume\",\n  KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n  KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n  KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n  KHR_MATERIALS_EMISSIVE_STRENGTH: \"KHR_materials_emissive_strength\",\n  EXT_MATERIALS_BUMP: \"EXT_materials_bump\",\n  EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n  EXT_TEXTURE_AVIF: \"EXT_texture_avif\",\n  EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\",\n  EXT_MESH_GPU_INSTANCING: \"EXT_mesh_gpu_instancing\"\n};\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n    this.cache = { refs: {}, uses: {} };\n  }\n  _markDefs() {\n    const parser = this.parser;\n    const nodeDefs = this.parser.json.nodes || [];\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n      }\n    }\n  }\n  _loadLight(lightIndex) {\n    const parser = this.parser;\n    const cacheKey = \"light:\" + lightIndex;\n    let dependency = parser.cache.get(cacheKey);\n    if (dependency)\n      return dependency;\n    const json = parser.json;\n    const extensions = json.extensions && json.extensions[this.name] || {};\n    const lightDefs = extensions.lights || [];\n    const lightDef = lightDefs[lightIndex];\n    let lightNode;\n    const color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n    if (lightDef.color !== void 0)\n      color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);\n    const range = lightDef.range !== void 0 ? lightDef.range : 0;\n    switch (lightDef.type) {\n      case \"directional\":\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      case \"point\":\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(color);\n        lightNode.distance = range;\n        break;\n      case \"spot\":\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight(color);\n        lightNode.distance = range;\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      default:\n        throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type);\n    }\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    assignExtrasToUserData(lightNode, lightDef);\n    if (lightDef.intensity !== void 0)\n      lightNode.intensity = lightDef.intensity;\n    lightNode.name = parser.createUniqueName(lightDef.name || \"light_\" + lightIndex);\n    dependency = Promise.resolve(lightNode);\n    parser.cache.add(cacheKey, dependency);\n    return dependency;\n  }\n  getDependency(type, index) {\n    if (type !== \"light\")\n      return;\n    return this._loadLight(index);\n  }\n  createNodeAttachment(nodeIndex) {\n    const self2 = this;\n    const parser = this.parser;\n    const json = parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n    const lightIndex = lightDef.light;\n    if (lightIndex === void 0)\n      return null;\n    return this._loadLight(lightIndex).then(function(light) {\n      return parser._getNodeRef(self2.cache, lightIndex, light);\n    });\n  }\n}\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n  getMaterialType() {\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial;\n  }\n  extendParams(materialParams, materialDef, parser) {\n    const pending = [];\n    materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n    materialParams.opacity = 1;\n    const metallicRoughness = materialDef.pbrMetallicRoughness;\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\n    if (emissiveStrength !== void 0) {\n      materialParams.emissiveIntensity = emissiveStrength;\n    }\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.clearcoatFactor !== void 0) {\n      materialParams.clearcoat = extension.clearcoatFactor;\n    }\n    if (extension.clearcoatTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatMap\", extension.clearcoatTexture));\n    }\n    if (extension.clearcoatRoughnessFactor !== void 0) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n    }\n    if (extension.clearcoatRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatRoughnessMap\", extension.clearcoatRoughnessTexture));\n    }\n    if (extension.clearcoatNormalTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatNormalMap\", extension.clearcoatNormalTexture));\n      if (extension.clearcoatNormalTexture.scale !== void 0) {\n        const scale = extension.clearcoatNormalTexture.scale;\n        materialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scale, scale);\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsDispersionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const extension = materialDef.extensions[this.name];\n    materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsIridescenceExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.iridescenceFactor !== void 0) {\n      materialParams.iridescence = extension.iridescenceFactor;\n    }\n    if (extension.iridescenceTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"iridescenceMap\", extension.iridescenceTexture));\n    }\n    if (extension.iridescenceIor !== void 0) {\n      materialParams.iridescenceIOR = extension.iridescenceIor;\n    }\n    if (materialParams.iridescenceThicknessRange === void 0) {\n      materialParams.iridescenceThicknessRange = [100, 400];\n    }\n    if (extension.iridescenceThicknessMinimum !== void 0) {\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;\n    }\n    if (extension.iridescenceThicknessMaximum !== void 0) {\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;\n    }\n    if (extension.iridescenceThicknessTexture !== void 0) {\n      pending.push(\n        parser.assignTexture(materialParams, \"iridescenceThicknessMap\", extension.iridescenceThicknessTexture)\n      );\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    materialParams.sheenColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0);\n    materialParams.sheenRoughness = 0;\n    materialParams.sheen = 1;\n    const extension = materialDef.extensions[this.name];\n    if (extension.sheenColorFactor !== void 0) {\n      const colorFactor = extension.sheenColorFactor;\n      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);\n    }\n    if (extension.sheenRoughnessFactor !== void 0) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor;\n    }\n    if (extension.sheenColorTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenColorMap\", extension.sheenColorTexture, SRGBColorSpace));\n    }\n    if (extension.sheenRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenRoughnessMap\", extension.sheenRoughnessTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.transmissionFactor !== void 0) {\n      materialParams.transmission = extension.transmissionFactor;\n    }\n    if (extension.transmissionTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"transmissionMap\", extension.transmissionTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;\n    if (extension.thicknessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"thicknessMap\", extension.thicknessTexture));\n    }\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n    const colorArray = extension.attenuationColor || [1, 1, 1];\n    materialParams.attenuationColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(\n      colorArray[0],\n      colorArray[1],\n      colorArray[2],\n      LinearSRGBColorSpace\n    );\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const extension = materialDef.extensions[this.name];\n    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;\n    return Promise.resolve();\n  }\n}\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;\n    if (extension.specularTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"specularIntensityMap\", extension.specularTexture));\n    }\n    const colorArray = extension.specularColorFactor || [1, 1, 1];\n    materialParams.specularColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);\n    if (extension.specularColorTexture !== void 0) {\n      pending.push(\n        parser.assignTexture(materialParams, \"specularColorMap\", extension.specularColorTexture, SRGBColorSpace)\n      );\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsBumpExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_MATERIALS_BUMP;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;\n    if (extension.bumpTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"bumpMap\", extension.bumpTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.anisotropyStrength !== void 0) {\n      materialParams.anisotropy = extension.anisotropyStrength;\n    }\n    if (extension.anisotropyRotation !== void 0) {\n      materialParams.anisotropyRotation = extension.anisotropyRotation;\n    }\n    if (extension.anisotropyTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"anisotropyMap\", extension.anisotropyTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n  }\n  loadTexture(textureIndex) {\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[this.name];\n    const loader = parser.options.ktx2Loader;\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n      } else {\n        return null;\n      }\n    }\n    return parser.loadTextureImage(textureIndex, extension.source, loader);\n  }\n}\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.detectSupport().then(function(isSupported) {\n      if (isSupported)\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function(resolve) {\n        const image = new Image();\n        image.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n        image.onload = image.onerror = function() {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFTextureAVIFExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.detectSupport().then(function(isSupported) {\n      if (isSupported)\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: AVIF required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function(resolve) {\n        const image = new Image();\n        image.src = \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=\";\n        image.onload = image.onerror = function() {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n    this.parser = parser;\n  }\n  loadBufferView(index) {\n    const json = this.parser.json;\n    const bufferView = json.bufferViews[index];\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name];\n      const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\n      const decoder = this.parser.options.meshoptDecoder;\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n        } else {\n          return null;\n        }\n      }\n      return buffer.then(function(res) {\n        const byteOffset = extensionDef.byteOffset || 0;\n        const byteLength = extensionDef.byteLength || 0;\n        const count = extensionDef.count;\n        const stride = extensionDef.byteStride;\n        const source = new Uint8Array(res, byteOffset, byteLength);\n        if (decoder.decodeGltfBufferAsync) {\n          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {\n            return res2.buffer;\n          });\n        } else {\n          return decoder.ready.then(function() {\n            const result = new ArrayBuffer(count * stride);\n            decoder.decodeGltfBuffer(\n              new Uint8Array(result),\n              count,\n              stride,\n              source,\n              extensionDef.mode,\n              extensionDef.filter\n            );\n            return result;\n          });\n        }\n      });\n    } else {\n      return null;\n    }\n  }\n}\nclass GLTFMeshGpuInstancing {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n    this.parser = parser;\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {\n      return null;\n    }\n    const meshDef = json.meshes[nodeDef.mesh];\n    for (const primitive of meshDef.primitives) {\n      if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {\n        return null;\n      }\n    }\n    const extensionDef = nodeDef.extensions[this.name];\n    const attributesDef = extensionDef.attributes;\n    const pending = [];\n    const attributes = {};\n    for (const key in attributesDef) {\n      pending.push(\n        this.parser.getDependency(\"accessor\", attributesDef[key]).then((accessor) => {\n          attributes[key] = accessor;\n          return attributes[key];\n        })\n      );\n    }\n    if (pending.length < 1) {\n      return null;\n    }\n    pending.push(this.parser.createNodeMesh(nodeIndex));\n    return Promise.all(pending).then((results) => {\n      const nodeObject = results.pop();\n      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];\n      const count = results[0].count;\n      const instancedMeshes = [];\n      for (const mesh of meshes) {\n        const m = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        const p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n        const s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n        const instancedMesh = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedMesh(mesh.geometry, mesh.material, count);\n        for (let i = 0; i < count; i++) {\n          if (attributes.TRANSLATION) {\n            p.fromBufferAttribute(attributes.TRANSLATION, i);\n          }\n          if (attributes.ROTATION) {\n            q.fromBufferAttribute(attributes.ROTATION, i);\n          }\n          if (attributes.SCALE) {\n            s.fromBufferAttribute(attributes.SCALE, i);\n          }\n          instancedMesh.setMatrixAt(i, m.compose(p, q, s));\n        }\n        for (const attributeName in attributes) {\n          if (attributeName === \"_COLOR_0\") {\n            const attr = attributes[attributeName];\n            instancedMesh.instanceColor = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);\n          } else if (attributeName !== \"TRANSLATION\" && attributeName !== \"ROTATION\" && attributeName !== \"SCALE\") {\n            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);\n          }\n        }\n        three__WEBPACK_IMPORTED_MODULE_0__.Object3D.prototype.copy.call(instancedMesh, mesh);\n        this.parser.assignFinalMaterial(instancedMesh);\n        instancedMeshes.push(instancedMesh);\n      }\n      if (nodeObject.isGroup) {\n        nodeObject.clear();\n        nodeObject.add(...instancedMeshes);\n        return nodeObject;\n      }\n      return instancedMeshes[0];\n    });\n  }\n}\nconst BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n    } else if (this.header.version < 2) {\n      throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n    }\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    let chunkIndex = 0;\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      const chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      }\n      chunkIndex += chunkLength;\n    }\n    if (this.content === null) {\n      throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n    }\n  }\n}\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n    }\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n    this.dracoLoader.preload();\n  }\n  decodePrimitive(primitive, parser) {\n    const json = this.json;\n    const dracoLoader = this.dracoLoader;\n    const bufferViewIndex = primitive.extensions[this.name].bufferView;\n    const gltfAttributeMap = primitive.extensions[this.name].attributes;\n    const threeAttributeMap = {};\n    const attributeNormalizedMap = {};\n    const attributeTypeMap = {};\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      if (gltfAttributeMap[attributeName] !== void 0) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]];\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType.name;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n    return parser.getDependency(\"bufferView\", bufferViewIndex).then(function(bufferView) {\n      return new Promise(function(resolve, reject) {\n        dracoLoader.decodeDracoFile(\n          bufferView,\n          function(geometry) {\n            for (const attributeName in geometry.attributes) {\n              const attribute = geometry.attributes[attributeName];\n              const normalized = attributeNormalizedMap[attributeName];\n              if (normalized !== void 0)\n                attribute.normalized = normalized;\n            }\n            resolve(geometry);\n          },\n          threeAttributeMap,\n          attributeTypeMap,\n          LinearSRGBColorSpace,\n          reject\n        );\n      });\n    });\n  }\n}\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n  extendTexture(texture, transform) {\n    if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {\n      return texture;\n    }\n    texture = texture.clone();\n    if (transform.texCoord !== void 0) {\n      texture.channel = transform.texCoord;\n    }\n    if (transform.offset !== void 0) {\n      texture.offset.fromArray(transform.offset);\n    }\n    if (transform.rotation !== void 0) {\n      texture.rotation = transform.rotation;\n    }\n    if (transform.scale !== void 0) {\n      texture.repeat.fromArray(transform.scale);\n    }\n    texture.needsUpdate = true;\n    return texture;\n  }\n}\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n  }\n}\nclass GLTFCubicSplineInterpolant extends three__WEBPACK_IMPORTED_MODULE_0__.Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  copySampleValue_(index) {\n    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n    return result;\n  }\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer;\n    const values = this.sampleValues;\n    const stride = this.valueSize;\n    const stride2 = stride * 2;\n    const stride3 = stride * 3;\n    const td = t1 - t0;\n    const p = (t - t0) / td;\n    const pp = p * p;\n    const ppp = pp * p;\n    const offset1 = i1 * stride3;\n    const offset0 = offset1 - stride3;\n    const s2 = -2 * ppp + 3 * pp;\n    const s3 = ppp - pp;\n    const s0 = 1 - s2;\n    const s1 = s3 - pp + p;\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride];\n      const m0 = values[offset0 + i + stride2] * td;\n      const p1 = values[offset1 + i + stride];\n      const m1 = values[offset1 + i] * td;\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n    }\n    return result;\n  }\n}\nconst _q = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1);\n    _q.fromArray(result).normalize().toArray(result);\n    return result;\n  }\n}\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n  9728: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n  9729: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n  9984: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter,\n  9985: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter,\n  9986: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter,\n  9987: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n  33071: three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n  33648: three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping,\n  10497: three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\nconst ATTRIBUTES = {\n  POSITION: \"position\",\n  NORMAL: \"normal\",\n  TANGENT: \"tangent\",\n  // uv => uv1, 4 uv channels\n  // https://github.com/mrdoob/three.js/pull/25943\n  // https://github.com/mrdoob/three.js/pull/25788\n  ..._polyfill_constants_js__WEBPACK_IMPORTED_MODULE_2__.version >= 152 ? {\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv1\",\n    TEXCOORD_2: \"uv2\",\n    TEXCOORD_3: \"uv3\"\n  } : {\n    TEXCOORD_0: \"uv\",\n    TEXCOORD_1: \"uv2\"\n  },\n  COLOR_0: \"color\",\n  WEIGHTS_0: \"skinWeight\",\n  JOINTS_0: \"skinIndex\"\n};\nconst PATH_PROPERTIES = {\n  scale: \"scale\",\n  translation: \"position\",\n  rotation: \"quaternion\",\n  weights: \"morphTargetInfluences\"\n};\nconst INTERPOLATION = {\n  CUBICSPLINE: void 0,\n  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,\n  STEP: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n  OPAQUE: \"OPAQUE\",\n  MASK: \"MASK\",\n  BLEND: \"BLEND\"\n};\nfunction createDefaultMaterial(cache) {\n  if (cache[\"DefaultMaterial\"] === void 0) {\n    cache[\"DefaultMaterial\"] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n      color: 16777215,\n      emissive: 0,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide\n    });\n  }\n  return cache[\"DefaultMaterial\"];\n}\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === void 0) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n      object.userData.gltfExtensions[name] = objectDef.extensions[name];\n    }\n  }\n}\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== void 0) {\n    if (typeof gltfDef.extras === \"object\") {\n      Object.assign(object.userData, gltfDef.extras);\n    } else {\n      console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras);\n    }\n  }\n}\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false;\n  let hasMorphNormal = false;\n  let hasMorphColor = false;\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (target.POSITION !== void 0)\n      hasMorphPosition = true;\n    if (target.NORMAL !== void 0)\n      hasMorphNormal = true;\n    if (target.COLOR_0 !== void 0)\n      hasMorphColor = true;\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor)\n      break;\n  }\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor)\n    return Promise.resolve(geometry);\n  const pendingPositionAccessors = [];\n  const pendingNormalAccessors = [];\n  const pendingColorAccessors = [];\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (hasMorphPosition) {\n      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency(\"accessor\", target.POSITION) : geometry.attributes.position;\n      pendingPositionAccessors.push(pendingAccessor);\n    }\n    if (hasMorphNormal) {\n      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency(\"accessor\", target.NORMAL) : geometry.attributes.normal;\n      pendingNormalAccessors.push(pendingAccessor);\n    }\n    if (hasMorphColor) {\n      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency(\"accessor\", target.COLOR_0) : geometry.attributes.color;\n      pendingColorAccessors.push(pendingAccessor);\n    }\n  }\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors),\n    Promise.all(pendingColorAccessors)\n  ]).then(function(accessors) {\n    const morphPositions = accessors[0];\n    const morphNormals = accessors[1];\n    const morphColors = accessors[2];\n    if (hasMorphPosition)\n      geometry.morphAttributes.position = morphPositions;\n    if (hasMorphNormal)\n      geometry.morphAttributes.normal = morphNormals;\n    if (hasMorphColor)\n      geometry.morphAttributes.color = morphColors;\n    geometry.morphTargetsRelative = true;\n    return geometry;\n  });\n}\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets();\n  if (meshDef.weights !== void 0) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i];\n    }\n  }\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames;\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {};\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i;\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n    }\n  }\n}\nfunction createPrimitiveKey(primitiveDef) {\n  let geometryKey;\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n  if (dracoExtension) {\n    geometryKey = \"draco:\" + dracoExtension.bufferView + \":\" + dracoExtension.indices + \":\" + createAttributesKey(dracoExtension.attributes);\n  } else {\n    geometryKey = primitiveDef.indices + \":\" + createAttributesKey(primitiveDef.attributes) + \":\" + primitiveDef.mode;\n  }\n  if (primitiveDef.targets !== void 0) {\n    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {\n      geometryKey += \":\" + createAttributesKey(primitiveDef.targets[i]);\n    }\n  }\n  return geometryKey;\n}\nfunction createAttributesKey(attributes) {\n  let attributesKey = \"\";\n  const keys = Object.keys(attributes).sort();\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\n  }\n  return attributesKey;\n}\nfunction getNormalizedComponentScale(constructor) {\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127;\n    case Uint8Array:\n      return 1 / 255;\n    case Int16Array:\n      return 1 / 32767;\n    case Uint16Array:\n      return 1 / 65535;\n    default:\n      throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n  }\n}\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0)\n    return \"image/jpeg\";\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0)\n    return \"image/webp\";\n  return \"image/png\";\n}\nconst _identityMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json;\n    this.extensions = {};\n    this.plugins = {};\n    this.options = options;\n    this.cache = new GLTFRegistry();\n    this.associations = /* @__PURE__ */ new Map();\n    this.primitiveCache = {};\n    this.nodeCache = {};\n    this.meshCache = { refs: {}, uses: {} };\n    this.cameraCache = { refs: {}, uses: {} };\n    this.lightCache = { refs: {}, uses: {} };\n    this.sourceCache = {};\n    this.textureCache = {};\n    this.nodeNamesUsed = {};\n    let isSafari = false;\n    let isFirefox = false;\n    let firefoxVersion = -1;\n    if (typeof navigator !== \"undefined\" && typeof navigator.userAgent !== \"undefined\") {\n      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;\n      isFirefox = navigator.userAgent.indexOf(\"Firefox\") > -1;\n      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\n    }\n    if (typeof createImageBitmap === \"undefined\" || isSafari || isFirefox && firefoxVersion < 98) {\n      this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader(this.options.manager);\n    } else {\n      this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader(this.options.manager);\n    }\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.textureLoader.setRequestHeader(this.options.requestHeader);\n    this.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.options.manager);\n    this.fileLoader.setResponseType(\"arraybuffer\");\n    if (this.options.crossOrigin === \"use-credentials\") {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n  setExtensions(extensions) {\n    this.extensions = extensions;\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  parse(onLoad, onError) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    this.cache.removeAll();\n    this.nodeCache = {};\n    this._invokeAll(function(ext) {\n      return ext._markDefs && ext._markDefs();\n    });\n    Promise.all(\n      this._invokeAll(function(ext) {\n        return ext.beforeRoot && ext.beforeRoot();\n      })\n    ).then(function() {\n      return Promise.all([\n        parser.getDependencies(\"scene\"),\n        parser.getDependencies(\"animation\"),\n        parser.getDependencies(\"camera\")\n      ]);\n    }).then(function(dependencies) {\n      const result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      assignExtrasToUserData(result, json);\n      return Promise.all(\n        parser._invokeAll(function(ext) {\n          return ext.afterRoot && ext.afterRoot(result);\n        })\n      ).then(function() {\n        for (const scene of result.scenes) {\n          scene.updateMatrixWorld();\n        }\n        onLoad(result);\n      });\n    }).catch(onError);\n  }\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const nodeDefs = this.json.nodes || [];\n    const skinDefs = this.json.skins || [];\n    const meshDefs = this.json.meshes || [];\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints;\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    }\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.mesh !== void 0) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh);\n        if (nodeDef.skin !== void 0) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n      if (nodeDef.camera !== void 0) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera);\n      }\n    }\n  }\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(cache, index) {\n    if (index === void 0)\n      return;\n    if (cache.refs[index] === void 0) {\n      cache.refs[index] = cache.uses[index] = 0;\n    }\n    cache.refs[index]++;\n  }\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1)\n      return object;\n    const ref = object.clone();\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original);\n      if (mappings != null) {\n        this.associations.set(clone, mappings);\n      }\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i]);\n      }\n    };\n    updateMappings(object, ref);\n    ref.name += \"_instance_\" + cache.uses[index]++;\n    return ref;\n  }\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.push(this);\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result)\n        return result;\n    }\n    return null;\n  }\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.unshift(this);\n    const pending = [];\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result)\n        pending.push(result);\n    }\n    return pending;\n  }\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(type, index) {\n    const cacheKey = type + \":\" + index;\n    let dependency = this.cache.get(cacheKey);\n    if (!dependency) {\n      switch (type) {\n        case \"scene\":\n          dependency = this.loadScene(index);\n          break;\n        case \"node\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadNode && ext.loadNode(index);\n          });\n          break;\n        case \"mesh\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadMesh && ext.loadMesh(index);\n          });\n          break;\n        case \"accessor\":\n          dependency = this.loadAccessor(index);\n          break;\n        case \"bufferView\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadBufferView && ext.loadBufferView(index);\n          });\n          break;\n        case \"buffer\":\n          dependency = this.loadBuffer(index);\n          break;\n        case \"material\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadMaterial && ext.loadMaterial(index);\n          });\n          break;\n        case \"texture\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadTexture && ext.loadTexture(index);\n          });\n          break;\n        case \"skin\":\n          dependency = this.loadSkin(index);\n          break;\n        case \"animation\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadAnimation && ext.loadAnimation(index);\n          });\n          break;\n        case \"camera\":\n          dependency = this.loadCamera(index);\n          break;\n        default:\n          dependency = this._invokeOne(function(ext) {\n            return ext != this && ext.getDependency && ext.getDependency(type, index);\n          });\n          if (!dependency) {\n            throw new Error(\"Unknown type: \" + type);\n          }\n          break;\n      }\n      this.cache.add(cacheKey, dependency);\n    }\n    return dependency;\n  }\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(type) {\n    let dependencies = this.cache.get(type);\n    if (!dependencies) {\n      const parser = this;\n      const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\n      dependencies = Promise.all(\n        defs.map(function(def, index) {\n          return parser.getDependency(type, index);\n        })\n      );\n      this.cache.add(type, dependencies);\n    }\n    return dependencies;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex];\n    const loader = this.fileLoader;\n    if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\n      throw new Error(\"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\");\n    }\n    if (bufferDef.uri === void 0 && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n    const options = this.options;\n    return new Promise(function(resolve, reject) {\n      loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function(buffer) {\n      const byteLength = bufferViewDef.byteLength || 0;\n      const byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(accessorIndex) {\n    const parser = this;\n    const json = this.json;\n    const accessorDef = this.json.accessors[accessorIndex];\n    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const normalized = accessorDef.normalized === true;\n      const array = new TypedArray(accessorDef.count * itemSize);\n      return Promise.resolve(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized));\n    }\n    const pendingBufferViews = [];\n    if (accessorDef.bufferView !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n    if (accessorDef.sparse !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView));\n    }\n    return Promise.all(pendingBufferViews).then(function(bufferViews) {\n      const bufferView = bufferViews[0];\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      const itemBytes = elementBytes * itemSize;\n      const byteOffset = accessorDef.byteOffset || 0;\n      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;\n      const normalized = accessorDef.normalized === true;\n      let array, bufferAttribute;\n      if (byteStride && byteStride !== itemBytes) {\n        const ibSlice = Math.floor(byteOffset / byteStride);\n        const ibCacheKey = \"InterleavedBuffer:\" + accessorDef.bufferView + \":\" + accessorDef.componentType + \":\" + ibSlice + \":\" + accessorDef.count;\n        let ib = parser.cache.get(ibCacheKey);\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n          ib = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n        bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(\n          ib,\n          itemSize,\n          byteOffset % byteStride / elementBytes,\n          normalized\n        );\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n        bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n      }\n      if (accessorDef.sparse !== void 0) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        const sparseIndices = new TypedArrayIndices(\n          bufferViews[1],\n          byteOffsetIndices,\n          accessorDef.sparse.count * itemSizeIndices\n        );\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n        if (bufferView !== null) {\n          bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(\n            bufferAttribute.array.slice(),\n            bufferAttribute.itemSize,\n            bufferAttribute.normalized\n          );\n        }\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2)\n            bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3)\n            bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4)\n            bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5)\n            throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n        }\n      }\n      return bufferAttribute;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */\n  loadTexture(textureIndex) {\n    const json = this.json;\n    const options = this.options;\n    const textureDef = json.textures[textureIndex];\n    const sourceIndex = textureDef.source;\n    const sourceDef = json.images[sourceIndex];\n    let loader = this.textureLoader;\n    if (sourceDef.uri) {\n      const handler = options.manager.getHandler(sourceDef.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.loadTextureImage(textureIndex, sourceIndex, loader);\n  }\n  loadTextureImage(textureIndex, sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const textureDef = json.textures[textureIndex];\n    const sourceDef = json.images[sourceIndex];\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + \":\" + textureDef.sampler;\n    if (this.textureCache[cacheKey]) {\n      return this.textureCache[cacheKey];\n    }\n    const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {\n      texture.flipY = false;\n      texture.name = textureDef.name || sourceDef.name || \"\";\n      if (texture.name === \"\" && typeof sourceDef.uri === \"string\" && sourceDef.uri.startsWith(\"data:image/\") === false) {\n        texture.name = sourceDef.uri;\n      }\n      const samplers = json.samplers || {};\n      const sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n      parser.associations.set(texture, { textures: textureIndex });\n      return texture;\n    }).catch(function() {\n      return null;\n    });\n    this.textureCache[cacheKey] = promise;\n    return promise;\n  }\n  loadImageSource(sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const options = this.options;\n    if (this.sourceCache[sourceIndex] !== void 0) {\n      return this.sourceCache[sourceIndex].then((texture) => texture.clone());\n    }\n    const sourceDef = json.images[sourceIndex];\n    const URL = self.URL || self.webkitURL;\n    let sourceURI = sourceDef.uri || \"\";\n    let isObjectURL = false;\n    if (sourceDef.bufferView !== void 0) {\n      sourceURI = parser.getDependency(\"bufferView\", sourceDef.bufferView).then(function(bufferView) {\n        isObjectURL = true;\n        const blob = new Blob([bufferView], { type: sourceDef.mimeType });\n        sourceURI = URL.createObjectURL(blob);\n        return sourceURI;\n      });\n    } else if (sourceDef.uri === void 0) {\n      throw new Error(\"THREE.GLTFLoader: Image \" + sourceIndex + \" is missing URI and bufferView\");\n    }\n    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {\n      return new Promise(function(resolve, reject) {\n        let onLoad = resolve;\n        if (loader.isImageBitmapLoader === true) {\n          onLoad = function(imageBitmap) {\n            const texture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(imageBitmap);\n            texture.needsUpdate = true;\n            resolve(texture);\n          };\n        }\n        loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);\n      });\n    }).then(function(texture) {\n      if (isObjectURL === true) {\n        URL.revokeObjectURL(sourceURI);\n      }\n      assignExtrasToUserData(texture, sourceDef);\n      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\n      return texture;\n    }).catch(function(error) {\n      console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n      throw error;\n    });\n    this.sourceCache[sourceIndex] = promise;\n    return promise;\n  }\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(materialParams, mapName, mapDef, colorSpace) {\n    const parser = this;\n    return this.getDependency(\"texture\", mapDef.index).then(function(texture) {\n      if (!texture)\n        return null;\n      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {\n        texture = texture.clone();\n        texture.channel = mapDef.texCoord;\n      }\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;\n        if (transform) {\n          const gltfReference = parser.associations.get(texture);\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n          parser.associations.set(texture, gltfReference);\n        }\n      }\n      if (colorSpace !== void 0) {\n        if (typeof colorSpace === \"number\")\n          colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n        if (\"colorSpace\" in texture)\n          texture.colorSpace = colorSpace;\n        else\n          texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n      }\n      materialParams[mapName] = texture;\n      return texture;\n    });\n  }\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry;\n    let material = mesh.material;\n    const useDerivativeTangents = geometry.attributes.tangent === void 0;\n    const useVertexColors = geometry.attributes.color !== void 0;\n    const useFlatShading = geometry.attributes.normal === void 0;\n    if (mesh.isPoints) {\n      const cacheKey = \"PointsMaterial:\" + material.uuid;\n      let pointsMaterial = this.cache.get(cacheKey);\n      if (!pointsMaterial) {\n        pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial();\n        three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.sizeAttenuation = false;\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      const cacheKey = \"LineBasicMaterial:\" + material.uuid;\n      let lineMaterial = this.cache.get(cacheKey);\n      if (!lineMaterial) {\n        lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n        three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        lineMaterial.map = material.map;\n        this.cache.add(cacheKey, lineMaterial);\n      }\n      material = lineMaterial;\n    }\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\n      if (useDerivativeTangents)\n        cacheKey += \"derivative-tangents:\";\n      if (useVertexColors)\n        cacheKey += \"vertex-colors:\";\n      if (useFlatShading)\n        cacheKey += \"flat-shading:\";\n      let cachedMaterial = this.cache.get(cacheKey);\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone();\n        if (useVertexColors)\n          cachedMaterial.vertexColors = true;\n        if (useFlatShading)\n          cachedMaterial.flatShading = true;\n        if (useDerivativeTangents) {\n          if (cachedMaterial.normalScale)\n            cachedMaterial.normalScale.y *= -1;\n          if (cachedMaterial.clearcoatNormalScale)\n            cachedMaterial.clearcoatNormalScale.y *= -1;\n        }\n        this.cache.add(cacheKey, cachedMaterial);\n        this.associations.set(cachedMaterial, this.associations.get(material));\n      }\n      material = cachedMaterial;\n    }\n    mesh.material = material;\n  }\n  getMaterialType() {\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(materialIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const materialDef = json.materials[materialIndex];\n    let materialType;\n    const materialParams = {};\n    const materialExtensions = materialDef.extensions || {};\n    const pending = [];\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n      materialParams.opacity = 1;\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n      }\n      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;\n      if (metallicRoughness.metallicRoughnessTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"metalnessMap\", metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, \"roughnessMap\", metallicRoughness.metallicRoughnessTexture));\n      }\n      materialType = this._invokeOne(function(ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex);\n      });\n      pending.push(\n        Promise.all(\n          this._invokeAll(function(ext) {\n            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n          })\n        )\n      );\n    }\n    if (materialDef.doubleSided === true) {\n      materialParams.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n    }\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true;\n      materialParams.depthWrite = false;\n    } else {\n      materialParams.transparent = false;\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n    if (materialDef.normalTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"normalMap\", materialDef.normalTexture));\n      materialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);\n      if (materialDef.normalTexture.scale !== void 0) {\n        const scale = materialDef.normalTexture.scale;\n        materialParams.normalScale.set(scale, scale);\n      }\n    }\n    if (materialDef.occlusionTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"aoMap\", materialDef.occlusionTexture));\n      if (materialDef.occlusionTexture.strength !== void 0) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n    if (materialDef.emissiveFactor !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      const emissiveFactor = materialDef.emissiveFactor;\n      materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(\n        emissiveFactor[0],\n        emissiveFactor[1],\n        emissiveFactor[2],\n        LinearSRGBColorSpace\n      );\n    }\n    if (materialDef.emissiveTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"emissiveMap\", materialDef.emissiveTexture, SRGBColorSpace));\n    }\n    return Promise.all(pending).then(function() {\n      const material = new materialType(materialParams);\n      if (materialDef.name)\n        material.name = materialDef.name;\n      assignExtrasToUserData(material, materialDef);\n      parser.associations.set(material, { materials: materialIndex });\n      if (materialDef.extensions)\n        addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  }\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(originalName) {\n    const sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName(originalName || \"\");\n    if (sanitizedName in this.nodeNamesUsed) {\n      return sanitizedName + \"_\" + ++this.nodeNamesUsed[sanitizedName];\n    } else {\n      this.nodeNamesUsed[sanitizedName] = 0;\n      return sanitizedName;\n    }\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(primitives) {\n    const parser = this;\n    const extensions = this.extensions;\n    const cache = this.primitiveCache;\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i];\n      const cacheKey = createPrimitiveKey(primitive);\n      const cached = cache[cacheKey];\n      if (cached) {\n        pending.push(cached.promise);\n      } else {\n        let geometryPromise;\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          geometryPromise = addPrimitiveAttributes(new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), primitive, parser);\n        }\n        cache[cacheKey] = { primitive, promise: geometryPromise };\n        pending.push(geometryPromise);\n      }\n    }\n    return Promise.all(pending);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(meshIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const meshDef = json.meshes[meshIndex];\n    const primitives = meshDef.primitives;\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency(\"material\", primitives[i].material);\n      pending.push(material);\n    }\n    pending.push(parser.loadGeometries(primitives));\n    return Promise.all(pending).then(function(results) {\n      const materials = results.slice(0, results.length - 1);\n      const geometries = results[results.length - 1];\n      const meshes = [];\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i];\n        const primitive = primitives[i];\n        let mesh;\n        const material = materials[i];\n        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {\n          mesh = meshDef.isSkinnedMesh === true ? new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh(geometry, material) : new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);\n          if (mesh.isSkinnedMesh === true) {\n            mesh.normalizeSkinWeights();\n          }\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode);\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode);\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Line(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineLoop(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points(geometry, material);\n        } else {\n          throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode);\n        }\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef);\n        }\n        mesh.name = parser.createUniqueName(meshDef.name || \"mesh_\" + meshIndex);\n        assignExtrasToUserData(mesh, meshDef);\n        if (primitive.extensions)\n          addUnknownExtensionsToUserData(extensions, mesh, primitive);\n        parser.assignFinalMaterial(mesh);\n        meshes.push(mesh);\n      }\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i\n        });\n      }\n      if (meshes.length === 1) {\n        if (meshDef.extensions)\n          addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);\n        return meshes[0];\n      }\n      const group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n      if (meshDef.extensions)\n        addUnknownExtensionsToUserData(extensions, group, meshDef);\n      parser.associations.set(group, { meshes: meshIndex });\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i]);\n      }\n      return group;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(cameraIndex) {\n    let camera;\n    const cameraDef = this.json.cameras[cameraIndex];\n    const params = cameraDef[cameraDef.type];\n    if (!params) {\n      console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n      return;\n    }\n    if (cameraDef.type === \"perspective\") {\n      camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(\n        three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(params.yfov),\n        params.aspectRatio || 1,\n        params.znear || 1,\n        params.zfar || 2e6\n      );\n    } else if (cameraDef.type === \"orthographic\") {\n      camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n    }\n    if (cameraDef.name)\n      camera.name = this.createUniqueName(cameraDef.name);\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex];\n    const pending = [];\n    for (let i = 0, il = skinDef.joints.length; i < il; i++) {\n      pending.push(this._loadNodeShallow(skinDef.joints[i]));\n    }\n    if (skinDef.inverseBindMatrices !== void 0) {\n      pending.push(this.getDependency(\"accessor\", skinDef.inverseBindMatrices));\n    } else {\n      pending.push(null);\n    }\n    return Promise.all(pending).then(function(results) {\n      const inverseBindMatrices = results.pop();\n      const jointNodes = results;\n      const bones = [];\n      const boneInverses = [];\n      for (let i = 0, il = jointNodes.length; i < il; i++) {\n        const jointNode = jointNodes[i];\n        if (jointNode) {\n          bones.push(jointNode);\n          const mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n          if (inverseBindMatrices !== null) {\n            mat.fromArray(inverseBindMatrices.array, i * 16);\n          }\n          boneInverses.push(mat);\n        } else {\n          console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i]);\n        }\n      }\n      return new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton(bones, boneInverses);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(animationIndex) {\n    const json = this.json;\n    const parser = this;\n    const animationDef = json.animations[animationIndex];\n    const animationName = animationDef.name ? animationDef.name : \"animation_\" + animationIndex;\n    const pendingNodes = [];\n    const pendingInputAccessors = [];\n    const pendingOutputAccessors = [];\n    const pendingSamplers = [];\n    const pendingTargets = [];\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i];\n      const sampler = animationDef.samplers[channel.sampler];\n      const target = channel.target;\n      const name = target.node;\n      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;\n      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;\n      if (target.node === void 0)\n        continue;\n      pendingNodes.push(this.getDependency(\"node\", name));\n      pendingInputAccessors.push(this.getDependency(\"accessor\", input));\n      pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets)\n    ]).then(function(dependencies) {\n      const nodes = dependencies[0];\n      const inputAccessors = dependencies[1];\n      const outputAccessors = dependencies[2];\n      const samplers = dependencies[3];\n      const targets = dependencies[4];\n      const tracks = [];\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i];\n        const inputAccessor = inputAccessors[i];\n        const outputAccessor = outputAccessors[i];\n        const sampler = samplers[i];\n        const target = targets[i];\n        if (node === void 0)\n          continue;\n        if (node.updateMatrix) {\n          node.updateMatrix();\n        }\n        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);\n        if (createdTracks) {\n          for (let k = 0; k < createdTracks.length; k++) {\n            tracks.push(createdTracks[k]);\n          }\n        }\n      }\n      return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(animationName, void 0, tracks);\n    });\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    if (nodeDef.mesh === void 0)\n      return null;\n    return parser.getDependency(\"mesh\", nodeDef.mesh).then(function(mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n      if (nodeDef.weights !== void 0) {\n        node.traverse(function(o) {\n          if (!o.isMesh)\n            return;\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i];\n          }\n        });\n      }\n      return node;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    const nodePending = parser._loadNodeShallow(nodeIndex);\n    const childPending = [];\n    const childrenDef = nodeDef.children || [];\n    for (let i = 0, il = childrenDef.length; i < il; i++) {\n      childPending.push(parser.getDependency(\"node\", childrenDef[i]));\n    }\n    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency(\"skin\", nodeDef.skin);\n    return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function(results) {\n      const node = results[0];\n      const children = results[1];\n      const skeleton = results[2];\n      if (skeleton !== null) {\n        node.traverse(function(mesh) {\n          if (!mesh.isSkinnedMesh)\n            return;\n          mesh.bind(skeleton, _identityMatrix);\n        });\n      }\n      for (let i = 0, il = children.length; i < il; i++) {\n        node.add(children[i]);\n      }\n      return node;\n    });\n  }\n  // ._loadNodeShallow() parses a single node.\n  // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n  _loadNodeShallow(nodeIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const parser = this;\n    if (this.nodeCache[nodeIndex] !== void 0) {\n      return this.nodeCache[nodeIndex];\n    }\n    const nodeDef = json.nodes[nodeIndex];\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\n    const pending = [];\n    const meshPromise = parser._invokeOne(function(ext) {\n      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n    });\n    if (meshPromise) {\n      pending.push(meshPromise);\n    }\n    if (nodeDef.camera !== void 0) {\n      pending.push(\n        parser.getDependency(\"camera\", nodeDef.camera).then(function(camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n        })\n      );\n    }\n    parser._invokeAll(function(ext) {\n      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n    }).forEach(function(promise) {\n      pending.push(promise);\n    });\n    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {\n      let node;\n      if (nodeDef.isBone === true) {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();\n      } else if (objects.length > 1) {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n      } else if (objects.length === 1) {\n        node = objects[0];\n      } else {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n      }\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i]);\n        }\n      }\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name;\n        node.name = nodeName;\n      }\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions)\n        addUnknownExtensionsToUserData(extensions, node, nodeDef);\n      if (nodeDef.matrix !== void 0) {\n        const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix4(matrix);\n      } else {\n        if (nodeDef.translation !== void 0) {\n          node.position.fromArray(nodeDef.translation);\n        }\n        if (nodeDef.rotation !== void 0) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n        if (nodeDef.scale !== void 0) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {});\n      }\n      parser.associations.get(node).nodes = nodeIndex;\n      return node;\n    });\n    return this.nodeCache[nodeIndex];\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(sceneIndex) {\n    const extensions = this.extensions;\n    const sceneDef = this.json.scenes[sceneIndex];\n    const parser = this;\n    const scene = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n    if (sceneDef.name)\n      scene.name = parser.createUniqueName(sceneDef.name);\n    assignExtrasToUserData(scene, sceneDef);\n    if (sceneDef.extensions)\n      addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n    const nodeIds = sceneDef.nodes || [];\n    const pending = [];\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(parser.getDependency(\"node\", nodeIds[i]));\n    }\n    return Promise.all(pending).then(function(nodes) {\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        scene.add(nodes[i]);\n      }\n      const reduceAssociations = (node) => {\n        const reducedAssociations = /* @__PURE__ */ new Map();\n        for (const [key, value] of parser.associations) {\n          if (key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) {\n            reducedAssociations.set(key, value);\n          }\n        }\n        node.traverse((node2) => {\n          const mappings = parser.associations.get(node2);\n          if (mappings != null) {\n            reducedAssociations.set(node2, mappings);\n          }\n        });\n        return reducedAssociations;\n      };\n      parser.associations = reduceAssociations(scene);\n      return scene;\n    });\n  }\n  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {\n    const tracks = [];\n    const targetName = node.name ? node.name : node.uuid;\n    const targetNames = [];\n    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n      node.traverse(function(object) {\n        if (object.morphTargetInfluences) {\n          targetNames.push(object.name ? object.name : object.uuid);\n        }\n      });\n    } else {\n      targetNames.push(targetName);\n    }\n    let TypedKeyframeTrack;\n    switch (PATH_PROPERTIES[target.path]) {\n      case PATH_PROPERTIES.weights:\n        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n        break;\n      case PATH_PROPERTIES.rotation:\n        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack;\n        break;\n      case PATH_PROPERTIES.position:\n      case PATH_PROPERTIES.scale:\n        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n        break;\n      default:\n        switch (outputAccessor.itemSize) {\n          case 1:\n            TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n            break;\n          case 2:\n          case 3:\n          default:\n            TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n            break;\n        }\n        break;\n    }\n    const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear;\n    const outputArray = this._getArrayFromAccessor(outputAccessor);\n    for (let j = 0, jl = targetNames.length; j < jl; j++) {\n      const track = new TypedKeyframeTrack(\n        targetNames[j] + \".\" + PATH_PROPERTIES[target.path],\n        inputAccessor.array,\n        outputArray,\n        interpolation\n      );\n      if (sampler.interpolation === \"CUBICSPLINE\") {\n        this._createCubicSplineTrackInterpolant(track);\n      }\n      tracks.push(track);\n    }\n    return tracks;\n  }\n  _getArrayFromAccessor(accessor) {\n    let outputArray = accessor.array;\n    if (accessor.normalized) {\n      const scale = getNormalizedComponentScale(outputArray.constructor);\n      const scaled = new Float32Array(outputArray.length);\n      for (let j = 0, jl = outputArray.length; j < jl; j++) {\n        scaled[j] = outputArray[j] * scale;\n      }\n      outputArray = scaled;\n    }\n    return outputArray;\n  }\n  _createCubicSplineTrackInterpolant(track) {\n    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n      const interpolantType = this instanceof three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n    };\n    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n  }\n}\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\n  if (attributes.POSITION !== void 0) {\n    const accessor = parser.json.accessors[attributes.POSITION];\n    const min = accessor.min;\n    const max = accessor.max;\n    if (min !== void 0 && max !== void 0) {\n      box.set(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(min[0], min[1], min[2]), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(max[0], max[1], max[2]));\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n        box.min.multiplyScalar(boxScale);\n        box.max.multiplyScalar(boxScale);\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n      return;\n    }\n  } else {\n    return;\n  }\n  const targets = primitiveDef.targets;\n  if (targets !== void 0) {\n    const maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i];\n      if (target.POSITION !== void 0) {\n        const accessor = parser.json.accessors[target.POSITION];\n        const min = accessor.min;\n        const max = accessor.max;\n        if (min !== void 0 && max !== void 0) {\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n            vector.multiplyScalar(boxScale);\n          }\n          maxDisplacement.max(vector);\n        } else {\n          console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n        }\n      }\n    }\n    box.expandByVector(maxDisplacement);\n  }\n  geometry.boundingBox = box;\n  const sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n  box.getCenter(sphere.center);\n  sphere.radius = box.min.distanceTo(box.max) / 2;\n  geometry.boundingSphere = sphere;\n}\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const pending = [];\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency(\"accessor\", accessorIndex).then(function(accessor) {\n      geometry.setAttribute(attributeName, accessor);\n    });\n  }\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n    if (threeAttributeName in geometry.attributes)\n      continue;\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n  }\n  if (primitiveDef.indices !== void 0 && !geometry.index) {\n    const accessor = parser.getDependency(\"accessor\", primitiveDef.indices).then(function(accessor2) {\n      geometry.setIndex(accessor2);\n    });\n    pending.push(accessor);\n  }\n  assignExtrasToUserData(geometry, primitiveDef);\n  computeBounds(geometry, primitiveDef, parser);\n  return Promise.all(pending).then(function() {\n    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n  });\n}\n\n//# sourceMappingURL=GLTFLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvR0xURkxvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwOUI7QUFDcDVCO0FBQ2xCO0FBQ0s7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUNBQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwwQkFBMEIsOENBQVc7QUFDckMscUJBQXFCLDhDQUFXO0FBQ2hDLE1BQU07QUFDTixxQkFBcUIsOENBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZDQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msd0NBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHdDQUFLO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3Q0FBSztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMENBQU87QUFDN0Isc0JBQXNCLDBDQUFPO0FB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LFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5Q0FBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFHRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvc2NobmVpZGVyY2FkZXQvRGVza3RvcC9maXp6aS9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvR0xURkxvYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb2FkZXIsIExvYWRlclV0aWxzLCBGaWxlTG9hZGVyLCBDb2xvciwgU3BvdExpZ2h0LCBQb2ludExpZ2h0LCBEaXJlY3Rpb25hbExpZ2h0LCBNZXNoQmFzaWNNYXRlcmlhbCwgTWVzaFBoeXNpY2FsTWF0ZXJpYWwsIFZlY3RvcjIsIE1hdHJpeDQsIFZlY3RvcjMsIFF1YXRlcm5pb24sIEluc3RhbmNlZE1lc2gsIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSwgT2JqZWN0M0QsIFRleHR1cmVMb2FkZXIsIEltYWdlQml0bWFwTG9hZGVyLCBCdWZmZXJBdHRyaWJ1dGUsIEludGVybGVhdmVkQnVmZmVyLCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSwgTGluZWFyRmlsdGVyLCBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIsIFJlcGVhdFdyYXBwaW5nLCBQb2ludHNNYXRlcmlhbCwgTWF0ZXJpYWwsIExpbmVCYXNpY01hdGVyaWFsLCBNZXNoU3RhbmRhcmRNYXRlcmlhbCwgRG91YmxlU2lkZSwgUHJvcGVydHlCaW5kaW5nLCBCdWZmZXJHZW9tZXRyeSwgU2tpbm5lZE1lc2gsIE1lc2gsIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSwgVHJpYW5nbGVGYW5EcmF3TW9kZSwgTGluZVNlZ21lbnRzLCBMaW5lLCBMaW5lTG9vcCwgUG9pbnRzLCBHcm91cCwgUGVyc3BlY3RpdmVDYW1lcmEsIE1hdGhVdGlscywgT3J0aG9ncmFwaGljQ2FtZXJhLCBTa2VsZXRvbiwgQW5pbWF0aW9uQ2xpcCwgQm9uZSwgSW50ZXJwb2xhdGVMaW5lYXIsIE5lYXJlc3RGaWx0ZXIsIE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLCBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyLCBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyLCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLCBJbnRlcnBvbGF0ZURpc2NyZXRlLCBGcm9udFNpZGUsIFRleHR1cmUsIFZlY3RvcktleWZyYW1lVHJhY2ssIE51bWJlcktleWZyYW1lVHJhY2ssIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLCBCb3gzLCBTcGhlcmUsIEludGVycG9sYW50IH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgeyB0b1RyaWFuZ2xlc0RyYXdNb2RlIH0gZnJvbSBcIi4uL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanNcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3BvbHlmaWxsL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgZGVjb2RlVGV4dCB9IGZyb20gXCIuLi9fcG9seWZpbGwvTG9hZGVyVXRpbHMuanNcIjtcbmNvbnN0IFNSR0JDb2xvclNwYWNlID0gXCJzcmdiXCI7XG5jb25zdCBMaW5lYXJTUkdCQ29sb3JTcGFjZSA9IFwic3JnYi1saW5lYXJcIjtcbmNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG5jb25zdCBMaW5lYXJFbmNvZGluZyA9IDNlMztcbmNsYXNzIEdMVEZMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG4gICAgc3VwZXIobWFuYWdlcik7XG4gICAgdGhpcy5kcmFjb0xvYWRlciA9IG51bGw7XG4gICAgdGhpcy5rdHgyTG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLm1lc2hvcHREZWNvZGVyID0gbnVsbDtcbiAgICB0aGlzLnBsdWdpbkNhbGxiYWNrcyA9IFtdO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNDbGVhcmNvYXRFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzRGlzcGVyc2lvbkV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZUZXh0dXJlQmFzaXNVRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURlRleHR1cmVXZWJQRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURlRleHR1cmVBVklGRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1NoZWVuRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1RyYW5zbWlzc2lvbkV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNWb2x1bWVFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzSW9yRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0VtaXNzaXZlU3RyZW5ndGhFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzU3BlY3VsYXJFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzSXJpZGVzY2VuY2VFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzQW5pc290cm9weUV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNCdW1wRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURkxpZ2h0c0V4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNZXNob3B0Q29tcHJlc3Npb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWVzaEdwdUluc3RhbmNpbmcocGFyc2VyKTtcbiAgICB9KTtcbiAgfVxuICBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzO1xuICAgIGxldCByZXNvdXJjZVBhdGg7XG4gICAgaWYgKHRoaXMucmVzb3VyY2VQYXRoICE9PSBcIlwiKSB7XG4gICAgICByZXNvdXJjZVBhdGggPSB0aGlzLnJlc291cmNlUGF0aDtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGF0aCAhPT0gXCJcIikge1xuICAgICAgY29uc3QgcmVsYXRpdmVVcmwgPSBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSh1cmwpO1xuICAgICAgcmVzb3VyY2VQYXRoID0gTG9hZGVyVXRpbHMucmVzb2x2ZVVSTChyZWxhdGl2ZVVybCwgdGhpcy5wYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb3VyY2VQYXRoID0gTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UodXJsKTtcbiAgICB9XG4gICAgdGhpcy5tYW5hZ2VyLml0ZW1TdGFydCh1cmwpO1xuICAgIGNvbnN0IF9vbkVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FcnJvcih1cmwpO1xuICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG4gICAgfTtcbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLm1hbmFnZXIpO1xuICAgIGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgbG9hZGVyLnNldFJlc3BvbnNlVHlwZShcImFycmF5YnVmZmVyXCIpO1xuICAgIGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgbG9hZGVyLmxvYWQoXG4gICAgICB1cmwsXG4gICAgICBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2NvcGUucGFyc2UoXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcmVzb3VyY2VQYXRoLFxuICAgICAgICAgICAgZnVuY3Rpb24oZ2x0Zikge1xuICAgICAgICAgICAgICBvbkxvYWQoZ2x0Zik7XG4gICAgICAgICAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9vbkVycm9yXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIF9vbkVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Qcm9ncmVzcyxcbiAgICAgIF9vbkVycm9yXG4gICAgKTtcbiAgfVxuICBzZXREUkFDT0xvYWRlcihkcmFjb0xvYWRlcikge1xuICAgIHRoaXMuZHJhY29Mb2FkZXIgPSBkcmFjb0xvYWRlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRERFNMb2FkZXIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUSFJFRS5HTFRGTG9hZGVyOiBcIk1TRlRfdGV4dHVyZV9kZHNcIiBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgdXBkYXRlIHRvIFwiS0hSX3RleHR1cmVfYmFzaXN1XCIuJyk7XG4gIH1cbiAgc2V0S1RYMkxvYWRlcihrdHgyTG9hZGVyKSB7XG4gICAgdGhpcy5rdHgyTG9hZGVyID0ga3R4MkxvYWRlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRNZXNob3B0RGVjb2RlcihtZXNob3B0RGVjb2Rlcikge1xuICAgIHRoaXMubWVzaG9wdERlY29kZXIgPSBtZXNob3B0RGVjb2RlcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWdpc3RlcihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnBsdWdpbkNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMucGx1Z2luQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB1bnJlZ2lzdGVyKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spICE9PSAtMSkge1xuICAgICAgdGhpcy5wbHVnaW5DYWxsYmFja3Muc3BsaWNlKHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcGFyc2UoZGF0YSwgcGF0aCwgb25Mb2FkLCBvbkVycm9yKSB7XG4gICAgbGV0IGpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHt9O1xuICAgIGNvbnN0IHBsdWdpbnMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGpzb24gPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICBjb25zdCBtYWdpYyA9IGRlY29kZVRleHQobmV3IFVpbnQ4QXJyYXkoZGF0YS5zbGljZSgwLCA0KSkpO1xuICAgICAgaWYgKG1hZ2ljID09PSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEZdID0gbmV3IEdMVEZCaW5hcnlFeHRlbnNpb24oZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaWYgKG9uRXJyb3IpXG4gICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAganNvbiA9IEpTT04ucGFyc2UoZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURl0uY29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqc29uID0gSlNPTi5wYXJzZShkZWNvZGVUZXh0KG5ldyBVaW50OEFycmF5KGRhdGEpKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGpzb24gPSBkYXRhO1xuICAgIH1cbiAgICBpZiAoanNvbi5hc3NldCA9PT0gdm9pZCAwIHx8IGpzb24uYXNzZXQudmVyc2lvblswXSA8IDIpIHtcbiAgICAgIGlmIChvbkVycm9yKVxuICAgICAgICBvbkVycm9yKG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGFzc2V0LiBnbFRGIHZlcnNpb25zID49Mi4wIGFyZSBzdXBwb3J0ZWQuXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IEdMVEZQYXJzZXIoanNvbiwge1xuICAgICAgcGF0aDogcGF0aCB8fCB0aGlzLnJlc291cmNlUGF0aCB8fCBcIlwiLFxuICAgICAgY3Jvc3NPcmlnaW46IHRoaXMuY3Jvc3NPcmlnaW4sXG4gICAgICByZXF1ZXN0SGVhZGVyOiB0aGlzLnJlcXVlc3RIZWFkZXIsXG4gICAgICBtYW5hZ2VyOiB0aGlzLm1hbmFnZXIsXG4gICAgICBrdHgyTG9hZGVyOiB0aGlzLmt0eDJMb2FkZXIsXG4gICAgICBtZXNob3B0RGVjb2RlcjogdGhpcy5tZXNob3B0RGVjb2RlclxuICAgIH0pO1xuICAgIHBhcnNlci5maWxlTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2luQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnBsdWdpbkNhbGxiYWNrc1tpXShwYXJzZXIpO1xuICAgICAgaWYgKCFwbHVnaW4ubmFtZSlcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IEludmFsaWQgcGx1Z2luIGZvdW5kOiBtaXNzaW5nIG5hbWVcIik7XG4gICAgICBwbHVnaW5zW3BsdWdpbi5uYW1lXSA9IHBsdWdpbjtcbiAgICAgIGV4dGVuc2lvbnNbcGx1Z2luLm5hbWVdID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGpzb24uZXh0ZW5zaW9uc1VzZWQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5leHRlbnNpb25zVXNlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBleHRlbnNpb25OYW1lID0ganNvbi5leHRlbnNpb25zVXNlZFtpXTtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uc1JlcXVpcmVkID0ganNvbi5leHRlbnNpb25zUmVxdWlyZWQgfHwgW107XG4gICAgICAgIHN3aXRjaCAoZXh0ZW5zaW9uTmFtZSkge1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUOlxuICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXSA9IG5ldyBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjpcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gPSBuZXcgR0xURkRyYWNvTWVzaENvbXByZXNzaW9uRXh0ZW5zaW9uKGpzb24sIHRoaXMuZHJhY29Mb2FkZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STTpcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gPSBuZXcgR0xURlRleHR1cmVUcmFuc2Zvcm1FeHRlbnNpb24oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfTUVTSF9RVUFOVElaQVRJT046XG4gICAgICAgICAgICBleHRlbnNpb25zW2V4dGVuc2lvbk5hbWVdID0gbmV3IEdMVEZNZXNoUXVhbnRpemF0aW9uRXh0ZW5zaW9uKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKGV4dGVuc2lvbk5hbWUpID49IDAgJiYgcGx1Z2luc1tleHRlbnNpb25OYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuR0xURkxvYWRlcjogVW5rbm93biBleHRlbnNpb24gXCInICsgZXh0ZW5zaW9uTmFtZSArICdcIi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwYXJzZXIuc2V0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgICBwYXJzZXIuc2V0UGx1Z2lucyhwbHVnaW5zKTtcbiAgICBwYXJzZXIucGFyc2Uob25Mb2FkLCBvbkVycm9yKTtcbiAgfVxuICBwYXJzZUFzeW5jKGRhdGEsIHBhdGgpIHtcbiAgICBjb25zdCBzY29wZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgc2NvcGUucGFyc2UoZGF0YSwgcGF0aCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gR0xURlJlZ2lzdHJ5KCkge1xuICBsZXQgb2JqZWN0cyA9IHt9O1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0c1trZXldO1xuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbihrZXksIG9iamVjdCkge1xuICAgICAgb2JqZWN0c1trZXldID0gb2JqZWN0O1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGRlbGV0ZSBvYmplY3RzW2tleV07XG4gICAgfSxcbiAgICByZW1vdmVBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgb2JqZWN0cyA9IHt9O1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IEVYVEVOU0lPTlMgPSB7XG4gIEtIUl9CSU5BUllfR0xURjogXCJLSFJfYmluYXJ5X2dsVEZcIixcbiAgS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT046IFwiS0hSX2RyYWNvX21lc2hfY29tcHJlc3Npb25cIixcbiAgS0hSX0xJR0hUU19QVU5DVFVBTDogXCJLSFJfbGlnaHRzX3B1bmN0dWFsXCIsXG4gIEtIUl9NQVRFUklBTFNfQ0xFQVJDT0FUOiBcIktIUl9tYXRlcmlhbHNfY2xlYXJjb2F0XCIsXG4gIEtIUl9NQVRFUklBTFNfRElTUEVSU0lPTjogXCJLSFJfbWF0ZXJpYWxzX2Rpc3BlcnNpb25cIixcbiAgS0hSX01BVEVSSUFMU19JT1I6IFwiS0hSX21hdGVyaWFsc19pb3JcIixcbiAgS0hSX01BVEVSSUFMU19TSEVFTjogXCJLSFJfbWF0ZXJpYWxzX3NoZWVuXCIsXG4gIEtIUl9NQVRFUklBTFNfU1BFQ1VMQVI6IFwiS0hSX21hdGVyaWFsc19zcGVjdWxhclwiLFxuICBLSFJfTUFURVJJQUxTX1RSQU5TTUlTU0lPTjogXCJLSFJfbWF0ZXJpYWxzX3RyYW5zbWlzc2lvblwiLFxuICBLSFJfTUFURVJJQUxTX0lSSURFU0NFTkNFOiBcIktIUl9tYXRlcmlhbHNfaXJpZGVzY2VuY2VcIixcbiAgS0hSX01BVEVSSUFMU19BTklTT1RST1BZOiBcIktIUl9tYXRlcmlhbHNfYW5pc290cm9weVwiLFxuICBLSFJfTUFURVJJQUxTX1VOTElUOiBcIktIUl9tYXRlcmlhbHNfdW5saXRcIixcbiAgS0hSX01BVEVSSUFMU19WT0xVTUU6IFwiS0hSX21hdGVyaWFsc192b2x1bWVcIixcbiAgS0hSX1RFWFRVUkVfQkFTSVNVOiBcIktIUl90ZXh0dXJlX2Jhc2lzdVwiLFxuICBLSFJfVEVYVFVSRV9UUkFOU0ZPUk06IFwiS0hSX3RleHR1cmVfdHJhbnNmb3JtXCIsXG4gIEtIUl9NRVNIX1FVQU5USVpBVElPTjogXCJLSFJfbWVzaF9xdWFudGl6YXRpb25cIixcbiAgS0hSX01BVEVSSUFMU19FTUlTU0lWRV9TVFJFTkdUSDogXCJLSFJfbWF0ZXJpYWxzX2VtaXNzaXZlX3N0cmVuZ3RoXCIsXG4gIEVYVF9NQVRFUklBTFNfQlVNUDogXCJFWFRfbWF0ZXJpYWxzX2J1bXBcIixcbiAgRVhUX1RFWFRVUkVfV0VCUDogXCJFWFRfdGV4dHVyZV93ZWJwXCIsXG4gIEVYVF9URVhUVVJFX0FWSUY6IFwiRVhUX3RleHR1cmVfYXZpZlwiLFxuICBFWFRfTUVTSE9QVF9DT01QUkVTU0lPTjogXCJFWFRfbWVzaG9wdF9jb21wcmVzc2lvblwiLFxuICBFWFRfTUVTSF9HUFVfSU5TVEFOQ0lORzogXCJFWFRfbWVzaF9ncHVfaW5zdGFuY2luZ1wiXG59O1xuY2xhc3MgR0xURkxpZ2h0c0V4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX0xJR0hUU19QVU5DVFVBTDtcbiAgICB0aGlzLmNhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcbiAgfVxuICBfbWFya0RlZnMoKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3Qgbm9kZURlZnMgPSB0aGlzLnBhcnNlci5qc29uLm5vZGVzIHx8IFtdO1xuICAgIGZvciAobGV0IG5vZGVJbmRleCA9IDAsIG5vZGVMZW5ndGggPSBub2RlRGVmcy5sZW5ndGg7IG5vZGVJbmRleCA8IG5vZGVMZW5ndGg7IG5vZGVJbmRleCsrKSB7XG4gICAgICBjb25zdCBub2RlRGVmID0gbm9kZURlZnNbbm9kZUluZGV4XTtcbiAgICAgIGlmIChub2RlRGVmLmV4dGVuc2lvbnMgJiYgbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0gJiYgbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0ubGlnaHQgIT09IHZvaWQgMCkge1xuICAgICAgICBwYXJzZXIuX2FkZE5vZGVSZWYodGhpcy5jYWNoZSwgbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0ubGlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfbG9hZExpZ2h0KGxpZ2h0SW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBjYWNoZUtleSA9IFwibGlnaHQ6XCIgKyBsaWdodEluZGV4O1xuICAgIGxldCBkZXBlbmRlbmN5ID0gcGFyc2VyLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKGRlcGVuZGVuY3kpXG4gICAgICByZXR1cm4gZGVwZW5kZW5jeTtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IGpzb24uZXh0ZW5zaW9ucyAmJiBqc29uLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSB8fCB7fTtcbiAgICBjb25zdCBsaWdodERlZnMgPSBleHRlbnNpb25zLmxpZ2h0cyB8fCBbXTtcbiAgICBjb25zdCBsaWdodERlZiA9IGxpZ2h0RGVmc1tsaWdodEluZGV4XTtcbiAgICBsZXQgbGlnaHROb2RlO1xuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yKDE2Nzc3MjE1KTtcbiAgICBpZiAobGlnaHREZWYuY29sb3IgIT09IHZvaWQgMClcbiAgICAgIGNvbG9yLnNldFJHQihsaWdodERlZi5jb2xvclswXSwgbGlnaHREZWYuY29sb3JbMV0sIGxpZ2h0RGVmLmNvbG9yWzJdLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgY29uc3QgcmFuZ2UgPSBsaWdodERlZi5yYW5nZSAhPT0gdm9pZCAwID8gbGlnaHREZWYucmFuZ2UgOiAwO1xuICAgIHN3aXRjaCAobGlnaHREZWYudHlwZSkge1xuICAgICAgY2FzZSBcImRpcmVjdGlvbmFsXCI6XG4gICAgICAgIGxpZ2h0Tm9kZSA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KGNvbG9yKTtcbiAgICAgICAgbGlnaHROb2RlLnRhcmdldC5wb3NpdGlvbi5zZXQoMCwgMCwgLTEpO1xuICAgICAgICBsaWdodE5vZGUuYWRkKGxpZ2h0Tm9kZS50YXJnZXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb2ludFwiOlxuICAgICAgICBsaWdodE5vZGUgPSBuZXcgUG9pbnRMaWdodChjb2xvcik7XG4gICAgICAgIGxpZ2h0Tm9kZS5kaXN0YW5jZSA9IHJhbmdlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzcG90XCI6XG4gICAgICAgIGxpZ2h0Tm9kZSA9IG5ldyBTcG90TGlnaHQoY29sb3IpO1xuICAgICAgICBsaWdodE5vZGUuZGlzdGFuY2UgPSByYW5nZTtcbiAgICAgICAgbGlnaHREZWYuc3BvdCA9IGxpZ2h0RGVmLnNwb3QgfHwge307XG4gICAgICAgIGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgPSBsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlICE9PSB2b2lkIDAgPyBsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlIDogMDtcbiAgICAgICAgbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZSA9IGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgIT09IHZvaWQgMCA/IGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgOiBNYXRoLlBJIC8gNDtcbiAgICAgICAgbGlnaHROb2RlLmFuZ2xlID0gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZTtcbiAgICAgICAgbGlnaHROb2RlLnBlbnVtYnJhID0gMSAtIGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgLyBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlO1xuICAgICAgICBsaWdodE5vZGUudGFyZ2V0LnBvc2l0aW9uLnNldCgwLCAwLCAtMSk7XG4gICAgICAgIGxpZ2h0Tm9kZS5hZGQobGlnaHROb2RlLnRhcmdldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5leHBlY3RlZCBsaWdodCB0eXBlOiBcIiArIGxpZ2h0RGVmLnR5cGUpO1xuICAgIH1cbiAgICBsaWdodE5vZGUucG9zaXRpb24uc2V0KDAsIDAsIDApO1xuICAgIGxpZ2h0Tm9kZS5kZWNheSA9IDI7XG4gICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShsaWdodE5vZGUsIGxpZ2h0RGVmKTtcbiAgICBpZiAobGlnaHREZWYuaW50ZW5zaXR5ICE9PSB2b2lkIDApXG4gICAgICBsaWdodE5vZGUuaW50ZW5zaXR5ID0gbGlnaHREZWYuaW50ZW5zaXR5O1xuICAgIGxpZ2h0Tm9kZS5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUobGlnaHREZWYubmFtZSB8fCBcImxpZ2h0X1wiICsgbGlnaHRJbmRleCk7XG4gICAgZGVwZW5kZW5jeSA9IFByb21pc2UucmVzb2x2ZShsaWdodE5vZGUpO1xuICAgIHBhcnNlci5jYWNoZS5hZGQoY2FjaGVLZXksIGRlcGVuZGVuY3kpO1xuICAgIHJldHVybiBkZXBlbmRlbmN5O1xuICB9XG4gIGdldERlcGVuZGVuY3kodHlwZSwgaW5kZXgpIHtcbiAgICBpZiAodHlwZSAhPT0gXCJsaWdodFwiKVxuICAgICAgcmV0dXJuO1xuICAgIHJldHVybiB0aGlzLl9sb2FkTGlnaHQoaW5kZXgpO1xuICB9XG4gIGNyZWF0ZU5vZGVBdHRhY2htZW50KG5vZGVJbmRleCkge1xuICAgIGNvbnN0IHNlbGYyID0gdGhpcztcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBjb25zdCBsaWdodERlZiA9IG5vZGVEZWYuZXh0ZW5zaW9ucyAmJiBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSB8fCB7fTtcbiAgICBjb25zdCBsaWdodEluZGV4ID0gbGlnaHREZWYubGlnaHQ7XG4gICAgaWYgKGxpZ2h0SW5kZXggPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLl9sb2FkTGlnaHQobGlnaHRJbmRleCkudGhlbihmdW5jdGlvbihsaWdodCkge1xuICAgICAgcmV0dXJuIHBhcnNlci5fZ2V0Tm9kZVJlZihzZWxmMi5jYWNoZSwgbGlnaHRJbmRleCwgbGlnaHQpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVQ7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKCkge1xuICAgIHJldHVybiBNZXNoQmFzaWNNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRQYXJhbXMobWF0ZXJpYWxQYXJhbXMsIG1hdGVyaWFsRGVmLCBwYXJzZXIpIHtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgbWF0ZXJpYWxQYXJhbXMuY29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSk7XG4gICAgbWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IDE7XG4gICAgY29uc3QgbWV0YWxsaWNSb3VnaG5lc3MgPSBtYXRlcmlhbERlZi5wYnJNZXRhbGxpY1JvdWdobmVzcztcbiAgICBpZiAobWV0YWxsaWNSb3VnaG5lc3MpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcikpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3I7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmNvbG9yLnNldFJHQihhcnJheVswXSwgYXJyYXlbMV0sIGFycmF5WzJdLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSBhcnJheVszXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcIm1hcFwiLCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNFbWlzc2l2ZVN0cmVuZ3RoRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0VNSVNTSVZFX1NUUkVOR1RIO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgZW1pc3NpdmVTdHJlbmd0aCA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5lbWlzc2l2ZVN0cmVuZ3RoO1xuICAgIGlmIChlbWlzc2l2ZVN0cmVuZ3RoICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmVtaXNzaXZlSW50ZW5zaXR5ID0gZW1pc3NpdmVTdHJlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzQ2xlYXJjb2F0RXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0NMRUFSQ09BVDtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdEZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5jbGVhcmNvYXQgPSBleHRlbnNpb24uY2xlYXJjb2F0RmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdFRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImNsZWFyY29hdE1hcFwiLCBleHRlbnNpb24uY2xlYXJjb2F0VGV4dHVyZSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc0ZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5jbGVhcmNvYXRSb3VnaG5lc3MgPSBleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc1RleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImNsZWFyY29hdFJvdWdobmVzc01hcFwiLCBleHRlbnNpb24uY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImNsZWFyY29hdE5vcm1hbE1hcFwiLCBleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSkpO1xuICAgICAgaWYgKGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlLnNjYWxlICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZS5zY2FsZTtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuY2xlYXJjb2F0Tm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMihzY2FsZSwgc2NhbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNEaXNwZXJzaW9uRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0RJU1BFUlNJT047XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5kaXNwZXJzaW9uID0gZXh0ZW5zaW9uLmRpc3BlcnNpb24gIT09IHZvaWQgMCA/IGV4dGVuc2lvbi5kaXNwZXJzaW9uIDogMDtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNJcmlkZXNjZW5jZUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19JUklERVNDRU5DRTtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlID0gZXh0ZW5zaW9uLmlyaWRlc2NlbmNlRmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiaXJpZGVzY2VuY2VNYXBcIiwgZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGV4dHVyZSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlSW9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlSU9SID0gZXh0ZW5zaW9uLmlyaWRlc2NlbmNlSW9yO1xuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9PT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlID0gWzEwMCwgNDAwXTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW0gIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZVswXSA9IGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW07XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2VbMV0gPSBleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImlyaWRlc2NlbmNlVGhpY2tuZXNzTWFwXCIsIGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmUpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNTaGVlbkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19TSEVFTjtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNoZWVuQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCk7XG4gICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW5Sb3VnaG5lc3MgPSAwO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNoZWVuID0gMTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgaWYgKGV4dGVuc2lvbi5zaGVlbkNvbG9yRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGNvbG9yRmFjdG9yID0gZXh0ZW5zaW9uLnNoZWVuQ29sb3JGYWN0b3I7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5zaGVlbkNvbG9yLnNldFJHQihjb2xvckZhY3RvclswXSwgY29sb3JGYWN0b3JbMV0sIGNvbG9yRmFjdG9yWzJdLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uc2hlZW5Sb3VnaG5lc3NGYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW5Sb3VnaG5lc3MgPSBleHRlbnNpb24uc2hlZW5Sb3VnaG5lc3NGYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uc2hlZW5Db2xvclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInNoZWVuQ29sb3JNYXBcIiwgZXh0ZW5zaW9uLnNoZWVuQ29sb3JUZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLnNoZWVuUm91Z2huZXNzVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwic2hlZW5Sb3VnaG5lc3NNYXBcIiwgZXh0ZW5zaW9uLnNoZWVuUm91Z2huZXNzVGV4dHVyZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNUcmFuc21pc3Npb25FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVFJBTlNNSVNTSU9OO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGlmIChleHRlbnNpb24udHJhbnNtaXNzaW9uRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnRyYW5zbWlzc2lvbiA9IGV4dGVuc2lvbi50cmFuc21pc3Npb25GYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24udHJhbnNtaXNzaW9uVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwidHJhbnNtaXNzaW9uTWFwXCIsIGV4dGVuc2lvbi50cmFuc21pc3Npb25UZXh0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc1ZvbHVtZUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19WT0xVTUU7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgbWF0ZXJpYWxQYXJhbXMudGhpY2tuZXNzID0gZXh0ZW5zaW9uLnRoaWNrbmVzc0ZhY3RvciAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLnRoaWNrbmVzc0ZhY3RvciA6IDA7XG4gICAgaWYgKGV4dGVuc2lvbi50aGlja25lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJ0aGlja25lc3NNYXBcIiwgZXh0ZW5zaW9uLnRoaWNrbmVzc1RleHR1cmUpKTtcbiAgICB9XG4gICAgbWF0ZXJpYWxQYXJhbXMuYXR0ZW51YXRpb25EaXN0YW5jZSA9IGV4dGVuc2lvbi5hdHRlbnVhdGlvbkRpc3RhbmNlIHx8IEluZmluaXR5O1xuICAgIGNvbnN0IGNvbG9yQXJyYXkgPSBleHRlbnNpb24uYXR0ZW51YXRpb25Db2xvciB8fCBbMSwgMSwgMV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuYXR0ZW51YXRpb25Db2xvciA9IG5ldyBDb2xvcigpLnNldFJHQihcbiAgICAgIGNvbG9yQXJyYXlbMF0sXG4gICAgICBjb2xvckFycmF5WzFdLFxuICAgICAgY29sb3JBcnJheVsyXSxcbiAgICAgIExpbmVhclNSR0JDb2xvclNwYWNlXG4gICAgKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNJb3JFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfSU9SO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuaW9yID0gZXh0ZW5zaW9uLmlvciAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLmlvciA6IDEuNTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNTcGVjdWxhckV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19TUEVDVUxBUjtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5zcGVjdWxhckludGVuc2l0eSA9IGV4dGVuc2lvbi5zcGVjdWxhckZhY3RvciAhPT0gdm9pZCAwID8gZXh0ZW5zaW9uLnNwZWN1bGFyRmFjdG9yIDogMTtcbiAgICBpZiAoZXh0ZW5zaW9uLnNwZWN1bGFyVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwic3BlY3VsYXJJbnRlbnNpdHlNYXBcIiwgZXh0ZW5zaW9uLnNwZWN1bGFyVGV4dHVyZSkpO1xuICAgIH1cbiAgICBjb25zdCBjb2xvckFycmF5ID0gZXh0ZW5zaW9uLnNwZWN1bGFyQ29sb3JGYWN0b3IgfHwgWzEsIDEsIDFdO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFyQ29sb3IgPSBuZXcgQ29sb3IoKS5zZXRSR0IoY29sb3JBcnJheVswXSwgY29sb3JBcnJheVsxXSwgY29sb3JBcnJheVsyXSwgTGluZWFyU1JHQkNvbG9yU3BhY2UpO1xuICAgIGlmIChleHRlbnNpb24uc3BlY3VsYXJDb2xvclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICBwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJzcGVjdWxhckNvbG9yTWFwXCIsIGV4dGVuc2lvbi5zcGVjdWxhckNvbG9yVGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNCdW1wRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfTUFURVJJQUxTX0JVTVA7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuYnVtcFNjYWxlID0gZXh0ZW5zaW9uLmJ1bXBGYWN0b3IgIT09IHZvaWQgMCA/IGV4dGVuc2lvbi5idW1wRmFjdG9yIDogMTtcbiAgICBpZiAoZXh0ZW5zaW9uLmJ1bXBUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJidW1wTWFwXCIsIGV4dGVuc2lvbi5idW1wVGV4dHVyZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNBbmlzb3Ryb3B5RXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0FOSVNPVFJPUFk7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgaWYgKGV4dGVuc2lvbi5hbmlzb3Ryb3B5U3RyZW5ndGggIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuYW5pc290cm9weSA9IGV4dGVuc2lvbi5hbmlzb3Ryb3B5U3RyZW5ndGg7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uYW5pc290cm9weVJvdGF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmFuaXNvdHJvcHlSb3RhdGlvbiA9IGV4dGVuc2lvbi5hbmlzb3Ryb3B5Um90YXRpb247XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uYW5pc290cm9weVRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImFuaXNvdHJvcHlNYXBcIiwgZXh0ZW5zaW9uLmFuaXNvdHJvcHlUZXh0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURlRleHR1cmVCYXNpc1VFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9URVhUVVJFX0JBU0lTVTtcbiAgfVxuICBsb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3QgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbdGV4dHVyZUluZGV4XTtcbiAgICBpZiAoIXRleHR1cmVEZWYuZXh0ZW5zaW9ucyB8fCAhdGV4dHVyZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBjb25zdCBsb2FkZXIgPSBwYXJzZXIub3B0aW9ucy5rdHgyTG9hZGVyO1xuICAgIGlmICghbG9hZGVyKSB7XG4gICAgICBpZiAoanNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZih0aGlzLm5hbWUpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogc2V0S1RYMkxvYWRlciBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgbG9hZGluZyBLVFgyIHRleHR1cmVzXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIGV4dGVuc2lvbi5zb3VyY2UsIGxvYWRlcik7XG4gIH1cbn1cbmNsYXNzIEdMVEZUZXh0dXJlV2ViUEV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuRVhUX1RFWFRVUkVfV0VCUDtcbiAgICB0aGlzLmlzU3VwcG9ydGVkID0gbnVsbDtcbiAgfVxuICBsb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGlmICghdGV4dHVyZURlZi5leHRlbnNpb25zIHx8ICF0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbbmFtZV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbbmFtZV07XG4gICAgY29uc3Qgc291cmNlID0ganNvbi5pbWFnZXNbZXh0ZW5zaW9uLnNvdXJjZV07XG4gICAgbGV0IGxvYWRlciA9IHBhcnNlci50ZXh0dXJlTG9hZGVyO1xuICAgIGlmIChzb3VyY2UudXJpKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gcGFyc2VyLm9wdGlvbnMubWFuYWdlci5nZXRIYW5kbGVyKHNvdXJjZS51cmkpO1xuICAgICAgaWYgKGhhbmRsZXIgIT09IG51bGwpXG4gICAgICAgIGxvYWRlciA9IGhhbmRsZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRldGVjdFN1cHBvcnQoKS50aGVuKGZ1bmN0aW9uKGlzU3VwcG9ydGVkKSB7XG4gICAgICBpZiAoaXNTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIGV4dGVuc2lvbi5zb3VyY2UsIGxvYWRlcik7XG4gICAgICBpZiAoanNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFdlYlAgcmVxdWlyZWQgYnkgYXNzZXQgYnV0IHVuc3VwcG9ydGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmUodGV4dHVyZUluZGV4KTtcbiAgICB9KTtcbiAgfVxuICBkZXRlY3RTdXBwb3J0KCkge1xuICAgIGlmICghdGhpcy5pc1N1cHBvcnRlZCkge1xuICAgICAgdGhpcy5pc1N1cHBvcnRlZCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1hZ2Uuc3JjID0gXCJkYXRhOmltYWdlL3dlYnA7YmFzZTY0LFVrbEdSaUlBQUFCWFJVSlFWbEE0SUJZQUFBQXdBUUNkQVNvQkFBRUFEc0QrSmFRQUEzQUFBQUFBXCI7XG4gICAgICAgIGltYWdlLm9ubG9hZCA9IGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXNvbHZlKGltYWdlLmhlaWdodCA9PT0gMSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXNTdXBwb3J0ZWQ7XG4gIH1cbn1cbmNsYXNzIEdMVEZUZXh0dXJlQVZJRkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuRVhUX1RFWFRVUkVfQVZJRjtcbiAgICB0aGlzLmlzU3VwcG9ydGVkID0gbnVsbDtcbiAgfVxuICBsb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGlmICghdGV4dHVyZURlZi5leHRlbnNpb25zIHx8ICF0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbbmFtZV0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSB0ZXh0dXJlRGVmLmV4dGVuc2lvbnNbbmFtZV07XG4gICAgY29uc3Qgc291cmNlID0ganNvbi5pbWFnZXNbZXh0ZW5zaW9uLnNvdXJjZV07XG4gICAgbGV0IGxvYWRlciA9IHBhcnNlci50ZXh0dXJlTG9hZGVyO1xuICAgIGlmIChzb3VyY2UudXJpKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gcGFyc2VyLm9wdGlvbnMubWFuYWdlci5nZXRIYW5kbGVyKHNvdXJjZS51cmkpO1xuICAgICAgaWYgKGhhbmRsZXIgIT09IG51bGwpXG4gICAgICAgIGxvYWRlciA9IGhhbmRsZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRldGVjdFN1cHBvcnQoKS50aGVuKGZ1bmN0aW9uKGlzU3VwcG9ydGVkKSB7XG4gICAgICBpZiAoaXNTdXBwb3J0ZWQpXG4gICAgICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIGV4dGVuc2lvbi5zb3VyY2UsIGxvYWRlcik7XG4gICAgICBpZiAoanNvbi5leHRlbnNpb25zUmVxdWlyZWQgJiYganNvbi5leHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IEFWSUYgcmVxdWlyZWQgYnkgYXNzZXQgYnV0IHVuc3VwcG9ydGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZXIubG9hZFRleHR1cmUodGV4dHVyZUluZGV4KTtcbiAgICB9KTtcbiAgfVxuICBkZXRlY3RTdXBwb3J0KCkge1xuICAgIGlmICghdGhpcy5pc1N1cHBvcnRlZCkge1xuICAgICAgdGhpcy5pc1N1cHBvcnRlZCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1hZ2Uuc3JjID0gXCJkYXRhOmltYWdlL2F2aWY7YmFzZTY0LEFBQUFJR1owZVhCaGRtbG1BQUFBQUdGMmFXWnRhV1l4YldsaFprMUJNVUlBQUFEeWJXVjBZUUFBQUFBQUFBQW9hR1JzY2dBQUFBQUFBQUFBY0dsamRBQUFBQUFBQUFBQUFBQUFBR3hwWW1GMmFXWUFBQUFBRG5CcGRHMEFBQUFBQUFFQUFBQWVhV3h2WXdBQUFBQkVBQUFCQUFFQUFBQUJBQUFCR2dBQUFCY0FBQUFvYVdsdVpnQUFBQUFBQVFBQUFCcHBibVpsQWdBQUFBQUJBQUJoZGpBeFEyOXNiM0lBQUFBQWFtbHdjbkFBQUFCTGFYQmpid0FBQUJScGMzQmxBQUFBQUFBQUFBRUFBQUFCQUFBQUVIQnBlR2tBQUFBQUF3Z0lDQUFBQUF4aGRqRkRnUUFNQUFBQUFCTmpiMnh5Ym1Oc2VBQUNBQUlBQm9BQUFBQVhhWEJ0WVFBQUFBQUFBQUFCQUFFRUFRS0RCQUFBQUI5dFpHRjBFZ0FLQ0JnQUJvZ1FFRFFnTWdrUUFBQUFCOGRTTGZJPVwiO1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVzb2x2ZShpbWFnZS5oZWlnaHQgPT09IDEpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzU3VwcG9ydGVkO1xuICB9XG59XG5jbGFzcyBHTFRGTWVzaG9wdENvbXByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfTUVTSE9QVF9DT01QUkVTU0lPTjtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgfVxuICBsb2FkQnVmZmVyVmlldyhpbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLnBhcnNlci5qc29uO1xuICAgIGNvbnN0IGJ1ZmZlclZpZXcgPSBqc29uLmJ1ZmZlclZpZXdzW2luZGV4XTtcbiAgICBpZiAoYnVmZmVyVmlldy5leHRlbnNpb25zICYmIGJ1ZmZlclZpZXcuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICBjb25zdCBleHRlbnNpb25EZWYgPSBidWZmZXJWaWV3LmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMucGFyc2VyLmdldERlcGVuZGVuY3koXCJidWZmZXJcIiwgZXh0ZW5zaW9uRGVmLmJ1ZmZlcik7XG4gICAgICBjb25zdCBkZWNvZGVyID0gdGhpcy5wYXJzZXIub3B0aW9ucy5tZXNob3B0RGVjb2RlcjtcbiAgICAgIGlmICghZGVjb2RlciB8fCAhZGVjb2Rlci5zdXBwb3J0ZWQpIHtcbiAgICAgICAgaWYgKGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkICYmIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YodGhpcy5uYW1lKSA+PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogc2V0TWVzaG9wdERlY29kZXIgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgY29tcHJlc3NlZCBmaWxlc1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlci50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0gZXh0ZW5zaW9uRGVmLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IGV4dGVuc2lvbkRlZi5ieXRlTGVuZ3RoIHx8IDA7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gZXh0ZW5zaW9uRGVmLmNvdW50O1xuICAgICAgICBjb25zdCBzdHJpZGUgPSBleHRlbnNpb25EZWYuYnl0ZVN0cmlkZTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkocmVzLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAgICAgaWYgKGRlY29kZXIuZGVjb2RlR2x0ZkJ1ZmZlckFzeW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlR2x0ZkJ1ZmZlckFzeW5jKGNvdW50LCBzdHJpZGUsIHNvdXJjZSwgZXh0ZW5zaW9uRGVmLm1vZGUsIGV4dGVuc2lvbkRlZi5maWx0ZXIpLnRoZW4oZnVuY3Rpb24ocmVzMikge1xuICAgICAgICAgICAgcmV0dXJuIHJlczIuYnVmZmVyO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZWNvZGVyLnJlYWR5LnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXlCdWZmZXIoY291bnQgKiBzdHJpZGUpO1xuICAgICAgICAgICAgZGVjb2Rlci5kZWNvZGVHbHRmQnVmZmVyKFxuICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShyZXN1bHQpLFxuICAgICAgICAgICAgICBjb3VudCxcbiAgICAgICAgICAgICAgc3RyaWRlLFxuICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgIGV4dGVuc2lvbkRlZi5tb2RlLFxuICAgICAgICAgICAgICBleHRlbnNpb25EZWYuZmlsdGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgR0xURk1lc2hHcHVJbnN0YW5jaW5nIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5FWFRfTUVTSF9HUFVfSU5TVEFOQ0lORztcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgfVxuICBjcmVhdGVOb2RlTWVzaChub2RlSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5wYXJzZXIuanNvbjtcbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGlmICghbm9kZURlZi5leHRlbnNpb25zIHx8ICFub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSB8fCBub2RlRGVmLm1lc2ggPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG1lc2hEZWYgPSBqc29uLm1lc2hlc1tub2RlRGVmLm1lc2hdO1xuICAgIGZvciAoY29uc3QgcHJpbWl0aXZlIG9mIG1lc2hEZWYucHJpbWl0aXZlcykge1xuICAgICAgaWYgKHByaW1pdGl2ZS5tb2RlICE9PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVTICYmIHByaW1pdGl2ZS5tb2RlICE9PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfU1RSSVAgJiYgcHJpbWl0aXZlLm1vZGUgIT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9GQU4gJiYgcHJpbWl0aXZlLm1vZGUgIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXh0ZW5zaW9uRGVmID0gbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgY29uc3QgYXR0cmlidXRlc0RlZiA9IGV4dGVuc2lvbkRlZi5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlc0RlZikge1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICB0aGlzLnBhcnNlci5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgYXR0cmlidXRlc0RlZltrZXldKS50aGVuKChhY2Nlc3NvcikgPT4ge1xuICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IGFjY2Vzc29yO1xuICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAocGVuZGluZy5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGVuZGluZy5wdXNoKHRoaXMucGFyc2VyLmNyZWF0ZU5vZGVNZXNoKG5vZGVJbmRleCkpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICBjb25zdCBub2RlT2JqZWN0ID0gcmVzdWx0cy5wb3AoKTtcbiAgICAgIGNvbnN0IG1lc2hlcyA9IG5vZGVPYmplY3QuaXNHcm91cCA/IG5vZGVPYmplY3QuY2hpbGRyZW4gOiBbbm9kZU9iamVjdF07XG4gICAgICBjb25zdCBjb3VudCA9IHJlc3VsdHNbMF0uY291bnQ7XG4gICAgICBjb25zdCBpbnN0YW5jZWRNZXNoZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgbWVzaCBvZiBtZXNoZXMpIHtcbiAgICAgICAgY29uc3QgbSA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICAgIGNvbnN0IHAgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgICBjb25zdCBxID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICAgICAgY29uc3QgcyA9IG5ldyBWZWN0b3IzKDEsIDEsIDEpO1xuICAgICAgICBjb25zdCBpbnN0YW5jZWRNZXNoID0gbmV3IEluc3RhbmNlZE1lc2gobWVzaC5nZW9tZXRyeSwgbWVzaC5tYXRlcmlhbCwgY291bnQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICBpZiAoYXR0cmlidXRlcy5UUkFOU0xBVElPTikge1xuICAgICAgICAgICAgcC5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZXMuVFJBTlNMQVRJT04sIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0cmlidXRlcy5ST1RBVElPTikge1xuICAgICAgICAgICAgcS5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZXMuUk9UQVRJT04sIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0cmlidXRlcy5TQ0FMRSkge1xuICAgICAgICAgICAgcy5mcm9tQnVmZmVyQXR0cmlidXRlKGF0dHJpYnV0ZXMuU0NBTEUsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnN0YW5jZWRNZXNoLnNldE1hdHJpeEF0KGksIG0uY29tcG9zZShwLCBxLCBzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gXCJfQ09MT1JfMFwiKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgICAgIGluc3RhbmNlZE1lc2guaW5zdGFuY2VDb2xvciA9IG5ldyBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUoYXR0ci5hcnJheSwgYXR0ci5pdGVtU2l6ZSwgYXR0ci5ub3JtYWxpemVkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWUgIT09IFwiVFJBTlNMQVRJT05cIiAmJiBhdHRyaWJ1dGVOYW1lICE9PSBcIlJPVEFUSU9OXCIgJiYgYXR0cmlidXRlTmFtZSAhPT0gXCJTQ0FMRVwiKSB7XG4gICAgICAgICAgICBtZXNoLmdlb21ldHJ5LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbChpbnN0YW5jZWRNZXNoLCBtZXNoKTtcbiAgICAgICAgdGhpcy5wYXJzZXIuYXNzaWduRmluYWxNYXRlcmlhbChpbnN0YW5jZWRNZXNoKTtcbiAgICAgICAgaW5zdGFuY2VkTWVzaGVzLnB1c2goaW5zdGFuY2VkTWVzaCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZU9iamVjdC5pc0dyb3VwKSB7XG4gICAgICAgIG5vZGVPYmplY3QuY2xlYXIoKTtcbiAgICAgICAgbm9kZU9iamVjdC5hZGQoLi4uaW5zdGFuY2VkTWVzaGVzKTtcbiAgICAgICAgcmV0dXJuIG5vZGVPYmplY3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zdGFuY2VkTWVzaGVzWzBdO1xuICAgIH0pO1xuICB9XG59XG5jb25zdCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQyA9IFwiZ2xURlwiO1xuY29uc3QgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIID0gMTI7XG5jb25zdCBCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTID0geyBKU09OOiAxMzEzODIxNTE0LCBCSU46IDUxMzA1NjIgfTtcbmNsYXNzIEdMVEZCaW5hcnlFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEY7XG4gICAgdGhpcy5jb250ZW50ID0gbnVsbDtcbiAgICB0aGlzLmJvZHkgPSBudWxsO1xuICAgIGNvbnN0IGhlYWRlclZpZXcgPSBuZXcgRGF0YVZpZXcoZGF0YSwgMCwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIKTtcbiAgICB0aGlzLmhlYWRlciA9IHtcbiAgICAgIG1hZ2ljOiBkZWNvZGVUZXh0KG5ldyBVaW50OEFycmF5KGRhdGEuc2xpY2UoMCwgNCkpKSxcbiAgICAgIHZlcnNpb246IGhlYWRlclZpZXcuZ2V0VWludDMyKDQsIHRydWUpLFxuICAgICAgbGVuZ3RoOiBoZWFkZXJWaWV3LmdldFVpbnQzMig4LCB0cnVlKVxuICAgIH07XG4gICAgaWYgKHRoaXMuaGVhZGVyLm1hZ2ljICE9PSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgZ2xURi1CaW5hcnkgaGVhZGVyLlwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaGVhZGVyLnZlcnNpb24gPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBMZWdhY3kgYmluYXJ5IGZpbGUgZGV0ZWN0ZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBjaHVua0NvbnRlbnRzTGVuZ3RoID0gdGhpcy5oZWFkZXIubGVuZ3RoIC0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIO1xuICAgIGNvbnN0IGNodW5rVmlldyA9IG5ldyBEYXRhVmlldyhkYXRhLCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEgpO1xuICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICB3aGlsZSAoY2h1bmtJbmRleCA8IGNodW5rQ29udGVudHNMZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNodW5rTGVuZ3RoID0gY2h1bmtWaWV3LmdldFVpbnQzMihjaHVua0luZGV4LCB0cnVlKTtcbiAgICAgIGNodW5rSW5kZXggKz0gNDtcbiAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rVmlldy5nZXRVaW50MzIoY2h1bmtJbmRleCwgdHJ1ZSk7XG4gICAgICBjaHVua0luZGV4ICs9IDQ7XG4gICAgICBpZiAoY2h1bmtUeXBlID09PSBCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTLkpTT04pIHtcbiAgICAgICAgY29uc3QgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIICsgY2h1bmtJbmRleCwgY2h1bmtMZW5ndGgpO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBkZWNvZGVUZXh0KGNvbnRlbnRBcnJheSk7XG4gICAgICB9IGVsc2UgaWYgKGNodW5rVHlwZSA9PT0gQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUy5CSU4pIHtcbiAgICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCArIGNodW5rSW5kZXg7XG4gICAgICAgIHRoaXMuYm9keSA9IGRhdGEuc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGNodW5rTGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGNodW5rSW5kZXggKz0gY2h1bmtMZW5ndGg7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IEpTT04gY29udGVudCBub3QgZm91bmQuXCIpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgR0xURkRyYWNvTWVzaENvbXByZXNzaW9uRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IoanNvbiwgZHJhY29Mb2FkZXIpIHtcbiAgICBpZiAoIWRyYWNvTG9hZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBObyBEUkFDT0xvYWRlciBpbnN0YW5jZSBwcm92aWRlZC5cIik7XG4gICAgfVxuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT047XG4gICAgdGhpcy5qc29uID0ganNvbjtcbiAgICB0aGlzLmRyYWNvTG9hZGVyID0gZHJhY29Mb2FkZXI7XG4gICAgdGhpcy5kcmFjb0xvYWRlci5wcmVsb2FkKCk7XG4gIH1cbiAgZGVjb2RlUHJpbWl0aXZlKHByaW1pdGl2ZSwgcGFyc2VyKSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBkcmFjb0xvYWRlciA9IHRoaXMuZHJhY29Mb2FkZXI7XG4gICAgY29uc3QgYnVmZmVyVmlld0luZGV4ID0gcHJpbWl0aXZlLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5idWZmZXJWaWV3O1xuICAgIGNvbnN0IGdsdGZBdHRyaWJ1dGVNYXAgPSBwcmltaXRpdmUuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdLmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgdGhyZWVBdHRyaWJ1dGVNYXAgPSB7fTtcbiAgICBjb25zdCBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwID0ge307XG4gICAgY29uc3QgYXR0cmlidXRlVHlwZU1hcCA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBnbHRmQXR0cmlidXRlTWFwKSB7XG4gICAgICBjb25zdCB0aHJlZUF0dHJpYnV0ZU5hbWUgPSBBVFRSSUJVVEVTW2F0dHJpYnV0ZU5hbWVdIHx8IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRocmVlQXR0cmlidXRlTWFwW3RocmVlQXR0cmlidXRlTmFtZV0gPSBnbHRmQXR0cmlidXRlTWFwW2F0dHJpYnV0ZU5hbWVdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gcHJpbWl0aXZlLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IHRocmVlQXR0cmlidXRlTmFtZSA9IEFUVFJJQlVURVNbYXR0cmlidXRlTmFtZV0gfHwgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGdsdGZBdHRyaWJ1dGVNYXBbYXR0cmlidXRlTmFtZV0gIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NvckRlZiA9IGpzb24uYWNjZXNzb3JzW3ByaW1pdGl2ZS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdXTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50VHlwZSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlXTtcbiAgICAgICAgYXR0cmlidXRlVHlwZU1hcFt0aHJlZUF0dHJpYnV0ZU5hbWVdID0gY29tcG9uZW50VHlwZS5uYW1lO1xuICAgICAgICBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwW3RocmVlQXR0cmlidXRlTmFtZV0gPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIGJ1ZmZlclZpZXdJbmRleCkudGhlbihmdW5jdGlvbihidWZmZXJWaWV3KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGRyYWNvTG9hZGVyLmRlY29kZURyYWNvRmlsZShcbiAgICAgICAgICBidWZmZXJWaWV3LFxuICAgICAgICAgIGZ1bmN0aW9uKGdlb21ldHJ5KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gYXR0cmlidXRlTm9ybWFsaXplZE1hcFthdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQgIT09IHZvaWQgMClcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKGdlb21ldHJ5KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRocmVlQXR0cmlidXRlTWFwLFxuICAgICAgICAgIGF0dHJpYnV0ZVR5cGVNYXAsXG4gICAgICAgICAgTGluZWFyU1JHQkNvbG9yU3BhY2UsXG4gICAgICAgICAgcmVqZWN0XG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgR0xURlRleHR1cmVUcmFuc2Zvcm1FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STTtcbiAgfVxuICBleHRlbmRUZXh0dXJlKHRleHR1cmUsIHRyYW5zZm9ybSkge1xuICAgIGlmICgodHJhbnNmb3JtLnRleENvb3JkID09PSB2b2lkIDAgfHwgdHJhbnNmb3JtLnRleENvb3JkID09PSB0ZXh0dXJlLmNoYW5uZWwpICYmIHRyYW5zZm9ybS5vZmZzZXQgPT09IHZvaWQgMCAmJiB0cmFuc2Zvcm0ucm90YXRpb24gPT09IHZvaWQgMCAmJiB0cmFuc2Zvcm0uc2NhbGUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfVxuICAgIHRleHR1cmUgPSB0ZXh0dXJlLmNsb25lKCk7XG4gICAgaWYgKHRyYW5zZm9ybS50ZXhDb29yZCAhPT0gdm9pZCAwKSB7XG4gICAgICB0ZXh0dXJlLmNoYW5uZWwgPSB0cmFuc2Zvcm0udGV4Q29vcmQ7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm0ub2Zmc2V0ICE9PSB2b2lkIDApIHtcbiAgICAgIHRleHR1cmUub2Zmc2V0LmZyb21BcnJheSh0cmFuc2Zvcm0ub2Zmc2V0KTtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybS5yb3RhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICB0ZXh0dXJlLnJvdGF0aW9uID0gdHJhbnNmb3JtLnJvdGF0aW9uO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtLnNjYWxlICE9PSB2b2lkIDApIHtcbiAgICAgIHRleHR1cmUucmVwZWF0LmZyb21BcnJheSh0cmFuc2Zvcm0uc2NhbGUpO1xuICAgIH1cbiAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxufVxuY2xhc3MgR0xURk1lc2hRdWFudGl6YXRpb25FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NRVNIX1FVQU5USVpBVElPTjtcbiAgfVxufVxuY2xhc3MgR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQgZXh0ZW5kcyBJbnRlcnBvbGFudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKTtcbiAgfVxuICBjb3B5U2FtcGxlVmFsdWVfKGluZGV4KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsIHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLCB2YWx1ZVNpemUgPSB0aGlzLnZhbHVlU2l6ZSwgb2Zmc2V0ID0gaW5kZXggKiB2YWx1ZVNpemUgKiAzICsgdmFsdWVTaXplO1xuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSB2YWx1ZVNpemU7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gdmFsdWVzW29mZnNldCArIGldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXI7XG4gICAgY29uc3QgdmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXM7XG4gICAgY29uc3Qgc3RyaWRlID0gdGhpcy52YWx1ZVNpemU7XG4gICAgY29uc3Qgc3RyaWRlMiA9IHN0cmlkZSAqIDI7XG4gICAgY29uc3Qgc3RyaWRlMyA9IHN0cmlkZSAqIDM7XG4gICAgY29uc3QgdGQgPSB0MSAtIHQwO1xuICAgIGNvbnN0IHAgPSAodCAtIHQwKSAvIHRkO1xuICAgIGNvbnN0IHBwID0gcCAqIHA7XG4gICAgY29uc3QgcHBwID0gcHAgKiBwO1xuICAgIGNvbnN0IG9mZnNldDEgPSBpMSAqIHN0cmlkZTM7XG4gICAgY29uc3Qgb2Zmc2V0MCA9IG9mZnNldDEgLSBzdHJpZGUzO1xuICAgIGNvbnN0IHMyID0gLTIgKiBwcHAgKyAzICogcHA7XG4gICAgY29uc3QgczMgPSBwcHAgLSBwcDtcbiAgICBjb25zdCBzMCA9IDEgLSBzMjtcbiAgICBjb25zdCBzMSA9IHMzIC0gcHAgKyBwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7IGkrKykge1xuICAgICAgY29uc3QgcDAgPSB2YWx1ZXNbb2Zmc2V0MCArIGkgKyBzdHJpZGVdO1xuICAgICAgY29uc3QgbTAgPSB2YWx1ZXNbb2Zmc2V0MCArIGkgKyBzdHJpZGUyXSAqIHRkO1xuICAgICAgY29uc3QgcDEgPSB2YWx1ZXNbb2Zmc2V0MSArIGkgKyBzdHJpZGVdO1xuICAgICAgY29uc3QgbTEgPSB2YWx1ZXNbb2Zmc2V0MSArIGldICogdGQ7XG4gICAgICByZXN1bHRbaV0gPSBzMCAqIHAwICsgczEgKiBtMCArIHMyICogcDEgKyBzMyAqIG0xO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5jb25zdCBfcSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUXVhdGVybmlvbigpO1xuY2xhc3MgR0xURkN1YmljU3BsaW5lUXVhdGVybmlvbkludGVycG9sYW50IGV4dGVuZHMgR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQge1xuICBpbnRlcnBvbGF0ZV8oaTEsIHQwLCB0LCB0MSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKTtcbiAgICBfcS5mcm9tQXJyYXkocmVzdWx0KS5ub3JtYWxpemUoKS50b0FycmF5KHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuY29uc3QgV0VCR0xfQ09OU1RBTlRTID0ge1xuICBGTE9BVDogNTEyNixcbiAgLy9GTE9BVF9NQVQyOiAzNTY3NCxcbiAgRkxPQVRfTUFUMzogMzU2NzUsXG4gIEZMT0FUX01BVDQ6IDM1Njc2LFxuICBGTE9BVF9WRUMyOiAzNTY2NCxcbiAgRkxPQVRfVkVDMzogMzU2NjUsXG4gIEZMT0FUX1ZFQzQ6IDM1NjY2LFxuICBMSU5FQVI6IDk3MjksXG4gIFJFUEVBVDogMTA0OTcsXG4gIFNBTVBMRVJfMkQ6IDM1Njc4LFxuICBQT0lOVFM6IDAsXG4gIExJTkVTOiAxLFxuICBMSU5FX0xPT1A6IDIsXG4gIExJTkVfU1RSSVA6IDMsXG4gIFRSSUFOR0xFUzogNCxcbiAgVFJJQU5HTEVfU1RSSVA6IDUsXG4gIFRSSUFOR0xFX0ZBTjogNixcbiAgVU5TSUdORURfQllURTogNTEyMSxcbiAgVU5TSUdORURfU0hPUlQ6IDUxMjNcbn07XG5jb25zdCBXRUJHTF9DT01QT05FTlRfVFlQRVMgPSB7XG4gIDUxMjA6IEludDhBcnJheSxcbiAgNTEyMTogVWludDhBcnJheSxcbiAgNTEyMjogSW50MTZBcnJheSxcbiAgNTEyMzogVWludDE2QXJyYXksXG4gIDUxMjU6IFVpbnQzMkFycmF5LFxuICA1MTI2OiBGbG9hdDMyQXJyYXlcbn07XG5jb25zdCBXRUJHTF9GSUxURVJTID0ge1xuICA5NzI4OiBOZWFyZXN0RmlsdGVyLFxuICA5NzI5OiBMaW5lYXJGaWx0ZXIsXG4gIDk5ODQ6IE5lYXJlc3RNaXBtYXBOZWFyZXN0RmlsdGVyLFxuICA5OTg1OiBMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyLFxuICA5OTg2OiBOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyLFxuICA5OTg3OiBMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXJcbn07XG5jb25zdCBXRUJHTF9XUkFQUElOR1MgPSB7XG4gIDMzMDcxOiBDbGFtcFRvRWRnZVdyYXBwaW5nLFxuICAzMzY0ODogTWlycm9yZWRSZXBlYXRXcmFwcGluZyxcbiAgMTA0OTc6IFJlcGVhdFdyYXBwaW5nXG59O1xuY29uc3QgV0VCR0xfVFlQRV9TSVpFUyA9IHtcbiAgU0NBTEFSOiAxLFxuICBWRUMyOiAyLFxuICBWRUMzOiAzLFxuICBWRUM0OiA0LFxuICBNQVQyOiA0LFxuICBNQVQzOiA5LFxuICBNQVQ0OiAxNlxufTtcbmNvbnN0IEFUVFJJQlVURVMgPSB7XG4gIFBPU0lUSU9OOiBcInBvc2l0aW9uXCIsXG4gIE5PUk1BTDogXCJub3JtYWxcIixcbiAgVEFOR0VOVDogXCJ0YW5nZW50XCIsXG4gIC8vIHV2ID0+IHV2MSwgNCB1diBjaGFubmVsc1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjU5NDNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzI1Nzg4XG4gIC4uLnZlcnNpb24gPj0gMTUyID8ge1xuICAgIFRFWENPT1JEXzA6IFwidXZcIixcbiAgICBURVhDT09SRF8xOiBcInV2MVwiLFxuICAgIFRFWENPT1JEXzI6IFwidXYyXCIsXG4gICAgVEVYQ09PUkRfMzogXCJ1djNcIlxuICB9IDoge1xuICAgIFRFWENPT1JEXzA6IFwidXZcIixcbiAgICBURVhDT09SRF8xOiBcInV2MlwiXG4gIH0sXG4gIENPTE9SXzA6IFwiY29sb3JcIixcbiAgV0VJR0hUU18wOiBcInNraW5XZWlnaHRcIixcbiAgSk9JTlRTXzA6IFwic2tpbkluZGV4XCJcbn07XG5jb25zdCBQQVRIX1BST1BFUlRJRVMgPSB7XG4gIHNjYWxlOiBcInNjYWxlXCIsXG4gIHRyYW5zbGF0aW9uOiBcInBvc2l0aW9uXCIsXG4gIHJvdGF0aW9uOiBcInF1YXRlcm5pb25cIixcbiAgd2VpZ2h0czogXCJtb3JwaFRhcmdldEluZmx1ZW5jZXNcIlxufTtcbmNvbnN0IElOVEVSUE9MQVRJT04gPSB7XG4gIENVQklDU1BMSU5FOiB2b2lkIDAsXG4gIC8vIFdlIHVzZSBhIGN1c3RvbSBpbnRlcnBvbGFudCAoR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhdGlvbikgZm9yIENVQklDU1BMSU5FIHRyYWNrcy4gRWFjaFxuICAvLyBrZXlmcmFtZSB0cmFjayB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYSBkZWZhdWx0IGludGVycG9sYXRpb24gdHlwZSwgdGhlbiBtb2RpZmllZC5cbiAgTElORUFSOiBJbnRlcnBvbGF0ZUxpbmVhcixcbiAgU1RFUDogSW50ZXJwb2xhdGVEaXNjcmV0ZVxufTtcbmNvbnN0IEFMUEhBX01PREVTID0ge1xuICBPUEFRVUU6IFwiT1BBUVVFXCIsXG4gIE1BU0s6IFwiTUFTS1wiLFxuICBCTEVORDogXCJCTEVORFwiXG59O1xuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdE1hdGVyaWFsKGNhY2hlKSB7XG4gIGlmIChjYWNoZVtcIkRlZmF1bHRNYXRlcmlhbFwiXSA9PT0gdm9pZCAwKSB7XG4gICAgY2FjaGVbXCJEZWZhdWx0TWF0ZXJpYWxcIl0gPSBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6IDE2Nzc3MjE1LFxuICAgICAgZW1pc3NpdmU6IDAsXG4gICAgICBtZXRhbG5lc3M6IDEsXG4gICAgICByb3VnaG5lc3M6IDEsXG4gICAgICB0cmFuc3BhcmVudDogZmFsc2UsXG4gICAgICBkZXB0aFRlc3Q6IHRydWUsXG4gICAgICBzaWRlOiBGcm9udFNpZGVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY2FjaGVbXCJEZWZhdWx0TWF0ZXJpYWxcIl07XG59XG5mdW5jdGlvbiBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoa25vd25FeHRlbnNpb25zLCBvYmplY3QsIG9iamVjdERlZikge1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gb2JqZWN0RGVmLmV4dGVuc2lvbnMpIHtcbiAgICBpZiAoa25vd25FeHRlbnNpb25zW25hbWVdID09PSB2b2lkIDApIHtcbiAgICAgIG9iamVjdC51c2VyRGF0YS5nbHRmRXh0ZW5zaW9ucyA9IG9iamVjdC51c2VyRGF0YS5nbHRmRXh0ZW5zaW9ucyB8fCB7fTtcbiAgICAgIG9iamVjdC51c2VyRGF0YS5nbHRmRXh0ZW5zaW9uc1tuYW1lXSA9IG9iamVjdERlZi5leHRlbnNpb25zW25hbWVdO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShvYmplY3QsIGdsdGZEZWYpIHtcbiAgaWYgKGdsdGZEZWYuZXh0cmFzICE9PSB2b2lkIDApIHtcbiAgICBpZiAodHlwZW9mIGdsdGZEZWYuZXh0cmFzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBPYmplY3QuYXNzaWduKG9iamVjdC51c2VyRGF0YSwgZ2x0ZkRlZi5leHRyYXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBJZ25vcmluZyBwcmltaXRpdmUgdHlwZSAuZXh0cmFzLCBcIiArIGdsdGZEZWYuZXh0cmFzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZE1vcnBoVGFyZ2V0cyhnZW9tZXRyeSwgdGFyZ2V0cywgcGFyc2VyKSB7XG4gIGxldCBoYXNNb3JwaFBvc2l0aW9uID0gZmFsc2U7XG4gIGxldCBoYXNNb3JwaE5vcm1hbCA9IGZhbHNlO1xuICBsZXQgaGFzTW9ycGhDb2xvciA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMCwgaWwgPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgIGlmICh0YXJnZXQuUE9TSVRJT04gIT09IHZvaWQgMClcbiAgICAgIGhhc01vcnBoUG9zaXRpb24gPSB0cnVlO1xuICAgIGlmICh0YXJnZXQuTk9STUFMICE9PSB2b2lkIDApXG4gICAgICBoYXNNb3JwaE5vcm1hbCA9IHRydWU7XG4gICAgaWYgKHRhcmdldC5DT0xPUl8wICE9PSB2b2lkIDApXG4gICAgICBoYXNNb3JwaENvbG9yID0gdHJ1ZTtcbiAgICBpZiAoaGFzTW9ycGhQb3NpdGlvbiAmJiBoYXNNb3JwaE5vcm1hbCAmJiBoYXNNb3JwaENvbG9yKVxuICAgICAgYnJlYWs7XG4gIH1cbiAgaWYgKCFoYXNNb3JwaFBvc2l0aW9uICYmICFoYXNNb3JwaE5vcm1hbCAmJiAhaGFzTW9ycGhDb2xvcilcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGdlb21ldHJ5KTtcbiAgY29uc3QgcGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzID0gW107XG4gIGNvbnN0IHBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMgPSBbXTtcbiAgY29uc3QgcGVuZGluZ0NvbG9yQWNjZXNzb3JzID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgaWYgKGhhc01vcnBoUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBlbmRpbmdBY2Nlc3NvciA9IHRhcmdldC5QT1NJVElPTiAhPT0gdm9pZCAwID8gcGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCB0YXJnZXQuUE9TSVRJT04pIDogZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgICAgIHBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycy5wdXNoKHBlbmRpbmdBY2Nlc3Nvcik7XG4gICAgfVxuICAgIGlmIChoYXNNb3JwaE5vcm1hbCkge1xuICAgICAgY29uc3QgcGVuZGluZ0FjY2Vzc29yID0gdGFyZ2V0Lk5PUk1BTCAhPT0gdm9pZCAwID8gcGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCB0YXJnZXQuTk9STUFMKSA6IGdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xuICAgICAgcGVuZGluZ05vcm1hbEFjY2Vzc29ycy5wdXNoKHBlbmRpbmdBY2Nlc3Nvcik7XG4gICAgfVxuICAgIGlmIChoYXNNb3JwaENvbG9yKSB7XG4gICAgICBjb25zdCBwZW5kaW5nQWNjZXNzb3IgPSB0YXJnZXQuQ09MT1JfMCAhPT0gdm9pZCAwID8gcGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCB0YXJnZXQuQ09MT1JfMCkgOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yO1xuICAgICAgcGVuZGluZ0NvbG9yQWNjZXNzb3JzLnB1c2gocGVuZGluZ0FjY2Vzc29yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICBQcm9taXNlLmFsbChwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMpLFxuICAgIFByb21pc2UuYWxsKHBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMpLFxuICAgIFByb21pc2UuYWxsKHBlbmRpbmdDb2xvckFjY2Vzc29ycylcbiAgXSkudGhlbihmdW5jdGlvbihhY2Nlc3NvcnMpIHtcbiAgICBjb25zdCBtb3JwaFBvc2l0aW9ucyA9IGFjY2Vzc29yc1swXTtcbiAgICBjb25zdCBtb3JwaE5vcm1hbHMgPSBhY2Nlc3NvcnNbMV07XG4gICAgY29uc3QgbW9ycGhDb2xvcnMgPSBhY2Nlc3NvcnNbMl07XG4gICAgaWYgKGhhc01vcnBoUG9zaXRpb24pXG4gICAgICBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gPSBtb3JwaFBvc2l0aW9ucztcbiAgICBpZiAoaGFzTW9ycGhOb3JtYWwpXG4gICAgICBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsID0gbW9ycGhOb3JtYWxzO1xuICAgIGlmIChoYXNNb3JwaENvbG9yKVxuICAgICAgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLmNvbG9yID0gbW9ycGhDb2xvcnM7XG4gICAgZ2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0cnVlO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVNb3JwaFRhcmdldHMobWVzaCwgbWVzaERlZikge1xuICBtZXNoLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xuICBpZiAobWVzaERlZi53ZWlnaHRzICE9PSB2b2lkIDApIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBtZXNoRGVmLndlaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgbWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXNbaV0gPSBtZXNoRGVmLndlaWdodHNbaV07XG4gICAgfVxuICB9XG4gIGlmIChtZXNoRGVmLmV4dHJhcyAmJiBBcnJheS5pc0FycmF5KG1lc2hEZWYuZXh0cmFzLnRhcmdldE5hbWVzKSkge1xuICAgIGNvbnN0IHRhcmdldE5hbWVzID0gbWVzaERlZi5leHRyYXMudGFyZ2V0TmFtZXM7XG4gICAgaWYgKG1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzLmxlbmd0aCA9PT0gdGFyZ2V0TmFtZXMubGVuZ3RoKSB7XG4gICAgICBtZXNoLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gdGFyZ2V0TmFtZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBtZXNoLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVt0YXJnZXROYW1lc1tpXV0gPSBpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBJbnZhbGlkIGV4dHJhcy50YXJnZXROYW1lcyBsZW5ndGguIElnbm9yaW5nIG5hbWVzLlwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZUtleShwcmltaXRpdmVEZWYpIHtcbiAgbGV0IGdlb21ldHJ5S2V5O1xuICBjb25zdCBkcmFjb0V4dGVuc2lvbiA9IHByaW1pdGl2ZURlZi5leHRlbnNpb25zICYmIHByaW1pdGl2ZURlZi5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT05dO1xuICBpZiAoZHJhY29FeHRlbnNpb24pIHtcbiAgICBnZW9tZXRyeUtleSA9IFwiZHJhY286XCIgKyBkcmFjb0V4dGVuc2lvbi5idWZmZXJWaWV3ICsgXCI6XCIgKyBkcmFjb0V4dGVuc2lvbi5pbmRpY2VzICsgXCI6XCIgKyBjcmVhdGVBdHRyaWJ1dGVzS2V5KGRyYWNvRXh0ZW5zaW9uLmF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIGdlb21ldHJ5S2V5ID0gcHJpbWl0aXZlRGVmLmluZGljZXMgKyBcIjpcIiArIGNyZWF0ZUF0dHJpYnV0ZXNLZXkocHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXMpICsgXCI6XCIgKyBwcmltaXRpdmVEZWYubW9kZTtcbiAgfVxuICBpZiAocHJpbWl0aXZlRGVmLnRhcmdldHMgIT09IHZvaWQgMCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHByaW1pdGl2ZURlZi50YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGdlb21ldHJ5S2V5ICs9IFwiOlwiICsgY3JlYXRlQXR0cmlidXRlc0tleShwcmltaXRpdmVEZWYudGFyZ2V0c1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZW9tZXRyeUtleTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUF0dHJpYnV0ZXNLZXkoYXR0cmlidXRlcykge1xuICBsZXQgYXR0cmlidXRlc0tleSA9IFwiXCI7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5zb3J0KCk7XG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IGtleXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIGF0dHJpYnV0ZXNLZXkgKz0ga2V5c1tpXSArIFwiOlwiICsgYXR0cmlidXRlc1trZXlzW2ldXSArIFwiO1wiO1xuICB9XG4gIHJldHVybiBhdHRyaWJ1dGVzS2V5O1xufVxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZENvbXBvbmVudFNjYWxlKGNvbnN0cnVjdG9yKSB7XG4gIHN3aXRjaCAoY29uc3RydWN0b3IpIHtcbiAgICBjYXNlIEludDhBcnJheTpcbiAgICAgIHJldHVybiAxIC8gMTI3O1xuICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgIHJldHVybiAxIC8gMjU1O1xuICAgIGNhc2UgSW50MTZBcnJheTpcbiAgICAgIHJldHVybiAxIC8gMzI3Njc7XG4gICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgIHJldHVybiAxIC8gNjU1MzU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIG5vcm1hbGl6ZWQgYWNjZXNzb3IgY29tcG9uZW50IHR5cGUuXCIpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRJbWFnZVVSSU1pbWVUeXBlKHVyaSkge1xuICBpZiAodXJpLnNlYXJjaCgvXFwuanBlP2coJHxcXD8pL2kpID4gMCB8fCB1cmkuc2VhcmNoKC9eZGF0YVxcOmltYWdlXFwvanBlZy8pID09PSAwKVxuICAgIHJldHVybiBcImltYWdlL2pwZWdcIjtcbiAgaWYgKHVyaS5zZWFyY2goL1xcLndlYnAoJHxcXD8pL2kpID4gMCB8fCB1cmkuc2VhcmNoKC9eZGF0YVxcOmltYWdlXFwvd2VicC8pID09PSAwKVxuICAgIHJldHVybiBcImltYWdlL3dlYnBcIjtcbiAgcmV0dXJuIFwiaW1hZ2UvcG5nXCI7XG59XG5jb25zdCBfaWRlbnRpdHlNYXRyaXggPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hdHJpeDQoKTtcbmNsYXNzIEdMVEZQYXJzZXIge1xuICBjb25zdHJ1Y3Rvcihqc29uID0ge30sIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuanNvbiA9IGpzb247XG4gICAgdGhpcy5leHRlbnNpb25zID0ge307XG4gICAgdGhpcy5wbHVnaW5zID0ge307XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmNhY2hlID0gbmV3IEdMVEZSZWdpc3RyeSgpO1xuICAgIHRoaXMuYXNzb2NpYXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnByaW1pdGl2ZUNhY2hlID0ge307XG4gICAgdGhpcy5ub2RlQ2FjaGUgPSB7fTtcbiAgICB0aGlzLm1lc2hDYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG4gICAgdGhpcy5jYW1lcmFDYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG4gICAgdGhpcy5saWdodENhY2hlID0geyByZWZzOiB7fSwgdXNlczoge30gfTtcbiAgICB0aGlzLnNvdXJjZUNhY2hlID0ge307XG4gICAgdGhpcy50ZXh0dXJlQ2FjaGUgPSB7fTtcbiAgICB0aGlzLm5vZGVOYW1lc1VzZWQgPSB7fTtcbiAgICBsZXQgaXNTYWZhcmkgPSBmYWxzZTtcbiAgICBsZXQgaXNGaXJlZm94ID0gZmFsc2U7XG4gICAgbGV0IGZpcmVmb3hWZXJzaW9uID0gLTE7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG5hdmlnYXRvci51c2VyQWdlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlzU2FmYXJpID0gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSA9PT0gdHJ1ZTtcbiAgICAgIGlzRmlyZWZveCA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkZpcmVmb3hcIikgPiAtMTtcbiAgICAgIGZpcmVmb3hWZXJzaW9uID0gaXNGaXJlZm94ID8gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRmlyZWZveFxcLyhbMC05XSspXFwuLylbMV0gOiAtMTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBpc1NhZmFyaSB8fCBpc0ZpcmVmb3ggJiYgZmlyZWZveFZlcnNpb24gPCA5OCkge1xuICAgICAgdGhpcy50ZXh0dXJlTG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIodGhpcy5vcHRpb25zLm1hbmFnZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRleHR1cmVMb2FkZXIgPSBuZXcgSW1hZ2VCaXRtYXBMb2FkZXIodGhpcy5vcHRpb25zLm1hbmFnZXIpO1xuICAgIH1cbiAgICB0aGlzLnRleHR1cmVMb2FkZXIuc2V0Q3Jvc3NPcmlnaW4odGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luKTtcbiAgICB0aGlzLnRleHR1cmVMb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLm9wdGlvbnMucmVxdWVzdEhlYWRlcik7XG4gICAgdGhpcy5maWxlTG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5vcHRpb25zLm1hbmFnZXIpO1xuICAgIHRoaXMuZmlsZUxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJhcnJheWJ1ZmZlclwiKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNyb3NzT3JpZ2luID09PSBcInVzZS1jcmVkZW50aWFsc1wiKSB7XG4gICAgICB0aGlzLmZpbGVMb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRydWUpO1xuICAgIH1cbiAgfVxuICBzZXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpIHtcbiAgICB0aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICB9XG4gIHNldFBsdWdpbnMocGx1Z2lucykge1xuICAgIHRoaXMucGx1Z2lucyA9IHBsdWdpbnM7XG4gIH1cbiAgcGFyc2Uob25Mb2FkLCBvbkVycm9yKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgdGhpcy5jYWNoZS5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLm5vZGVDYWNoZSA9IHt9O1xuICAgIHRoaXMuX2ludm9rZUFsbChmdW5jdGlvbihleHQpIHtcbiAgICAgIHJldHVybiBleHQuX21hcmtEZWZzICYmIGV4dC5fbWFya0RlZnMoKTtcbiAgICB9KTtcbiAgICBQcm9taXNlLmFsbChcbiAgICAgIHRoaXMuX2ludm9rZUFsbChmdW5jdGlvbihleHQpIHtcbiAgICAgICAgcmV0dXJuIGV4dC5iZWZvcmVSb290ICYmIGV4dC5iZWZvcmVSb290KCk7XG4gICAgICB9KVxuICAgICkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgIHBhcnNlci5nZXREZXBlbmRlbmNpZXMoXCJzY2VuZVwiKSxcbiAgICAgICAgcGFyc2VyLmdldERlcGVuZGVuY2llcyhcImFuaW1hdGlvblwiKSxcbiAgICAgICAgcGFyc2VyLmdldERlcGVuZGVuY2llcyhcImNhbWVyYVwiKVxuICAgICAgXSk7XG4gICAgfSkudGhlbihmdW5jdGlvbihkZXBlbmRlbmNpZXMpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgc2NlbmU6IGRlcGVuZGVuY2llc1swXVtqc29uLnNjZW5lIHx8IDBdLFxuICAgICAgICBzY2VuZXM6IGRlcGVuZGVuY2llc1swXSxcbiAgICAgICAgYW5pbWF0aW9uczogZGVwZW5kZW5jaWVzWzFdLFxuICAgICAgICBjYW1lcmFzOiBkZXBlbmRlbmNpZXNbMl0sXG4gICAgICAgIGFzc2V0OiBqc29uLmFzc2V0LFxuICAgICAgICBwYXJzZXIsXG4gICAgICAgIHVzZXJEYXRhOiB7fVxuICAgICAgfTtcbiAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCByZXN1bHQsIGpzb24pO1xuICAgICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShyZXN1bHQsIGpzb24pO1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgICBwYXJzZXIuX2ludm9rZUFsbChmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICByZXR1cm4gZXh0LmFmdGVyUm9vdCAmJiBleHQuYWZ0ZXJSb290KHJlc3VsdCk7XG4gICAgICAgIH0pXG4gICAgICApLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NlbmUgb2YgcmVzdWx0LnNjZW5lcykge1xuICAgICAgICAgIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgICAgIH1cbiAgICAgICAgb25Mb2FkKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KS5jYXRjaChvbkVycm9yKTtcbiAgfVxuICAvKipcbiAgICogTWFya3MgdGhlIHNwZWNpYWwgbm9kZXMvbWVzaGVzIGluIGpzb24gZm9yIGVmZmljaWVudCBwYXJzZS5cbiAgICovXG4gIF9tYXJrRGVmcygpIHtcbiAgICBjb25zdCBub2RlRGVmcyA9IHRoaXMuanNvbi5ub2RlcyB8fCBbXTtcbiAgICBjb25zdCBza2luRGVmcyA9IHRoaXMuanNvbi5za2lucyB8fCBbXTtcbiAgICBjb25zdCBtZXNoRGVmcyA9IHRoaXMuanNvbi5tZXNoZXMgfHwgW107XG4gICAgZm9yIChsZXQgc2tpbkluZGV4ID0gMCwgc2tpbkxlbmd0aCA9IHNraW5EZWZzLmxlbmd0aDsgc2tpbkluZGV4IDwgc2tpbkxlbmd0aDsgc2tpbkluZGV4KyspIHtcbiAgICAgIGNvbnN0IGpvaW50cyA9IHNraW5EZWZzW3NraW5JbmRleF0uam9pbnRzO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gam9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgbm9kZURlZnNbam9pbnRzW2ldXS5pc0JvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBub2RlSW5kZXggPSAwLCBub2RlTGVuZ3RoID0gbm9kZURlZnMubGVuZ3RoOyBub2RlSW5kZXggPCBub2RlTGVuZ3RoOyBub2RlSW5kZXgrKykge1xuICAgICAgY29uc3Qgbm9kZURlZiA9IG5vZGVEZWZzW25vZGVJbmRleF07XG4gICAgICBpZiAobm9kZURlZi5tZXNoICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5fYWRkTm9kZVJlZih0aGlzLm1lc2hDYWNoZSwgbm9kZURlZi5tZXNoKTtcbiAgICAgICAgaWYgKG5vZGVEZWYuc2tpbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgbWVzaERlZnNbbm9kZURlZi5tZXNoXS5pc1NraW5uZWRNZXNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGVEZWYuY2FtZXJhICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5fYWRkTm9kZVJlZih0aGlzLmNhbWVyYUNhY2hlLCBub2RlRGVmLmNhbWVyYSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb3VudHMgcmVmZXJlbmNlcyB0byBzaGFyZWQgbm9kZSAvIE9iamVjdDNEIHJlc291cmNlcy4gVGhlc2UgcmVzb3VyY2VzXG4gICAqIGNhbiBiZSByZXVzZWQsIG9yIFwiaW5zdGFudGlhdGVkXCIsIGF0IG11bHRpcGxlIG5vZGVzIGluIHRoZSBzY2VuZVxuICAgKiBoaWVyYXJjaHkuIE1lc2gsIENhbWVyYSwgYW5kIExpZ2h0IGluc3RhbmNlcyBhcmUgaW5zdGFudGlhdGVkIGFuZCBtdXN0XG4gICAqIGJlIG1hcmtlZC4gTm9uLXNjZW5lZ3JhcGggcmVzb3VyY2VzIChsaWtlIE1hdGVyaWFscywgR2VvbWV0cmllcywgYW5kXG4gICAqIFRleHR1cmVzKSBjYW4gYmUgcmV1c2VkIGRpcmVjdGx5IGFuZCBhcmUgbm90IG1hcmtlZCBoZXJlLlxuICAgKlxuICAgKiBFeGFtcGxlOiBDZXNpdW1NaWxrVHJ1Y2sgc2FtcGxlIG1vZGVsIHJldXNlcyBcIldoZWVsXCIgbWVzaGVzLlxuICAgKi9cbiAgX2FkZE5vZGVSZWYoY2FjaGUsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgaWYgKGNhY2hlLnJlZnNbaW5kZXhdID09PSB2b2lkIDApIHtcbiAgICAgIGNhY2hlLnJlZnNbaW5kZXhdID0gY2FjaGUudXNlc1tpbmRleF0gPSAwO1xuICAgIH1cbiAgICBjYWNoZS5yZWZzW2luZGV4XSsrO1xuICB9XG4gIC8qKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIGEgc2hhcmVkIHJlc291cmNlLCBjbG9uaW5nIGl0IGlmIG5lY2Vzc2FyeS4gKi9cbiAgX2dldE5vZGVSZWYoY2FjaGUsIGluZGV4LCBvYmplY3QpIHtcbiAgICBpZiAoY2FjaGUucmVmc1tpbmRleF0gPD0gMSlcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgY29uc3QgcmVmID0gb2JqZWN0LmNsb25lKCk7XG4gICAgY29uc3QgdXBkYXRlTWFwcGluZ3MgPSAob3JpZ2luYWwsIGNsb25lKSA9PiB7XG4gICAgICBjb25zdCBtYXBwaW5ncyA9IHRoaXMuYXNzb2NpYXRpb25zLmdldChvcmlnaW5hbCk7XG4gICAgICBpZiAobWFwcGluZ3MgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmFzc29jaWF0aW9ucy5zZXQoY2xvbmUsIG1hcHBpbmdzKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW2ksIGNoaWxkXSBvZiBvcmlnaW5hbC5jaGlsZHJlbi5lbnRyaWVzKCkpIHtcbiAgICAgICAgdXBkYXRlTWFwcGluZ3MoY2hpbGQsIGNsb25lLmNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHVwZGF0ZU1hcHBpbmdzKG9iamVjdCwgcmVmKTtcbiAgICByZWYubmFtZSArPSBcIl9pbnN0YW5jZV9cIiArIGNhY2hlLnVzZXNbaW5kZXhdKys7XG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuICBfaW52b2tlT25lKGZ1bmMpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gT2JqZWN0LnZhbHVlcyh0aGlzLnBsdWdpbnMpO1xuICAgIGV4dGVuc2lvbnMucHVzaCh0aGlzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZ1bmMoZXh0ZW5zaW9uc1tpXSk7XG4gICAgICBpZiAocmVzdWx0KVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBfaW52b2tlQWxsKGZ1bmMpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gT2JqZWN0LnZhbHVlcyh0aGlzLnBsdWdpbnMpO1xuICAgIGV4dGVuc2lvbnMudW5zaGlmdCh0aGlzKTtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHRlbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBmdW5jKGV4dGVuc2lvbnNbaV0pO1xuICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgcGVuZGluZy5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9XG4gIC8qKlxuICAgKiBSZXF1ZXN0cyB0aGUgc3BlY2lmaWVkIGRlcGVuZGVuY3kgYXN5bmNocm9ub3VzbHksIHdpdGggY2FjaGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0M0R8TWF0ZXJpYWx8VEhSRUUuVGV4dHVyZXxBbmltYXRpb25DbGlwfEFycmF5QnVmZmVyfE9iamVjdD59XG4gICAqL1xuICBnZXREZXBlbmRlbmN5KHR5cGUsIGluZGV4KSB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSB0eXBlICsgXCI6XCIgKyBpbmRleDtcbiAgICBsZXQgZGVwZW5kZW5jeSA9IHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIWRlcGVuZGVuY3kpIHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwic2NlbmVcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5sb2FkU2NlbmUoaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibm9kZVwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWROb2RlICYmIGV4dC5sb2FkTm9kZShpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtZXNoXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZE1lc2ggJiYgZXh0LmxvYWRNZXNoKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFjY2Vzc29yXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMubG9hZEFjY2Vzc29yKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJ1ZmZlclZpZXdcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkQnVmZmVyVmlldyAmJiBleHQubG9hZEJ1ZmZlclZpZXcoaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYnVmZmVyXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMubG9hZEJ1ZmZlcihpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtYXRlcmlhbFwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWRNYXRlcmlhbCAmJiBleHQubG9hZE1hdGVyaWFsKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRleHR1cmVcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkVGV4dHVyZSAmJiBleHQubG9hZFRleHR1cmUoaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2tpblwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRTa2luKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFuaW1hdGlvblwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWRBbmltYXRpb24gJiYgZXh0LmxvYWRBbmltYXRpb24oaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2FtZXJhXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMubG9hZENhbWVyYShpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQgIT0gdGhpcyAmJiBleHQuZ2V0RGVwZW5kZW5jeSAmJiBleHQuZ2V0RGVwZW5kZW5jeSh0eXBlLCBpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFkZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZS5hZGQoY2FjaGVLZXksIGRlcGVuZGVuY3kpO1xuICAgIH1cbiAgICByZXR1cm4gZGVwZW5kZW5jeTtcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgYWxsIGRlcGVuZGVuY2llcyBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgYXN5bmNocm9ub3VzbHksIHdpdGggY2FjaGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxPYmplY3Q+Pn1cbiAgICovXG4gIGdldERlcGVuZGVuY2llcyh0eXBlKSB7XG4gICAgbGV0IGRlcGVuZGVuY2llcyA9IHRoaXMuY2FjaGUuZ2V0KHR5cGUpO1xuICAgIGlmICghZGVwZW5kZW5jaWVzKSB7XG4gICAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgICAgY29uc3QgZGVmcyA9IHRoaXMuanNvblt0eXBlICsgKHR5cGUgPT09IFwibWVzaFwiID8gXCJlc1wiIDogXCJzXCIpXSB8fCBbXTtcbiAgICAgIGRlcGVuZGVuY2llcyA9IFByb21pc2UuYWxsKFxuICAgICAgICBkZWZzLm1hcChmdW5jdGlvbihkZWYsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KHR5cGUsIGluZGV4KTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICB0aGlzLmNhY2hlLmFkZCh0eXBlLCBkZXBlbmRlbmNpZXMpO1xuICAgIH1cbiAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2J1ZmZlcnMtYW5kLWJ1ZmZlci12aWV3c1xuICAgKiBAcGFyYW0ge251bWJlcn0gYnVmZmVySW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheUJ1ZmZlcj59XG4gICAqL1xuICBsb2FkQnVmZmVyKGJ1ZmZlckluZGV4KSB7XG4gICAgY29uc3QgYnVmZmVyRGVmID0gdGhpcy5qc29uLmJ1ZmZlcnNbYnVmZmVySW5kZXhdO1xuICAgIGNvbnN0IGxvYWRlciA9IHRoaXMuZmlsZUxvYWRlcjtcbiAgICBpZiAoYnVmZmVyRGVmLnR5cGUgJiYgYnVmZmVyRGVmLnR5cGUgIT09IFwiYXJyYXlidWZmZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogXCIgKyBidWZmZXJEZWYudHlwZSArIFwiIGJ1ZmZlciB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoYnVmZmVyRGVmLnVyaSA9PT0gdm9pZCAwICYmIGJ1ZmZlckluZGV4ID09PSAwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURl0uYm9keSk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgbG9hZGVyLmxvYWQoTG9hZGVyVXRpbHMucmVzb2x2ZVVSTChidWZmZXJEZWYudXJpLCBvcHRpb25zLnBhdGgpLCByZXNvbHZlLCB2b2lkIDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdUSFJFRS5HTFRGTG9hZGVyOiBGYWlsZWQgdG8gbG9hZCBidWZmZXIgXCInICsgYnVmZmVyRGVmLnVyaSArICdcIi4nKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNidWZmZXJzLWFuZC1idWZmZXItdmlld3NcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlclZpZXdJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5QnVmZmVyPn1cbiAgICovXG4gIGxvYWRCdWZmZXJWaWV3KGJ1ZmZlclZpZXdJbmRleCkge1xuICAgIGNvbnN0IGJ1ZmZlclZpZXdEZWYgPSB0aGlzLmpzb24uYnVmZmVyVmlld3NbYnVmZmVyVmlld0luZGV4XTtcbiAgICByZXR1cm4gdGhpcy5nZXREZXBlbmRlbmN5KFwiYnVmZmVyXCIsIGJ1ZmZlclZpZXdEZWYuYnVmZmVyKS50aGVuKGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IGJ1ZmZlclZpZXdEZWYuYnl0ZUxlbmd0aCB8fCAwO1xuICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IGJ1ZmZlclZpZXdEZWYuYnl0ZU9mZnNldCB8fCAwO1xuICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZShieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjYWNjZXNzb3JzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhY2Nlc3NvckluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8QnVmZmVyQXR0cmlidXRlfEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlPn1cbiAgICovXG4gIGxvYWRBY2Nlc3NvcihhY2Nlc3NvckluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGFjY2Vzc29yRGVmID0gdGhpcy5qc29uLmFjY2Vzc29yc1thY2Nlc3NvckluZGV4XTtcbiAgICBpZiAoYWNjZXNzb3JEZWYuYnVmZmVyVmlldyA9PT0gdm9pZCAwICYmIGFjY2Vzc29yRGVmLnNwYXJzZSA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IFdFQkdMX1RZUEVfU0laRVNbYWNjZXNzb3JEZWYudHlwZV07XG4gICAgICBjb25zdCBUeXBlZEFycmF5ID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yRGVmLmNvbXBvbmVudFR5cGVdO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGFjY2Vzc29yRGVmLm5vcm1hbGl6ZWQgPT09IHRydWU7XG4gICAgICBjb25zdCBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGFjY2Vzc29yRGVmLmNvdW50ICogaXRlbVNpemUpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCkpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nQnVmZmVyVmlld3MgPSBbXTtcbiAgICBpZiAoYWNjZXNzb3JEZWYuYnVmZmVyVmlldyAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nQnVmZmVyVmlld3MucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZ0J1ZmZlclZpZXdzLnB1c2gobnVsbCk7XG4gICAgfVxuICAgIGlmIChhY2Nlc3NvckRlZi5zcGFyc2UgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZ0J1ZmZlclZpZXdzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLCBhY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5idWZmZXJWaWV3KSk7XG4gICAgICBwZW5kaW5nQnVmZmVyVmlld3MucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIGFjY2Vzc29yRGVmLnNwYXJzZS52YWx1ZXMuYnVmZmVyVmlldykpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZ0J1ZmZlclZpZXdzKS50aGVuKGZ1bmN0aW9uKGJ1ZmZlclZpZXdzKSB7XG4gICAgICBjb25zdCBidWZmZXJWaWV3ID0gYnVmZmVyVmlld3NbMF07XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IFdFQkdMX1RZUEVfU0laRVNbYWNjZXNzb3JEZWYudHlwZV07XG4gICAgICBjb25zdCBUeXBlZEFycmF5ID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yRGVmLmNvbXBvbmVudFR5cGVdO1xuICAgICAgY29uc3QgZWxlbWVudEJ5dGVzID0gVHlwZWRBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgIGNvbnN0IGl0ZW1CeXRlcyA9IGVsZW1lbnRCeXRlcyAqIGl0ZW1TaXplO1xuICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IGFjY2Vzc29yRGVmLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgIGNvbnN0IGJ5dGVTdHJpZGUgPSBhY2Nlc3NvckRlZi5idWZmZXJWaWV3ICE9PSB2b2lkIDAgPyBqc29uLmJ1ZmZlclZpZXdzW2FjY2Vzc29yRGVmLmJ1ZmZlclZpZXddLmJ5dGVTdHJpZGUgOiB2b2lkIDA7XG4gICAgICBjb25zdCBub3JtYWxpemVkID0gYWNjZXNzb3JEZWYubm9ybWFsaXplZCA9PT0gdHJ1ZTtcbiAgICAgIGxldCBhcnJheSwgYnVmZmVyQXR0cmlidXRlO1xuICAgICAgaWYgKGJ5dGVTdHJpZGUgJiYgYnl0ZVN0cmlkZSAhPT0gaXRlbUJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IGliU2xpY2UgPSBNYXRoLmZsb29yKGJ5dGVPZmZzZXQgLyBieXRlU3RyaWRlKTtcbiAgICAgICAgY29uc3QgaWJDYWNoZUtleSA9IFwiSW50ZXJsZWF2ZWRCdWZmZXI6XCIgKyBhY2Nlc3NvckRlZi5idWZmZXJWaWV3ICsgXCI6XCIgKyBhY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlICsgXCI6XCIgKyBpYlNsaWNlICsgXCI6XCIgKyBhY2Nlc3NvckRlZi5jb3VudDtcbiAgICAgICAgbGV0IGliID0gcGFyc2VyLmNhY2hlLmdldChpYkNhY2hlS2V5KTtcbiAgICAgICAgaWYgKCFpYikge1xuICAgICAgICAgIGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYnVmZmVyVmlldywgaWJTbGljZSAqIGJ5dGVTdHJpZGUsIGFjY2Vzc29yRGVmLmNvdW50ICogYnl0ZVN0cmlkZSAvIGVsZW1lbnRCeXRlcyk7XG4gICAgICAgICAgaWIgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXIoYXJyYXksIGJ5dGVTdHJpZGUgLyBlbGVtZW50Qnl0ZXMpO1xuICAgICAgICAgIHBhcnNlci5jYWNoZS5hZGQoaWJDYWNoZUtleSwgaWIpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZShcbiAgICAgICAgICBpYixcbiAgICAgICAgICBpdGVtU2l6ZSxcbiAgICAgICAgICBieXRlT2Zmc2V0ICUgYnl0ZVN0cmlkZSAvIGVsZW1lbnRCeXRlcyxcbiAgICAgICAgICBub3JtYWxpemVkXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYnVmZmVyVmlldyA9PT0gbnVsbCkge1xuICAgICAgICAgIGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYWNjZXNzb3JEZWYuY291bnQgKiBpdGVtU2l6ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShidWZmZXJWaWV3LCBieXRlT2Zmc2V0LCBhY2Nlc3NvckRlZi5jb3VudCAqIGl0ZW1TaXplKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG4gICAgICB9XG4gICAgICBpZiAoYWNjZXNzb3JEZWYuc3BhcnNlICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgaXRlbVNpemVJbmRpY2VzID0gV0VCR0xfVFlQRV9TSVpFUy5TQ0FMQVI7XG4gICAgICAgIGNvbnN0IFR5cGVkQXJyYXlJbmRpY2VzID0gV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yRGVmLnNwYXJzZS5pbmRpY2VzLmNvbXBvbmVudFR5cGVdO1xuICAgICAgICBjb25zdCBieXRlT2Zmc2V0SW5kaWNlcyA9IGFjY2Vzc29yRGVmLnNwYXJzZS5pbmRpY2VzLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3QgYnl0ZU9mZnNldFZhbHVlcyA9IGFjY2Vzc29yRGVmLnNwYXJzZS52YWx1ZXMuYnl0ZU9mZnNldCB8fCAwO1xuICAgICAgICBjb25zdCBzcGFyc2VJbmRpY2VzID0gbmV3IFR5cGVkQXJyYXlJbmRpY2VzKFxuICAgICAgICAgIGJ1ZmZlclZpZXdzWzFdLFxuICAgICAgICAgIGJ5dGVPZmZzZXRJbmRpY2VzLFxuICAgICAgICAgIGFjY2Vzc29yRGVmLnNwYXJzZS5jb3VudCAqIGl0ZW1TaXplSW5kaWNlc1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBzcGFyc2VWYWx1ZXMgPSBuZXcgVHlwZWRBcnJheShidWZmZXJWaWV3c1syXSwgYnl0ZU9mZnNldFZhbHVlcywgYWNjZXNzb3JEZWYuc3BhcnNlLmNvdW50ICogaXRlbVNpemUpO1xuICAgICAgICBpZiAoYnVmZmVyVmlldyAhPT0gbnVsbCkge1xuICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuYXJyYXkuc2xpY2UoKSxcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5pdGVtU2l6ZSxcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5ub3JtYWxpemVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBzcGFyc2VJbmRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHNwYXJzZUluZGljZXNbaV07XG4gICAgICAgICAgYnVmZmVyQXR0cmlidXRlLnNldFgoaW5kZXgsIHNwYXJzZVZhbHVlc1tpICogaXRlbVNpemVdKTtcbiAgICAgICAgICBpZiAoaXRlbVNpemUgPj0gMilcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5zZXRZKGluZGV4LCBzcGFyc2VWYWx1ZXNbaSAqIGl0ZW1TaXplICsgMV0pO1xuICAgICAgICAgIGlmIChpdGVtU2l6ZSA+PSAzKVxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLnNldFooaW5kZXgsIHNwYXJzZVZhbHVlc1tpICogaXRlbVNpemUgKyAyXSk7XG4gICAgICAgICAgaWYgKGl0ZW1TaXplID49IDQpXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuc2V0VyhpbmRleCwgc3BhcnNlVmFsdWVzW2kgKiBpdGVtU2l6ZSArIDNdKTtcbiAgICAgICAgICBpZiAoaXRlbVNpemUgPj0gNSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGl0ZW1TaXplIGluIHNwYXJzZSBCdWZmZXJBdHRyaWJ1dGUuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmZmVyQXR0cmlidXRlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjdGV4dHVyZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRleHR1cmVJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFRIUkVFLlRleHR1cmV8bnVsbD59XG4gICAqL1xuICBsb2FkVGV4dHVyZSh0ZXh0dXJlSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbdGV4dHVyZUluZGV4XTtcbiAgICBjb25zdCBzb3VyY2VJbmRleCA9IHRleHR1cmVEZWYuc291cmNlO1xuICAgIGNvbnN0IHNvdXJjZURlZiA9IGpzb24uaW1hZ2VzW3NvdXJjZUluZGV4XTtcbiAgICBsZXQgbG9hZGVyID0gdGhpcy50ZXh0dXJlTG9hZGVyO1xuICAgIGlmIChzb3VyY2VEZWYudXJpKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gb3B0aW9ucy5tYW5hZ2VyLmdldEhhbmRsZXIoc291cmNlRGVmLnVyaSk7XG4gICAgICBpZiAoaGFuZGxlciAhPT0gbnVsbClcbiAgICAgICAgbG9hZGVyID0gaGFuZGxlcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG9hZFRleHR1cmVJbWFnZSh0ZXh0dXJlSW5kZXgsIHNvdXJjZUluZGV4LCBsb2FkZXIpO1xuICB9XG4gIGxvYWRUZXh0dXJlSW1hZ2UodGV4dHVyZUluZGV4LCBzb3VyY2VJbmRleCwgbG9hZGVyKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzW3RleHR1cmVJbmRleF07XG4gICAgY29uc3Qgc291cmNlRGVmID0ganNvbi5pbWFnZXNbc291cmNlSW5kZXhdO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gKHNvdXJjZURlZi51cmkgfHwgc291cmNlRGVmLmJ1ZmZlclZpZXcpICsgXCI6XCIgKyB0ZXh0dXJlRGVmLnNhbXBsZXI7XG4gICAgaWYgKHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XSkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubG9hZEltYWdlU291cmNlKHNvdXJjZUluZGV4LCBsb2FkZXIpLnRoZW4oZnVuY3Rpb24odGV4dHVyZSkge1xuICAgICAgdGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuICAgICAgdGV4dHVyZS5uYW1lID0gdGV4dHVyZURlZi5uYW1lIHx8IHNvdXJjZURlZi5uYW1lIHx8IFwiXCI7XG4gICAgICBpZiAodGV4dHVyZS5uYW1lID09PSBcIlwiICYmIHR5cGVvZiBzb3VyY2VEZWYudXJpID09PSBcInN0cmluZ1wiICYmIHNvdXJjZURlZi51cmkuc3RhcnRzV2l0aChcImRhdGE6aW1hZ2UvXCIpID09PSBmYWxzZSkge1xuICAgICAgICB0ZXh0dXJlLm5hbWUgPSBzb3VyY2VEZWYudXJpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2FtcGxlcnMgPSBqc29uLnNhbXBsZXJzIHx8IHt9O1xuICAgICAgY29uc3Qgc2FtcGxlciA9IHNhbXBsZXJzW3RleHR1cmVEZWYuc2FtcGxlcl0gfHwge307XG4gICAgICB0ZXh0dXJlLm1hZ0ZpbHRlciA9IFdFQkdMX0ZJTFRFUlNbc2FtcGxlci5tYWdGaWx0ZXJdIHx8IExpbmVhckZpbHRlcjtcbiAgICAgIHRleHR1cmUubWluRmlsdGVyID0gV0VCR0xfRklMVEVSU1tzYW1wbGVyLm1pbkZpbHRlcl0gfHwgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyO1xuICAgICAgdGV4dHVyZS53cmFwUyA9IFdFQkdMX1dSQVBQSU5HU1tzYW1wbGVyLndyYXBTXSB8fCBSZXBlYXRXcmFwcGluZztcbiAgICAgIHRleHR1cmUud3JhcFQgPSBXRUJHTF9XUkFQUElOR1Nbc2FtcGxlci53cmFwVF0gfHwgUmVwZWF0V3JhcHBpbmc7XG4gICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldCh0ZXh0dXJlLCB7IHRleHR1cmVzOiB0ZXh0dXJlSW5kZXggfSk7XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICAgIHRoaXMudGV4dHVyZUNhY2hlW2NhY2hlS2V5XSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgbG9hZEltYWdlU291cmNlKHNvdXJjZUluZGV4LCBsb2FkZXIpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAodGhpcy5zb3VyY2VDYWNoZVtzb3VyY2VJbmRleF0gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlQ2FjaGVbc291cmNlSW5kZXhdLnRoZW4oKHRleHR1cmUpID0+IHRleHR1cmUuY2xvbmUoKSk7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZURlZiA9IGpzb24uaW1hZ2VzW3NvdXJjZUluZGV4XTtcbiAgICBjb25zdCBVUkwgPSBzZWxmLlVSTCB8fCBzZWxmLndlYmtpdFVSTDtcbiAgICBsZXQgc291cmNlVVJJID0gc291cmNlRGVmLnVyaSB8fCBcIlwiO1xuICAgIGxldCBpc09iamVjdFVSTCA9IGZhbHNlO1xuICAgIGlmIChzb3VyY2VEZWYuYnVmZmVyVmlldyAhPT0gdm9pZCAwKSB7XG4gICAgICBzb3VyY2VVUkkgPSBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclZpZXdcIiwgc291cmNlRGVmLmJ1ZmZlclZpZXcpLnRoZW4oZnVuY3Rpb24oYnVmZmVyVmlldykge1xuICAgICAgICBpc09iamVjdFVSTCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbYnVmZmVyVmlld10sIHsgdHlwZTogc291cmNlRGVmLm1pbWVUeXBlIH0pO1xuICAgICAgICBzb3VyY2VVUkkgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICByZXR1cm4gc291cmNlVVJJO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChzb3VyY2VEZWYudXJpID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IEltYWdlIFwiICsgc291cmNlSW5kZXggKyBcIiBpcyBtaXNzaW5nIFVSSSBhbmQgYnVmZmVyVmlld1wiKTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShzb3VyY2VVUkkpLnRoZW4oZnVuY3Rpb24oc291cmNlVVJJMikge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBsZXQgb25Mb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgaWYgKGxvYWRlci5pc0ltYWdlQml0bWFwTG9hZGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgb25Mb2FkID0gZnVuY3Rpb24oaW1hZ2VCaXRtYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZShpbWFnZUJpdG1hcCk7XG4gICAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUodGV4dHVyZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsb2FkZXIubG9hZChMb2FkZXJVdGlscy5yZXNvbHZlVVJMKHNvdXJjZVVSSTIsIG9wdGlvbnMucGF0aCksIG9uTG9hZCwgdm9pZCAwLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSkudGhlbihmdW5jdGlvbih0ZXh0dXJlKSB7XG4gICAgICBpZiAoaXNPYmplY3RVUkwgPT09IHRydWUpIHtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChzb3VyY2VVUkkpO1xuICAgICAgfVxuICAgICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YSh0ZXh0dXJlLCBzb3VyY2VEZWYpO1xuICAgICAgdGV4dHVyZS51c2VyRGF0YS5taW1lVHlwZSA9IHNvdXJjZURlZi5taW1lVHlwZSB8fCBnZXRJbWFnZVVSSU1pbWVUeXBlKHNvdXJjZURlZi51cmkpO1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBDb3VsZG4ndCBsb2FkIHRleHR1cmVcIiwgc291cmNlVVJJKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICAgIHRoaXMuc291cmNlQ2FjaGVbc291cmNlSW5kZXhdID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogQXN5bmNocm9ub3VzbHkgYXNzaWducyBhIHRleHR1cmUgdG8gdGhlIGdpdmVuIG1hdGVyaWFsIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXRlcmlhbFBhcmFtc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFwTmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwRGVmXG4gICAqIEByZXR1cm4ge1Byb21pc2U8VGV4dHVyZT59XG4gICAqL1xuICBhc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBtYXBOYW1lLCBtYXBEZWYsIGNvbG9yU3BhY2UpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLmdldERlcGVuZGVuY3koXCJ0ZXh0dXJlXCIsIG1hcERlZi5pbmRleCkudGhlbihmdW5jdGlvbih0ZXh0dXJlKSB7XG4gICAgICBpZiAoIXRleHR1cmUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgaWYgKG1hcERlZi50ZXhDb29yZCAhPT0gdm9pZCAwICYmIG1hcERlZi50ZXhDb29yZCA+IDApIHtcbiAgICAgICAgdGV4dHVyZSA9IHRleHR1cmUuY2xvbmUoKTtcbiAgICAgICAgdGV4dHVyZS5jaGFubmVsID0gbWFwRGVmLnRleENvb3JkO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnNlci5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNXSkge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBtYXBEZWYuZXh0ZW5zaW9ucyAhPT0gdm9pZCAwID8gbWFwRGVmLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk1dIDogdm9pZCAwO1xuICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgY29uc3QgZ2x0ZlJlZmVyZW5jZSA9IHBhcnNlci5hc3NvY2lhdGlvbnMuZ2V0KHRleHR1cmUpO1xuICAgICAgICAgIHRleHR1cmUgPSBwYXJzZXIuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STV0uZXh0ZW5kVGV4dHVyZSh0ZXh0dXJlLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KHRleHR1cmUsIGdsdGZSZWZlcmVuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29sb3JTcGFjZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29sb3JTcGFjZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICBjb2xvclNwYWNlID0gY29sb3JTcGFjZSA9PT0gc1JHQkVuY29kaW5nID8gU1JHQkNvbG9yU3BhY2UgOiBMaW5lYXJTUkdCQ29sb3JTcGFjZTtcbiAgICAgICAgaWYgKFwiY29sb3JTcGFjZVwiIGluIHRleHR1cmUpXG4gICAgICAgICAgdGV4dHVyZS5jb2xvclNwYWNlID0gY29sb3JTcGFjZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRleHR1cmUuZW5jb2RpbmcgPSBjb2xvclNwYWNlID09PSBTUkdCQ29sb3JTcGFjZSA/IHNSR0JFbmNvZGluZyA6IExpbmVhckVuY29kaW5nO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWxQYXJhbXNbbWFwTmFtZV0gPSB0ZXh0dXJlO1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFzc2lnbnMgZmluYWwgbWF0ZXJpYWwgdG8gYSBNZXNoLCBMaW5lLCBvciBQb2ludHMgaW5zdGFuY2UuIFRoZSBpbnN0YW5jZVxuICAgKiBhbHJlYWR5IGhhcyBhIG1hdGVyaWFsIChnZW5lcmF0ZWQgZnJvbSB0aGUgZ2xURiBtYXRlcmlhbCBvcHRpb25zIGFsb25lKVxuICAgKiBidXQgcmV1c2Ugb2YgdGhlIHNhbWUgZ2xURiBtYXRlcmlhbCBtYXkgcmVxdWlyZSBtdWx0aXBsZSB0aHJlZWpzIG1hdGVyaWFsc1xuICAgKiB0byBhY2NvbW1vZGF0ZSBkaWZmZXJlbnQgcHJpbWl0aXZlIHR5cGVzLCBkZWZpbmVzLCBldGMuIE5ldyBtYXRlcmlhbHMgd2lsbFxuICAgKiBiZSBjcmVhdGVkIGlmIG5lY2Vzc2FyeSwgYW5kIHJldXNlZCBmcm9tIGEgY2FjaGUuXG4gICAqIEBwYXJhbSAge09iamVjdDNEfSBtZXNoIE1lc2gsIExpbmUsIG9yIFBvaW50cyBpbnN0YW5jZS5cbiAgICovXG4gIGFzc2lnbkZpbmFsTWF0ZXJpYWwobWVzaCkge1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcbiAgICBsZXQgbWF0ZXJpYWwgPSBtZXNoLm1hdGVyaWFsO1xuICAgIGNvbnN0IHVzZURlcml2YXRpdmVUYW5nZW50cyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMudGFuZ2VudCA9PT0gdm9pZCAwO1xuICAgIGNvbnN0IHVzZVZlcnRleENvbG9ycyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IgIT09IHZvaWQgMDtcbiAgICBjb25zdCB1c2VGbGF0U2hhZGluZyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsID09PSB2b2lkIDA7XG4gICAgaWYgKG1lc2guaXNQb2ludHMpIHtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gXCJQb2ludHNNYXRlcmlhbDpcIiArIG1hdGVyaWFsLnV1aWQ7XG4gICAgICBsZXQgcG9pbnRzTWF0ZXJpYWwgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoIXBvaW50c01hdGVyaWFsKSB7XG4gICAgICAgIHBvaW50c01hdGVyaWFsID0gbmV3IFBvaW50c01hdGVyaWFsKCk7XG4gICAgICAgIE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwocG9pbnRzTWF0ZXJpYWwsIG1hdGVyaWFsKTtcbiAgICAgICAgcG9pbnRzTWF0ZXJpYWwuY29sb3IuY29weShtYXRlcmlhbC5jb2xvcik7XG4gICAgICAgIHBvaW50c01hdGVyaWFsLm1hcCA9IG1hdGVyaWFsLm1hcDtcbiAgICAgICAgcG9pbnRzTWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FjaGUuYWRkKGNhY2hlS2V5LCBwb2ludHNNYXRlcmlhbCk7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbCA9IHBvaW50c01hdGVyaWFsO1xuICAgIH0gZWxzZSBpZiAobWVzaC5pc0xpbmUpIHtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gXCJMaW5lQmFzaWNNYXRlcmlhbDpcIiArIG1hdGVyaWFsLnV1aWQ7XG4gICAgICBsZXQgbGluZU1hdGVyaWFsID0gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgaWYgKCFsaW5lTWF0ZXJpYWwpIHtcbiAgICAgICAgbGluZU1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCk7XG4gICAgICAgIE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwobGluZU1hdGVyaWFsLCBtYXRlcmlhbCk7XG4gICAgICAgIGxpbmVNYXRlcmlhbC5jb2xvci5jb3B5KG1hdGVyaWFsLmNvbG9yKTtcbiAgICAgICAgbGluZU1hdGVyaWFsLm1hcCA9IG1hdGVyaWFsLm1hcDtcbiAgICAgICAgdGhpcy5jYWNoZS5hZGQoY2FjaGVLZXksIGxpbmVNYXRlcmlhbCk7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbCA9IGxpbmVNYXRlcmlhbDtcbiAgICB9XG4gICAgaWYgKHVzZURlcml2YXRpdmVUYW5nZW50cyB8fCB1c2VWZXJ0ZXhDb2xvcnMgfHwgdXNlRmxhdFNoYWRpbmcpIHtcbiAgICAgIGxldCBjYWNoZUtleSA9IFwiQ2xvbmVkTWF0ZXJpYWw6XCIgKyBtYXRlcmlhbC51dWlkICsgXCI6XCI7XG4gICAgICBpZiAodXNlRGVyaXZhdGl2ZVRhbmdlbnRzKVxuICAgICAgICBjYWNoZUtleSArPSBcImRlcml2YXRpdmUtdGFuZ2VudHM6XCI7XG4gICAgICBpZiAodXNlVmVydGV4Q29sb3JzKVxuICAgICAgICBjYWNoZUtleSArPSBcInZlcnRleC1jb2xvcnM6XCI7XG4gICAgICBpZiAodXNlRmxhdFNoYWRpbmcpXG4gICAgICAgIGNhY2hlS2V5ICs9IFwiZmxhdC1zaGFkaW5nOlwiO1xuICAgICAgbGV0IGNhY2hlZE1hdGVyaWFsID0gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgaWYgKCFjYWNoZWRNYXRlcmlhbCkge1xuICAgICAgICBjYWNoZWRNYXRlcmlhbCA9IG1hdGVyaWFsLmNsb25lKCk7XG4gICAgICAgIGlmICh1c2VWZXJ0ZXhDb2xvcnMpXG4gICAgICAgICAgY2FjaGVkTWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdHJ1ZTtcbiAgICAgICAgaWYgKHVzZUZsYXRTaGFkaW5nKVxuICAgICAgICAgIGNhY2hlZE1hdGVyaWFsLmZsYXRTaGFkaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHVzZURlcml2YXRpdmVUYW5nZW50cykge1xuICAgICAgICAgIGlmIChjYWNoZWRNYXRlcmlhbC5ub3JtYWxTY2FsZSlcbiAgICAgICAgICAgIGNhY2hlZE1hdGVyaWFsLm5vcm1hbFNjYWxlLnkgKj0gLTE7XG4gICAgICAgICAgaWYgKGNhY2hlZE1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbFNjYWxlKVxuICAgICAgICAgICAgY2FjaGVkTWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsU2NhbGUueSAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlLmFkZChjYWNoZUtleSwgY2FjaGVkTWF0ZXJpYWwpO1xuICAgICAgICB0aGlzLmFzc29jaWF0aW9ucy5zZXQoY2FjaGVkTWF0ZXJpYWwsIHRoaXMuYXNzb2NpYXRpb25zLmdldChtYXRlcmlhbCkpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWwgPSBjYWNoZWRNYXRlcmlhbDtcbiAgICB9XG4gICAgbWVzaC5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZSgpIHtcbiAgICByZXR1cm4gTWVzaFN0YW5kYXJkTWF0ZXJpYWw7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjbWF0ZXJpYWxzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXRlcmlhbEluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8TWF0ZXJpYWw+fVxuICAgKi9cbiAgbG9hZE1hdGVyaWFsKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IGpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGxldCBtYXRlcmlhbFR5cGU7XG4gICAgY29uc3QgbWF0ZXJpYWxQYXJhbXMgPSB7fTtcbiAgICBjb25zdCBtYXRlcmlhbEV4dGVuc2lvbnMgPSBtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8IHt9O1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBpZiAobWF0ZXJpYWxFeHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19VTkxJVF0pIHtcbiAgICAgIGNvbnN0IGttdUV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUXTtcbiAgICAgIG1hdGVyaWFsVHlwZSA9IGttdUV4dGVuc2lvbi5nZXRNYXRlcmlhbFR5cGUoKTtcbiAgICAgIHBlbmRpbmcucHVzaChrbXVFeHRlbnNpb24uZXh0ZW5kUGFyYW1zKG1hdGVyaWFsUGFyYW1zLCBtYXRlcmlhbERlZiwgcGFyc2VyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1ldGFsbGljUm91Z2huZXNzID0gbWF0ZXJpYWxEZWYucGJyTWV0YWxsaWNSb3VnaG5lc3MgfHwge307XG4gICAgICBtYXRlcmlhbFBhcmFtcy5jb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxKTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSAxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yKSkge1xuICAgICAgICBjb25zdCBhcnJheSA9IG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcjtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuY29sb3Iuc2V0UkdCKGFycmF5WzBdLCBhcnJheVsxXSwgYXJyYXlbMl0sIExpbmVhclNSR0JDb2xvclNwYWNlKTtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IGFycmF5WzNdO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwibWFwXCIsIG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUsIFNSR0JDb2xvclNwYWNlKSk7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbFBhcmFtcy5tZXRhbG5lc3MgPSBtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY0ZhY3RvciAhPT0gdm9pZCAwID8gbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNGYWN0b3IgOiAxO1xuICAgICAgbWF0ZXJpYWxQYXJhbXMucm91Z2huZXNzID0gbWV0YWxsaWNSb3VnaG5lc3Mucm91Z2huZXNzRmFjdG9yICE9PSB2b2lkIDAgPyBtZXRhbGxpY1JvdWdobmVzcy5yb3VnaG5lc3NGYWN0b3IgOiAxO1xuICAgICAgaWYgKG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJtZXRhbG5lc3NNYXBcIiwgbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlKSk7XG4gICAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJyb3VnaG5lc3NNYXBcIiwgbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlKSk7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbFR5cGUgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgIHJldHVybiBleHQuZ2V0TWF0ZXJpYWxUeXBlICYmIGV4dC5nZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmcucHVzaChcbiAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgdGhpcy5faW52b2tlQWxsKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5leHRlbmRNYXRlcmlhbFBhcmFtcyAmJiBleHQuZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpO1xuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbERlZi5kb3VibGVTaWRlZCA9PT0gdHJ1ZSkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuc2lkZSA9IERvdWJsZVNpZGU7XG4gICAgfVxuICAgIGNvbnN0IGFscGhhTW9kZSA9IG1hdGVyaWFsRGVmLmFscGhhTW9kZSB8fCBBTFBIQV9NT0RFUy5PUEFRVUU7XG4gICAgaWYgKGFscGhhTW9kZSA9PT0gQUxQSEFfTU9ERVMuQkxFTkQpIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmRlcHRoV3JpdGUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMudHJhbnNwYXJlbnQgPSBmYWxzZTtcbiAgICAgIGlmIChhbHBoYU1vZGUgPT09IEFMUEhBX01PREVTLk1BU0spIHtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuYWxwaGFUZXN0ID0gbWF0ZXJpYWxEZWYuYWxwaGFDdXRvZmYgIT09IHZvaWQgMCA/IG1hdGVyaWFsRGVmLmFscGhhQ3V0b2ZmIDogMC41O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZSAhPT0gdm9pZCAwICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwpIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJub3JtYWxNYXBcIiwgbWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZSkpO1xuICAgICAgbWF0ZXJpYWxQYXJhbXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMigxLCAxKTtcbiAgICAgIGlmIChtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlLnNjYWxlICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBtYXRlcmlhbERlZi5ub3JtYWxUZXh0dXJlLnNjYWxlO1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5ub3JtYWxTY2FsZS5zZXQoc2NhbGUsIHNjYWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUgIT09IHZvaWQgMCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiYW9NYXBcIiwgbWF0ZXJpYWxEZWYub2NjbHVzaW9uVGV4dHVyZSkpO1xuICAgICAgaWYgKG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUuc3RyZW5ndGggIT09IHZvaWQgMCkge1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5hb01hcEludGVuc2l0eSA9IG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUuc3RyZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbERlZi5lbWlzc2l2ZUZhY3RvciAhPT0gdm9pZCAwICYmIG1hdGVyaWFsVHlwZSAhPT0gTWVzaEJhc2ljTWF0ZXJpYWwpIHtcbiAgICAgIGNvbnN0IGVtaXNzaXZlRmFjdG9yID0gbWF0ZXJpYWxEZWYuZW1pc3NpdmVGYWN0b3I7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5lbWlzc2l2ZSA9IG5ldyBDb2xvcigpLnNldFJHQihcbiAgICAgICAgZW1pc3NpdmVGYWN0b3JbMF0sXG4gICAgICAgIGVtaXNzaXZlRmFjdG9yWzFdLFxuICAgICAgICBlbWlzc2l2ZUZhY3RvclsyXSxcbiAgICAgICAgTGluZWFyU1JHQkNvbG9yU3BhY2VcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbERlZi5lbWlzc2l2ZVRleHR1cmUgIT09IHZvaWQgMCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiZW1pc3NpdmVNYXBcIiwgbWF0ZXJpYWxEZWYuZW1pc3NpdmVUZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IG1hdGVyaWFsVHlwZShtYXRlcmlhbFBhcmFtcyk7XG4gICAgICBpZiAobWF0ZXJpYWxEZWYubmFtZSlcbiAgICAgICAgbWF0ZXJpYWwubmFtZSA9IG1hdGVyaWFsRGVmLm5hbWU7XG4gICAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKG1hdGVyaWFsLCBtYXRlcmlhbERlZik7XG4gICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldChtYXRlcmlhbCwgeyBtYXRlcmlhbHM6IG1hdGVyaWFsSW5kZXggfSk7XG4gICAgICBpZiAobWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucylcbiAgICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIG1hdGVyaWFsLCBtYXRlcmlhbERlZik7XG4gICAgICByZXR1cm4gbWF0ZXJpYWw7XG4gICAgfSk7XG4gIH1cbiAgLyoqIFdoZW4gT2JqZWN0M0QgaW5zdGFuY2VzIGFyZSB0YXJnZXRlZCBieSBhbmltYXRpb24sIHRoZXkgbmVlZCB1bmlxdWUgbmFtZXMuICovXG4gIGNyZWF0ZVVuaXF1ZU5hbWUob3JpZ2luYWxOYW1lKSB7XG4gICAgY29uc3Qgc2FuaXRpemVkTmFtZSA9IFByb3BlcnR5QmluZGluZy5zYW5pdGl6ZU5vZGVOYW1lKG9yaWdpbmFsTmFtZSB8fCBcIlwiKTtcbiAgICBpZiAoc2FuaXRpemVkTmFtZSBpbiB0aGlzLm5vZGVOYW1lc1VzZWQpIHtcbiAgICAgIHJldHVybiBzYW5pdGl6ZWROYW1lICsgXCJfXCIgKyArK3RoaXMubm9kZU5hbWVzVXNlZFtzYW5pdGl6ZWROYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub2RlTmFtZXNVc2VkW3Nhbml0aXplZE5hbWVdID0gMDtcbiAgICAgIHJldHVybiBzYW5pdGl6ZWROYW1lO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNnZW9tZXRyeVxuICAgKlxuICAgKiBDcmVhdGVzIEJ1ZmZlckdlb21ldHJpZXMgZnJvbSBwcmltaXRpdmVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PEdMVEYuUHJpbWl0aXZlPn0gcHJpbWl0aXZlc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PEJ1ZmZlckdlb21ldHJ5Pj59XG4gICAqL1xuICBsb2FkR2VvbWV0cmllcyhwcmltaXRpdmVzKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5wcmltaXRpdmVDYWNoZTtcbiAgICBmdW5jdGlvbiBjcmVhdGVEcmFjb1ByaW1pdGl2ZShwcmltaXRpdmUpIHtcbiAgICAgIHJldHVybiBleHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT05dLmRlY29kZVByaW1pdGl2ZShwcmltaXRpdmUsIHBhcnNlcikudGhlbihmdW5jdGlvbihnZW9tZXRyeSkge1xuICAgICAgICByZXR1cm4gYWRkUHJpbWl0aXZlQXR0cmlidXRlcyhnZW9tZXRyeSwgcHJpbWl0aXZlLCBwYXJzZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBwcmltaXRpdmVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGNvbnN0IHByaW1pdGl2ZSA9IHByaW1pdGl2ZXNbaV07XG4gICAgICBjb25zdCBjYWNoZUtleSA9IGNyZWF0ZVByaW1pdGl2ZUtleShwcmltaXRpdmUpO1xuICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICBwZW5kaW5nLnB1c2goY2FjaGVkLnByb21pc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGdlb21ldHJ5UHJvbWlzZTtcbiAgICAgICAgaWYgKHByaW1pdGl2ZS5leHRlbnNpb25zICYmIHByaW1pdGl2ZS5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT05dKSB7XG4gICAgICAgICAgZ2VvbWV0cnlQcm9taXNlID0gY3JlYXRlRHJhY29QcmltaXRpdmUocHJpbWl0aXZlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZW9tZXRyeVByb21pc2UgPSBhZGRQcmltaXRpdmVBdHRyaWJ1dGVzKG5ldyBCdWZmZXJHZW9tZXRyeSgpLCBwcmltaXRpdmUsIHBhcnNlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGVbY2FjaGVLZXldID0geyBwcmltaXRpdmUsIHByb21pc2U6IGdlb21ldHJ5UHJvbWlzZSB9O1xuICAgICAgICBwZW5kaW5nLnB1c2goZ2VvbWV0cnlQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI21lc2hlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gbWVzaEluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8R3JvdXB8TWVzaHxTa2lubmVkTWVzaD59XG4gICAqL1xuICBsb2FkTWVzaChtZXNoSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICBjb25zdCBtZXNoRGVmID0ganNvbi5tZXNoZXNbbWVzaEluZGV4XTtcbiAgICBjb25zdCBwcmltaXRpdmVzID0gbWVzaERlZi5wcmltaXRpdmVzO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBwcmltaXRpdmVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGNvbnN0IG1hdGVyaWFsID0gcHJpbWl0aXZlc1tpXS5tYXRlcmlhbCA9PT0gdm9pZCAwID8gY3JlYXRlRGVmYXVsdE1hdGVyaWFsKHRoaXMuY2FjaGUpIDogdGhpcy5nZXREZXBlbmRlbmN5KFwibWF0ZXJpYWxcIiwgcHJpbWl0aXZlc1tpXS5tYXRlcmlhbCk7XG4gICAgICBwZW5kaW5nLnB1c2gobWF0ZXJpYWwpO1xuICAgIH1cbiAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmxvYWRHZW9tZXRyaWVzKHByaW1pdGl2ZXMpKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICBjb25zdCBtYXRlcmlhbHMgPSByZXN1bHRzLnNsaWNlKDAsIHJlc3VsdHMubGVuZ3RoIC0gMSk7XG4gICAgICBjb25zdCBnZW9tZXRyaWVzID0gcmVzdWx0c1tyZXN1bHRzLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgbWVzaGVzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBnZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzW2ldO1xuICAgICAgICBjb25zdCBwcmltaXRpdmUgPSBwcmltaXRpdmVzW2ldO1xuICAgICAgICBsZXQgbWVzaDtcbiAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBtYXRlcmlhbHNbaV07XG4gICAgICAgIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFUyB8fCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX1NUUklQIHx8IHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfRkFOIHx8IHByaW1pdGl2ZS5tb2RlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBtZXNoID0gbWVzaERlZi5pc1NraW5uZWRNZXNoID09PSB0cnVlID8gbmV3IFNraW5uZWRNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCkgOiBuZXcgTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICAgIGlmIChtZXNoLmlzU2tpbm5lZE1lc2ggPT09IHRydWUpIHtcbiAgICAgICAgICAgIG1lc2gubm9ybWFsaXplU2tpbldlaWdodHMoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfU1RSSVApIHtcbiAgICAgICAgICAgIG1lc2guZ2VvbWV0cnkgPSB0b1RyaWFuZ2xlc0RyYXdNb2RlKG1lc2guZ2VvbWV0cnksIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX0ZBTikge1xuICAgICAgICAgICAgbWVzaC5nZW9tZXRyeSA9IHRvVHJpYW5nbGVzRHJhd01vZGUobWVzaC5nZW9tZXRyeSwgVHJpYW5nbGVGYW5EcmF3TW9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuTElORVMpIHtcbiAgICAgICAgICBtZXNoID0gbmV3IExpbmVTZWdtZW50cyhnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuTElORV9TVFJJUCkge1xuICAgICAgICAgIG1lc2ggPSBuZXcgTGluZShnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuTElORV9MT09QKSB7XG4gICAgICAgICAgbWVzaCA9IG5ldyBMaW5lTG9vcChnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICB9IGVsc2UgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuUE9JTlRTKSB7XG4gICAgICAgICAgbWVzaCA9IG5ldyBQb2ludHMoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBQcmltaXRpdmUgbW9kZSB1bnN1cHBvcnRlZDogXCIgKyBwcmltaXRpdmUubW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1lc2guZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdXBkYXRlTW9ycGhUYXJnZXRzKG1lc2gsIG1lc2hEZWYpO1xuICAgICAgICB9XG4gICAgICAgIG1lc2gubmFtZSA9IHBhcnNlci5jcmVhdGVVbmlxdWVOYW1lKG1lc2hEZWYubmFtZSB8fCBcIm1lc2hfXCIgKyBtZXNoSW5kZXgpO1xuICAgICAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKG1lc2gsIG1lc2hEZWYpO1xuICAgICAgICBpZiAocHJpbWl0aXZlLmV4dGVuc2lvbnMpXG4gICAgICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIG1lc2gsIHByaW1pdGl2ZSk7XG4gICAgICAgIHBhcnNlci5hc3NpZ25GaW5hbE1hdGVyaWFsKG1lc2gpO1xuICAgICAgICBtZXNoZXMucHVzaChtZXNoKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG1lc2hlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KG1lc2hlc1tpXSwge1xuICAgICAgICAgIG1lc2hlczogbWVzaEluZGV4LFxuICAgICAgICAgIHByaW1pdGl2ZXM6IGlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAobWVzaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAobWVzaERlZi5leHRlbnNpb25zKVxuICAgICAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBtZXNoZXNbMF0sIG1lc2hEZWYpO1xuICAgICAgICByZXR1cm4gbWVzaGVzWzBdO1xuICAgICAgfVxuICAgICAgY29uc3QgZ3JvdXAgPSBuZXcgR3JvdXAoKTtcbiAgICAgIGlmIChtZXNoRGVmLmV4dGVuc2lvbnMpXG4gICAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBncm91cCwgbWVzaERlZik7XG4gICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldChncm91cCwgeyBtZXNoZXM6IG1lc2hJbmRleCB9KTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG1lc2hlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGdyb3VwLmFkZChtZXNoZXNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjY2FtZXJhc1xuICAgKiBAcGFyYW0ge251bWJlcn0gY2FtZXJhSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxUSFJFRS5DYW1lcmE+fVxuICAgKi9cbiAgbG9hZENhbWVyYShjYW1lcmFJbmRleCkge1xuICAgIGxldCBjYW1lcmE7XG4gICAgY29uc3QgY2FtZXJhRGVmID0gdGhpcy5qc29uLmNhbWVyYXNbY2FtZXJhSW5kZXhdO1xuICAgIGNvbnN0IHBhcmFtcyA9IGNhbWVyYURlZltjYW1lcmFEZWYudHlwZV07XG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IE1pc3NpbmcgY2FtZXJhIHBhcmFtZXRlcnMuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2FtZXJhRGVmLnR5cGUgPT09IFwicGVyc3BlY3RpdmVcIikge1xuICAgICAgY2FtZXJhID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKFxuICAgICAgICBNYXRoVXRpbHMucmFkVG9EZWcocGFyYW1zLnlmb3YpLFxuICAgICAgICBwYXJhbXMuYXNwZWN0UmF0aW8gfHwgMSxcbiAgICAgICAgcGFyYW1zLnpuZWFyIHx8IDEsXG4gICAgICAgIHBhcmFtcy56ZmFyIHx8IDJlNlxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGNhbWVyYURlZi50eXBlID09PSBcIm9ydGhvZ3JhcGhpY1wiKSB7XG4gICAgICBjYW1lcmEgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKC1wYXJhbXMueG1hZywgcGFyYW1zLnhtYWcsIHBhcmFtcy55bWFnLCAtcGFyYW1zLnltYWcsIHBhcmFtcy56bmVhciwgcGFyYW1zLnpmYXIpO1xuICAgIH1cbiAgICBpZiAoY2FtZXJhRGVmLm5hbWUpXG4gICAgICBjYW1lcmEubmFtZSA9IHRoaXMuY3JlYXRlVW5pcXVlTmFtZShjYW1lcmFEZWYubmFtZSk7XG4gICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShjYW1lcmEsIGNhbWVyYURlZik7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYW1lcmEpO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjc2tpbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNraW5JbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFNrZWxldG9uPn1cbiAgICovXG4gIGxvYWRTa2luKHNraW5JbmRleCkge1xuICAgIGNvbnN0IHNraW5EZWYgPSB0aGlzLmpzb24uc2tpbnNbc2tpbkluZGV4XTtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gc2tpbkRlZi5qb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgcGVuZGluZy5wdXNoKHRoaXMuX2xvYWROb2RlU2hhbGxvdyhza2luRGVmLmpvaW50c1tpXSkpO1xuICAgIH1cbiAgICBpZiAoc2tpbkRlZi5pbnZlcnNlQmluZE1hdHJpY2VzICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBza2luRGVmLmludmVyc2VCaW5kTWF0cmljZXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZy5wdXNoKG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICBjb25zdCBpbnZlcnNlQmluZE1hdHJpY2VzID0gcmVzdWx0cy5wb3AoKTtcbiAgICAgIGNvbnN0IGpvaW50Tm9kZXMgPSByZXN1bHRzO1xuICAgICAgY29uc3QgYm9uZXMgPSBbXTtcbiAgICAgIGNvbnN0IGJvbmVJbnZlcnNlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gam9pbnROb2Rlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGpvaW50Tm9kZSA9IGpvaW50Tm9kZXNbaV07XG4gICAgICAgIGlmIChqb2ludE5vZGUpIHtcbiAgICAgICAgICBib25lcy5wdXNoKGpvaW50Tm9kZSk7XG4gICAgICAgICAgY29uc3QgbWF0ID0gbmV3IE1hdHJpeDQoKTtcbiAgICAgICAgICBpZiAoaW52ZXJzZUJpbmRNYXRyaWNlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWF0LmZyb21BcnJheShpbnZlcnNlQmluZE1hdHJpY2VzLmFycmF5LCBpICogMTYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBib25lSW52ZXJzZXMucHVzaChtYXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuR0xURkxvYWRlcjogSm9pbnQgXCIlc1wiIGNvdWxkIG5vdCBiZSBmb3VuZC4nLCBza2luRGVmLmpvaW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgU2tlbGV0b24oYm9uZXMsIGJvbmVJbnZlcnNlcyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNhbmltYXRpb25zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbmltYXRpb25JbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFuaW1hdGlvbkNsaXA+fVxuICAgKi9cbiAgbG9hZEFuaW1hdGlvbihhbmltYXRpb25JbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBhbmltYXRpb25EZWYgPSBqc29uLmFuaW1hdGlvbnNbYW5pbWF0aW9uSW5kZXhdO1xuICAgIGNvbnN0IGFuaW1hdGlvbk5hbWUgPSBhbmltYXRpb25EZWYubmFtZSA/IGFuaW1hdGlvbkRlZi5uYW1lIDogXCJhbmltYXRpb25fXCIgKyBhbmltYXRpb25JbmRleDtcbiAgICBjb25zdCBwZW5kaW5nTm9kZXMgPSBbXTtcbiAgICBjb25zdCBwZW5kaW5nSW5wdXRBY2Nlc3NvcnMgPSBbXTtcbiAgICBjb25zdCBwZW5kaW5nT3V0cHV0QWNjZXNzb3JzID0gW107XG4gICAgY29uc3QgcGVuZGluZ1NhbXBsZXJzID0gW107XG4gICAgY29uc3QgcGVuZGluZ1RhcmdldHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBhbmltYXRpb25EZWYuY2hhbm5lbHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IGFuaW1hdGlvbkRlZi5jaGFubmVsc1tpXTtcbiAgICAgIGNvbnN0IHNhbXBsZXIgPSBhbmltYXRpb25EZWYuc2FtcGxlcnNbY2hhbm5lbC5zYW1wbGVyXTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGNoYW5uZWwudGFyZ2V0O1xuICAgICAgY29uc3QgbmFtZSA9IHRhcmdldC5ub2RlO1xuICAgICAgY29uc3QgaW5wdXQgPSBhbmltYXRpb25EZWYucGFyYW1ldGVycyAhPT0gdm9pZCAwID8gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnNbc2FtcGxlci5pbnB1dF0gOiBzYW1wbGVyLmlucHV0O1xuICAgICAgY29uc3Qgb3V0cHV0ID0gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnMgIT09IHZvaWQgMCA/IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzW3NhbXBsZXIub3V0cHV0XSA6IHNhbXBsZXIub3V0cHV0O1xuICAgICAgaWYgKHRhcmdldC5ub2RlID09PSB2b2lkIDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgcGVuZGluZ05vZGVzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwibm9kZVwiLCBuYW1lKSk7XG4gICAgICBwZW5kaW5nSW5wdXRBY2Nlc3NvcnMucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBpbnB1dCkpO1xuICAgICAgcGVuZGluZ091dHB1dEFjY2Vzc29ycy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIG91dHB1dCkpO1xuICAgICAgcGVuZGluZ1NhbXBsZXJzLnB1c2goc2FtcGxlcik7XG4gICAgICBwZW5kaW5nVGFyZ2V0cy5wdXNoKHRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICBQcm9taXNlLmFsbChwZW5kaW5nTm9kZXMpLFxuICAgICAgUHJvbWlzZS5hbGwocGVuZGluZ0lucHV0QWNjZXNzb3JzKSxcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMpLFxuICAgICAgUHJvbWlzZS5hbGwocGVuZGluZ1NhbXBsZXJzKSxcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdUYXJnZXRzKVxuICAgIF0pLnRoZW4oZnVuY3Rpb24oZGVwZW5kZW5jaWVzKSB7XG4gICAgICBjb25zdCBub2RlcyA9IGRlcGVuZGVuY2llc1swXTtcbiAgICAgIGNvbnN0IGlucHV0QWNjZXNzb3JzID0gZGVwZW5kZW5jaWVzWzFdO1xuICAgICAgY29uc3Qgb3V0cHV0QWNjZXNzb3JzID0gZGVwZW5kZW5jaWVzWzJdO1xuICAgICAgY29uc3Qgc2FtcGxlcnMgPSBkZXBlbmRlbmNpZXNbM107XG4gICAgICBjb25zdCB0YXJnZXRzID0gZGVwZW5kZW5jaWVzWzRdO1xuICAgICAgY29uc3QgdHJhY2tzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBub2Rlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgY29uc3QgaW5wdXRBY2Nlc3NvciA9IGlucHV0QWNjZXNzb3JzW2ldO1xuICAgICAgICBjb25zdCBvdXRwdXRBY2Nlc3NvciA9IG91dHB1dEFjY2Vzc29yc1tpXTtcbiAgICAgICAgY29uc3Qgc2FtcGxlciA9IHNhbXBsZXJzW2ldO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAobm9kZS51cGRhdGVNYXRyaXgpIHtcbiAgICAgICAgICBub2RlLnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNyZWF0ZWRUcmFja3MgPSBwYXJzZXIuX2NyZWF0ZUFuaW1hdGlvblRyYWNrcyhub2RlLCBpbnB1dEFjY2Vzc29yLCBvdXRwdXRBY2Nlc3Nvciwgc2FtcGxlciwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKGNyZWF0ZWRUcmFja3MpIHtcbiAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNyZWF0ZWRUcmFja3MubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHRyYWNrcy5wdXNoKGNyZWF0ZWRUcmFja3Nba10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25DbGlwKGFuaW1hdGlvbk5hbWUsIHZvaWQgMCwgdHJhY2tzKTtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVOb2RlTWVzaChub2RlSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBpZiAobm9kZURlZi5tZXNoID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koXCJtZXNoXCIsIG5vZGVEZWYubWVzaCkudGhlbihmdW5jdGlvbihtZXNoKSB7XG4gICAgICBjb25zdCBub2RlID0gcGFyc2VyLl9nZXROb2RlUmVmKHBhcnNlci5tZXNoQ2FjaGUsIG5vZGVEZWYubWVzaCwgbWVzaCk7XG4gICAgICBpZiAobm9kZURlZi53ZWlnaHRzICE9PSB2b2lkIDApIHtcbiAgICAgICAgbm9kZS50cmF2ZXJzZShmdW5jdGlvbihvKSB7XG4gICAgICAgICAgaWYgKCFvLmlzTWVzaClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBub2RlRGVmLndlaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgICAgby5tb3JwaFRhcmdldEluZmx1ZW5jZXNbaV0gPSBub2RlRGVmLndlaWdodHNbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjbm9kZXMtYW5kLWhpZXJhcmNoeVxuICAgKiBAcGFyYW0ge251bWJlcn0gbm9kZUluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0M0Q+fVxuICAgKi9cbiAgbG9hZE5vZGUobm9kZUluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzW25vZGVJbmRleF07XG4gICAgY29uc3Qgbm9kZVBlbmRpbmcgPSBwYXJzZXIuX2xvYWROb2RlU2hhbGxvdyhub2RlSW5kZXgpO1xuICAgIGNvbnN0IGNoaWxkUGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGNoaWxkcmVuRGVmID0gbm9kZURlZi5jaGlsZHJlbiB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBjaGlsZHJlbkRlZi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjaGlsZFBlbmRpbmcucHVzaChwYXJzZXIuZ2V0RGVwZW5kZW5jeShcIm5vZGVcIiwgY2hpbGRyZW5EZWZbaV0pKTtcbiAgICB9XG4gICAgY29uc3Qgc2tlbGV0b25QZW5kaW5nID0gbm9kZURlZi5za2luID09PSB2b2lkIDAgPyBQcm9taXNlLnJlc29sdmUobnVsbCkgOiBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcInNraW5cIiwgbm9kZURlZi5za2luKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW25vZGVQZW5kaW5nLCBQcm9taXNlLmFsbChjaGlsZFBlbmRpbmcpLCBza2VsZXRvblBlbmRpbmddKS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSByZXN1bHRzWzBdO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSByZXN1bHRzWzFdO1xuICAgICAgY29uc3Qgc2tlbGV0b24gPSByZXN1bHRzWzJdO1xuICAgICAgaWYgKHNrZWxldG9uICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUudHJhdmVyc2UoZnVuY3Rpb24obWVzaCkge1xuICAgICAgICAgIGlmICghbWVzaC5pc1NraW5uZWRNZXNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIG1lc2guYmluZChza2VsZXRvbiwgX2lkZW50aXR5TWF0cml4KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIG5vZGUuYWRkKGNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICB9XG4gIC8vIC5fbG9hZE5vZGVTaGFsbG93KCkgcGFyc2VzIGEgc2luZ2xlIG5vZGUuXG4gIC8vIHNraW4gYW5kIGNoaWxkIG5vZGVzIGFyZSBjcmVhdGVkIGFuZCBhZGRlZCBpbiAubG9hZE5vZGUoKSAobm8gJ18nIHByZWZpeCkuXG4gIF9sb2FkTm9kZVNoYWxsb3cobm9kZUluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgaWYgKHRoaXMubm9kZUNhY2hlW25vZGVJbmRleF0gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZUNhY2hlW25vZGVJbmRleF07XG4gICAgfVxuICAgIGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzW25vZGVJbmRleF07XG4gICAgY29uc3Qgbm9kZU5hbWUgPSBub2RlRGVmLm5hbWUgPyBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZShub2RlRGVmLm5hbWUpIDogXCJcIjtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgbWVzaFByb21pc2UgPSBwYXJzZXIuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgIHJldHVybiBleHQuY3JlYXRlTm9kZU1lc2ggJiYgZXh0LmNyZWF0ZU5vZGVNZXNoKG5vZGVJbmRleCk7XG4gICAgfSk7XG4gICAgaWYgKG1lc2hQcm9taXNlKSB7XG4gICAgICBwZW5kaW5nLnB1c2gobWVzaFByb21pc2UpO1xuICAgIH1cbiAgICBpZiAobm9kZURlZi5jYW1lcmEgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImNhbWVyYVwiLCBub2RlRGVmLmNhbWVyYSkudGhlbihmdW5jdGlvbihjYW1lcmEpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLl9nZXROb2RlUmVmKHBhcnNlci5jYW1lcmFDYWNoZSwgbm9kZURlZi5jYW1lcmEsIGNhbWVyYSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBwYXJzZXIuX2ludm9rZUFsbChmdW5jdGlvbihleHQpIHtcbiAgICAgIHJldHVybiBleHQuY3JlYXRlTm9kZUF0dGFjaG1lbnQgJiYgZXh0LmNyZWF0ZU5vZGVBdHRhY2htZW50KG5vZGVJbmRleCk7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocHJvbWlzZSk7XG4gICAgfSk7XG4gICAgdGhpcy5ub2RlQ2FjaGVbbm9kZUluZGV4XSA9IFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24ob2JqZWN0cykge1xuICAgICAgbGV0IG5vZGU7XG4gICAgICBpZiAobm9kZURlZi5pc0JvbmUgPT09IHRydWUpIHtcbiAgICAgICAgbm9kZSA9IG5ldyBCb25lKCk7XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdHMubGVuZ3RoID4gMSkge1xuICAgICAgICBub2RlID0gbmV3IEdyb3VwKCk7XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG5vZGUgPSBvYmplY3RzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IG5ldyBPYmplY3QzRCgpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgIT09IG9iamVjdHNbMF0pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgbm9kZS5hZGQob2JqZWN0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlRGVmLm5hbWUpIHtcbiAgICAgICAgbm9kZS51c2VyRGF0YS5uYW1lID0gbm9kZURlZi5uYW1lO1xuICAgICAgICBub2RlLm5hbWUgPSBub2RlTmFtZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEobm9kZSwgbm9kZURlZik7XG4gICAgICBpZiAobm9kZURlZi5leHRlbnNpb25zKVxuICAgICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgbm9kZSwgbm9kZURlZik7XG4gICAgICBpZiAobm9kZURlZi5tYXRyaXggIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgICAgICBtYXRyaXguZnJvbUFycmF5KG5vZGVEZWYubWF0cml4KTtcbiAgICAgICAgbm9kZS5hcHBseU1hdHJpeDQobWF0cml4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChub2RlRGVmLnRyYW5zbGF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBub2RlLnBvc2l0aW9uLmZyb21BcnJheShub2RlRGVmLnRyYW5zbGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZURlZi5yb3RhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgbm9kZS5xdWF0ZXJuaW9uLmZyb21BcnJheShub2RlRGVmLnJvdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZURlZi5zY2FsZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgbm9kZS5zY2FsZS5mcm9tQXJyYXkobm9kZURlZi5zY2FsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcGFyc2VyLmFzc29jaWF0aW9ucy5oYXMobm9kZSkpIHtcbiAgICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQobm9kZSwge30pO1xuICAgICAgfVxuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5nZXQobm9kZSkubm9kZXMgPSBub2RlSW5kZXg7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5ub2RlQ2FjaGVbbm9kZUluZGV4XTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3NjZW5lc1xuICAgKiBAcGFyYW0ge251bWJlcn0gc2NlbmVJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEdyb3VwPn1cbiAgICovXG4gIGxvYWRTY2VuZShzY2VuZUluZGV4KSB7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICBjb25zdCBzY2VuZURlZiA9IHRoaXMuanNvbi5zY2VuZXNbc2NlbmVJbmRleF07XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBzY2VuZSA9IG5ldyBHcm91cCgpO1xuICAgIGlmIChzY2VuZURlZi5uYW1lKVxuICAgICAgc2NlbmUubmFtZSA9IHBhcnNlci5jcmVhdGVVbmlxdWVOYW1lKHNjZW5lRGVmLm5hbWUpO1xuICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoc2NlbmUsIHNjZW5lRGVmKTtcbiAgICBpZiAoc2NlbmVEZWYuZXh0ZW5zaW9ucylcbiAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBzY2VuZSwgc2NlbmVEZWYpO1xuICAgIGNvbnN0IG5vZGVJZHMgPSBzY2VuZURlZi5ub2RlcyB8fCBbXTtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbm9kZUlkcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmdldERlcGVuZGVuY3koXCJub2RlXCIsIG5vZGVJZHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgc2NlbmUuYWRkKG5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlZHVjZUFzc29jaWF0aW9ucyA9IChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZHVjZWRBc3NvY2lhdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBwYXJzZXIuYXNzb2NpYXRpb25zKSB7XG4gICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIE1hdGVyaWFsIHx8IGtleSBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgICAgICAgIHJlZHVjZWRBc3NvY2lhdGlvbnMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlLnRyYXZlcnNlKChub2RlMikgPT4ge1xuICAgICAgICAgIGNvbnN0IG1hcHBpbmdzID0gcGFyc2VyLmFzc29jaWF0aW9ucy5nZXQobm9kZTIpO1xuICAgICAgICAgIGlmIChtYXBwaW5ncyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZWR1Y2VkQXNzb2NpYXRpb25zLnNldChub2RlMiwgbWFwcGluZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZWR1Y2VkQXNzb2NpYXRpb25zO1xuICAgICAgfTtcbiAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMgPSByZWR1Y2VBc3NvY2lhdGlvbnMoc2NlbmUpO1xuICAgICAgcmV0dXJuIHNjZW5lO1xuICAgIH0pO1xuICB9XG4gIF9jcmVhdGVBbmltYXRpb25UcmFja3Mobm9kZSwgaW5wdXRBY2Nlc3Nvciwgb3V0cHV0QWNjZXNzb3IsIHNhbXBsZXIsIHRhcmdldCkge1xuICAgIGNvbnN0IHRyYWNrcyA9IFtdO1xuICAgIGNvbnN0IHRhcmdldE5hbWUgPSBub2RlLm5hbWUgPyBub2RlLm5hbWUgOiBub2RlLnV1aWQ7XG4gICAgY29uc3QgdGFyZ2V0TmFtZXMgPSBbXTtcbiAgICBpZiAoUEFUSF9QUk9QRVJUSUVTW3RhcmdldC5wYXRoXSA9PT0gUEFUSF9QUk9QRVJUSUVTLndlaWdodHMpIHtcbiAgICAgIG5vZGUudHJhdmVyc2UoZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzKSB7XG4gICAgICAgICAgdGFyZ2V0TmFtZXMucHVzaChvYmplY3QubmFtZSA/IG9iamVjdC5uYW1lIDogb2JqZWN0LnV1aWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0TmFtZXMucHVzaCh0YXJnZXROYW1lKTtcbiAgICB9XG4gICAgbGV0IFR5cGVkS2V5ZnJhbWVUcmFjaztcbiAgICBzd2l0Y2ggKFBBVEhfUFJPUEVSVElFU1t0YXJnZXQucGF0aF0pIHtcbiAgICAgIGNhc2UgUEFUSF9QUk9QRVJUSUVTLndlaWdodHM6XG4gICAgICAgIFR5cGVkS2V5ZnJhbWVUcmFjayA9IE51bWJlcktleWZyYW1lVHJhY2s7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQQVRIX1BST1BFUlRJRVMucm90YXRpb246XG4gICAgICAgIFR5cGVkS2V5ZnJhbWVUcmFjayA9IFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUEFUSF9QUk9QRVJUSUVTLnBvc2l0aW9uOlxuICAgICAgY2FzZSBQQVRIX1BST1BFUlRJRVMuc2NhbGU6XG4gICAgICAgIFR5cGVkS2V5ZnJhbWVUcmFjayA9IFZlY3RvcktleWZyYW1lVHJhY2s7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3dpdGNoIChvdXRwdXRBY2Nlc3Nvci5pdGVtU2l6ZSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIFR5cGVkS2V5ZnJhbWVUcmFjayA9IE51bWJlcktleWZyYW1lVHJhY2s7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBUeXBlZEtleWZyYW1lVHJhY2sgPSBWZWN0b3JLZXlmcmFtZVRyYWNrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IGludGVycG9sYXRpb24gPSBzYW1wbGVyLmludGVycG9sYXRpb24gIT09IHZvaWQgMCA/IElOVEVSUE9MQVRJT05bc2FtcGxlci5pbnRlcnBvbGF0aW9uXSA6IEludGVycG9sYXRlTGluZWFyO1xuICAgIGNvbnN0IG91dHB1dEFycmF5ID0gdGhpcy5fZ2V0QXJyYXlGcm9tQWNjZXNzb3Iob3V0cHV0QWNjZXNzb3IpO1xuICAgIGZvciAobGV0IGogPSAwLCBqbCA9IHRhcmdldE5hbWVzLmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgIGNvbnN0IHRyYWNrID0gbmV3IFR5cGVkS2V5ZnJhbWVUcmFjayhcbiAgICAgICAgdGFyZ2V0TmFtZXNbal0gKyBcIi5cIiArIFBBVEhfUFJPUEVSVElFU1t0YXJnZXQucGF0aF0sXG4gICAgICAgIGlucHV0QWNjZXNzb3IuYXJyYXksXG4gICAgICAgIG91dHB1dEFycmF5LFxuICAgICAgICBpbnRlcnBvbGF0aW9uXG4gICAgICApO1xuICAgICAgaWYgKHNhbXBsZXIuaW50ZXJwb2xhdGlvbiA9PT0gXCJDVUJJQ1NQTElORVwiKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUN1YmljU3BsaW5lVHJhY2tJbnRlcnBvbGFudCh0cmFjayk7XG4gICAgICB9XG4gICAgICB0cmFja3MucHVzaCh0cmFjayk7XG4gICAgfVxuICAgIHJldHVybiB0cmFja3M7XG4gIH1cbiAgX2dldEFycmF5RnJvbUFjY2Vzc29yKGFjY2Vzc29yKSB7XG4gICAgbGV0IG91dHB1dEFycmF5ID0gYWNjZXNzb3IuYXJyYXk7XG4gICAgaWYgKGFjY2Vzc29yLm5vcm1hbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHNjYWxlID0gZ2V0Tm9ybWFsaXplZENvbXBvbmVudFNjYWxlKG91dHB1dEFycmF5LmNvbnN0cnVjdG9yKTtcbiAgICAgIGNvbnN0IHNjYWxlZCA9IG5ldyBGbG9hdDMyQXJyYXkob3V0cHV0QXJyYXkubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGogPSAwLCBqbCA9IG91dHB1dEFycmF5Lmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgc2NhbGVkW2pdID0gb3V0cHV0QXJyYXlbal0gKiBzY2FsZTtcbiAgICAgIH1cbiAgICAgIG91dHB1dEFycmF5ID0gc2NhbGVkO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0QXJyYXk7XG4gIH1cbiAgX2NyZWF0ZUN1YmljU3BsaW5lVHJhY2tJbnRlcnBvbGFudCh0cmFjaykge1xuICAgIHRyYWNrLmNyZWF0ZUludGVycG9sYW50ID0gZnVuY3Rpb24gSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lKHJlc3VsdCkge1xuICAgICAgY29uc3QgaW50ZXJwb2xhbnRUeXBlID0gdGhpcyBpbnN0YW5jZW9mIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrID8gR0xURkN1YmljU3BsaW5lUXVhdGVybmlvbkludGVycG9sYW50IDogR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQ7XG4gICAgICByZXR1cm4gbmV3IGludGVycG9sYW50VHlwZSh0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSAvIDMsIHJlc3VsdCk7XG4gICAgfTtcbiAgICB0cmFjay5jcmVhdGVJbnRlcnBvbGFudC5pc0ludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSA9IHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVCb3VuZHMoZ2VvbWV0cnksIHByaW1pdGl2ZURlZiwgcGFyc2VyKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBwcmltaXRpdmVEZWYuYXR0cmlidXRlcztcbiAgY29uc3QgYm94ID0gbmV3IEJveDMoKTtcbiAgaWYgKGF0dHJpYnV0ZXMuUE9TSVRJT04gIT09IHZvaWQgMCkge1xuICAgIGNvbnN0IGFjY2Vzc29yID0gcGFyc2VyLmpzb24uYWNjZXNzb3JzW2F0dHJpYnV0ZXMuUE9TSVRJT05dO1xuICAgIGNvbnN0IG1pbiA9IGFjY2Vzc29yLm1pbjtcbiAgICBjb25zdCBtYXggPSBhY2Nlc3Nvci5tYXg7XG4gICAgaWYgKG1pbiAhPT0gdm9pZCAwICYmIG1heCAhPT0gdm9pZCAwKSB7XG4gICAgICBib3guc2V0KG5ldyBWZWN0b3IzKG1pblswXSwgbWluWzFdLCBtaW5bMl0pLCBuZXcgVmVjdG9yMyhtYXhbMF0sIG1heFsxXSwgbWF4WzJdKSk7XG4gICAgICBpZiAoYWNjZXNzb3Iubm9ybWFsaXplZCkge1xuICAgICAgICBjb25zdCBib3hTY2FsZSA9IGdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZShXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3IuY29tcG9uZW50VHlwZV0pO1xuICAgICAgICBib3gubWluLm11bHRpcGx5U2NhbGFyKGJveFNjYWxlKTtcbiAgICAgICAgYm94Lm1heC5tdWx0aXBseVNjYWxhcihib3hTY2FsZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IE1pc3NpbmcgbWluL21heCBwcm9wZXJ0aWVzIGZvciBhY2Nlc3NvciBQT1NJVElPTi5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0YXJnZXRzID0gcHJpbWl0aXZlRGVmLnRhcmdldHM7XG4gIGlmICh0YXJnZXRzICE9PSB2b2lkIDApIHtcbiAgICBjb25zdCBtYXhEaXNwbGFjZW1lbnQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNvbnN0IHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgaWYgKHRhcmdldC5QT1NJVElPTiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc29yID0gcGFyc2VyLmpzb24uYWNjZXNzb3JzW3RhcmdldC5QT1NJVElPTl07XG4gICAgICAgIGNvbnN0IG1pbiA9IGFjY2Vzc29yLm1pbjtcbiAgICAgICAgY29uc3QgbWF4ID0gYWNjZXNzb3IubWF4O1xuICAgICAgICBpZiAobWluICE9PSB2b2lkIDAgJiYgbWF4ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB2ZWN0b3Iuc2V0WChNYXRoLm1heChNYXRoLmFicyhtaW5bMF0pLCBNYXRoLmFicyhtYXhbMF0pKSk7XG4gICAgICAgICAgdmVjdG9yLnNldFkoTWF0aC5tYXgoTWF0aC5hYnMobWluWzFdKSwgTWF0aC5hYnMobWF4WzFdKSkpO1xuICAgICAgICAgIHZlY3Rvci5zZXRaKE1hdGgubWF4KE1hdGguYWJzKG1pblsyXSksIE1hdGguYWJzKG1heFsyXSkpKTtcbiAgICAgICAgICBpZiAoYWNjZXNzb3Iubm9ybWFsaXplZCkge1xuICAgICAgICAgICAgY29uc3QgYm94U2NhbGUgPSBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUoV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yLmNvbXBvbmVudFR5cGVdKTtcbiAgICAgICAgICAgIHZlY3Rvci5tdWx0aXBseVNjYWxhcihib3hTY2FsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1heERpc3BsYWNlbWVudC5tYXgodmVjdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBNaXNzaW5nIG1pbi9tYXggcHJvcGVydGllcyBmb3IgYWNjZXNzb3IgUE9TSVRJT04uXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGJveC5leHBhbmRCeVZlY3RvcihtYXhEaXNwbGFjZW1lbnQpO1xuICB9XG4gIGdlb21ldHJ5LmJvdW5kaW5nQm94ID0gYm94O1xuICBjb25zdCBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gIGJveC5nZXRDZW50ZXIoc3BoZXJlLmNlbnRlcik7XG4gIHNwaGVyZS5yYWRpdXMgPSBib3gubWluLmRpc3RhbmNlVG8oYm94Lm1heCkgLyAyO1xuICBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9IHNwaGVyZTtcbn1cbmZ1bmN0aW9uIGFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMoZ2VvbWV0cnksIHByaW1pdGl2ZURlZiwgcGFyc2VyKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBwcmltaXRpdmVEZWYuYXR0cmlidXRlcztcbiAgY29uc3QgcGVuZGluZyA9IFtdO1xuICBmdW5jdGlvbiBhc3NpZ25BdHRyaWJ1dGVBY2Nlc3NvcihhY2Nlc3NvckluZGV4LCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgcmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgYWNjZXNzb3JJbmRleCkudGhlbihmdW5jdGlvbihhY2Nlc3Nvcikge1xuICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGFjY2Vzc29yKTtcbiAgICB9KTtcbiAgfVxuICBmb3IgKGNvbnN0IGdsdGZBdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCB0aHJlZUF0dHJpYnV0ZU5hbWUgPSBBVFRSSUJVVEVTW2dsdGZBdHRyaWJ1dGVOYW1lXSB8fCBnbHRmQXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh0aHJlZUF0dHJpYnV0ZU5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcylcbiAgICAgIGNvbnRpbnVlO1xuICAgIHBlbmRpbmcucHVzaChhc3NpZ25BdHRyaWJ1dGVBY2Nlc3NvcihhdHRyaWJ1dGVzW2dsdGZBdHRyaWJ1dGVOYW1lXSwgdGhyZWVBdHRyaWJ1dGVOYW1lKSk7XG4gIH1cbiAgaWYgKHByaW1pdGl2ZURlZi5pbmRpY2VzICE9PSB2b2lkIDAgJiYgIWdlb21ldHJ5LmluZGV4KSB7XG4gICAgY29uc3QgYWNjZXNzb3IgPSBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHByaW1pdGl2ZURlZi5pbmRpY2VzKS50aGVuKGZ1bmN0aW9uKGFjY2Vzc29yMikge1xuICAgICAgZ2VvbWV0cnkuc2V0SW5kZXgoYWNjZXNzb3IyKTtcbiAgICB9KTtcbiAgICBwZW5kaW5nLnB1c2goYWNjZXNzb3IpO1xuICB9XG4gIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoZ2VvbWV0cnksIHByaW1pdGl2ZURlZik7XG4gIGNvbXB1dGVCb3VuZHMoZ2VvbWV0cnksIHByaW1pdGl2ZURlZiwgcGFyc2VyKTtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZURlZi50YXJnZXRzICE9PSB2b2lkIDAgPyBhZGRNb3JwaFRhcmdldHMoZ2VvbWV0cnksIHByaW1pdGl2ZURlZi50YXJnZXRzLCBwYXJzZXIpIDogZ2VvbWV0cnk7XG4gIH0pO1xufVxuZXhwb3J0IHtcbiAgR0xURkxvYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdMVEZMb2FkZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/RGBELoader.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/RGBELoader.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RGBELoader: () => (/* binding */ RGBELoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nclass RGBELoader extends three__WEBPACK_IMPORTED_MODULE_0__.DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n    this.type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n  }\n  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n  parse(buffer) {\n    const rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {\n      switch (rgbe_error_code) {\n        case rgbe_read_error:\n          throw new Error(\"THREE.RGBELoader: Read Error: \" + (msg || \"\"));\n        case rgbe_write_error:\n          throw new Error(\"THREE.RGBELoader: Write Error: \" + (msg || \"\"));\n        case rgbe_format_error:\n          throw new Error(\"THREE.RGBELoader: Bad File Format: \" + (msg || \"\"));\n        default:\n        case rgbe_memory_error:\n          throw new Error(\"THREE.RGBELoader: Memory Error: \" + (msg || \"\"));\n      }\n    }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = \"\\n\", fgets = function(buffer2, lineLimit, consume) {\n      const chunkSize = 128;\n      lineLimit = !lineLimit ? 1024 : lineLimit;\n      let p = buffer2.pos, i = -1, len = 0, s = \"\", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n      while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer2.byteLength) {\n        s += chunk;\n        len += chunk.length;\n        p += chunkSize;\n        chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n      }\n      if (-1 < i) {\n        if (false !== consume)\n          buffer2.pos += len + i + 1;\n        return s + chunk.slice(0, i);\n      }\n      return false;\n    }, RGBE_ReadHeader = function(buffer2) {\n      const magic_token_re = /^#\\?(\\S+)/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, header = {\n        valid: 0,\n        string: \"\",\n        comments: \"\",\n        programtype: \"RGBE\",\n        format: \"\",\n        gamma: 1,\n        exposure: 1,\n        width: 0,\n        height: 0\n      };\n      let line, match;\n      if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {\n        rgbe_error(rgbe_read_error, \"no header found\");\n      }\n      if (!(match = line.match(magic_token_re))) {\n        rgbe_error(rgbe_format_error, \"bad initial token\");\n      }\n      header.valid |= RGBE_VALID_PROGRAMTYPE;\n      header.programtype = match[1];\n      header.string += line + \"\\n\";\n      while (true) {\n        line = fgets(buffer2);\n        if (false === line)\n          break;\n        header.string += line + \"\\n\";\n        if (\"#\" === line.charAt(0)) {\n          header.comments += line + \"\\n\";\n          continue;\n        }\n        if (match = line.match(gamma_re)) {\n          header.gamma = parseFloat(match[1]);\n        }\n        if (match = line.match(exposure_re)) {\n          header.exposure = parseFloat(match[1]);\n        }\n        if (match = line.match(format_re)) {\n          header.valid |= RGBE_VALID_FORMAT;\n          header.format = match[1];\n        }\n        if (match = line.match(dimensions_re)) {\n          header.valid |= RGBE_VALID_DIMENSIONS;\n          header.height = parseInt(match[1], 10);\n          header.width = parseInt(match[2], 10);\n        }\n        if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS)\n          break;\n      }\n      if (!(header.valid & RGBE_VALID_FORMAT)) {\n        rgbe_error(rgbe_format_error, \"missing format specifier\");\n      }\n      if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n        rgbe_error(rgbe_format_error, \"missing image size specifier\");\n      }\n      return header;\n    }, RGBE_ReadPixels_RLE = function(buffer2, w2, h2) {\n      const scanline_width = w2;\n      if (\n        // run length encoding is not allowed so read flat\n        scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded\n        2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128\n      ) {\n        return new Uint8Array(buffer2);\n      }\n      if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {\n        rgbe_error(rgbe_format_error, \"wrong scanline width\");\n      }\n      const data_rgba = new Uint8Array(4 * w2 * h2);\n      if (!data_rgba.length) {\n        rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n      }\n      let offset = 0, pos = 0;\n      const ptr_end = 4 * scanline_width;\n      const rgbeStart = new Uint8Array(4);\n      const scanline_buffer = new Uint8Array(ptr_end);\n      let num_scanlines = h2;\n      while (num_scanlines > 0 && pos < buffer2.byteLength) {\n        if (pos + 4 > buffer2.byteLength) {\n          rgbe_error(rgbe_read_error);\n        }\n        rgbeStart[0] = buffer2[pos++];\n        rgbeStart[1] = buffer2[pos++];\n        rgbeStart[2] = buffer2[pos++];\n        rgbeStart[3] = buffer2[pos++];\n        if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n          rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n        }\n        let ptr = 0, count;\n        while (ptr < ptr_end && pos < buffer2.byteLength) {\n          count = buffer2[pos++];\n          const isEncodedRun = count > 128;\n          if (isEncodedRun)\n            count -= 128;\n          if (0 === count || ptr + count > ptr_end) {\n            rgbe_error(rgbe_format_error, \"bad scanline data\");\n          }\n          if (isEncodedRun) {\n            const byteValue = buffer2[pos++];\n            for (let i = 0; i < count; i++) {\n              scanline_buffer[ptr++] = byteValue;\n            }\n          } else {\n            scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);\n            ptr += count;\n            pos += count;\n          }\n        }\n        const l = scanline_width;\n        for (let i = 0; i < l; i++) {\n          let off = 0;\n          data_rgba[offset] = scanline_buffer[i + off];\n          off += scanline_width;\n          data_rgba[offset + 1] = scanline_buffer[i + off];\n          off += scanline_width;\n          data_rgba[offset + 2] = scanline_buffer[i + off];\n          off += scanline_width;\n          data_rgba[offset + 3] = scanline_buffer[i + off];\n          offset += 4;\n        }\n        num_scanlines--;\n      }\n      return data_rgba;\n    };\n    const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3];\n      const scale = Math.pow(2, e - 128) / 255;\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n      destArray[destOffset + 3] = 1;\n    };\n    const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3];\n      const scale = Math.pow(2, e - 128) / 255;\n      destArray[destOffset + 0] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n      destArray[destOffset + 1] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n      destArray[destOffset + 2] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n      destArray[destOffset + 3] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(1);\n    };\n    const byteArray = new Uint8Array(buffer);\n    byteArray.pos = 0;\n    const rgbe_header_info = RGBE_ReadHeader(byteArray);\n    const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n    let data, type;\n    let numElements;\n    switch (this.type) {\n      case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n        numElements = image_rgba_data.length / 4;\n        const floatArray = new Float32Array(numElements * 4);\n        for (let j = 0; j < numElements; j++) {\n          RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\n        }\n        data = floatArray;\n        type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n        break;\n      case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n        numElements = image_rgba_data.length / 4;\n        const halfArray = new Uint16Array(numElements * 4);\n        for (let j = 0; j < numElements; j++) {\n          RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);\n        }\n        data = halfArray;\n        type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n        break;\n      default:\n        throw new Error(\"THREE.RGBELoader: Unsupported type: \" + this.type);\n    }\n    return {\n      width: w,\n      height: h,\n      data,\n      header: rgbe_header_info.string,\n      gamma: rgbe_header_info.gamma,\n      exposure: rgbe_header_info.exposure,\n      type\n    };\n  }\n  setDataType(value) {\n    this.type = value;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n        case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n          if (\"colorSpace\" in texture)\n            texture.colorSpace = \"srgb-linear\";\n          else\n            texture.encoding = 3e3;\n          texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n          texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n          texture.generateMipmaps = false;\n          texture.flipY = true;\n          break;\n      }\n      if (onLoad)\n        onLoad(texture, texData);\n    }\n    return super.load(url, onLoadCallback, onProgress, onError);\n  }\n}\n\n//# sourceMappingURL=RGBELoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvUkdCRUxvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2RjtBQUM3Rix5QkFBeUIsb0RBQWlCO0FBQzFDO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDRDQUFTO0FBQzNDLGtDQUFrQyw0Q0FBUztBQUMzQyxrQ0FBa0MsNENBQVM7QUFDM0Msa0NBQWtDLDRDQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRDQUFTO0FBQ3BCO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQVM7QUFDeEI7QUFDQSxXQUFXLGdEQUFhO0FBQ3hCO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0Q0FBUztBQUN0QixhQUFhLGdEQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtDQUFZO0FBQzFDLDhCQUE4QiwrQ0FBWTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2huZWlkZXJjYWRldC9EZXNrdG9wL2ZpenppL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbG9hZGVycy9SR0JFTG9hZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERhdGFUZXh0dXJlTG9hZGVyLCBIYWxmRmxvYXRUeXBlLCBGbG9hdFR5cGUsIERhdGFVdGlscywgTGluZWFyRmlsdGVyIH0gZnJvbSBcInRocmVlXCI7XG5jbGFzcyBSR0JFTG9hZGVyIGV4dGVuZHMgRGF0YVRleHR1cmVMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG4gICAgc3VwZXIobWFuYWdlcik7XG4gICAgdGhpcy50eXBlID0gSGFsZkZsb2F0VHlwZTtcbiAgfVxuICAvLyBhZGFwdGVkIGZyb20gaHR0cDovL3d3dy5ncmFwaGljcy5jb3JuZWxsLmVkdS9+Ymp3L3JnYmUuaHRtbFxuICBwYXJzZShidWZmZXIpIHtcbiAgICBjb25zdCByZ2JlX3JlYWRfZXJyb3IgPSAxLCByZ2JlX3dyaXRlX2Vycm9yID0gMiwgcmdiZV9mb3JtYXRfZXJyb3IgPSAzLCByZ2JlX21lbW9yeV9lcnJvciA9IDQsIHJnYmVfZXJyb3IgPSBmdW5jdGlvbihyZ2JlX2Vycm9yX2NvZGUsIG1zZykge1xuICAgICAgc3dpdGNoIChyZ2JlX2Vycm9yX2NvZGUpIHtcbiAgICAgICAgY2FzZSByZ2JlX3JlYWRfZXJyb3I6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuUkdCRUxvYWRlcjogUmVhZCBFcnJvcjogXCIgKyAobXNnIHx8IFwiXCIpKTtcbiAgICAgICAgY2FzZSByZ2JlX3dyaXRlX2Vycm9yOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLlJHQkVMb2FkZXI6IFdyaXRlIEVycm9yOiBcIiArIChtc2cgfHwgXCJcIikpO1xuICAgICAgICBjYXNlIHJnYmVfZm9ybWF0X2Vycm9yOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLlJHQkVMb2FkZXI6IEJhZCBGaWxlIEZvcm1hdDogXCIgKyAobXNnIHx8IFwiXCIpKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2FzZSByZ2JlX21lbW9yeV9lcnJvcjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5SR0JFTG9hZGVyOiBNZW1vcnkgRXJyb3I6IFwiICsgKG1zZyB8fCBcIlwiKSk7XG4gICAgICB9XG4gICAgfSwgUkdCRV9WQUxJRF9QUk9HUkFNVFlQRSA9IDEsIFJHQkVfVkFMSURfRk9STUFUID0gMiwgUkdCRV9WQUxJRF9ESU1FTlNJT05TID0gNCwgTkVXTElORSA9IFwiXFxuXCIsIGZnZXRzID0gZnVuY3Rpb24oYnVmZmVyMiwgbGluZUxpbWl0LCBjb25zdW1lKSB7XG4gICAgICBjb25zdCBjaHVua1NpemUgPSAxMjg7XG4gICAgICBsaW5lTGltaXQgPSAhbGluZUxpbWl0ID8gMTAyNCA6IGxpbmVMaW1pdDtcbiAgICAgIGxldCBwID0gYnVmZmVyMi5wb3MsIGkgPSAtMSwgbGVuID0gMCwgcyA9IFwiXCIsIGNodW5rID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDE2QXJyYXkoYnVmZmVyMi5zdWJhcnJheShwLCBwICsgY2h1bmtTaXplKSkpO1xuICAgICAgd2hpbGUgKDAgPiAoaSA9IGNodW5rLmluZGV4T2YoTkVXTElORSkpICYmIGxlbiA8IGxpbmVMaW1pdCAmJiBwIDwgYnVmZmVyMi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHMgKz0gY2h1bms7XG4gICAgICAgIGxlbiArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIHAgKz0gY2h1bmtTaXplO1xuICAgICAgICBjaHVuayArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheShidWZmZXIyLnN1YmFycmF5KHAsIHAgKyBjaHVua1NpemUpKSk7XG4gICAgICB9XG4gICAgICBpZiAoLTEgPCBpKSB7XG4gICAgICAgIGlmIChmYWxzZSAhPT0gY29uc3VtZSlcbiAgICAgICAgICBidWZmZXIyLnBvcyArPSBsZW4gKyBpICsgMTtcbiAgICAgICAgcmV0dXJuIHMgKyBjaHVuay5zbGljZSgwLCBpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBSR0JFX1JlYWRIZWFkZXIgPSBmdW5jdGlvbihidWZmZXIyKSB7XG4gICAgICBjb25zdCBtYWdpY190b2tlbl9yZSA9IC9eI1xcPyhcXFMrKS8sIGdhbW1hX3JlID0gL15cXHMqR0FNTUFcXHMqPVxccyooXFxkKyhcXC5cXGQrKT8pXFxzKiQvLCBleHBvc3VyZV9yZSA9IC9eXFxzKkVYUE9TVVJFXFxzKj1cXHMqKFxcZCsoXFwuXFxkKyk/KVxccyokLywgZm9ybWF0X3JlID0gL15cXHMqRk9STUFUPShcXFMrKVxccyokLywgZGltZW5zaW9uc19yZSA9IC9eXFxzKlxcLVlcXHMrKFxcZCspXFxzK1xcK1hcXHMrKFxcZCspXFxzKiQvLCBoZWFkZXIgPSB7XG4gICAgICAgIHZhbGlkOiAwLFxuICAgICAgICBzdHJpbmc6IFwiXCIsXG4gICAgICAgIGNvbW1lbnRzOiBcIlwiLFxuICAgICAgICBwcm9ncmFtdHlwZTogXCJSR0JFXCIsXG4gICAgICAgIGZvcm1hdDogXCJcIixcbiAgICAgICAgZ2FtbWE6IDEsXG4gICAgICAgIGV4cG9zdXJlOiAxLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9O1xuICAgICAgbGV0IGxpbmUsIG1hdGNoO1xuICAgICAgaWYgKGJ1ZmZlcjIucG9zID49IGJ1ZmZlcjIuYnl0ZUxlbmd0aCB8fCAhKGxpbmUgPSBmZ2V0cyhidWZmZXIyKSkpIHtcbiAgICAgICAgcmdiZV9lcnJvcihyZ2JlX3JlYWRfZXJyb3IsIFwibm8gaGVhZGVyIGZvdW5kXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCEobWF0Y2ggPSBsaW5lLm1hdGNoKG1hZ2ljX3Rva2VuX3JlKSkpIHtcbiAgICAgICAgcmdiZV9lcnJvcihyZ2JlX2Zvcm1hdF9lcnJvciwgXCJiYWQgaW5pdGlhbCB0b2tlblwiKTtcbiAgICAgIH1cbiAgICAgIGhlYWRlci52YWxpZCB8PSBSR0JFX1ZBTElEX1BST0dSQU1UWVBFO1xuICAgICAgaGVhZGVyLnByb2dyYW10eXBlID0gbWF0Y2hbMV07XG4gICAgICBoZWFkZXIuc3RyaW5nICs9IGxpbmUgKyBcIlxcblwiO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGluZSA9IGZnZXRzKGJ1ZmZlcjIpO1xuICAgICAgICBpZiAoZmFsc2UgPT09IGxpbmUpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGhlYWRlci5zdHJpbmcgKz0gbGluZSArIFwiXFxuXCI7XG4gICAgICAgIGlmIChcIiNcIiA9PT0gbGluZS5jaGFyQXQoMCkpIHtcbiAgICAgICAgICBoZWFkZXIuY29tbWVudHMgKz0gbGluZSArIFwiXFxuXCI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoID0gbGluZS5tYXRjaChnYW1tYV9yZSkpIHtcbiAgICAgICAgICBoZWFkZXIuZ2FtbWEgPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2ggPSBsaW5lLm1hdGNoKGV4cG9zdXJlX3JlKSkge1xuICAgICAgICAgIGhlYWRlci5leHBvc3VyZSA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCA9IGxpbmUubWF0Y2goZm9ybWF0X3JlKSkge1xuICAgICAgICAgIGhlYWRlci52YWxpZCB8PSBSR0JFX1ZBTElEX0ZPUk1BVDtcbiAgICAgICAgICBoZWFkZXIuZm9ybWF0ID0gbWF0Y2hbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoID0gbGluZS5tYXRjaChkaW1lbnNpb25zX3JlKSkge1xuICAgICAgICAgIGhlYWRlci52YWxpZCB8PSBSR0JFX1ZBTElEX0RJTUVOU0lPTlM7XG4gICAgICAgICAgaGVhZGVyLmhlaWdodCA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICAgICAgaGVhZGVyLndpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVyLnZhbGlkICYgUkdCRV9WQUxJRF9GT1JNQVQgJiYgaGVhZGVyLnZhbGlkICYgUkdCRV9WQUxJRF9ESU1FTlNJT05TKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKCEoaGVhZGVyLnZhbGlkICYgUkdCRV9WQUxJRF9GT1JNQVQpKSB7XG4gICAgICAgIHJnYmVfZXJyb3IocmdiZV9mb3JtYXRfZXJyb3IsIFwibWlzc2luZyBmb3JtYXQgc3BlY2lmaWVyXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCEoaGVhZGVyLnZhbGlkICYgUkdCRV9WQUxJRF9ESU1FTlNJT05TKSkge1xuICAgICAgICByZ2JlX2Vycm9yKHJnYmVfZm9ybWF0X2Vycm9yLCBcIm1pc3NpbmcgaW1hZ2Ugc2l6ZSBzcGVjaWZpZXJcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGVhZGVyO1xuICAgIH0sIFJHQkVfUmVhZFBpeGVsc19STEUgPSBmdW5jdGlvbihidWZmZXIyLCB3MiwgaDIpIHtcbiAgICAgIGNvbnN0IHNjYW5saW5lX3dpZHRoID0gdzI7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIHJ1biBsZW5ndGggZW5jb2RpbmcgaXMgbm90IGFsbG93ZWQgc28gcmVhZCBmbGF0XG4gICAgICAgIHNjYW5saW5lX3dpZHRoIDwgOCB8fCBzY2FubGluZV93aWR0aCA+IDMyNzY3IHx8IC8vIHRoaXMgZmlsZSBpcyBub3QgcnVuIGxlbmd0aCBlbmNvZGVkXG4gICAgICAgIDIgIT09IGJ1ZmZlcjJbMF0gfHwgMiAhPT0gYnVmZmVyMlsxXSB8fCBidWZmZXIyWzJdICYgMTI4XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcjIpO1xuICAgICAgfVxuICAgICAgaWYgKHNjYW5saW5lX3dpZHRoICE9PSAoYnVmZmVyMlsyXSA8PCA4IHwgYnVmZmVyMlszXSkpIHtcbiAgICAgICAgcmdiZV9lcnJvcihyZ2JlX2Zvcm1hdF9lcnJvciwgXCJ3cm9uZyBzY2FubGluZSB3aWR0aFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGFfcmdiYSA9IG5ldyBVaW50OEFycmF5KDQgKiB3MiAqIGgyKTtcbiAgICAgIGlmICghZGF0YV9yZ2JhLmxlbmd0aCkge1xuICAgICAgICByZ2JlX2Vycm9yKHJnYmVfbWVtb3J5X2Vycm9yLCBcInVuYWJsZSB0byBhbGxvY2F0ZSBidWZmZXIgc3BhY2VcIik7XG4gICAgICB9XG4gICAgICBsZXQgb2Zmc2V0ID0gMCwgcG9zID0gMDtcbiAgICAgIGNvbnN0IHB0cl9lbmQgPSA0ICogc2NhbmxpbmVfd2lkdGg7XG4gICAgICBjb25zdCByZ2JlU3RhcnQgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgIGNvbnN0IHNjYW5saW5lX2J1ZmZlciA9IG5ldyBVaW50OEFycmF5KHB0cl9lbmQpO1xuICAgICAgbGV0IG51bV9zY2FubGluZXMgPSBoMjtcbiAgICAgIHdoaWxlIChudW1fc2NhbmxpbmVzID4gMCAmJiBwb3MgPCBidWZmZXIyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgaWYgKHBvcyArIDQgPiBidWZmZXIyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICByZ2JlX2Vycm9yKHJnYmVfcmVhZF9lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmdiZVN0YXJ0WzBdID0gYnVmZmVyMltwb3MrK107XG4gICAgICAgIHJnYmVTdGFydFsxXSA9IGJ1ZmZlcjJbcG9zKytdO1xuICAgICAgICByZ2JlU3RhcnRbMl0gPSBidWZmZXIyW3BvcysrXTtcbiAgICAgICAgcmdiZVN0YXJ0WzNdID0gYnVmZmVyMltwb3MrK107XG4gICAgICAgIGlmICgyICE9IHJnYmVTdGFydFswXSB8fCAyICE9IHJnYmVTdGFydFsxXSB8fCAocmdiZVN0YXJ0WzJdIDw8IDggfCByZ2JlU3RhcnRbM10pICE9IHNjYW5saW5lX3dpZHRoKSB7XG4gICAgICAgICAgcmdiZV9lcnJvcihyZ2JlX2Zvcm1hdF9lcnJvciwgXCJiYWQgcmdiZSBzY2FubGluZSBmb3JtYXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHB0ciA9IDAsIGNvdW50O1xuICAgICAgICB3aGlsZSAocHRyIDwgcHRyX2VuZCAmJiBwb3MgPCBidWZmZXIyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICBjb3VudCA9IGJ1ZmZlcjJbcG9zKytdO1xuICAgICAgICAgIGNvbnN0IGlzRW5jb2RlZFJ1biA9IGNvdW50ID4gMTI4O1xuICAgICAgICAgIGlmIChpc0VuY29kZWRSdW4pXG4gICAgICAgICAgICBjb3VudCAtPSAxMjg7XG4gICAgICAgICAgaWYgKDAgPT09IGNvdW50IHx8IHB0ciArIGNvdW50ID4gcHRyX2VuZCkge1xuICAgICAgICAgICAgcmdiZV9lcnJvcihyZ2JlX2Zvcm1hdF9lcnJvciwgXCJiYWQgc2NhbmxpbmUgZGF0YVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzRW5jb2RlZFJ1bikge1xuICAgICAgICAgICAgY29uc3QgYnl0ZVZhbHVlID0gYnVmZmVyMltwb3MrK107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgc2NhbmxpbmVfYnVmZmVyW3B0cisrXSA9IGJ5dGVWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2NhbmxpbmVfYnVmZmVyLnNldChidWZmZXIyLnN1YmFycmF5KHBvcywgcG9zICsgY291bnQpLCBwdHIpO1xuICAgICAgICAgICAgcHRyICs9IGNvdW50O1xuICAgICAgICAgICAgcG9zICs9IGNvdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsID0gc2NhbmxpbmVfd2lkdGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgbGV0IG9mZiA9IDA7XG4gICAgICAgICAgZGF0YV9yZ2JhW29mZnNldF0gPSBzY2FubGluZV9idWZmZXJbaSArIG9mZl07XG4gICAgICAgICAgb2ZmICs9IHNjYW5saW5lX3dpZHRoO1xuICAgICAgICAgIGRhdGFfcmdiYVtvZmZzZXQgKyAxXSA9IHNjYW5saW5lX2J1ZmZlcltpICsgb2ZmXTtcbiAgICAgICAgICBvZmYgKz0gc2NhbmxpbmVfd2lkdGg7XG4gICAgICAgICAgZGF0YV9yZ2JhW29mZnNldCArIDJdID0gc2NhbmxpbmVfYnVmZmVyW2kgKyBvZmZdO1xuICAgICAgICAgIG9mZiArPSBzY2FubGluZV93aWR0aDtcbiAgICAgICAgICBkYXRhX3JnYmFbb2Zmc2V0ICsgM10gPSBzY2FubGluZV9idWZmZXJbaSArIG9mZl07XG4gICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgbnVtX3NjYW5saW5lcy0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFfcmdiYTtcbiAgICB9O1xuICAgIGNvbnN0IFJHQkVCeXRlVG9SR0JGbG9hdCA9IGZ1bmN0aW9uKHNvdXJjZUFycmF5LCBzb3VyY2VPZmZzZXQsIGRlc3RBcnJheSwgZGVzdE9mZnNldCkge1xuICAgICAgY29uc3QgZSA9IHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDNdO1xuICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCBlIC0gMTI4KSAvIDI1NTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMF0gPSBzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAwXSAqIHNjYWxlO1xuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAxXSA9IHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDFdICogc2NhbGU7XG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDJdID0gc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMl0gKiBzY2FsZTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgM10gPSAxO1xuICAgIH07XG4gICAgY29uc3QgUkdCRUJ5dGVUb1JHQkhhbGYgPSBmdW5jdGlvbihzb3VyY2VBcnJheSwgc291cmNlT2Zmc2V0LCBkZXN0QXJyYXksIGRlc3RPZmZzZXQpIHtcbiAgICAgIGNvbnN0IGUgPSBzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAzXTtcbiAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMiwgZSAtIDEyOCkgLyAyNTU7XG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDBdID0gRGF0YVV0aWxzLnRvSGFsZkZsb2F0KE1hdGgubWluKHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDBdICogc2NhbGUsIDY1NTA0KSk7XG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDFdID0gRGF0YVV0aWxzLnRvSGFsZkZsb2F0KE1hdGgubWluKHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDFdICogc2NhbGUsIDY1NTA0KSk7XG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDJdID0gRGF0YVV0aWxzLnRvSGFsZkZsb2F0KE1hdGgubWluKHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDJdICogc2NhbGUsIDY1NTA0KSk7XG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDNdID0gRGF0YVV0aWxzLnRvSGFsZkZsb2F0KDEpO1xuICAgIH07XG4gICAgY29uc3QgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBieXRlQXJyYXkucG9zID0gMDtcbiAgICBjb25zdCByZ2JlX2hlYWRlcl9pbmZvID0gUkdCRV9SZWFkSGVhZGVyKGJ5dGVBcnJheSk7XG4gICAgY29uc3QgdyA9IHJnYmVfaGVhZGVyX2luZm8ud2lkdGgsIGggPSByZ2JlX2hlYWRlcl9pbmZvLmhlaWdodCwgaW1hZ2VfcmdiYV9kYXRhID0gUkdCRV9SZWFkUGl4ZWxzX1JMRShieXRlQXJyYXkuc3ViYXJyYXkoYnl0ZUFycmF5LnBvcyksIHcsIGgpO1xuICAgIGxldCBkYXRhLCB0eXBlO1xuICAgIGxldCBudW1FbGVtZW50cztcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSBGbG9hdFR5cGU6XG4gICAgICAgIG51bUVsZW1lbnRzID0gaW1hZ2VfcmdiYV9kYXRhLmxlbmd0aCAvIDQ7XG4gICAgICAgIGNvbnN0IGZsb2F0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KG51bUVsZW1lbnRzICogNCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtRWxlbWVudHM7IGorKykge1xuICAgICAgICAgIFJHQkVCeXRlVG9SR0JGbG9hdChpbWFnZV9yZ2JhX2RhdGEsIGogKiA0LCBmbG9hdEFycmF5LCBqICogNCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IGZsb2F0QXJyYXk7XG4gICAgICAgIHR5cGUgPSBGbG9hdFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIYWxmRmxvYXRUeXBlOlxuICAgICAgICBudW1FbGVtZW50cyA9IGltYWdlX3JnYmFfZGF0YS5sZW5ndGggLyA0O1xuICAgICAgICBjb25zdCBoYWxmQXJyYXkgPSBuZXcgVWludDE2QXJyYXkobnVtRWxlbWVudHMgKiA0KTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1FbGVtZW50czsgaisrKSB7XG4gICAgICAgICAgUkdCRUJ5dGVUb1JHQkhhbGYoaW1hZ2VfcmdiYV9kYXRhLCBqICogNCwgaGFsZkFycmF5LCBqICogNCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IGhhbGZBcnJheTtcbiAgICAgICAgdHlwZSA9IEhhbGZGbG9hdFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuUkdCRUxvYWRlcjogVW5zdXBwb3J0ZWQgdHlwZTogXCIgKyB0aGlzLnR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHcsXG4gICAgICBoZWlnaHQ6IGgsXG4gICAgICBkYXRhLFxuICAgICAgaGVhZGVyOiByZ2JlX2hlYWRlcl9pbmZvLnN0cmluZyxcbiAgICAgIGdhbW1hOiByZ2JlX2hlYWRlcl9pbmZvLmdhbW1hLFxuICAgICAgZXhwb3N1cmU6IHJnYmVfaGVhZGVyX2luZm8uZXhwb3N1cmUsXG4gICAgICB0eXBlXG4gICAgfTtcbiAgfVxuICBzZXREYXRhVHlwZSh2YWx1ZSkge1xuICAgIHRoaXMudHlwZSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICBmdW5jdGlvbiBvbkxvYWRDYWxsYmFjayh0ZXh0dXJlLCB0ZXhEYXRhKSB7XG4gICAgICBzd2l0Y2ggKHRleHR1cmUudHlwZSkge1xuICAgICAgICBjYXNlIEZsb2F0VHlwZTpcbiAgICAgICAgY2FzZSBIYWxmRmxvYXRUeXBlOlxuICAgICAgICAgIGlmIChcImNvbG9yU3BhY2VcIiBpbiB0ZXh0dXJlKVxuICAgICAgICAgICAgdGV4dHVyZS5jb2xvclNwYWNlID0gXCJzcmdiLWxpbmVhclwiO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRleHR1cmUuZW5jb2RpbmcgPSAzZTM7XG4gICAgICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG4gICAgICAgICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG4gICAgICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICAgICAgICB0ZXh0dXJlLmZsaXBZID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChvbkxvYWQpXG4gICAgICAgIG9uTG9hZCh0ZXh0dXJlLCB0ZXhEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmxvYWQodXJsLCBvbkxvYWRDYWxsYmFjaywgb25Qcm9ncmVzcywgb25FcnJvcik7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFJHQkVMb2FkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SR0JFTG9hZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/RGBELoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/objects/GroundProjectedEnv.js":
/*!*****************************************************************!*\
  !*** ./node_modules/three-stdlib/objects/GroundProjectedEnv.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GroundProjectedEnv: () => (/* binding */ GroundProjectedEnv)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\");\n\n\nconst isCubeTexture = (def) => def && def.isCubeTexture;\nclass GroundProjectedEnv extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {\n  constructor(texture, options) {\n    var _a, _b;\n    const isCubeMap = isCubeTexture(texture);\n    const w = (_b = isCubeMap ? (_a = texture.image[0]) == null ? void 0 : _a.width : texture.image.width) != null ? _b : 1024;\n    const cubeSize = w / 4;\n    const _lodMax = Math.floor(Math.log2(cubeSize));\n    const _cubeSize = Math.pow(2, _lodMax);\n    const width = 3 * Math.max(_cubeSize, 16 * 7);\n    const height = 4 * _cubeSize;\n    const defines = [\n      isCubeMap ? \"#define ENVMAP_TYPE_CUBE\" : \"\",\n      `#define CUBEUV_TEXEL_WIDTH ${1 / width}`,\n      `#define CUBEUV_TEXEL_HEIGHT ${1 / height}`,\n      `#define CUBEUV_MAX_MIP ${_lodMax}.0`\n    ];\n    const vertexShader = (\n      /* glsl */\n      `\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        `\n    );\n    const fragmentShader = defines.join(\"\\n\") + /* glsl */\n    `\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <${_polyfill_constants_js__WEBPACK_IMPORTED_MODULE_1__.version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n        }\n        `;\n    const uniforms = {\n      map: { value: texture },\n      height: { value: (options == null ? void 0 : options.height) || 15 },\n      radius: { value: (options == null ? void 0 : options.radius) || 100 }\n    };\n    const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.IcosahedronGeometry(1, 16);\n    const material = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n      uniforms,\n      fragmentShader,\n      vertexShader,\n      side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide\n    });\n    super(geometry, material);\n  }\n  set radius(radius) {\n    this.material.uniforms.radius.value = radius;\n  }\n  get radius() {\n    return this.material.uniforms.radius.value;\n  }\n  set height(height) {\n    this.material.uniforms.height.value = height;\n  }\n  get height() {\n    return this.material.uniforms.height.value;\n  }\n}\n\n//# sourceMappingURL=GroundProjectedEnv.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL29iamVjdHMvR3JvdW5kUHJvamVjdGVkRW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4RTtBQUMxQjtBQUNwRDtBQUNBLGlDQUFpQyx1Q0FBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUMscUNBQXFDLFdBQVc7QUFDaEQsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJEQUFPLHVEQUF1RDtBQUN0RjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixnQkFBZ0IsMERBQTBEO0FBQzFFLGdCQUFnQjtBQUNoQjtBQUNBLHlCQUF5QixzREFBbUI7QUFDNUMseUJBQXlCLGlEQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkNBQVU7QUFDdEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2huZWlkZXJjYWRldC9EZXNrdG9wL2ZpenppL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvb2JqZWN0cy9Hcm91bmRQcm9qZWN0ZWRFbnYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWVzaCwgSWNvc2FoZWRyb25HZW9tZXRyeSwgU2hhZGVyTWF0ZXJpYWwsIERvdWJsZVNpZGUgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3BvbHlmaWxsL2NvbnN0YW50cy5qc1wiO1xuY29uc3QgaXNDdWJlVGV4dHVyZSA9IChkZWYpID0+IGRlZiAmJiBkZWYuaXNDdWJlVGV4dHVyZTtcbmNsYXNzIEdyb3VuZFByb2plY3RlZEVudiBleHRlbmRzIE1lc2gge1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBpc0N1YmVNYXAgPSBpc0N1YmVUZXh0dXJlKHRleHR1cmUpO1xuICAgIGNvbnN0IHcgPSAoX2IgPSBpc0N1YmVNYXAgPyAoX2EgPSB0ZXh0dXJlLmltYWdlWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2Eud2lkdGggOiB0ZXh0dXJlLmltYWdlLndpZHRoKSAhPSBudWxsID8gX2IgOiAxMDI0O1xuICAgIGNvbnN0IGN1YmVTaXplID0gdyAvIDQ7XG4gICAgY29uc3QgX2xvZE1heCA9IE1hdGguZmxvb3IoTWF0aC5sb2cyKGN1YmVTaXplKSk7XG4gICAgY29uc3QgX2N1YmVTaXplID0gTWF0aC5wb3coMiwgX2xvZE1heCk7XG4gICAgY29uc3Qgd2lkdGggPSAzICogTWF0aC5tYXgoX2N1YmVTaXplLCAxNiAqIDcpO1xuICAgIGNvbnN0IGhlaWdodCA9IDQgKiBfY3ViZVNpemU7XG4gICAgY29uc3QgZGVmaW5lcyA9IFtcbiAgICAgIGlzQ3ViZU1hcCA/IFwiI2RlZmluZSBFTlZNQVBfVFlQRV9DVUJFXCIgOiBcIlwiLFxuICAgICAgYCNkZWZpbmUgQ1VCRVVWX1RFWEVMX1dJRFRIICR7MSAvIHdpZHRofWAsXG4gICAgICBgI2RlZmluZSBDVUJFVVZfVEVYRUxfSEVJR0hUICR7MSAvIGhlaWdodH1gLFxuICAgICAgYCNkZWZpbmUgQ1VCRVVWX01BWF9NSVAgJHtfbG9kTWF4fS4wYFxuICAgIF07XG4gICAgY29uc3QgdmVydGV4U2hhZGVyID0gKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICB2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XG4gICAgICAgIHZvaWQgbWFpbigpIFxuICAgICAgICB7XG4gICAgICAgICAgICB2ZWM0IHdvcmxkUG9zaXRpb24gPSAoIG1vZGVsTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApICk7XG4gICAgICAgICAgICB2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG4gICAgICAgIH1cbiAgICAgICAgYFxuICAgICk7XG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBkZWZpbmVzLmpvaW4oXCJcXG5cIikgKyAvKiBnbHNsICovXG4gICAgYFxuICAgICAgICAjZGVmaW5lIEVOVk1BUF9UWVBFX0NVQkVfVVZcbiAgICAgICAgdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IHJhZGl1cztcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBoZWlnaHQ7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgYW5nbGU7XG4gICAgICAgICNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXJDdWJlIG1hcDtcbiAgICAgICAgI2Vsc2VcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcbiAgICAgICAgI2VuZGlmXG4gICAgICAgIC8vIEZyb206IGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy80dHNCRDdcbiAgICAgICAgZmxvYXQgZGlza0ludGVyc2VjdFdpdGhCYWNrRmFjZUN1bGxpbmcoIHZlYzMgcm8sIHZlYzMgcmQsIHZlYzMgYywgdmVjMyBuLCBmbG9hdCByICkgXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZsb2F0IGQgPSBkb3QgKCByZCwgbiApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiggZCA+IDAuMCApIHsgcmV0dXJuIDFlNjsgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2ZWMzICBvID0gcm8gLSBjO1xuICAgICAgICAgICAgZmxvYXQgdCA9IC0gZG90KCBuLCBvICkgLyBkO1xuICAgICAgICAgICAgdmVjMyAgcSA9IG8gKyByZCAqIHQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiAoIGRvdCggcSwgcSApIDwgciAqIHIgKSA/IHQgOiAxZTY7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRnJvbTogaHR0cHM6Ly93d3cuaXF1aWxlemxlcy5vcmcvd3d3L2FydGljbGVzL2ludGVyc2VjdG9ycy9pbnRlcnNlY3RvcnMuaHRtXG4gICAgICAgIGZsb2F0IHNwaGVyZUludGVyc2VjdCggdmVjMyBybywgdmVjMyByZCwgdmVjMyBjZSwgZmxvYXQgcmEgKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdmVjMyBvYyA9IHJvIC0gY2U7XG4gICAgICAgICAgICBmbG9hdCBiID0gZG90KCBvYywgcmQgKTtcbiAgICAgICAgICAgIGZsb2F0IGMgPSBkb3QoIG9jLCBvYyApIC0gcmEgKiByYTtcbiAgICAgICAgICAgIGZsb2F0IGggPSBiICogYiAtIGM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCBoIDwgMC4wICkgeyByZXR1cm4gLTEuMDsgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBoID0gc3FydCggaCApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gLSBiICsgaDtcbiAgICAgICAgfVxuICAgICAgICB2ZWMzIHByb2plY3QoKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdmVjMyBwID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiApO1xuICAgICAgICAgICAgdmVjMyBjYW1Qb3MgPSBjYW1lcmFQb3NpdGlvbjtcbiAgICAgICAgICAgIGNhbVBvcy55IC09IGhlaWdodDtcbiAgICAgICAgICAgIGZsb2F0IGludGVyc2VjdGlvbiA9IHNwaGVyZUludGVyc2VjdCggY2FtUG9zLCBwLCB2ZWMzKCAwLjAgKSwgcmFkaXVzICk7XG4gICAgICAgICAgICBpZiggaW50ZXJzZWN0aW9uID4gMC4wICkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZlYzMgaCA9IHZlYzMoIDAuMCwgLSBoZWlnaHQsIDAuMCApO1xuICAgICAgICAgICAgICAgIGZsb2F0IGludGVyc2VjdGlvbjIgPSBkaXNrSW50ZXJzZWN0V2l0aEJhY2tGYWNlQ3VsbGluZyggY2FtUG9zLCBwLCBoLCB2ZWMzKCAwLjAsIDEuMCwgMC4wICksIHJhZGl1cyApO1xuICAgICAgICAgICAgICAgIHAgPSAoIGNhbVBvcyArIG1pbiggaW50ZXJzZWN0aW9uLCBpbnRlcnNlY3Rpb24yICkgKiBwICkgLyByYWRpdXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHAgPSB2ZWMzKCAwLjAsIDEuMCwgMC4wICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgICAgICAjaW5jbHVkZSA8Y29tbW9uPlxuICAgICAgICAjaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PlxuICAgICAgICB2b2lkIG1haW4oKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdmVjMyBwcm9qZWN0ZWRXb3JsZFBvc2l0aW9uID0gcHJvamVjdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxuICAgICAgICAgICAgICAgIHZlYzMgb3V0Y29sb3IgPSB0ZXh0dXJlQ3ViZSggbWFwLCBwcm9qZWN0ZWRXb3JsZFBvc2l0aW9uICkucmdiO1xuICAgICAgICAgICAgI2Vsc2VcbiAgICAgICAgICAgICAgICB2ZWMzIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggcHJvamVjdGVkV29ybGRQb3NpdGlvbiApO1xuICAgICAgICAgICAgICAgIHZlYzIgdXYgPSBlcXVpcmVjdFV2KCBkaXJlY3Rpb24gKTtcbiAgICAgICAgICAgICAgICB2ZWMzIG91dGNvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHV2ICkucmdiO1xuICAgICAgICAgICAgI2VuZGlmXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRjb2xvciwgMS4wICk7XG4gICAgICAgICAgICAjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XG4gICAgICAgICAgICAjaW5jbHVkZSA8JHt2ZXJzaW9uID49IDE1NCA/IFwiY29sb3JzcGFjZV9mcmFnbWVudFwiIDogXCJlbmNvZGluZ3NfZnJhZ21lbnRcIn0+XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAgIG1hcDogeyB2YWx1ZTogdGV4dHVyZSB9LFxuICAgICAgaGVpZ2h0OiB7IHZhbHVlOiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5oZWlnaHQpIHx8IDE1IH0sXG4gICAgICByYWRpdXM6IHsgdmFsdWU6IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnJhZGl1cykgfHwgMTAwIH1cbiAgICB9O1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEljb3NhaGVkcm9uR2VvbWV0cnkoMSwgMTYpO1xuICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IFNoYWRlck1hdGVyaWFsKHtcbiAgICAgIHVuaWZvcm1zLFxuICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICB2ZXJ0ZXhTaGFkZXIsXG4gICAgICBzaWRlOiBEb3VibGVTaWRlXG4gICAgfSk7XG4gICAgc3VwZXIoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgfVxuICBzZXQgcmFkaXVzKHJhZGl1cykge1xuICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMucmFkaXVzLnZhbHVlID0gcmFkaXVzO1xuICB9XG4gIGdldCByYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMucmFkaXVzLnZhbHVlO1xuICB9XG4gIHNldCBoZWlnaHQoaGVpZ2h0KSB7XG4gICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5oZWlnaHQudmFsdWUgPSBoZWlnaHQ7XG4gIH1cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5oZWlnaHQudmFsdWU7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEdyb3VuZFByb2plY3RlZEVudlxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyb3VuZFByb2plY3RlZEVudi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/objects/GroundProjectedEnv.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/types/helpers.js":
/*!****************************************************!*\
  !*** ./node_modules/three-stdlib/types/helpers.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWithKey: () => (/* binding */ getWithKey)\n/* harmony export */ });\nconst getWithKey = (obj, key) => obj[key];\n\n//# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3R5cGVzL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3NjaG5laWRlcmNhZGV0L0Rlc2t0b3AvZml6emkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi90eXBlcy9oZWxwZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGdldFdpdGhLZXkgPSAob2JqLCBrZXkpID0+IG9ialtrZXldO1xuZXhwb3J0IHtcbiAgZ2V0V2l0aEtleVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/types/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/three-stdlib/utils/BufferGeometryUtils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeMorphedAttributes: () => (/* binding */ computeMorphedAttributes),\n/* harmony export */   estimateBytesUsed: () => (/* binding */ estimateBytesUsed),\n/* harmony export */   interleaveAttributes: () => (/* binding */ interleaveAttributes),\n/* harmony export */   mergeBufferAttributes: () => (/* binding */ mergeBufferAttributes),\n/* harmony export */   mergeBufferGeometries: () => (/* binding */ mergeBufferGeometries),\n/* harmony export */   mergeVertices: () => (/* binding */ mergeVertices),\n/* harmony export */   toCreasedNormals: () => (/* binding */ toCreasedNormals),\n/* harmony export */   toTrianglesDrawMode: () => (/* binding */ toTrianglesDrawMode)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _types_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/helpers.js */ \"(ssr)/./node_modules/three-stdlib/types/helpers.js\");\n\n\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0;\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\"\n      );\n      return null;\n    }\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.'\n        );\n        return null;\n      }\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\"\n      );\n      return null;\n    }\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\"\n      );\n      return null;\n    }\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\"\n        );\n        return null;\n      }\n      if (morphAttributes[name] === void 0)\n        morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    }\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      let count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\"\n        );\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach((geom) => {\n      const index = geom.index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\"\n      );\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0)\n      break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\"\n        );\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let itemSize = void 0;\n  let normalized = void 0;\n  let arrayLength = 0;\n  attributes.forEach((attr) => {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\"\n      );\n      return null;\n    }\n    if (itemSize === void 0)\n      itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    if (normalized === void 0)\n      normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n  }\n};\nconst interleaveAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let arrayLength = 0;\n  let stride = 0;\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === void 0)\n      TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n  const interleavedBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(iba, setters[k]);\n        const get = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\nfunction estimateBytesUsed(geometry) {\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  }\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode || drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"\n        );\n        return geometry;\n      }\n    }\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (index) {\n      if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode) {\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n  const _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _tempC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const _morphC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n    _vB.fromBufferAttribute(attribute, b2);\n    _vC.fromBufferAttribute(attribute, c2);\n    const morphInfluences = object2.morphTargetInfluences;\n    if (\n      // @ts-ignore\n      material2.morphTargets && morphAttribute && morphInfluences\n    ) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        const influence = morphInfluences[i2];\n        const morph = morphAttribute[i2];\n        if (influence === 0)\n          continue;\n        _tempA.fromBufferAttribute(morph, a2);\n        _tempB.fromBufferAttribute(morph, b2);\n        _tempC.fromBufferAttribute(morph, c2);\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  }\n  const morphedPositionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute,\n    normalAttribute,\n    morphedPositionAttribute,\n    morphedNormalAttribute\n  };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 100;\n  const verts = [new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()];\n  const tempVec1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempVec2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  const tempNorm2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\n\n//# sourceMappingURL=BufferGeometryUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1TTtBQUN0SjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpREFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0pBQXNKO0FBQ3RKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdKQUF3SjtBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQSxzQkFBc0Isa0NBQWtDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseURBQXNCO0FBQzdELHFDQUFxQyx5REFBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQU8sUUFBUSwwQ0FBTyxRQUFRLDBDQUFPO0FBQzFELHVCQUF1QiwwQ0FBTztBQUM5Qix1QkFBdUIsMENBQU87QUFDOUIsdUJBQXVCLDBDQUFPO0FBQzlCLHdCQUF3QiwwQ0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBDQUFPO0FBQzlCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrREFBZTtBQUN0Qyx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVUU7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3NjaG5laWRlcmNhZGV0L0Rlc2t0b3AvZml6emkvbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi91dGlscy9CdWZmZXJHZW9tZXRyeVV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5LCBCdWZmZXJBdHRyaWJ1dGUsIEludGVybGVhdmVkQnVmZmVyLCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSwgVHJpYW5nbGVzRHJhd01vZGUsIFRyaWFuZ2xlRmFuRHJhd01vZGUsIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSwgVmVjdG9yMywgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgZ2V0V2l0aEtleSB9IGZyb20gXCIuLi90eXBlcy9oZWxwZXJzLmpzXCI7XG5jb25zdCBtZXJnZUJ1ZmZlckdlb21ldHJpZXMgPSAoZ2VvbWV0cmllcywgdXNlR3JvdXBzKSA9PiB7XG4gIGNvbnN0IGlzSW5kZXhlZCA9IGdlb21ldHJpZXNbMF0uaW5kZXggIT09IG51bGw7XG4gIGNvbnN0IGF0dHJpYnV0ZXNVc2VkID0gbmV3IFNldChPYmplY3Qua2V5cyhnZW9tZXRyaWVzWzBdLmF0dHJpYnV0ZXMpKTtcbiAgY29uc3QgbW9ycGhBdHRyaWJ1dGVzVXNlZCA9IG5ldyBTZXQoT2JqZWN0LmtleXMoZ2VvbWV0cmllc1swXS5tb3JwaEF0dHJpYnV0ZXMpKTtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICBjb25zdCBtb3JwaEF0dHJpYnV0ZXMgPSB7fTtcbiAgY29uc3QgbW9ycGhUYXJnZXRzUmVsYXRpdmUgPSBnZW9tZXRyaWVzWzBdLm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuICBjb25zdCBtZXJnZWRHZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZ2VvbWV0cmllcy5mb3JFYWNoKChnZW9tLCBpKSA9PiB7XG4gICAgbGV0IGF0dHJpYnV0ZXNDb3VudCA9IDA7XG4gICAgaWYgKGlzSW5kZXhlZCAhPT0gKGdlb20uaW5kZXggIT09IG51bGwpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gQWxsIGdlb21ldHJpZXMgbXVzdCBoYXZlIGNvbXBhdGlibGUgYXR0cmlidXRlczsgbWFrZSBzdXJlIGluZGV4IGF0dHJpYnV0ZSBleGlzdHMgYW1vbmcgYWxsIGdlb21ldHJpZXMsIG9yIGluIG5vbmUgb2YgdGhlbS5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3IgKGxldCBuYW1lIGluIGdlb20uYXR0cmlidXRlcykge1xuICAgICAgaWYgKCFhdHRyaWJ1dGVzVXNlZC5oYXMobmFtZSkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyAnLiBBbGwgZ2VvbWV0cmllcyBtdXN0IGhhdmUgY29tcGF0aWJsZSBhdHRyaWJ1dGVzOyBtYWtlIHN1cmUgXCInICsgbmFtZSArICdcIiBhdHRyaWJ1dGUgZXhpc3RzIGFtb25nIGFsbCBnZW9tZXRyaWVzLCBvciBpbiBub25lIG9mIHRoZW0uJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGVzW25hbWVdID09PSB2b2lkIDApIHtcbiAgICAgICAgYXR0cmlidXRlc1tuYW1lXSA9IFtdO1xuICAgICAgfVxuICAgICAgYXR0cmlidXRlc1tuYW1lXS5wdXNoKGdlb20uYXR0cmlidXRlc1tuYW1lXSk7XG4gICAgICBhdHRyaWJ1dGVzQ291bnQrKztcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZXNDb3VudCAhPT0gYXR0cmlidXRlc1VzZWQuc2l6ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIE1ha2Ugc3VyZSBhbGwgZ2VvbWV0cmllcyBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBhdHRyaWJ1dGVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChtb3JwaFRhcmdldHNSZWxhdGl2ZSAhPT0gZ2VvbS5tb3JwaFRhcmdldHNSZWxhdGl2ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIC5tb3JwaFRhcmdldHNSZWxhdGl2ZSBtdXN0IGJlIGNvbnNpc3RlbnQgdGhyb3VnaG91dCBhbGwgZ2VvbWV0cmllcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3IgKGxldCBuYW1lIGluIGdlb20ubW9ycGhBdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIW1vcnBoQXR0cmlidXRlc1VzZWQuaGFzKG5hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuICAubW9ycGhBdHRyaWJ1dGVzIG11c3QgYmUgY29uc2lzdGVudCB0aHJvdWdob3V0IGFsbCBnZW9tZXRyaWVzLlwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKG1vcnBoQXR0cmlidXRlc1tuYW1lXSA9PT0gdm9pZCAwKVxuICAgICAgICBtb3JwaEF0dHJpYnV0ZXNbbmFtZV0gPSBbXTtcbiAgICAgIG1vcnBoQXR0cmlidXRlc1tuYW1lXS5wdXNoKGdlb20ubW9ycGhBdHRyaWJ1dGVzW25hbWVdKTtcbiAgICB9XG4gICAgbWVyZ2VkR2VvbWV0cnkudXNlckRhdGEubWVyZ2VkVXNlckRhdGEgPSBtZXJnZWRHZW9tZXRyeS51c2VyRGF0YS5tZXJnZWRVc2VyRGF0YSB8fCBbXTtcbiAgICBtZXJnZWRHZW9tZXRyeS51c2VyRGF0YS5tZXJnZWRVc2VyRGF0YS5wdXNoKGdlb20udXNlckRhdGEpO1xuICAgIGlmICh1c2VHcm91cHMpIHtcbiAgICAgIGxldCBjb3VudDtcbiAgICAgIGlmIChnZW9tLmluZGV4KSB7XG4gICAgICAgIGNvdW50ID0gZ2VvbS5pbmRleC5jb3VudDtcbiAgICAgIH0gZWxzZSBpZiAoZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgY291bnQgPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiBUaGUgZ2VvbWV0cnkgbXVzdCBoYXZlIGVpdGhlciBhbiBpbmRleCBvciBhIHBvc2l0aW9uIGF0dHJpYnV0ZVwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbWVyZ2VkR2VvbWV0cnkuYWRkR3JvdXAob2Zmc2V0LCBjb3VudCwgaSk7XG4gICAgICBvZmZzZXQgKz0gY291bnQ7XG4gICAgfVxuICB9KTtcbiAgaWYgKGlzSW5kZXhlZCkge1xuICAgIGxldCBpbmRleE9mZnNldCA9IDA7XG4gICAgY29uc3QgbWVyZ2VkSW5kZXggPSBbXTtcbiAgICBnZW9tZXRyaWVzLmZvckVhY2goKGdlb20pID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gZ2VvbS5pbmRleDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5kZXguY291bnQ7ICsraikge1xuICAgICAgICBtZXJnZWRJbmRleC5wdXNoKGluZGV4LmdldFgoaikgKyBpbmRleE9mZnNldCk7XG4gICAgICB9XG4gICAgICBpbmRleE9mZnNldCArPSBnZW9tLmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG4gICAgfSk7XG4gICAgbWVyZ2VkR2VvbWV0cnkuc2V0SW5kZXgobWVyZ2VkSW5kZXgpO1xuICB9XG4gIGZvciAobGV0IG5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgIGNvbnN0IG1lcmdlZEF0dHJpYnV0ZSA9IG1lcmdlQnVmZmVyQXR0cmlidXRlcyhhdHRyaWJ1dGVzW25hbWVdKTtcbiAgICBpZiAoIW1lcmdlZEF0dHJpYnV0ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdoaWxlIHRyeWluZyB0byBtZXJnZSB0aGUgXCIgKyBuYW1lICsgXCIgYXR0cmlidXRlLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG1lcmdlZEdlb21ldHJ5LnNldEF0dHJpYnV0ZShuYW1lLCBtZXJnZWRBdHRyaWJ1dGUpO1xuICB9XG4gIGZvciAobGV0IG5hbWUgaW4gbW9ycGhBdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgbnVtTW9ycGhUYXJnZXRzID0gbW9ycGhBdHRyaWJ1dGVzW25hbWVdWzBdLmxlbmd0aDtcbiAgICBpZiAobnVtTW9ycGhUYXJnZXRzID09PSAwKVxuICAgICAgYnJlYWs7XG4gICAgbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzID0gbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzIHx8IHt9O1xuICAgIG1lcmdlZEdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTW9ycGhUYXJnZXRzOyArK2kpIHtcbiAgICAgIGNvbnN0IG1vcnBoQXR0cmlidXRlc1RvTWVyZ2UgPSBbXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbW9ycGhBdHRyaWJ1dGVzW25hbWVdLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIG1vcnBoQXR0cmlidXRlc1RvTWVyZ2UucHVzaChtb3JwaEF0dHJpYnV0ZXNbbmFtZV1bal1baV0pO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVyZ2VkTW9ycGhBdHRyaWJ1dGUgPSBtZXJnZUJ1ZmZlckF0dHJpYnV0ZXMobW9ycGhBdHRyaWJ1dGVzVG9NZXJnZSk7XG4gICAgICBpZiAoIW1lcmdlZE1vcnBoQXR0cmlidXRlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdoaWxlIHRyeWluZyB0byBtZXJnZSB0aGUgXCIgKyBuYW1lICsgXCIgbW9ycGhBdHRyaWJ1dGUuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV0ucHVzaChtZXJnZWRNb3JwaEF0dHJpYnV0ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZXJnZWRHZW9tZXRyeTtcbn07XG5jb25zdCBtZXJnZUJ1ZmZlckF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlcykgPT4ge1xuICBsZXQgVHlwZWRBcnJheSA9IHZvaWQgMDtcbiAgbGV0IGl0ZW1TaXplID0gdm9pZCAwO1xuICBsZXQgbm9ybWFsaXplZCA9IHZvaWQgMDtcbiAgbGV0IGFycmF5TGVuZ3RoID0gMDtcbiAgYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgaWYgKFR5cGVkQXJyYXkgPT09IHZvaWQgMCkge1xuICAgICAgVHlwZWRBcnJheSA9IGF0dHIuYXJyYXkuY29uc3RydWN0b3I7XG4gICAgfVxuICAgIGlmIChUeXBlZEFycmF5ICE9PSBhdHRyLmFycmF5LmNvbnN0cnVjdG9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoKSBmYWlsZWQuIEJ1ZmZlckF0dHJpYnV0ZS5hcnJheSBtdXN0IGJlIG9mIGNvbnNpc3RlbnQgYXJyYXkgdHlwZXMgYWNyb3NzIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGl0ZW1TaXplID09PSB2b2lkIDApXG4gICAgICBpdGVtU2l6ZSA9IGF0dHIuaXRlbVNpemU7XG4gICAgaWYgKGl0ZW1TaXplICE9PSBhdHRyLml0ZW1TaXplKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoKSBmYWlsZWQuIEJ1ZmZlckF0dHJpYnV0ZS5pdGVtU2l6ZSBtdXN0IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6ZWQgPT09IHZvaWQgMClcbiAgICAgIG5vcm1hbGl6ZWQgPSBhdHRyLm5vcm1hbGl6ZWQ7XG4gICAgaWYgKG5vcm1hbGl6ZWQgIT09IGF0dHIubm9ybWFsaXplZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKCkgZmFpbGVkLiBCdWZmZXJBdHRyaWJ1dGUubm9ybWFsaXplZCBtdXN0IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG1hdGNoaW5nIGF0dHJpYnV0ZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXJyYXlMZW5ndGggKz0gYXR0ci5hcnJheS5sZW5ndGg7XG4gIH0pO1xuICBpZiAoVHlwZWRBcnJheSAmJiBpdGVtU2l6ZSkge1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYXJyYXlMZW5ndGgpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgYXJyYXkuc2V0KGF0dHIuYXJyYXksIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gYXR0ci5hcnJheS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkKTtcbiAgfVxufTtcbmNvbnN0IGludGVybGVhdmVBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXMpID0+IHtcbiAgbGV0IFR5cGVkQXJyYXkgPSB2b2lkIDA7XG4gIGxldCBhcnJheUxlbmd0aCA9IDA7XG4gIGxldCBzdHJpZGUgPSAwO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpXTtcbiAgICBpZiAoVHlwZWRBcnJheSA9PT0gdm9pZCAwKVxuICAgICAgVHlwZWRBcnJheSA9IGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoVHlwZWRBcnJheSAhPT0gYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQXR0cmlidXRlQnVmZmVycyBvZiBkaWZmZXJlbnQgdHlwZXMgY2Fubm90IGJlIGludGVybGVhdmVkXCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFycmF5TGVuZ3RoICs9IGF0dHJpYnV0ZS5hcnJheS5sZW5ndGg7XG4gICAgc3RyaWRlICs9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgfVxuICBjb25zdCBpbnRlcmxlYXZlZEJ1ZmZlciA9IG5ldyBJbnRlcmxlYXZlZEJ1ZmZlcihuZXcgVHlwZWRBcnJheShhcnJheUxlbmd0aCksIHN0cmlkZSk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBjb25zdCByZXMgPSBbXTtcbiAgY29uc3QgZ2V0dGVycyA9IFtcImdldFhcIiwgXCJnZXRZXCIsIFwiZ2V0WlwiLCBcImdldFdcIl07XG4gIGNvbnN0IHNldHRlcnMgPSBbXCJzZXRYXCIsIFwic2V0WVwiLCBcInNldFpcIiwgXCJzZXRXXCJdO1xuICBmb3IgKGxldCBqID0gMCwgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1tqXTtcbiAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICBjb25zdCBjb3VudCA9IGF0dHJpYnV0ZS5jb3VudDtcbiAgICBjb25zdCBpYmEgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoaW50ZXJsZWF2ZWRCdWZmZXIsIGl0ZW1TaXplLCBvZmZzZXQsIGF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcbiAgICByZXMucHVzaChpYmEpO1xuICAgIG9mZnNldCArPSBpdGVtU2l6ZTtcbiAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNvdW50OyBjKyspIHtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaXRlbVNpemU7IGsrKykge1xuICAgICAgICBjb25zdCBzZXQgPSBnZXRXaXRoS2V5KGliYSwgc2V0dGVyc1trXSk7XG4gICAgICAgIGNvbnN0IGdldCA9IGdldFdpdGhLZXkoYXR0cmlidXRlLCBnZXR0ZXJzW2tdKTtcbiAgICAgICAgc2V0KGMsIGdldChjKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuZnVuY3Rpb24gZXN0aW1hdGVCeXRlc1VzZWQoZ2VvbWV0cnkpIHtcbiAgbGV0IG1lbSA9IDA7XG4gIGZvciAobGV0IG5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGF0dHIgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgbWVtICs9IGF0dHIuY291bnQgKiBhdHRyLml0ZW1TaXplICogYXR0ci5hcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgfVxuICBjb25zdCBpbmRpY2VzID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcbiAgbWVtICs9IGluZGljZXMgPyBpbmRpY2VzLmNvdW50ICogaW5kaWNlcy5pdGVtU2l6ZSAqIGluZGljZXMuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQgOiAwO1xuICByZXR1cm4gbWVtO1xufVxuZnVuY3Rpb24gbWVyZ2VWZXJ0aWNlcyhnZW9tZXRyeSwgdG9sZXJhbmNlID0gMWUtNCkge1xuICB0b2xlcmFuY2UgPSBNYXRoLm1heCh0b2xlcmFuY2UsIE51bWJlci5FUFNJTE9OKTtcbiAgY29uc3QgaGFzaFRvSW5kZXggPSB7fTtcbiAgY29uc3QgaW5kaWNlcyA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gIGNvbnN0IHBvc2l0aW9ucyA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpO1xuICBjb25zdCB2ZXJ0ZXhDb3VudCA9IGluZGljZXMgPyBpbmRpY2VzLmNvdW50IDogcG9zaXRpb25zLmNvdW50O1xuICBsZXQgbmV4dEluZGV4ID0gMDtcbiAgY29uc3QgYXR0cmlidXRlTmFtZXMgPSBPYmplY3Qua2V5cyhnZW9tZXRyeS5hdHRyaWJ1dGVzKTtcbiAgY29uc3QgYXR0ckFycmF5cyA9IHt9O1xuICBjb25zdCBtb3JwaEF0dHJzQXJyYXlzID0ge307XG4gIGNvbnN0IG5ld0luZGljZXMgPSBbXTtcbiAgY29uc3QgZ2V0dGVycyA9IFtcImdldFhcIiwgXCJnZXRZXCIsIFwiZ2V0WlwiLCBcImdldFdcIl07XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2ldO1xuICAgIGF0dHJBcnJheXNbbmFtZV0gPSBbXTtcbiAgICBjb25zdCBtb3JwaEF0dHIgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV07XG4gICAgaWYgKG1vcnBoQXR0cikge1xuICAgICAgbW9ycGhBdHRyc0FycmF5c1tuYW1lXSA9IG5ldyBBcnJheShtb3JwaEF0dHIubGVuZ3RoKS5maWxsKDApLm1hcCgoKSA9PiBbXSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRlY2ltYWxTaGlmdCA9IE1hdGgubG9nMTAoMSAvIHRvbGVyYW5jZSk7XG4gIGNvbnN0IHNoaWZ0TXVsdGlwbGllciA9IE1hdGgucG93KDEwLCBkZWNpbWFsU2hpZnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpKyspIHtcbiAgICBjb25zdCBpbmRleCA9IGluZGljZXMgPyBpbmRpY2VzLmdldFgoaSkgOiBpO1xuICAgIGxldCBoYXNoID0gXCJcIjtcbiAgICBmb3IgKGxldCBqID0gMCwgbCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWVzW2pdO1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgY29uc3QgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGl0ZW1TaXplOyBrKyspIHtcbiAgICAgICAgaGFzaCArPSBgJHt+fihhdHRyaWJ1dGVbZ2V0dGVyc1trXV0oaW5kZXgpICogc2hpZnRNdWx0aXBsaWVyKX0sYDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc2ggaW4gaGFzaFRvSW5kZXgpIHtcbiAgICAgIG5ld0luZGljZXMucHVzaChoYXNoVG9JbmRleFtoYXNoXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGogPSAwLCBsID0gYXR0cmlidXRlTmFtZXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tqXTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICBjb25zdCBtb3JwaEF0dHIgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuICAgICAgICBjb25zdCBuZXdhcnJheSA9IGF0dHJBcnJheXNbbmFtZV07XG4gICAgICAgIGNvbnN0IG5ld01vcnBoQXJyYXlzID0gbW9ycGhBdHRyc0FycmF5c1tuYW1lXTtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBpdGVtU2l6ZTsgaysrKSB7XG4gICAgICAgICAgY29uc3QgZ2V0dGVyRnVuYyA9IGdldHRlcnNba107XG4gICAgICAgICAgbmV3YXJyYXkucHVzaChhdHRyaWJ1dGVbZ2V0dGVyRnVuY10oaW5kZXgpKTtcbiAgICAgICAgICBpZiAobW9ycGhBdHRyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBtID0gMCwgbWwgPSBtb3JwaEF0dHIubGVuZ3RoOyBtIDwgbWw7IG0rKykge1xuICAgICAgICAgICAgICBuZXdNb3JwaEFycmF5c1ttXS5wdXNoKG1vcnBoQXR0clttXVtnZXR0ZXJGdW5jXShpbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGFzaFRvSW5kZXhbaGFzaF0gPSBuZXh0SW5kZXg7XG4gICAgICBuZXdJbmRpY2VzLnB1c2gobmV4dEluZGV4KTtcbiAgICAgIG5leHRJbmRleCsrO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXN1bHQgPSBnZW9tZXRyeS5jbG9uZSgpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tpXTtcbiAgICBjb25zdCBvbGRBdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IG9sZEF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3RvcihhdHRyQXJyYXlzW25hbWVdKTtcbiAgICBjb25zdCBhdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKGJ1ZmZlciwgb2xkQXR0cmlidXRlLml0ZW1TaXplLCBvbGRBdHRyaWJ1dGUubm9ybWFsaXplZCk7XG4gICAgcmVzdWx0LnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyaWJ1dGUpO1xuICAgIGlmIChuYW1lIGluIG1vcnBoQXR0cnNBcnJheXMpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbW9ycGhBdHRyc0FycmF5c1tuYW1lXS5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBvbGRNb3JwaEF0dHJpYnV0ZSA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlc1tuYW1lXVtqXTtcbiAgICAgICAgY29uc3QgYnVmZmVyMiA9IG5ldyBvbGRNb3JwaEF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3Rvcihtb3JwaEF0dHJzQXJyYXlzW25hbWVdW2pdKTtcbiAgICAgICAgY29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKGJ1ZmZlcjIsIG9sZE1vcnBoQXR0cmlidXRlLml0ZW1TaXplLCBvbGRNb3JwaEF0dHJpYnV0ZS5ub3JtYWxpemVkKTtcbiAgICAgICAgcmVzdWx0Lm1vcnBoQXR0cmlidXRlc1tuYW1lXVtqXSA9IG1vcnBoQXR0cmlidXRlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXN1bHQuc2V0SW5kZXgobmV3SW5kaWNlcyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b1RyaWFuZ2xlc0RyYXdNb2RlKGdlb21ldHJ5LCBkcmF3TW9kZSkge1xuICBpZiAoZHJhd01vZGUgPT09IFRyaWFuZ2xlc0RyYXdNb2RlKSB7XG4gICAgY29uc29sZS53YXJuKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IEdlb21ldHJ5IGFscmVhZHkgZGVmaW5lZCBhcyB0cmlhbmdsZXMuXCIpO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxuICBpZiAoZHJhd01vZGUgPT09IFRyaWFuZ2xlRmFuRHJhd01vZGUgfHwgZHJhd01vZGUgPT09IFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSkge1xuICAgIGxldCBpbmRleCA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gICAgaWYgKGluZGV4ID09PSBudWxsKSB7XG4gICAgICBjb25zdCBpbmRpY2VzID0gW107XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShcInBvc2l0aW9uXCIpO1xuICAgICAgaWYgKHBvc2l0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbi5jb3VudDsgaSsrKSB7XG4gICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIGdlb21ldHJ5LnNldEluZGV4KGluZGljZXMpO1xuICAgICAgICBpbmRleCA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVuZGVmaW5lZCBwb3NpdGlvbiBhdHRyaWJ1dGUuIFByb2Nlc3Npbmcgbm90IHBvc3NpYmxlLlwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBnZW9tZXRyeTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbnVtYmVyT2ZUcmlhbmdsZXMgPSBpbmRleC5jb3VudCAtIDI7XG4gICAgY29uc3QgbmV3SW5kaWNlcyA9IFtdO1xuICAgIGlmIChpbmRleCkge1xuICAgICAgaWYgKGRyYXdNb2RlID09PSBUcmlhbmdsZUZhbkRyYXdNb2RlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IG51bWJlck9mVHJpYW5nbGVzOyBpKyspIHtcbiAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WCgwKSk7XG4gICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSkpO1xuICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZUcmlhbmdsZXM7IGkrKykge1xuICAgICAgICAgIGlmIChpICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSkpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDEpKTtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAyKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAyKSk7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMSkpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3SW5kaWNlcy5sZW5ndGggLyAzICE9PSBudW1iZXJPZlRyaWFuZ2xlcykge1xuICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmFibGUgdG8gZ2VuZXJhdGUgY29ycmVjdCBhbW91bnQgb2YgdHJpYW5nbGVzLlwiKTtcbiAgICB9XG4gICAgY29uc3QgbmV3R2VvbWV0cnkgPSBnZW9tZXRyeS5jbG9uZSgpO1xuICAgIG5ld0dlb21ldHJ5LnNldEluZGV4KG5ld0luZGljZXMpO1xuICAgIG5ld0dlb21ldHJ5LmNsZWFyR3JvdXBzKCk7XG4gICAgcmV0dXJuIG5ld0dlb21ldHJ5O1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogVW5rbm93biBkcmF3IG1vZGU6XCIsIGRyYXdNb2RlKTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVNb3JwaGVkQXR0cmlidXRlcyhvYmplY3QpIHtcbiAgaWYgKG9iamVjdC5nZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICE9PSB0cnVlKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IEdlb21ldHJ5IGlzIG5vdCBvZiB0eXBlIEJ1ZmZlckdlb21ldHJ5LlwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBfdkEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdkIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdkMgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdGVtcEEgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdGVtcEIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfdGVtcEMgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfbW9ycGhBID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX21vcnBoQiA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF9tb3JwaEMgPSBuZXcgVmVjdG9yMygpO1xuICBmdW5jdGlvbiBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEob2JqZWN0MiwgbWF0ZXJpYWwyLCBhdHRyaWJ1dGUsIG1vcnBoQXR0cmlidXRlLCBtb3JwaFRhcmdldHNSZWxhdGl2ZTIsIGEyLCBiMiwgYzIsIG1vZGlmaWVkQXR0cmlidXRlQXJyYXkpIHtcbiAgICBfdkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGEyKTtcbiAgICBfdkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGIyKTtcbiAgICBfdkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGUsIGMyKTtcbiAgICBjb25zdCBtb3JwaEluZmx1ZW5jZXMgPSBvYmplY3QyLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcbiAgICBpZiAoXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBtYXRlcmlhbDIubW9ycGhUYXJnZXRzICYmIG1vcnBoQXR0cmlidXRlICYmIG1vcnBoSW5mbHVlbmNlc1xuICAgICkge1xuICAgICAgX21vcnBoQS5zZXQoMCwgMCwgMCk7XG4gICAgICBfbW9ycGhCLnNldCgwLCAwLCAwKTtcbiAgICAgIF9tb3JwaEMuc2V0KDAsIDAsIDApO1xuICAgICAgZm9yIChsZXQgaTIgPSAwLCBpbDIgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IGkyIDwgaWwyOyBpMisrKSB7XG4gICAgICAgIGNvbnN0IGluZmx1ZW5jZSA9IG1vcnBoSW5mbHVlbmNlc1tpMl07XG4gICAgICAgIGNvbnN0IG1vcnBoID0gbW9ycGhBdHRyaWJ1dGVbaTJdO1xuICAgICAgICBpZiAoaW5mbHVlbmNlID09PSAwKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBfdGVtcEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaCwgYTIpO1xuICAgICAgICBfdGVtcEIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaCwgYjIpO1xuICAgICAgICBfdGVtcEMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShtb3JwaCwgYzIpO1xuICAgICAgICBpZiAobW9ycGhUYXJnZXRzUmVsYXRpdmUyKSB7XG4gICAgICAgICAgX21vcnBoQS5hZGRTY2FsZWRWZWN0b3IoX3RlbXBBLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEIuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQiwgaW5mbHVlbmNlKTtcbiAgICAgICAgICBfbW9ycGhDLmFkZFNjYWxlZFZlY3RvcihfdGVtcEMsIGluZmx1ZW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX21vcnBoQS5hZGRTY2FsZWRWZWN0b3IoX3RlbXBBLnN1YihfdkEpLCBpbmZsdWVuY2UpO1xuICAgICAgICAgIF9tb3JwaEIuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQi5zdWIoX3ZCKSwgaW5mbHVlbmNlKTtcbiAgICAgICAgICBfbW9ycGhDLmFkZFNjYWxlZFZlY3RvcihfdGVtcEMuc3ViKF92QyksIGluZmx1ZW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF92QS5hZGQoX21vcnBoQSk7XG4gICAgICBfdkIuYWRkKF9tb3JwaEIpO1xuICAgICAgX3ZDLmFkZChfbW9ycGhDKTtcbiAgICB9XG4gICAgaWYgKG9iamVjdDIuaXNTa2lubmVkTWVzaCkge1xuICAgICAgb2JqZWN0Mi5ib25lVHJhbnNmb3JtKGEyLCBfdkEpO1xuICAgICAgb2JqZWN0Mi5ib25lVHJhbnNmb3JtKGIyLCBfdkIpO1xuICAgICAgb2JqZWN0Mi5ib25lVHJhbnNmb3JtKGMyLCBfdkMpO1xuICAgIH1cbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2EyICogMyArIDBdID0gX3ZBLng7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVthMiAqIDMgKyAxXSA9IF92QS55O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYTIgKiAzICsgMl0gPSBfdkEuejtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2IyICogMyArIDBdID0gX3ZCLng7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtiMiAqIDMgKyAxXSA9IF92Qi55O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYjIgKiAzICsgMl0gPSBfdkIuejtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2MyICogMyArIDBdID0gX3ZDLng7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtjMiAqIDMgKyAxXSA9IF92Qy55O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYzIgKiAzICsgMl0gPSBfdkMuejtcbiAgfVxuICBjb25zdCBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcbiAgY29uc3QgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG4gIGxldCBhLCBiLCBjO1xuICBjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuICBjb25zdCBwb3NpdGlvbkF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gIGNvbnN0IG1vcnBoUG9zaXRpb24gPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG4gIGNvbnN0IG1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzUmVsYXRpdmU7XG4gIGNvbnN0IG5vcm1hbEF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsO1xuICBjb25zdCBtb3JwaE5vcm1hbCA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuICBjb25zdCBkcmF3UmFuZ2UgPSBnZW9tZXRyeS5kcmF3UmFuZ2U7XG4gIGxldCBpLCBqLCBpbCwgamw7XG4gIGxldCBncm91cCwgZ3JvdXBNYXRlcmlhbDtcbiAgbGV0IHN0YXJ0LCBlbmQ7XG4gIGNvbnN0IG1vZGlmaWVkUG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9uQXR0cmlidXRlLmNvdW50ICogcG9zaXRpb25BdHRyaWJ1dGUuaXRlbVNpemUpO1xuICBjb25zdCBtb2RpZmllZE5vcm1hbCA9IG5ldyBGbG9hdDMyQXJyYXkobm9ybWFsQXR0cmlidXRlLmNvdW50ICogbm9ybWFsQXR0cmlidXRlLml0ZW1TaXplKTtcbiAgaWYgKGluZGV4ICE9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgICBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbZ3JvdXAubWF0ZXJpYWxJbmRleF07XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoZ3JvdXAuc3RhcnQsIGRyYXdSYW5nZS5zdGFydCk7XG4gICAgICAgIGVuZCA9IE1hdGgubWluKGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICAgIGZvciAoaiA9IHN0YXJ0LCBqbCA9IGVuZDsgaiA8IGpsOyBqICs9IDMpIHtcbiAgICAgICAgICBhID0gaW5kZXguZ2V0WChqKTtcbiAgICAgICAgICBiID0gaW5kZXguZ2V0WChqICsgMSk7XG4gICAgICAgICAgYyA9IGluZGV4LmdldFgoaiArIDIpO1xuICAgICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwsXG4gICAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoUG9zaXRpb24sXG4gICAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwsXG4gICAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgICBtb3JwaE5vcm1hbCxcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgIGVuZCA9IE1hdGgubWluKGluZGV4LmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuICAgICAgZm9yIChpID0gc3RhcnQsIGlsID0gZW5kOyBpIDwgaWw7IGkgKz0gMykge1xuICAgICAgICBhID0gaW5kZXguZ2V0WChpKTtcbiAgICAgICAgYiA9IGluZGV4LmdldFgoaSArIDEpO1xuICAgICAgICBjID0gaW5kZXguZ2V0WChpICsgMik7XG4gICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBtb2RpZmllZFBvc2l0aW9uXG4gICAgICAgICk7XG4gICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgbm9ybWFsQXR0cmlidXRlLFxuICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkTm9ybWFsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHBvc2l0aW9uQXR0cmlidXRlICE9PSB2b2lkIDApIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRlcmlhbCkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFtncm91cC5tYXRlcmlhbEluZGV4XTtcbiAgICAgICAgc3RhcnQgPSBNYXRoLm1heChncm91cC5zdGFydCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgICAgZW5kID0gTWF0aC5taW4oZ3JvdXAuc3RhcnQgKyBncm91cC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgICAgZm9yIChqID0gc3RhcnQsIGpsID0gZW5kOyBqIDwgamw7IGogKz0gMykge1xuICAgICAgICAgIGEgPSBqO1xuICAgICAgICAgIGIgPSBqICsgMTtcbiAgICAgICAgICBjID0gaiArIDI7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWRQb3NpdGlvblxuICAgICAgICAgICk7XG4gICAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgZ3JvdXBNYXRlcmlhbCxcbiAgICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBtb2RpZmllZE5vcm1hbFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSBNYXRoLm1heCgwLCBkcmF3UmFuZ2Uuc3RhcnQpO1xuICAgICAgZW5kID0gTWF0aC5taW4ocG9zaXRpb25BdHRyaWJ1dGUuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICBmb3IgKGkgPSBzdGFydCwgaWwgPSBlbmQ7IGkgPCBpbDsgaSArPSAzKSB7XG4gICAgICAgIGEgPSBpO1xuICAgICAgICBiID0gaSArIDE7XG4gICAgICAgIGMgPSBpICsgMjtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICBtb3JwaFBvc2l0aW9uLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhOb3JtYWwsXG4gICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgbW9ycGhlZFBvc2l0aW9uQXR0cmlidXRlID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobW9kaWZpZWRQb3NpdGlvbiwgMyk7XG4gIGNvbnN0IG1vcnBoZWROb3JtYWxBdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShtb2RpZmllZE5vcm1hbCwgMyk7XG4gIHJldHVybiB7XG4gICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgbm9ybWFsQXR0cmlidXRlLFxuICAgIG1vcnBoZWRQb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICBtb3JwaGVkTm9ybWFsQXR0cmlidXRlXG4gIH07XG59XG5mdW5jdGlvbiB0b0NyZWFzZWROb3JtYWxzKGdlb21ldHJ5LCBjcmVhc2VBbmdsZSA9IE1hdGguUEkgLyAzKSB7XG4gIGNvbnN0IGNyZWFzZURvdCA9IE1hdGguY29zKGNyZWFzZUFuZ2xlKTtcbiAgY29uc3QgaGFzaE11bHRpcGxpZXIgPSAoMSArIDFlLTEwKSAqIDEwMDtcbiAgY29uc3QgdmVydHMgPSBbbmV3IFZlY3RvcjMoKSwgbmV3IFZlY3RvcjMoKSwgbmV3IFZlY3RvcjMoKV07XG4gIGNvbnN0IHRlbXBWZWMxID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgdGVtcFZlYzIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCB0ZW1wTm9ybSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IHRlbXBOb3JtMiA9IG5ldyBWZWN0b3IzKCk7XG4gIGZ1bmN0aW9uIGhhc2hWZXJ0ZXgodikge1xuICAgIGNvbnN0IHggPSB+fih2LnggKiBoYXNoTXVsdGlwbGllcik7XG4gICAgY29uc3QgeSA9IH5+KHYueSAqIGhhc2hNdWx0aXBsaWVyKTtcbiAgICBjb25zdCB6ID0gfn4odi56ICogaGFzaE11bHRpcGxpZXIpO1xuICAgIHJldHVybiBgJHt4fSwke3l9LCR7en1gO1xuICB9XG4gIGNvbnN0IHJlc3VsdEdlb21ldHJ5ID0gZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS50b05vbkluZGV4ZWQoKSA6IGdlb21ldHJ5O1xuICBjb25zdCBwb3NBdHRyID0gcmVzdWx0R2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcbiAgY29uc3QgdmVydGV4TWFwID0ge307XG4gIGZvciAobGV0IGkgPSAwLCBsID0gcG9zQXR0ci5jb3VudCAvIDM7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBpMyA9IDMgKiBpO1xuICAgIGNvbnN0IGEgPSB2ZXJ0c1swXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMCk7XG4gICAgY29uc3QgYiA9IHZlcnRzWzFdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAxKTtcbiAgICBjb25zdCBjID0gdmVydHNbMl0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDIpO1xuICAgIHRlbXBWZWMxLnN1YlZlY3RvcnMoYywgYik7XG4gICAgdGVtcFZlYzIuc3ViVmVjdG9ycyhhLCBiKTtcbiAgICBjb25zdCBub3JtYWwgPSBuZXcgVmVjdG9yMygpLmNyb3NzVmVjdG9ycyh0ZW1wVmVjMSwgdGVtcFZlYzIpLm5vcm1hbGl6ZSgpO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgMzsgbisrKSB7XG4gICAgICBjb25zdCB2ZXJ0ID0gdmVydHNbbl07XG4gICAgICBjb25zdCBoYXNoID0gaGFzaFZlcnRleCh2ZXJ0KTtcbiAgICAgIGlmICghKGhhc2ggaW4gdmVydGV4TWFwKSkge1xuICAgICAgICB2ZXJ0ZXhNYXBbaGFzaF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHZlcnRleE1hcFtoYXNoXS5wdXNoKG5vcm1hbCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG5vcm1hbEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShwb3NBdHRyLmNvdW50ICogMyk7XG4gIGNvbnN0IG5vcm1BdHRyID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShub3JtYWxBcnJheSwgMywgZmFsc2UpO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHBvc0F0dHIuY291bnQgLyAzOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgaTMgPSAzICogaTtcbiAgICBjb25zdCBhID0gdmVydHNbMF0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDApO1xuICAgIGNvbnN0IGIgPSB2ZXJ0c1sxXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMSk7XG4gICAgY29uc3QgYyA9IHZlcnRzWzJdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAyKTtcbiAgICB0ZW1wVmVjMS5zdWJWZWN0b3JzKGMsIGIpO1xuICAgIHRlbXBWZWMyLnN1YlZlY3RvcnMoYSwgYik7XG4gICAgdGVtcE5vcm0uY3Jvc3NWZWN0b3JzKHRlbXBWZWMxLCB0ZW1wVmVjMikubm9ybWFsaXplKCk7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCAzOyBuKyspIHtcbiAgICAgIGNvbnN0IHZlcnQgPSB2ZXJ0c1tuXTtcbiAgICAgIGNvbnN0IGhhc2ggPSBoYXNoVmVydGV4KHZlcnQpO1xuICAgICAgY29uc3Qgb3RoZXJOb3JtYWxzID0gdmVydGV4TWFwW2hhc2hdO1xuICAgICAgdGVtcE5vcm0yLnNldCgwLCAwLCAwKTtcbiAgICAgIGZvciAobGV0IGsgPSAwLCBsayA9IG90aGVyTm9ybWFscy5sZW5ndGg7IGsgPCBsazsgaysrKSB7XG4gICAgICAgIGNvbnN0IG90aGVyTm9ybSA9IG90aGVyTm9ybWFsc1trXTtcbiAgICAgICAgaWYgKHRlbXBOb3JtLmRvdChvdGhlck5vcm0pID4gY3JlYXNlRG90KSB7XG4gICAgICAgICAgdGVtcE5vcm0yLmFkZChvdGhlck5vcm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZW1wTm9ybTIubm9ybWFsaXplKCk7XG4gICAgICBub3JtQXR0ci5zZXRYWVooaTMgKyBuLCB0ZW1wTm9ybTIueCwgdGVtcE5vcm0yLnksIHRlbXBOb3JtMi56KTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0R2VvbWV0cnkuc2V0QXR0cmlidXRlKFwibm9ybWFsXCIsIG5vcm1BdHRyKTtcbiAgcmV0dXJuIHJlc3VsdEdlb21ldHJ5O1xufVxuZXhwb3J0IHtcbiAgY29tcHV0ZU1vcnBoZWRBdHRyaWJ1dGVzLFxuICBlc3RpbWF0ZUJ5dGVzVXNlZCxcbiAgaW50ZXJsZWF2ZUF0dHJpYnV0ZXMsXG4gIG1lcmdlQnVmZmVyQXR0cmlidXRlcyxcbiAgbWVyZ2VCdWZmZXJHZW9tZXRyaWVzLFxuICBtZXJnZVZlcnRpY2VzLFxuICB0b0NyZWFzZWROb3JtYWxzLFxuICB0b1RyaWFuZ2xlc0RyYXdNb2RlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnVmZmVyR2VvbWV0cnlVdGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/utils/SkeletonUtils.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/utils/SkeletonUtils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SkeletonUtils: () => (/* binding */ SkeletonUtils)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nfunction retarget(target, source, options = {}) {\n  const pos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), quat = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion(), scale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), bindBoneMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), relativeMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), globalMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n  options.preserveMatrix = options.preserveMatrix !== void 0 ? options.preserveMatrix : true;\n  options.preservePosition = options.preservePosition !== void 0 ? options.preservePosition : true;\n  options.preserveHipPosition = options.preserveHipPosition !== void 0 ? options.preserveHipPosition : false;\n  options.useTargetMatrix = options.useTargetMatrix !== void 0 ? options.useTargetMatrix : false;\n  options.hip = options.hip !== void 0 ? options.hip : \"hip\";\n  options.names = options.names || {};\n  const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source), bones = target.isObject3D ? target.skeleton.bones : getBones(target);\n  let bindBones, bone, name, boneTo, bonesPosition;\n  if (target.isObject3D) {\n    target.skeleton.pose();\n  } else {\n    options.useTargetMatrix = true;\n    options.preserveMatrix = false;\n  }\n  if (options.preservePosition) {\n    bonesPosition = [];\n    for (let i = 0; i < bones.length; i++) {\n      bonesPosition.push(bones[i].position.clone());\n    }\n  }\n  if (options.preserveMatrix) {\n    target.updateMatrixWorld();\n    target.matrixWorld.identity();\n    for (let i = 0; i < target.children.length; ++i) {\n      target.children[i].updateMatrixWorld(true);\n    }\n  }\n  if (options.offsets) {\n    bindBones = [];\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (options.offsets[name]) {\n        bone.matrix.multiply(options.offsets[name]);\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n      bindBones.push(bone.matrixWorld.clone());\n    }\n  }\n  for (let i = 0; i < bones.length; ++i) {\n    bone = bones[i];\n    name = options.names[bone.name] || bone.name;\n    boneTo = getBoneByName(name, sourceBones);\n    globalMatrix.copy(bone.matrixWorld);\n    if (boneTo) {\n      boneTo.updateMatrixWorld();\n      if (options.useTargetMatrix) {\n        relativeMatrix.copy(boneTo.matrixWorld);\n      } else {\n        relativeMatrix.copy(target.matrixWorld).invert();\n        relativeMatrix.multiply(boneTo.matrixWorld);\n      }\n      scale.setFromMatrixScale(relativeMatrix);\n      relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));\n      globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n      if (target.isObject3D) {\n        const boneIndex = bones.indexOf(bone), wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n        globalMatrix.multiply(wBindMatrix);\n      }\n      globalMatrix.copyPosition(relativeMatrix);\n    }\n    if (bone.parent && bone.parent.isBone) {\n      bone.matrix.copy(bone.parent.matrixWorld).invert();\n      bone.matrix.multiply(globalMatrix);\n    } else {\n      bone.matrix.copy(globalMatrix);\n    }\n    if (options.preserveHipPosition && name === options.hip) {\n      bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n    }\n    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n    bone.updateMatrixWorld();\n  }\n  if (options.preservePosition) {\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (name !== options.hip) {\n        bone.position.copy(bonesPosition[i]);\n      }\n    }\n  }\n  if (options.preserveMatrix) {\n    target.updateMatrixWorld(true);\n  }\n}\nfunction retargetClip(target, source, clip, options = {}) {\n  options.useFirstFramePosition = options.useFirstFramePosition !== void 0 ? options.useFirstFramePosition : false;\n  options.fps = options.fps !== void 0 ? options.fps : 30;\n  options.names = options.names || [];\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source);\n  }\n  const numFrames = Math.round(clip.duration * (options.fps / 1e3) * 1e3), delta = 1 / options.fps, convertedTracks = [], mixer = new three__WEBPACK_IMPORTED_MODULE_0__.AnimationMixer(source), bones = getBones(target.skeleton), boneDatas = [];\n  let positionOffset, bone, boneTo, boneData, name;\n  mixer.clipAction(clip).play();\n  mixer.update(0);\n  source.updateMatrixWorld();\n  for (let i = 0; i < numFrames; ++i) {\n    const time = i * delta;\n    retarget(target, source, options);\n    for (let j = 0; j < bones.length; ++j) {\n      name = options.names[bones[j].name] || bones[j].name;\n      boneTo = getBoneByName(name, source.skeleton);\n      if (boneTo) {\n        bone = bones[j];\n        boneData = boneDatas[j] = boneDatas[j] || { bone };\n        if (options.hip === name) {\n          if (!boneData.pos) {\n            boneData.pos = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 3)\n            };\n          }\n          if (options.useFirstFramePosition) {\n            if (i === 0) {\n              positionOffset = bone.position.clone();\n            }\n            bone.position.sub(positionOffset);\n          }\n          boneData.pos.times[i] = time;\n          bone.position.toArray(boneData.pos.values, i * 3);\n        }\n        if (!boneData.quat) {\n          boneData.quat = {\n            times: new Float32Array(numFrames),\n            values: new Float32Array(numFrames * 4)\n          };\n        }\n        boneData.quat.times[i] = time;\n        bone.quaternion.toArray(boneData.quat.values, i * 4);\n      }\n    }\n    mixer.update(delta);\n    source.updateMatrixWorld();\n  }\n  for (let i = 0; i < boneDatas.length; ++i) {\n    boneData = boneDatas[i];\n    if (boneData) {\n      if (boneData.pos) {\n        convertedTracks.push(\n          new three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack(\n            \".bones[\" + boneData.bone.name + \"].position\",\n            boneData.pos.times,\n            boneData.pos.values\n          )\n        );\n      }\n      convertedTracks.push(\n        new three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack(\n          \".bones[\" + boneData.bone.name + \"].quaternion\",\n          boneData.quat.times,\n          boneData.quat.values\n        )\n      );\n    }\n  }\n  mixer.uncacheAction(clip);\n  return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(clip.name, -1, convertedTracks);\n}\nfunction clone(source) {\n  const sourceLookup = /* @__PURE__ */ new Map();\n  const cloneLookup = /* @__PURE__ */ new Map();\n  const clone2 = source.clone();\n  parallelTraverse(source, clone2, function(sourceNode, clonedNode) {\n    sourceLookup.set(clonedNode, sourceNode);\n    cloneLookup.set(sourceNode, clonedNode);\n  });\n  clone2.traverse(function(node) {\n    if (!node.isSkinnedMesh)\n      return;\n    const clonedMesh = node;\n    const sourceMesh = sourceLookup.get(node);\n    const sourceBones = sourceMesh.skeleton.bones;\n    clonedMesh.skeleton = sourceMesh.skeleton.clone();\n    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n    clonedMesh.skeleton.bones = sourceBones.map(function(bone) {\n      return cloneLookup.get(bone);\n    });\n    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n  });\n  return clone2;\n}\nfunction getBoneByName(name, skeleton) {\n  for (let i = 0, bones = getBones(skeleton); i < bones.length; i++) {\n    if (name === bones[i].name)\n      return bones[i];\n  }\n}\nfunction getBones(skeleton) {\n  return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n}\nfunction getHelperFromSkeleton(skeleton) {\n  const source = new three__WEBPACK_IMPORTED_MODULE_0__.SkeletonHelper(skeleton.bones[0]);\n  source.skeleton = skeleton;\n  return source;\n}\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\nconst SkeletonUtils = { retarget, retargetClip, clone };\n\n//# sourceMappingURL=SkeletonUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL1NrZWxldG9uVXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0o7QUFDbEosOENBQThDO0FBQzlDLGtCQUFrQiwwQ0FBTyxlQUFlLDZDQUFVLGdCQUFnQiwwQ0FBTyx5QkFBeUIsMENBQU8seUJBQXlCLDBDQUFPLHVCQUF1QiwwQ0FBTztBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0lBQXNJLGlEQUFjO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdEQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlEQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUd0QjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvc2NobmVpZGVyY2FkZXQvRGVza3RvcC9maXp6aS9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL1NrZWxldG9uVXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVjdG9yMywgUXVhdGVybmlvbiwgTWF0cml4NCwgQW5pbWF0aW9uTWl4ZXIsIFZlY3RvcktleWZyYW1lVHJhY2ssIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLCBBbmltYXRpb25DbGlwLCBTa2VsZXRvbkhlbHBlciB9IGZyb20gXCJ0aHJlZVwiO1xuZnVuY3Rpb24gcmV0YXJnZXQodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBwb3MgPSBuZXcgVmVjdG9yMygpLCBxdWF0ID0gbmV3IFF1YXRlcm5pb24oKSwgc2NhbGUgPSBuZXcgVmVjdG9yMygpLCBiaW5kQm9uZU1hdHJpeCA9IG5ldyBNYXRyaXg0KCksIHJlbGF0aXZlTWF0cml4ID0gbmV3IE1hdHJpeDQoKSwgZ2xvYmFsTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgb3B0aW9ucy5wcmVzZXJ2ZU1hdHJpeCA9IG9wdGlvbnMucHJlc2VydmVNYXRyaXggIT09IHZvaWQgMCA/IG9wdGlvbnMucHJlc2VydmVNYXRyaXggOiB0cnVlO1xuICBvcHRpb25zLnByZXNlcnZlUG9zaXRpb24gPSBvcHRpb25zLnByZXNlcnZlUG9zaXRpb24gIT09IHZvaWQgMCA/IG9wdGlvbnMucHJlc2VydmVQb3NpdGlvbiA6IHRydWU7XG4gIG9wdGlvbnMucHJlc2VydmVIaXBQb3NpdGlvbiA9IG9wdGlvbnMucHJlc2VydmVIaXBQb3NpdGlvbiAhPT0gdm9pZCAwID8gb3B0aW9ucy5wcmVzZXJ2ZUhpcFBvc2l0aW9uIDogZmFsc2U7XG4gIG9wdGlvbnMudXNlVGFyZ2V0TWF0cml4ID0gb3B0aW9ucy51c2VUYXJnZXRNYXRyaXggIT09IHZvaWQgMCA/IG9wdGlvbnMudXNlVGFyZ2V0TWF0cml4IDogZmFsc2U7XG4gIG9wdGlvbnMuaGlwID0gb3B0aW9ucy5oaXAgIT09IHZvaWQgMCA/IG9wdGlvbnMuaGlwIDogXCJoaXBcIjtcbiAgb3B0aW9ucy5uYW1lcyA9IG9wdGlvbnMubmFtZXMgfHwge307XG4gIGNvbnN0IHNvdXJjZUJvbmVzID0gc291cmNlLmlzT2JqZWN0M0QgPyBzb3VyY2Uuc2tlbGV0b24uYm9uZXMgOiBnZXRCb25lcyhzb3VyY2UpLCBib25lcyA9IHRhcmdldC5pc09iamVjdDNEID8gdGFyZ2V0LnNrZWxldG9uLmJvbmVzIDogZ2V0Qm9uZXModGFyZ2V0KTtcbiAgbGV0IGJpbmRCb25lcywgYm9uZSwgbmFtZSwgYm9uZVRvLCBib25lc1Bvc2l0aW9uO1xuICBpZiAodGFyZ2V0LmlzT2JqZWN0M0QpIHtcbiAgICB0YXJnZXQuc2tlbGV0b24ucG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMudXNlVGFyZ2V0TWF0cml4ID0gdHJ1ZTtcbiAgICBvcHRpb25zLnByZXNlcnZlTWF0cml4ID0gZmFsc2U7XG4gIH1cbiAgaWYgKG9wdGlvbnMucHJlc2VydmVQb3NpdGlvbikge1xuICAgIGJvbmVzUG9zaXRpb24gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBib25lc1Bvc2l0aW9uLnB1c2goYm9uZXNbaV0ucG9zaXRpb24uY2xvbmUoKSk7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLnByZXNlcnZlTWF0cml4KSB7XG4gICAgdGFyZ2V0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgdGFyZ2V0Lm1hdHJpeFdvcmxkLmlkZW50aXR5KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXQuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgIHRhcmdldC5jaGlsZHJlbltpXS51cGRhdGVNYXRyaXhXb3JsZCh0cnVlKTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMub2Zmc2V0cykge1xuICAgIGJpbmRCb25lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJvbmUgPSBib25lc1tpXTtcbiAgICAgIG5hbWUgPSBvcHRpb25zLm5hbWVzW2JvbmUubmFtZV0gfHwgYm9uZS5uYW1lO1xuICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0c1tuYW1lXSkge1xuICAgICAgICBib25lLm1hdHJpeC5tdWx0aXBseShvcHRpb25zLm9mZnNldHNbbmFtZV0pO1xuICAgICAgICBib25lLm1hdHJpeC5kZWNvbXBvc2UoYm9uZS5wb3NpdGlvbiwgYm9uZS5xdWF0ZXJuaW9uLCBib25lLnNjYWxlKTtcbiAgICAgICAgYm9uZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgICAgfVxuICAgICAgYmluZEJvbmVzLnB1c2goYm9uZS5tYXRyaXhXb3JsZC5jbG9uZSgpKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBib25lcy5sZW5ndGg7ICsraSkge1xuICAgIGJvbmUgPSBib25lc1tpXTtcbiAgICBuYW1lID0gb3B0aW9ucy5uYW1lc1tib25lLm5hbWVdIHx8IGJvbmUubmFtZTtcbiAgICBib25lVG8gPSBnZXRCb25lQnlOYW1lKG5hbWUsIHNvdXJjZUJvbmVzKTtcbiAgICBnbG9iYWxNYXRyaXguY29weShib25lLm1hdHJpeFdvcmxkKTtcbiAgICBpZiAoYm9uZVRvKSB7XG4gICAgICBib25lVG8udXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICAgIGlmIChvcHRpb25zLnVzZVRhcmdldE1hdHJpeCkge1xuICAgICAgICByZWxhdGl2ZU1hdHJpeC5jb3B5KGJvbmVUby5tYXRyaXhXb3JsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWxhdGl2ZU1hdHJpeC5jb3B5KHRhcmdldC5tYXRyaXhXb3JsZCkuaW52ZXJ0KCk7XG4gICAgICAgIHJlbGF0aXZlTWF0cml4Lm11bHRpcGx5KGJvbmVUby5tYXRyaXhXb3JsZCk7XG4gICAgICB9XG4gICAgICBzY2FsZS5zZXRGcm9tTWF0cml4U2NhbGUocmVsYXRpdmVNYXRyaXgpO1xuICAgICAgcmVsYXRpdmVNYXRyaXguc2NhbGUoc2NhbGUuc2V0KDEgLyBzY2FsZS54LCAxIC8gc2NhbGUueSwgMSAvIHNjYWxlLnopKTtcbiAgICAgIGdsb2JhbE1hdHJpeC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbihxdWF0LnNldEZyb21Sb3RhdGlvbk1hdHJpeChyZWxhdGl2ZU1hdHJpeCkpO1xuICAgICAgaWYgKHRhcmdldC5pc09iamVjdDNEKSB7XG4gICAgICAgIGNvbnN0IGJvbmVJbmRleCA9IGJvbmVzLmluZGV4T2YoYm9uZSksIHdCaW5kTWF0cml4ID0gYmluZEJvbmVzID8gYmluZEJvbmVzW2JvbmVJbmRleF0gOiBiaW5kQm9uZU1hdHJpeC5jb3B5KHRhcmdldC5za2VsZXRvbi5ib25lSW52ZXJzZXNbYm9uZUluZGV4XSkuaW52ZXJ0KCk7XG4gICAgICAgIGdsb2JhbE1hdHJpeC5tdWx0aXBseSh3QmluZE1hdHJpeCk7XG4gICAgICB9XG4gICAgICBnbG9iYWxNYXRyaXguY29weVBvc2l0aW9uKHJlbGF0aXZlTWF0cml4KTtcbiAgICB9XG4gICAgaWYgKGJvbmUucGFyZW50ICYmIGJvbmUucGFyZW50LmlzQm9uZSkge1xuICAgICAgYm9uZS5tYXRyaXguY29weShib25lLnBhcmVudC5tYXRyaXhXb3JsZCkuaW52ZXJ0KCk7XG4gICAgICBib25lLm1hdHJpeC5tdWx0aXBseShnbG9iYWxNYXRyaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib25lLm1hdHJpeC5jb3B5KGdsb2JhbE1hdHJpeCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnByZXNlcnZlSGlwUG9zaXRpb24gJiYgbmFtZSA9PT0gb3B0aW9ucy5oaXApIHtcbiAgICAgIGJvbmUubWF0cml4LnNldFBvc2l0aW9uKHBvcy5zZXQoMCwgYm9uZS5wb3NpdGlvbi55LCAwKSk7XG4gICAgfVxuICAgIGJvbmUubWF0cml4LmRlY29tcG9zZShib25lLnBvc2l0aW9uLCBib25lLnF1YXRlcm5pb24sIGJvbmUuc2NhbGUpO1xuICAgIGJvbmUudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgfVxuICBpZiAob3B0aW9ucy5wcmVzZXJ2ZVBvc2l0aW9uKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib25lcy5sZW5ndGg7ICsraSkge1xuICAgICAgYm9uZSA9IGJvbmVzW2ldO1xuICAgICAgbmFtZSA9IG9wdGlvbnMubmFtZXNbYm9uZS5uYW1lXSB8fCBib25lLm5hbWU7XG4gICAgICBpZiAobmFtZSAhPT0gb3B0aW9ucy5oaXApIHtcbiAgICAgICAgYm9uZS5wb3NpdGlvbi5jb3B5KGJvbmVzUG9zaXRpb25baV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5wcmVzZXJ2ZU1hdHJpeCkge1xuICAgIHRhcmdldC51cGRhdGVNYXRyaXhXb3JsZCh0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gcmV0YXJnZXRDbGlwKHRhcmdldCwgc291cmNlLCBjbGlwLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucy51c2VGaXJzdEZyYW1lUG9zaXRpb24gPSBvcHRpb25zLnVzZUZpcnN0RnJhbWVQb3NpdGlvbiAhPT0gdm9pZCAwID8gb3B0aW9ucy51c2VGaXJzdEZyYW1lUG9zaXRpb24gOiBmYWxzZTtcbiAgb3B0aW9ucy5mcHMgPSBvcHRpb25zLmZwcyAhPT0gdm9pZCAwID8gb3B0aW9ucy5mcHMgOiAzMDtcbiAgb3B0aW9ucy5uYW1lcyA9IG9wdGlvbnMubmFtZXMgfHwgW107XG4gIGlmICghc291cmNlLmlzT2JqZWN0M0QpIHtcbiAgICBzb3VyY2UgPSBnZXRIZWxwZXJGcm9tU2tlbGV0b24oc291cmNlKTtcbiAgfVxuICBjb25zdCBudW1GcmFtZXMgPSBNYXRoLnJvdW5kKGNsaXAuZHVyYXRpb24gKiAob3B0aW9ucy5mcHMgLyAxZTMpICogMWUzKSwgZGVsdGEgPSAxIC8gb3B0aW9ucy5mcHMsIGNvbnZlcnRlZFRyYWNrcyA9IFtdLCBtaXhlciA9IG5ldyBBbmltYXRpb25NaXhlcihzb3VyY2UpLCBib25lcyA9IGdldEJvbmVzKHRhcmdldC5za2VsZXRvbiksIGJvbmVEYXRhcyA9IFtdO1xuICBsZXQgcG9zaXRpb25PZmZzZXQsIGJvbmUsIGJvbmVUbywgYm9uZURhdGEsIG5hbWU7XG4gIG1peGVyLmNsaXBBY3Rpb24oY2xpcCkucGxheSgpO1xuICBtaXhlci51cGRhdGUoMCk7XG4gIHNvdXJjZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUZyYW1lczsgKytpKSB7XG4gICAgY29uc3QgdGltZSA9IGkgKiBkZWx0YTtcbiAgICByZXRhcmdldCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBib25lcy5sZW5ndGg7ICsraikge1xuICAgICAgbmFtZSA9IG9wdGlvbnMubmFtZXNbYm9uZXNbal0ubmFtZV0gfHwgYm9uZXNbal0ubmFtZTtcbiAgICAgIGJvbmVUbyA9IGdldEJvbmVCeU5hbWUobmFtZSwgc291cmNlLnNrZWxldG9uKTtcbiAgICAgIGlmIChib25lVG8pIHtcbiAgICAgICAgYm9uZSA9IGJvbmVzW2pdO1xuICAgICAgICBib25lRGF0YSA9IGJvbmVEYXRhc1tqXSA9IGJvbmVEYXRhc1tqXSB8fCB7IGJvbmUgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaGlwID09PSBuYW1lKSB7XG4gICAgICAgICAgaWYgKCFib25lRGF0YS5wb3MpIHtcbiAgICAgICAgICAgIGJvbmVEYXRhLnBvcyA9IHtcbiAgICAgICAgICAgICAgdGltZXM6IG5ldyBGbG9hdDMyQXJyYXkobnVtRnJhbWVzKSxcbiAgICAgICAgICAgICAgdmFsdWVzOiBuZXcgRmxvYXQzMkFycmF5KG51bUZyYW1lcyAqIDMpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy51c2VGaXJzdEZyYW1lUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uT2Zmc2V0ID0gYm9uZS5wb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYm9uZS5wb3NpdGlvbi5zdWIocG9zaXRpb25PZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBib25lRGF0YS5wb3MudGltZXNbaV0gPSB0aW1lO1xuICAgICAgICAgIGJvbmUucG9zaXRpb24udG9BcnJheShib25lRGF0YS5wb3MudmFsdWVzLCBpICogMyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFib25lRGF0YS5xdWF0KSB7XG4gICAgICAgICAgYm9uZURhdGEucXVhdCA9IHtcbiAgICAgICAgICAgIHRpbWVzOiBuZXcgRmxvYXQzMkFycmF5KG51bUZyYW1lcyksXG4gICAgICAgICAgICB2YWx1ZXM6IG5ldyBGbG9hdDMyQXJyYXkobnVtRnJhbWVzICogNClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGJvbmVEYXRhLnF1YXQudGltZXNbaV0gPSB0aW1lO1xuICAgICAgICBib25lLnF1YXRlcm5pb24udG9BcnJheShib25lRGF0YS5xdWF0LnZhbHVlcywgaSAqIDQpO1xuICAgICAgfVxuICAgIH1cbiAgICBtaXhlci51cGRhdGUoZGVsdGEpO1xuICAgIHNvdXJjZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYm9uZURhdGFzLmxlbmd0aDsgKytpKSB7XG4gICAgYm9uZURhdGEgPSBib25lRGF0YXNbaV07XG4gICAgaWYgKGJvbmVEYXRhKSB7XG4gICAgICBpZiAoYm9uZURhdGEucG9zKSB7XG4gICAgICAgIGNvbnZlcnRlZFRyYWNrcy5wdXNoKFxuICAgICAgICAgIG5ldyBWZWN0b3JLZXlmcmFtZVRyYWNrKFxuICAgICAgICAgICAgXCIuYm9uZXNbXCIgKyBib25lRGF0YS5ib25lLm5hbWUgKyBcIl0ucG9zaXRpb25cIixcbiAgICAgICAgICAgIGJvbmVEYXRhLnBvcy50aW1lcyxcbiAgICAgICAgICAgIGJvbmVEYXRhLnBvcy52YWx1ZXNcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb252ZXJ0ZWRUcmFja3MucHVzaChcbiAgICAgICAgbmV3IFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrKFxuICAgICAgICAgIFwiLmJvbmVzW1wiICsgYm9uZURhdGEuYm9uZS5uYW1lICsgXCJdLnF1YXRlcm5pb25cIixcbiAgICAgICAgICBib25lRGF0YS5xdWF0LnRpbWVzLFxuICAgICAgICAgIGJvbmVEYXRhLnF1YXQudmFsdWVzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIG1peGVyLnVuY2FjaGVBY3Rpb24oY2xpcCk7XG4gIHJldHVybiBuZXcgQW5pbWF0aW9uQ2xpcChjbGlwLm5hbWUsIC0xLCBjb252ZXJ0ZWRUcmFja3MpO1xufVxuZnVuY3Rpb24gY2xvbmUoc291cmNlKSB7XG4gIGNvbnN0IHNvdXJjZUxvb2t1cCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGNsb25lTG9va3VwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgY2xvbmUyID0gc291cmNlLmNsb25lKCk7XG4gIHBhcmFsbGVsVHJhdmVyc2Uoc291cmNlLCBjbG9uZTIsIGZ1bmN0aW9uKHNvdXJjZU5vZGUsIGNsb25lZE5vZGUpIHtcbiAgICBzb3VyY2VMb29rdXAuc2V0KGNsb25lZE5vZGUsIHNvdXJjZU5vZGUpO1xuICAgIGNsb25lTG9va3VwLnNldChzb3VyY2VOb2RlLCBjbG9uZWROb2RlKTtcbiAgfSk7XG4gIGNsb25lMi50cmF2ZXJzZShmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmlzU2tpbm5lZE1lc2gpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY2xvbmVkTWVzaCA9IG5vZGU7XG4gICAgY29uc3Qgc291cmNlTWVzaCA9IHNvdXJjZUxvb2t1cC5nZXQobm9kZSk7XG4gICAgY29uc3Qgc291cmNlQm9uZXMgPSBzb3VyY2VNZXNoLnNrZWxldG9uLmJvbmVzO1xuICAgIGNsb25lZE1lc2guc2tlbGV0b24gPSBzb3VyY2VNZXNoLnNrZWxldG9uLmNsb25lKCk7XG4gICAgY2xvbmVkTWVzaC5iaW5kTWF0cml4LmNvcHkoc291cmNlTWVzaC5iaW5kTWF0cml4KTtcbiAgICBjbG9uZWRNZXNoLnNrZWxldG9uLmJvbmVzID0gc291cmNlQm9uZXMubWFwKGZ1bmN0aW9uKGJvbmUpIHtcbiAgICAgIHJldHVybiBjbG9uZUxvb2t1cC5nZXQoYm9uZSk7XG4gICAgfSk7XG4gICAgY2xvbmVkTWVzaC5iaW5kKGNsb25lZE1lc2guc2tlbGV0b24sIGNsb25lZE1lc2guYmluZE1hdHJpeCk7XG4gIH0pO1xuICByZXR1cm4gY2xvbmUyO1xufVxuZnVuY3Rpb24gZ2V0Qm9uZUJ5TmFtZShuYW1lLCBza2VsZXRvbikge1xuICBmb3IgKGxldCBpID0gMCwgYm9uZXMgPSBnZXRCb25lcyhza2VsZXRvbik7IGkgPCBib25lcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChuYW1lID09PSBib25lc1tpXS5uYW1lKVxuICAgICAgcmV0dXJuIGJvbmVzW2ldO1xuICB9XG59XG5mdW5jdGlvbiBnZXRCb25lcyhza2VsZXRvbikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShza2VsZXRvbikgPyBza2VsZXRvbiA6IHNrZWxldG9uLmJvbmVzO1xufVxuZnVuY3Rpb24gZ2V0SGVscGVyRnJvbVNrZWxldG9uKHNrZWxldG9uKSB7XG4gIGNvbnN0IHNvdXJjZSA9IG5ldyBTa2VsZXRvbkhlbHBlcihza2VsZXRvbi5ib25lc1swXSk7XG4gIHNvdXJjZS5za2VsZXRvbiA9IHNrZWxldG9uO1xuICByZXR1cm4gc291cmNlO1xufVxuZnVuY3Rpb24gcGFyYWxsZWxUcmF2ZXJzZShhLCBiLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayhhLCBiKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFyYWxsZWxUcmF2ZXJzZShhLmNoaWxkcmVuW2ldLCBiLmNoaWxkcmVuW2ldLCBjYWxsYmFjayk7XG4gIH1cbn1cbmNvbnN0IFNrZWxldG9uVXRpbHMgPSB7IHJldGFyZ2V0LCByZXRhcmdldENsaXAsIGNsb25lIH07XG5leHBvcnQge1xuICBTa2VsZXRvblV0aWxzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2tlbGV0b25VdGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/utils/SkeletonUtils.js\n");

/***/ })

};
;