/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-mesh-bvh";
exports.ids = ["vendor-chunks/three-mesh-bvh"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-mesh-bvh/build/index.umd.cjs":
/*!*********************************************************!*\
  !*** ./node_modules/three-mesh-bvh/build/index.umd.cjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n\t true ? factory(exports, __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\")) :\n\t0;\n})(this, (function (exports, THREE) { 'use strict';\n\n\tfunction _interopNamespaceDefault(e) {\n\t\tvar n = Object.create(null);\n\t\tif (e) {\n\t\t\tObject.keys(e).forEach(function (k) {\n\t\t\t\tif (k !== 'default') {\n\t\t\t\t\tvar d = Object.getOwnPropertyDescriptor(e, k);\n\t\t\t\t\tObject.defineProperty(n, k, d.get ? d : {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tget: function () { return e[k]; }\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tn.default = e;\n\t\treturn Object.freeze(n);\n\t}\n\n\tvar THREE__namespace = /*#__PURE__*/_interopNamespaceDefault(THREE);\n\n\t// Split strategy constants\n\tconst CENTER = 0;\n\tconst AVERAGE = 1;\n\tconst SAH = 2;\n\n\t// Traversal constants\n\tconst NOT_INTERSECTED = 0;\n\tconst INTERSECTED = 1;\n\tconst CONTAINED = 2;\n\n\t// SAH cost constants\n\t// TODO: hone these costs more. The relative difference between them should be the\n\t// difference in measured time to perform a triangle intersection vs traversing\n\t// bounds.\n\tconst TRIANGLE_INTERSECT_COST = 1.25;\n\tconst TRAVERSAL_COST = 1;\n\n\n\t// Build constants\n\tconst BYTES_PER_NODE = 6 * 4 + 4 + 4;\n\tconst IS_LEAFNODE_FLAG = 0xFFFF;\n\n\t// EPSILON for computing floating point error during build\n\t// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\n\tconst FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\n\tconst SKIP_GENERATION = Symbol( 'SKIP_GENERATION' );\n\n\tfunction getVertexCount( geo ) {\n\n\t\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n\t}\n\n\tfunction getTriCount( geo ) {\n\n\t\treturn getVertexCount( geo ) / 3;\n\n\t}\n\n\tfunction getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\t\tif ( vertexCount > 65535 ) {\n\n\t\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t\t} else {\n\n\t\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t\t}\n\n\t}\n\n\t// ensures that an index is present on the geometry\n\tfunction ensureIndex( geo, options ) {\n\n\t\tif ( ! geo.index ) {\n\n\t\t\tconst vertexCount = geo.attributes.position.count;\n\t\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\t\tgeo.setIndex( new THREE.BufferAttribute( index, 1 ) );\n\n\t\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\t\tindex[ i ] = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n\t// region in the geometry index that belongs to a different set of material groups requires\n\t// a separate BVH root, so that triangles indices belonging to one group never get swapped\n\t// with triangle indices belongs to another group. For example, if the groups were like this:\n\t//\n\t// [-------------------------------------------------------------]\n\t// |__________________|\n\t//   g0 = [0, 20]  |______________________||_____________________|\n\t//                      g1 = [16, 40]           g2 = [41, 60]\n\t//\n\t// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\n\tfunction getFullGeometryRange( geo, range ) {\n\n\t\tconst triCount = getTriCount( geo );\n\t\tconst drawRange = range ? range : geo.drawRange;\n\t\tconst start = drawRange.start / 3;\n\t\tconst end = ( drawRange.start + drawRange.count ) / 3;\n\n\t\tconst offset = Math.max( 0, start );\n\t\tconst count = Math.min( triCount, end ) - offset;\n\t\treturn [ {\n\t\t\toffset: Math.floor( offset ),\n\t\t\tcount: Math.floor( count ),\n\t\t} ];\n\n\t}\n\n\tfunction getRootIndexRanges( geo, range ) {\n\n\t\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\t\treturn getFullGeometryRange( geo, range );\n\n\t\t}\n\n\t\tconst ranges = [];\n\t\tconst rangeBoundaries = new Set();\n\n\t\tconst drawRange = range ? range : geo.drawRange;\n\t\tconst drawRangeStart = drawRange.start / 3;\n\t\tconst drawRangeEnd = ( drawRange.start + drawRange.count ) / 3;\n\t\tfor ( const group of geo.groups ) {\n\n\t\t\tconst groupStart = group.start / 3;\n\t\t\tconst groupEnd = ( group.start + group.count ) / 3;\n\t\t\trangeBoundaries.add( Math.max( drawRangeStart, groupStart ) );\n\t\t\trangeBoundaries.add( Math.min( drawRangeEnd, groupEnd ) );\n\n\t\t}\n\n\n\t\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\t\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\t\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\t\tconst start = sortedBoundaries[ i ];\n\t\t\tconst end = sortedBoundaries[ i + 1 ];\n\n\t\t\tranges.push( {\n\t\t\t\toffset: Math.floor( start ),\n\t\t\t\tcount: Math.floor( end - start ),\n\t\t\t} );\n\n\t\t}\n\n\t\treturn ranges;\n\n\t}\n\n\tfunction hasGroupGaps( geometry, range ) {\n\n\t\tconst vertexCount = getTriCount( geometry );\n\t\tconst groups = getRootIndexRanges( geometry, range )\n\t\t\t.sort( ( a, b ) => a.offset - b.offset );\n\n\t\tconst finalGroup = groups[ groups.length - 1 ];\n\t\tfinalGroup.count = Math.min( vertexCount - finalGroup.offset, finalGroup.count );\n\n\t\tlet total = 0;\n\t\tgroups.forEach( ( { count } ) => total += count );\n\t\treturn vertexCount !== total;\n\n\t}\n\n\t// computes the union of the bounds of all of the given triangles and puts the resulting box in \"target\".\n\t// A bounding box is computed for the centroids of the triangles, as well, and placed in \"centroidTarget\".\n\t// These are computed together to avoid redundant accesses to bounds array.\n\tfunction getBounds( triangleBounds, offset, count, target, centroidTarget ) {\n\n\t\tlet minx = Infinity;\n\t\tlet miny = Infinity;\n\t\tlet minz = Infinity;\n\t\tlet maxx = - Infinity;\n\t\tlet maxy = - Infinity;\n\t\tlet maxz = - Infinity;\n\n\t\tlet cminx = Infinity;\n\t\tlet cminy = Infinity;\n\t\tlet cminz = Infinity;\n\t\tlet cmaxx = - Infinity;\n\t\tlet cmaxy = - Infinity;\n\t\tlet cmaxz = - Infinity;\n\n\t\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\t\tconst cx = triangleBounds[ i + 0 ];\n\t\t\tconst hx = triangleBounds[ i + 1 ];\n\t\t\tconst lx = cx - hx;\n\t\t\tconst rx = cx + hx;\n\t\t\tif ( lx < minx ) minx = lx;\n\t\t\tif ( rx > maxx ) maxx = rx;\n\t\t\tif ( cx < cminx ) cminx = cx;\n\t\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\t\tconst cy = triangleBounds[ i + 2 ];\n\t\t\tconst hy = triangleBounds[ i + 3 ];\n\t\t\tconst ly = cy - hy;\n\t\t\tconst ry = cy + hy;\n\t\t\tif ( ly < miny ) miny = ly;\n\t\t\tif ( ry > maxy ) maxy = ry;\n\t\t\tif ( cy < cminy ) cminy = cy;\n\t\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\t\tconst cz = triangleBounds[ i + 4 ];\n\t\t\tconst hz = triangleBounds[ i + 5 ];\n\t\t\tconst lz = cz - hz;\n\t\t\tconst rz = cz + hz;\n\t\t\tif ( lz < minz ) minz = lz;\n\t\t\tif ( rz > maxz ) maxz = rz;\n\t\t\tif ( cz < cminz ) cminz = cz;\n\t\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t\t}\n\n\t\ttarget[ 0 ] = minx;\n\t\ttarget[ 1 ] = miny;\n\t\ttarget[ 2 ] = minz;\n\n\t\ttarget[ 3 ] = maxx;\n\t\ttarget[ 4 ] = maxy;\n\t\ttarget[ 5 ] = maxz;\n\n\t\tcentroidTarget[ 0 ] = cminx;\n\t\tcentroidTarget[ 1 ] = cminy;\n\t\tcentroidTarget[ 2 ] = cminz;\n\n\t\tcentroidTarget[ 3 ] = cmaxx;\n\t\tcentroidTarget[ 4 ] = cmaxy;\n\t\tcentroidTarget[ 5 ] = cmaxz;\n\n\t}\n\n\t// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n\t// result is an array of size tris.length * 6 where triangle i maps to a\n\t// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n\t// representing the center and half-extent in each dimension of triangle i\n\tfunction computeTriangleBounds( geo, target = null, offset = null, count = null ) {\n\n\t\tconst posAttr = geo.attributes.position;\n\t\tconst index = geo.index ? geo.index.array : null;\n\t\tconst triCount = getTriCount( geo );\n\t\tconst normalized = posAttr.normalized;\n\t\tlet triangleBounds;\n\t\tif ( target === null ) {\n\n\t\t\ttriangleBounds = new Float32Array( triCount * 6 * 4 );\n\t\t\toffset = 0;\n\t\t\tcount = triCount;\n\n\t\t} else {\n\n\t\t\ttriangleBounds = target;\n\t\t\toffset = offset || 0;\n\t\t\tcount = count || triCount;\n\n\t\t}\n\n\t\t// used for non-normalized positions\n\t\tconst posArr = posAttr.array;\n\n\t\t// support for an interleaved position buffer\n\t\tconst bufferOffset = posAttr.offset || 0;\n\t\tlet stride = 3;\n\t\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\t\tstride = posAttr.data.stride;\n\n\t\t}\n\n\t\t// used for normalized positions\n\t\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\t\tfor ( let tri = offset; tri < offset + count; tri ++ ) {\n\n\t\t\tconst tri3 = tri * 3;\n\t\t\tconst tri6 = tri * 6;\n\n\t\t\tlet ai = tri3 + 0;\n\t\t\tlet bi = tri3 + 1;\n\t\t\tlet ci = tri3 + 2;\n\n\t\t\tif ( index ) {\n\n\t\t\t\tai = index[ ai ];\n\t\t\t\tbi = index[ bi ];\n\t\t\t\tci = index[ ci ];\n\n\t\t\t}\n\n\t\t\t// we add the stride and offset here since we access the array directly\n\t\t\t// below for the sake of performance\n\t\t\tif ( ! normalized ) {\n\n\t\t\t\tai = ai * stride + bufferOffset;\n\t\t\t\tbi = bi * stride + bufferOffset;\n\t\t\t\tci = ci * stride + bufferOffset;\n\n\t\t\t}\n\n\t\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\t\tlet a, b, c;\n\n\t\t\t\tif ( normalized ) {\n\n\t\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t\t}\n\n\t\t\t\tlet min = a;\n\t\t\t\tif ( b < min ) min = b;\n\t\t\t\tif ( c < min ) min = c;\n\n\t\t\t\tlet max = a;\n\t\t\t\tif ( b > max ) max = b;\n\t\t\t\tif ( c > max ) max = c;\n\n\t\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t\t// worked with.\n\t\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\t\tconst el2 = el * 2;\n\t\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn triangleBounds;\n\n\t}\n\n\tfunction arrayToBox( nodeIndex32, array, target ) {\n\n\t\ttarget.min.x = array[ nodeIndex32 ];\n\t\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\t\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\t\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\t\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\t\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\t\treturn target;\n\n\t}\n\n\tfunction makeEmptyBounds( target ) {\n\n\t\ttarget[ 0 ] = target[ 1 ] = target[ 2 ] = Infinity;\n\t\ttarget[ 3 ] = target[ 4 ] = target[ 5 ] = - Infinity;\n\n\t}\n\n\tfunction getLongestEdgeIndex( bounds ) {\n\n\t\tlet splitDimIdx = - 1;\n\t\tlet splitDist = - Infinity;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\t\tif ( dist > splitDist ) {\n\n\t\t\t\tsplitDist = dist;\n\t\t\t\tsplitDimIdx = i;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn splitDimIdx;\n\n\t}\n\n\t// copies bounds a into bounds b\n\tfunction copyBounds( source, target ) {\n\n\t\ttarget.set( source );\n\n\t}\n\n\t// sets bounds target to the union of bounds a and b\n\tfunction unionBounds( a, b, target ) {\n\n\t\tlet aVal, bVal;\n\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\tconst d3 = d + 3;\n\n\t\t\t// set the minimum values\n\t\t\taVal = a[ d ];\n\t\t\tbVal = b[ d ];\n\t\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t\t// set the max values\n\t\t\taVal = a[ d3 ];\n\t\t\tbVal = b[ d3 ];\n\t\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t\t}\n\n\t}\n\n\t// expands the given bounds by the provided triangle bounds\n\tfunction expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\t\tconst tMin = tCenter - tHalf;\n\t\t\tconst tMax = tCenter + tHalf;\n\n\t\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\t\tbounds[ d ] = tMin;\n\n\t\t\t}\n\n\t\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// compute bounds surface area\n\tfunction computeSurfaceArea( bounds ) {\n\n\t\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\t\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\t\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\t\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n\t}\n\n\tconst BIN_COUNT = 32;\n\tconst binsSort = ( a, b ) => a.candidate - b.candidate;\n\tconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\t\treturn {\n\n\t\t\tcount: 0,\n\t\t\tbounds: new Float32Array( 6 ),\n\t\t\trightCacheBounds: new Float32Array( 6 ),\n\t\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\t\tcandidate: 0,\n\n\t\t};\n\n\t} );\n\tconst leftBounds = new Float32Array( 6 );\n\n\tfunction getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\t\tlet axis = - 1;\n\t\tlet pos = 0;\n\n\t\t// Center\n\t\tif ( strategy === CENTER ) {\n\n\t\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\t\tif ( axis !== - 1 ) {\n\n\t\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t\t}\n\n\t\t} else if ( strategy === AVERAGE ) {\n\n\t\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\t\tif ( axis !== - 1 ) {\n\n\t\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t\t}\n\n\t\t} else if ( strategy === SAH ) {\n\n\t\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t\t// iterate over all axes\n\t\t\tconst cStart = offset * 6;\n\t\t\tconst cEnd = ( offset + count ) * 6;\n\t\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t\t// the triangle positions because it will be faster.\n\t\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t\t// initialize the bin candidates\n\t\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t\t// set the candidates\n\t\t\t\t\tlet b = 0;\n\t\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\tbounds,\n\t\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t\t} = bin;\n\t\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t\t// remove redundant splits\n\t\t\t\t\tlet splitCount = count;\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// expand all the bounds\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t\t// check the cost of this split\n\t\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// reset the bins\n\t\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\t\tbin.count = 0;\n\t\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// iterate over all center positions\n\t\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet leftCount = 0;\n\t\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t\t// check the cost of this split\n\t\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t\t}\n\n\t\treturn { axis, pos };\n\n\t}\n\n\t// returns the average coordinate on the specified axis of the all the provided triangles\n\tfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\t\tlet avg = 0;\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t\t}\n\n\t\treturn avg / count;\n\n\t}\n\n\tclass MeshBVHNode {\n\n\t\tconstructor() {\n\n\t\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t\t\tthis.boundingData = new Float32Array( 6 );\n\n\t\t}\n\n\t}\n\n\t/********************************************************/\n\t/* This file is generated from \"sortUtils.template.js\". */\n\t/********************************************************/\n\t// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n\t// will be on the left and elements on the right side of the split will be on the right. returns the index\n\t// of the first element on the right side, or offset + count if there are no elements on the right side.\n\tfunction partition( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\t\tlet left = offset;\n\t\tlet right = offset + count - 1;\n\t\tconst pos = split.pos;\n\t\tconst axisOffset = split.axis * 2;\n\n\t\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\t\twhile ( true ) {\n\n\t\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\t\tleft ++;\n\n\t\t\t}\n\n\t\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\t\tright --;\n\n\t\t\t}\n\n\t\t\tif ( left < right ) {\n\n\t\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t\t// and perhaps the SAH planes\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t\t}\n\n\n\t\t\t\t// swap bounds\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t\t}\n\n\t\t\t\tleft ++;\n\t\t\t\tright --;\n\n\t\t\t} else {\n\n\t\t\t\treturn left;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/********************************************************/\n\t/* This file is generated from \"sortUtils.template.js\". */\n\t/********************************************************/\n\t// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n\t// will be on the left and elements on the right side of the split will be on the right. returns the index\n\t// of the first element on the right side, or offset + count if there are no elements on the right side.\n\tfunction partition_indirect( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\t\tlet left = offset;\n\t\tlet right = offset + count - 1;\n\t\tconst pos = split.pos;\n\t\tconst axisOffset = split.axis * 2;\n\n\t\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\t\twhile ( true ) {\n\n\t\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\t\tleft ++;\n\n\t\t\t}\n\n\t\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\t\tright --;\n\n\t\t\t}\n\n\t\t\tif ( left < right ) {\n\n\t\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t\t// and perhaps the SAH planes\n\t\t\t\tlet t = indirectBuffer[ left ];\n\t\t\t\tindirectBuffer[ left ] = indirectBuffer[ right ];\n\t\t\t\tindirectBuffer[ right ] = t;\n\n\n\t\t\t\t// swap bounds\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t\t}\n\n\t\t\t\tleft ++;\n\t\t\t\tright --;\n\n\t\t\t} else {\n\n\t\t\t\treturn left;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction IS_LEAF( n16, uint16Array ) {\n\n\t\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n\t}\n\n\tfunction OFFSET( n32, uint32Array ) {\n\n\t\treturn uint32Array[ n32 + 6 ];\n\n\t}\n\n\tfunction COUNT( n16, uint16Array ) {\n\n\t\treturn uint16Array[ n16 + 14 ];\n\n\t}\n\n\tfunction LEFT_NODE( n32 ) {\n\n\t\treturn n32 + 8;\n\n\t}\n\n\tfunction RIGHT_NODE( n32, uint32Array ) {\n\n\t\treturn uint32Array[ n32 + 6 ];\n\n\t}\n\n\tfunction SPLIT_AXIS( n32, uint32Array ) {\n\n\t\treturn uint32Array[ n32 + 7 ];\n\n\t}\n\n\tfunction BOUNDING_DATA_INDEX( n32 ) {\n\n\t\treturn n32;\n\n\t}\n\n\tlet float32Array, uint32Array, uint16Array, uint8Array;\n\tconst MAX_POINTER = Math.pow( 2, 32 );\n\n\tfunction countNodes( node ) {\n\n\t\tif ( 'count' in node ) {\n\n\t\t\treturn 1;\n\n\t\t} else {\n\n\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t\t}\n\n\t}\n\n\tfunction populateBuffer( byteOffset, node, buffer ) {\n\n\t\tfloat32Array = new Float32Array( buffer );\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tuint8Array = new Uint8Array( buffer );\n\n\t\treturn _populateBuffer( byteOffset, node );\n\n\t}\n\n\t// pack structure\n\t// boundingData  \t\t\t\t: 6 float32\n\t// right / offset \t\t\t\t: 1 uint32\n\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n\tfunction _populateBuffer( byteOffset, node ) {\n\n\t\tconst stride4Offset = byteOffset / 4;\n\t\tconst stride2Offset = byteOffset / 2;\n\t\tconst isLeaf = 'count' in node;\n\t\tconst boundingData = node.boundingData;\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t\t}\n\n\t\tif ( isLeaf ) {\n\n\t\t\tif ( node.buffer ) {\n\n\t\t\t\tconst buffer = node.buffer;\n\t\t\t\tuint8Array.set( new Uint8Array( buffer ), byteOffset );\n\n\t\t\t\tfor ( let offset = byteOffset, l = byteOffset + buffer.byteLength; offset < l; offset += BYTES_PER_NODE ) {\n\n\t\t\t\t\tconst offset2 = offset / 2;\n\t\t\t\t\tif ( ! IS_LEAF( offset2, uint16Array ) ) {\n\n\t\t\t\t\t\tuint32Array[ ( offset / 4 ) + 6 ] += stride4Offset;\n\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn byteOffset + buffer.byteLength;\n\n\t\t\t} else {\n\n\t\t\t\tconst offset = node.offset;\n\t\t\t\tconst count = node.count;\n\t\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node.left;\n\t\t\tconst right = node.right;\n\t\t\tconst splitAxis = node.splitAxis;\n\n\t\t\tlet nextUnusedPointer;\n\t\t\tnextUnusedPointer = _populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\t\tif ( ( nextUnusedPointer / 4 ) > MAX_POINTER ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t\t}\n\n\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\t\tnextUnusedPointer = _populateBuffer( nextUnusedPointer, right );\n\n\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\t\treturn nextUnusedPointer;\n\n\t\t}\n\n\t}\n\n\tfunction generateIndirectBuffer( geometry, useSharedArrayBuffer ) {\n\n\t\tconst triCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tconst useUint32 = triCount > 2 ** 16;\n\t\tconst byteCount = useUint32 ? 4 : 2;\n\n\t\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( triCount * byteCount ) : new ArrayBuffer( triCount * byteCount );\n\t\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\n\t\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\t\tindirectBuffer[ i ] = i;\n\n\t\t}\n\n\t\treturn indirectBuffer;\n\n\t}\n\n\tfunction buildTree( bvh, triangleBounds, offset, count, options ) {\n\n\t\t// epxand variables\n\t\tconst {\n\t\t\tmaxDepth,\n\t\t\tverbose,\n\t\t\tmaxLeafTris,\n\t\t\tstrategy,\n\t\t\tonProgress,\n\t\t\tindirect,\n\t\t} = options;\n\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\tconst geometry = bvh.geometry;\n\t\tconst indexArray = geometry.index ? geometry.index.array : null;\n\t\tconst partionFunc = indirect ? partition_indirect : partition;\n\n\t\t// generate intermediate variables\n\t\tconst totalTriangles = getTriCount( geometry );\n\t\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\t\tlet reachedMaxDepth = false;\n\n\t\tconst root = new MeshBVHNode();\n\t\tgetBounds( triangleBounds, offset, count, root.boundingData, cacheCentroidBoundingData );\n\t\tsplitNode( root, offset, count, cacheCentroidBoundingData );\n\t\treturn root;\n\n\t\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\t\tif ( onProgress ) {\n\n\t\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\t\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\t\treachedMaxDepth = true;\n\t\t\t\tif ( verbose ) {\n\n\t\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\t\tconsole.warn( geometry );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// early out if we've met our capacity\n\t\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\t\ttriggerProgress( offset + count );\n\t\t\t\tnode.offset = offset;\n\t\t\t\tnode.count = count;\n\t\t\t\treturn node;\n\n\t\t\t}\n\n\t\t\t// Find where to split the volume\n\t\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\t\tif ( split.axis === - 1 ) {\n\n\t\t\t\ttriggerProgress( offset + count );\n\t\t\t\tnode.offset = offset;\n\t\t\t\tnode.count = count;\n\t\t\t\treturn node;\n\n\t\t\t}\n\n\t\t\tconst splitOffset = partionFunc( indirectBuffer, indexArray, triangleBounds, offset, count, split );\n\n\t\t\t// create the two new child nodes\n\t\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\t\ttriggerProgress( offset + count );\n\t\t\t\tnode.offset = offset;\n\t\t\t\tnode.count = count;\n\n\t\t\t} else {\n\n\t\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t\t// create the left child and compute its bounding box\n\t\t\t\tconst left = new MeshBVHNode();\n\t\t\t\tconst lstart = offset;\n\t\t\t\tconst lcount = splitOffset - offset;\n\t\t\t\tnode.left = left;\n\n\t\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t\t// repeat for right\n\t\t\t\tconst right = new MeshBVHNode();\n\t\t\t\tconst rstart = splitOffset;\n\t\t\t\tconst rcount = count - lcount;\n\t\t\t\tnode.right = right;\n\n\t\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t}\n\n\t}\n\n\tfunction buildPackedTree( bvh, options ) {\n\n\t\tconst geometry = bvh.geometry;\n\t\tif ( options.indirect ) {\n\n\t\t\tbvh._indirectBuffer = generateIndirectBuffer( geometry, options.useSharedArrayBuffer );\n\n\t\t\tif ( hasGroupGaps( geometry, options.range ) && ! options.verbose ) {\n\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the \"indirect\" option. ' +\n\t\t\t\t\t'BVH may incorrectly report intersections on unrendered portions of the geometry.'\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ! bvh._indirectBuffer ) {\n\n\t\t\tensureIndex( geometry, options );\n\n\t\t}\n\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\n\t\tconst triangleBounds = computeTriangleBounds( geometry );\n\t\tconst geometryRanges = options.indirect ? getFullGeometryRange( geometry, options.range ) : getRootIndexRanges( geometry, options.range );\n\t\tbvh._roots = geometryRanges.map( range => {\n\n\t\t\tconst root = buildTree( bvh, triangleBounds, range.offset, range.count, options );\n\t\t\tconst nodeCount = countNodes( root );\n\t\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\t\tpopulateBuffer( 0, root, buffer );\n\t\t\treturn buffer;\n\n\t\t} );\n\n\t}\n\n\tclass SeparatingAxisBounds {\n\n\t\tconstructor() {\n\n\t\t\tthis.min = Infinity;\n\t\t\tthis.max = - Infinity;\n\n\t\t}\n\n\t\tsetFromPointsField( points, field ) {\n\n\t\t\tlet min = Infinity;\n\t\t\tlet max = - Infinity;\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\t\t\t\tconst val = p[ field ];\n\t\t\t\tmin = val < min ? val : min;\n\t\t\t\tmax = val > max ? val : max;\n\n\t\t\t}\n\n\t\t\tthis.min = min;\n\t\t\tthis.max = max;\n\n\t\t}\n\n\t\tsetFromPoints( axis, points ) {\n\n\t\t\tlet min = Infinity;\n\t\t\tlet max = - Infinity;\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\t\t\t\tconst val = axis.dot( p );\n\t\t\t\tmin = val < min ? val : min;\n\t\t\t\tmax = val > max ? val : max;\n\n\t\t\t}\n\n\t\t\tthis.min = min;\n\t\t\tthis.max = max;\n\n\t\t}\n\n\t\tisSeparated( other ) {\n\n\t\t\treturn this.min > other.max || other.min > this.max;\n\n\t\t}\n\n\t}\n\n\tSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\t\tconst p = new THREE.Vector3();\n\t\treturn function setFromBox( axis, box ) {\n\n\t\t\tconst boxMin = box.min;\n\t\t\tconst boxMax = box.max;\n\t\t\tlet min = Infinity;\n\t\t\tlet max = - Infinity;\n\t\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.min = min;\n\t\t\tthis.max = max;\n\n\t\t};\n\n\t} )();\n\n\tconst areIntersecting = ( function () {\n\n\t\tconst cacheSatBounds = new SeparatingAxisBounds();\n\t\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\t\tconst points1 = shape1.points;\n\t\t\tconst satAxes1 = shape1.satAxes;\n\t\t\tconst satBounds1 = shape1.satBounds;\n\n\t\t\tconst points2 = shape2.points;\n\t\t\tconst satAxes2 = shape2.satAxes;\n\t\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t\t// check axes of the first shape\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check axes of the second shape\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t};\n\n\t} )();\n\n\tconst closestPointLineToLine = ( function () {\n\n\t\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\t\tconst dir1 = new THREE.Vector3();\n\t\tconst dir2 = new THREE.Vector3();\n\t\tconst v02 = new THREE.Vector3();\n\t\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\t\tconst v0 = l1.start;\n\t\t\tconst v10 = dir1;\n\t\t\tconst v2 = l2.start;\n\t\t\tconst v32 = dir2;\n\n\t\t\tv02.subVectors( v0, v2 );\n\t\t\tdir1.subVectors( l1.end, l1.start );\n\t\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t\t// float d0232 = v02.Dot(v32);\n\t\t\tconst d0232 = v02.dot( v32 );\n\n\t\t\t// float d3210 = v32.Dot(v10);\n\t\t\tconst d3210 = v32.dot( v10 );\n\n\t\t\t// float d3232 = v32.Dot(v32);\n\t\t\tconst d3232 = v32.dot( v32 );\n\n\t\t\t// float d0210 = v02.Dot(v10);\n\t\t\tconst d0210 = v02.dot( v10 );\n\n\t\t\t// float d1010 = v10.Dot(v10);\n\t\t\tconst d1010 = v10.dot( v10 );\n\n\t\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\t\tlet d, d2;\n\t\t\tif ( denom !== 0 ) {\n\n\t\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t\t} else {\n\n\t\t\t\td = 0;\n\n\t\t\t}\n\n\t\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\t\tresult.x = d;\n\t\t\tresult.y = d2;\n\n\t\t};\n\n\t} )();\n\n\tconst closestPointsSegmentToSegment = ( function () {\n\n\t\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\t\tconst paramResult = new THREE.Vector2();\n\t\tconst temp1 = new THREE.Vector3();\n\t\tconst temp2 = new THREE.Vector3();\n\t\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\t\tlet d = paramResult.x;\n\t\t\tlet d2 = paramResult.y;\n\t\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t\tl1.at( d, target1 );\n\t\t\t\tl2.at( d2, target2 );\n\n\t\t\t\treturn;\n\n\t\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t\t// Only d2 is out of bounds.\n\t\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t\t}\n\n\t\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\t\treturn;\n\n\t\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t\t// Only d is out of bounds.\n\t\t\t\tif ( d < 0 ) {\n\n\t\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t\t}\n\n\t\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\t// Both u and u2 are out of bounds.\n\t\t\t\tlet p;\n\t\t\t\tif ( d < 0 ) {\n\n\t\t\t\t\tp = l1.start;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp = l1.end;\n\n\t\t\t\t}\n\n\t\t\t\tlet p2;\n\t\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\t\tp2 = l2.start;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tp2 = l2.end;\n\n\t\t\t\t}\n\n\t\t\t\tconst closestPoint = temp1;\n\t\t\t\tconst closestPoint2 = temp2;\n\t\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\t\ttarget2.copy( p2 );\n\t\t\t\t\treturn;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget1.copy( p );\n\t\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t} )();\n\n\n\tconst sphereIntersectTriangle = ( function () {\n\n\t\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\t\tconst closestPointTemp = new THREE.Vector3();\n\t\tconst projectedPointTemp = new THREE.Vector3();\n\t\tconst planeTemp = new THREE.Plane();\n\t\tconst lineTemp = new THREE.Line3();\n\t\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\t\tconst { radius, center } = sphere;\n\t\t\tconst { a, b, c } = triangle;\n\n\t\t\t// phase 1\n\t\t\tlineTemp.start = a;\n\t\t\tlineTemp.end = b;\n\t\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\t\tlineTemp.start = a;\n\t\t\tlineTemp.end = c;\n\t\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\t\tlineTemp.start = b;\n\t\t\tlineTemp.end = c;\n\t\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t\t// phase 2\n\t\t\tconst plane = triangle.getPlane( planeTemp );\n\t\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\t\tif ( dp <= radius ) {\n\n\t\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\t\tif ( cp ) return true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t};\n\n\t} )();\n\n\tconst ZERO_EPSILON = 1e-15;\n\tfunction isNearZero( value ) {\n\n\t\treturn Math.abs( value ) < ZERO_EPSILON;\n\n\t}\n\n\tclass ExtendedTriangle extends THREE.Triangle {\n\n\t\tconstructor( ...args ) {\n\n\t\t\tsuper( ...args );\n\n\t\t\tthis.isExtendedTriangle = true;\n\t\t\tthis.satAxes = new Array( 4 ).fill().map( () => new THREE.Vector3() );\n\t\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\t\tthis.points = [ this.a, this.b, this.c ];\n\t\t\tthis.sphere = new THREE.Sphere();\n\t\t\tthis.plane = new THREE.Plane();\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tintersectsSphere( sphere ) {\n\n\t\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t\t}\n\n\t\tupdate() {\n\n\t\t\tconst a = this.a;\n\t\t\tconst b = this.b;\n\t\t\tconst c = this.c;\n\t\t\tconst points = this.points;\n\n\t\t\tconst satAxes = this.satAxes;\n\t\t\tconst satBounds = this.satBounds;\n\n\t\t\tconst axis0 = satAxes[ 0 ];\n\t\t\tconst sab0 = satBounds[ 0 ];\n\t\t\tthis.getNormal( axis0 );\n\t\t\tsab0.setFromPoints( axis0, points );\n\n\t\t\tconst axis1 = satAxes[ 1 ];\n\t\t\tconst sab1 = satBounds[ 1 ];\n\t\t\taxis1.subVectors( a, b );\n\t\t\tsab1.setFromPoints( axis1, points );\n\n\t\t\tconst axis2 = satAxes[ 2 ];\n\t\t\tconst sab2 = satBounds[ 2 ];\n\t\t\taxis2.subVectors( b, c );\n\t\t\tsab2.setFromPoints( axis2, points );\n\n\t\t\tconst axis3 = satAxes[ 3 ];\n\t\t\tconst sab3 = satBounds[ 3 ];\n\t\t\taxis3.subVectors( c, a );\n\t\t\tsab3.setFromPoints( axis3, points );\n\n\t\t\tthis.sphere.setFromPoints( this.points );\n\t\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\t\t\tthis.needsUpdate = false;\n\n\t\t}\n\n\t}\n\n\tExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\t\tconst point1 = new THREE.Vector3();\n\t\tconst point2 = new THREE.Vector3();\n\t\tconst edge = new THREE.Line3();\n\n\t\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\t\tconst { start, end } = segment;\n\t\t\tconst points = this.points;\n\t\t\tlet distSq;\n\t\t\tlet closestDistanceSq = Infinity;\n\n\t\t\t// check the triangle edges\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\t\tedge.start.copy( points[ i ] );\n\t\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// check end points\n\t\t\tthis.closestPointToPoint( start, point1 );\n\t\t\tdistSq = start.distanceToSquared( point1 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t\t}\n\n\t\t\tthis.closestPointToPoint( end, point1 );\n\t\t\tdistSq = end.distanceToSquared( point1 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t\t}\n\n\t\t\treturn Math.sqrt( closestDistanceSq );\n\n\t\t};\n\n\t} )();\n\n\tExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\t\tconst saTri2 = new ExtendedTriangle();\n\t\tconst arr1 = new Array( 3 );\n\t\tconst arr2 = new Array( 3 );\n\t\tconst cachedSatBounds = new SeparatingAxisBounds();\n\t\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\t\tconst cachedAxis = new THREE.Vector3();\n\t\tconst dir = new THREE.Vector3();\n\t\tconst dir1 = new THREE.Vector3();\n\t\tconst dir2 = new THREE.Vector3();\n\t\tconst tempDir = new THREE.Vector3();\n\t\tconst edge = new THREE.Line3();\n\t\tconst edge1 = new THREE.Line3();\n\t\tconst edge2 = new THREE.Line3();\n\t\tconst tempPoint = new THREE.Vector3();\n\n\t\tfunction triIntersectPlane( tri, plane, targetEdge ) {\n\n\t\t\t// find the edge that intersects the other triangle plane\n\t\t\tconst points = tri.points;\n\t\t\tlet count = 0;\n\t\t\tlet startPointIntersection = - 1;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst { start, end } = edge;\n\t\t\t\tstart.copy( points[ i ] );\n\t\t\t\tend.copy( points[ ( i + 1 ) % 3 ] );\n\t\t\t\tedge.delta( dir );\n\n\t\t\t\tconst startIntersects = isNearZero( plane.distanceToPoint( start ) );\n\t\t\t\tif ( isNearZero( plane.normal.dot( dir ) ) && startIntersects ) {\n\n\t\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\t\ttargetEdge.copy( edge );\n\t\t\t\t\tcount = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\t\tconst doesIntersect = plane.intersectLine( edge, tempPoint );\n\t\t\t\tif ( ! doesIntersect && startIntersects ) {\n\n\t\t\t\t\ttempPoint.copy( start );\n\n\t\t\t\t}\n\n\t\t\t\t// ignore the end point\n\t\t\t\tif ( ( doesIntersect || startIntersects ) && ! isNearZero( tempPoint.distanceTo( end ) ) ) {\n\n\t\t\t\t\tif ( count <= 1 ) {\n\n\t\t\t\t\t\t// assign to the start or end point and save which index was snapped to\n\t\t\t\t\t\t// the start point if necessary\n\t\t\t\t\t\tconst point = count === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\t\tif ( startIntersects ) {\n\n\t\t\t\t\t\t\tstartPointIntersection = count;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( count >= 2 ) {\n\n\t\t\t\t\t\t// if we're here that means that there must have been one point that had\n\t\t\t\t\t\t// snapped to the start point so replace it here\n\t\t\t\t\t\tconst point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\t\tcount = 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcount ++;\n\t\t\t\t\tif ( count === 2 && startPointIntersection === - 1 ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn count;\n\n\t\t}\n\n\t\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\n\t\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\n\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\t\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\t\tsaTri2.copy( other );\n\t\t\t\tsaTri2.update();\n\t\t\t\tother = saTri2;\n\n\t\t\t} else if ( other.needsUpdate ) {\n\n\t\t\t\tother.update();\n\n\t\t\t}\n\n\t\t\tconst plane1 = this.plane;\n\t\t\tconst plane2 = other.plane;\n\n\t\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\n\n\t\t\t\t// perform separating axis intersection test only for coplanar triangles\n\t\t\t\tconst satBounds1 = this.satBounds;\n\t\t\t\tconst satAxes1 = this.satAxes;\n\t\t\t\tarr2[ 0 ] = other.a;\n\t\t\t\tarr2[ 1 ] = other.b;\n\t\t\t\tarr2[ 2 ] = other.c;\n\t\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\n\t\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t\tconst satBounds2 = other.satBounds;\n\t\t\t\tconst satAxes2 = other.satAxes;\n\t\t\t\tarr1[ 0 ] = this.a;\n\t\t\t\tarr1[ 1 ] = this.b;\n\t\t\t\tarr1[ 2 ] = this.c;\n\t\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\n\t\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t\t// check crossed axes\n\t\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tconst sa1 = satAxes1[ i ];\n\t\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\n\t\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\n\t\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\n\t\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\t\t\tif ( ! suppressLog ) {\n\n\t\t\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\t// find the edge that intersects the other triangle plane\n\t\t\t\tconst count1 = triIntersectPlane( this, plane2, edge1 );\n\t\t\t\tif ( count1 === 1 && other.containsPoint( edge1.end ) ) {\n\n\t\t\t\t\tif ( target ) {\n\n\t\t\t\t\t\ttarget.start.copy( edge1.end );\n\t\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if ( count1 !== 2 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// find the other triangles edge that intersects this plane\n\t\t\t\tconst count2 = triIntersectPlane( other, plane1, edge2 );\n\t\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\n\n\t\t\t\t\tif ( target ) {\n\n\t\t\t\t\t\ttarget.start.copy( edge2.end );\n\t\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if ( count2 !== 2 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// find swap the second edge so both lines are running the same direction\n\t\t\t\tedge1.delta( dir1 );\n\t\t\t\tedge2.delta( dir2 );\n\n\t\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\n\n\t\t\t\t\tlet tmp = edge2.start;\n\t\t\t\t\tedge2.start = edge2.end;\n\t\t\t\t\tedge2.end = tmp;\n\n\t\t\t\t}\n\n\t\t\t\t// check if the edges are overlapping\n\t\t\t\tconst s1 = edge1.start.dot( dir1 );\n\t\t\t\tconst e1 = edge1.end.dot( dir1 );\n\t\t\t\tconst s2 = edge2.start.dot( dir1 );\n\t\t\t\tconst e2 = edge2.end.dot( dir1 );\n\t\t\t\tconst separated1 = e1 < s2;\n\t\t\t\tconst separated2 = s1 < e2;\n\n\t\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\t// assign the target output\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\n\t\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\n\n\t\t\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\n\t\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\n\n\t\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t};\n\n\t} )();\n\n\n\tExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\t\tconst target = new THREE.Vector3();\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tthis.closestPointToPoint( point, target );\n\t\t\treturn point.distanceTo( target );\n\n\t\t};\n\n\t} )();\n\n\n\tExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\t\tconst point = new THREE.Vector3();\n\t\tconst point2 = new THREE.Vector3();\n\t\tconst cornerFields = [ 'a', 'b', 'c' ];\n\t\tconst line1 = new THREE.Line3();\n\t\tconst line2 = new THREE.Line3();\n\n\t\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t\t}\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\tlet closestDistanceSq = Infinity;\n\n\t\t\t// check all point distances\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet dist;\n\t\t\t\tconst field = cornerFields[ i ];\n\t\t\t\tconst otherVec = other[ field ];\n\t\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t\t}\n\n\n\t\t\t\tconst thisVec = this[ field ];\n\t\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst f11 = cornerFields[ i ];\n\t\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Math.sqrt( closestDistanceSq );\n\n\t\t};\n\n\t} )();\n\n\tclass OrientedBox {\n\n\t\tconstructor( min, max, matrix ) {\n\n\t\t\tthis.isOrientedBox = true;\n\t\t\tthis.min = new THREE.Vector3();\n\t\t\tthis.max = new THREE.Vector3();\n\t\t\tthis.matrix = new THREE.Matrix4();\n\t\t\tthis.invMatrix = new THREE.Matrix4();\n\t\t\tthis.points = new Array( 8 ).fill().map( () => new THREE.Vector3() );\n\t\t\tthis.satAxes = new Array( 3 ).fill().map( () => new THREE.Vector3() );\n\t\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\t\tthis.needsUpdate = false;\n\n\t\t\tif ( min ) this.min.copy( min );\n\t\t\tif ( max ) this.max.copy( max );\n\t\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t\t}\n\n\t\tset( min, max, matrix ) {\n\n\t\t\tthis.min.copy( min );\n\t\t\tthis.max.copy( max );\n\t\t\tthis.matrix.copy( matrix );\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t\tcopy( other ) {\n\n\t\t\tthis.min.copy( other.min );\n\t\t\tthis.max.copy( other.max );\n\t\t\tthis.matrix.copy( other.matrix );\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tOrientedBox.prototype.update = ( function () {\n\n\t\treturn function update() {\n\n\t\t\tconst matrix = this.matrix;\n\t\t\tconst min = this.min;\n\t\t\tconst max = this.max;\n\n\t\t\tconst points = this.points;\n\t\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst satBounds = this.satBounds;\n\t\t\tconst satAxes = this.satAxes;\n\t\t\tconst minVec = points[ 0 ];\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst axis = satAxes[ i ];\n\t\t\t\tconst sb = satBounds[ i ];\n\t\t\t\tconst index = 1 << i;\n\t\t\t\tconst pi = points[ index ];\n\n\t\t\t\taxis.subVectors( minVec, pi );\n\t\t\t\tsb.setFromPoints( axis, points );\n\n\t\t\t}\n\n\t\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\t\tthis.needsUpdate = false;\n\n\t\t};\n\n\t} )();\n\n\tOrientedBox.prototype.intersectsBox = ( function () {\n\n\t\tconst aabbBounds = new SeparatingAxisBounds();\n\t\treturn function intersectsBox( box ) {\n\n\t\t\t// TODO: should this be doing SAT against the AABB?\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\t\t\tconst min = box.min;\n\t\t\tconst max = box.max;\n\t\t\tconst satBounds = this.satBounds;\n\t\t\tconst satAxes = this.satAxes;\n\t\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\t\taabbBounds.min = min.x;\n\t\t\taabbBounds.max = max.x;\n\t\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\t\taabbBounds.min = min.y;\n\t\t\taabbBounds.max = max.y;\n\t\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\t\taabbBounds.min = min.z;\n\t\t\taabbBounds.max = max.z;\n\t\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst axis = satAxes[ i ];\n\t\t\t\tconst sb = satBounds[ i ];\n\t\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t};\n\n\t} )();\n\n\tOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\t\tconst saTri = new ExtendedTriangle();\n\t\tconst pointsArr = new Array( 3 );\n\t\tconst cachedSatBounds = new SeparatingAxisBounds();\n\t\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\t\tconst cachedAxis = new THREE.Vector3();\n\t\treturn function intersectsTriangle( triangle ) {\n\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\t\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\t\tsaTri.copy( triangle );\n\t\t\t\tsaTri.update();\n\t\t\t\ttriangle = saTri;\n\n\t\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\t\ttriangle.update();\n\n\t\t\t}\n\n\t\t\tconst satBounds = this.satBounds;\n\t\t\tconst satAxes = this.satAxes;\n\n\t\t\tpointsArr[ 0 ] = triangle.a;\n\t\t\tpointsArr[ 1 ] = triangle.b;\n\t\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sb = satBounds[ i ];\n\t\t\t\tconst sa = satAxes[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\tconst triSatBounds = triangle.satBounds;\n\t\t\tconst triSatAxes = triangle.satAxes;\n\t\t\tconst points = this.points;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sb = triSatBounds[ i ];\n\t\t\t\tconst sa = triSatAxes[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check crossed axes\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sa1 = satAxes[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t};\n\n\t} )();\n\n\tOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\t\treturn function closestPointToPoint( point, target1 ) {\n\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\t\t\ttarget1\n\t\t\t\t.copy( point )\n\t\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t\t.clamp( this.min, this.max )\n\t\t\t\t.applyMatrix4( this.matrix );\n\n\t\t\treturn target1;\n\n\t\t};\n\n\t} )();\n\n\tOrientedBox.prototype.distanceToPoint = ( function () {\n\n\t\tconst target = new THREE.Vector3();\n\t\treturn function distanceToPoint( point ) {\n\n\t\t\tthis.closestPointToPoint( point, target );\n\t\t\treturn point.distanceTo( target );\n\n\t\t};\n\n\t} )();\n\n\tOrientedBox.prototype.distanceToBox = ( function () {\n\n\t\tconst xyzFields = [ 'x', 'y', 'z' ];\n\t\tconst segments1 = new Array( 12 ).fill().map( () => new THREE.Line3() );\n\t\tconst segments2 = new Array( 12 ).fill().map( () => new THREE.Line3() );\n\n\t\tconst point1 = new THREE.Vector3();\n\t\tconst point2 = new THREE.Vector3();\n\n\t\t// early out if we find a value below threshold\n\t\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\t\tif ( this.needsUpdate ) {\n\n\t\t\t\tthis.update();\n\n\t\t\t}\n\n\t\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\t\tbox.getCenter( point2 );\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\tconst threshold2 = threshold * threshold;\n\t\t\tconst min = box.min;\n\t\t\tconst max = box.max;\n\t\t\tconst points = this.points;\n\n\n\t\t\t// iterate over every edge and compare distances\n\t\t\tlet closestDistanceSq = Infinity;\n\n\t\t\t// check over all these points\n\t\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\t\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// generate and check all line segment distances\n\t\t\tlet count = 0;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t\t// get obb line segments\n\t\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t\t// get aabb line segments\n\t\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\t\tcount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// check all the other boxes point\n\t\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\t\tconst l1 = segments1[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn Math.sqrt( closestDistanceSq );\n\n\t\t};\n\n\t} )();\n\n\tclass PrimitivePool {\n\n\t\tconstructor( getNewPrimitive ) {\n\n\t\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\t\tthis._primitives = [];\n\n\t\t}\n\n\t\tgetPrimitive() {\n\n\t\t\tconst primitives = this._primitives;\n\t\t\tif ( primitives.length === 0 ) {\n\n\t\t\t\treturn this._getNewPrimitive();\n\n\t\t\t} else {\n\n\t\t\t\treturn primitives.pop();\n\n\t\t\t}\n\n\t\t}\n\n\t\treleasePrimitive( primitive ) {\n\n\t\t\tthis._primitives.push( primitive );\n\n\t\t}\n\n\t}\n\n\tclass ExtendedTrianglePoolBase extends PrimitivePool {\n\n\t\tconstructor() {\n\n\t\t\tsuper( () => new ExtendedTriangle() );\n\n\t\t}\n\n\t}\n\n\tconst ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();\n\n\tclass _BufferStack {\n\n\t\tconstructor() {\n\n\t\t\tthis.float32Array = null;\n\t\t\tthis.uint16Array = null;\n\t\t\tthis.uint32Array = null;\n\n\t\t\tconst stack = [];\n\t\t\tlet prevBuffer = null;\n\t\t\tthis.setBuffer = buffer => {\n\n\t\t\t\tif ( prevBuffer ) {\n\n\t\t\t\t\tstack.push( prevBuffer );\n\n\t\t\t\t}\n\n\t\t\t\tprevBuffer = buffer;\n\t\t\t\tthis.float32Array = new Float32Array( buffer );\n\t\t\t\tthis.uint16Array = new Uint16Array( buffer );\n\t\t\t\tthis.uint32Array = new Uint32Array( buffer );\n\n\t\t\t};\n\n\t\t\tthis.clearBuffer = () => {\n\n\t\t\t\tprevBuffer = null;\n\t\t\t\tthis.float32Array = null;\n\t\t\t\tthis.uint16Array = null;\n\t\t\t\tthis.uint32Array = null;\n\n\t\t\t\tif ( stack.length !== 0 ) {\n\n\t\t\t\t\tthis.setBuffer( stack.pop() );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\tconst BufferStack = new _BufferStack();\n\n\tlet _box1$1, _box2$1;\n\tconst boxStack = [];\n\tconst boxPool = /* @__PURE__ */ new PrimitivePool( () => new THREE.Box3() );\n\n\tfunction shapecast( bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset ) {\n\n\t\t// setup\n\t\t_box1$1 = boxPool.getPrimitive();\n\t\t_box2$1 = boxPool.getPrimitive();\n\t\tboxStack.push( _box1$1, _box2$1 );\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\n\t\tconst result = shapecastTraverse( 0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t\t// cleanup\n\t\tBufferStack.clearBuffer();\n\t\tboxPool.releasePrimitive( _box1$1 );\n\t\tboxPool.releasePrimitive( _box2$1 );\n\t\tboxStack.pop();\n\t\tboxStack.pop();\n\n\t\tconst length = boxStack.length;\n\t\tif ( length > 0 ) {\n\n\t\t\t_box2$1 = boxStack[ length - 1 ];\n\t\t\t_box1$1 = boxStack[ length - 2 ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction shapecastTraverse(\n\t\tnodeIndex32,\n\t\tgeometry,\n\t\tintersectsBoundsFunc,\n\t\tintersectsRangeFunc,\n\t\tnodeScoreFunc = null,\n\t\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\t\tdepth = 0\n\t) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1$1 );\n\t\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1$1 );\n\n\t\t} else {\n\n\t\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tlet c1 = left;\n\t\t\tlet c2 = right;\n\n\t\t\tlet score1, score2;\n\t\t\tlet box1, box2;\n\t\t\tif ( nodeScoreFunc ) {\n\n\t\t\t\tbox1 = _box1$1;\n\t\t\t\tbox2 = _box2$1;\n\n\t\t\t\t// bounding data is not offset\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\t\tc1 = right;\n\t\t\t\t\tc2 = left;\n\n\t\t\t\t\tconst temp = score1;\n\t\t\t\t\tscore1 = score2;\n\t\t\t\t\tscore2 = temp;\n\n\t\t\t\t\tbox1 = box2;\n\t\t\t\t\t// box2 is always set before use below\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Check box 1 intersection\n\t\t\tif ( ! box1 ) {\n\n\t\t\t\tbox1 = _box1$1;\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t\t}\n\n\t\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\t\tlet c1StopTraversal;\n\t\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\t\tconst count = end - offset;\n\n\t\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t\t} else {\n\n\t\t\t\tc1StopTraversal =\n\t\t\t\t\tc1Intersection &&\n\t\t\t\t\tshapecastTraverse(\n\t\t\t\t\t\tc1,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( c1StopTraversal ) return true;\n\n\t\t\t// Check box 2 intersection\n\t\t\t// cached box2 will have been overwritten by previous traversal\n\t\t\tbox2 = _box2$1;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\t\tlet c2StopTraversal;\n\t\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\t\tconst count = end - offset;\n\n\t\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t\t} else {\n\n\t\t\t\tc2StopTraversal =\n\t\t\t\t\tc2Intersection &&\n\t\t\t\t\tshapecastTraverse(\n\t\t\t\t\t\tc2,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( c2StopTraversal ) return true;\n\n\t\t\treturn false;\n\n\t\t\t// Define these inside the function so it has access to the local variables needed\n\t\t\t// when converting to the buffer equivalents\n\t\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t\t// traverse until we find a leaf\n\t\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t\t}\n\n\t\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t\t}\n\n\t\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t\t// traverse until we find a leaf\n\t\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t\t// adjust offset to point to the right node\n\t\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t\t}\n\n\t\t\t\t// return the end offset of the triangle range\n\t\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst temp = /* @__PURE__ */ new THREE.Vector3();\n\tconst temp1$2 = /* @__PURE__ */ new THREE.Vector3();\n\n\tfunction closestPointToPoint(\n\t\tbvh,\n\t\tpoint,\n\t\ttarget = { },\n\t\tminThreshold = 0,\n\t\tmaxThreshold = Infinity,\n\t) {\n\n\t\t// early out if under minThreshold\n\t\t// skip checking if over maxThreshold\n\t\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t\t// returns Infinity if no value found\n\t\tconst minThresholdSq = minThreshold * minThreshold;\n\t\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\t\tlet closestDistanceSq = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tbvh.shapecast(\n\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\t\ttemp1$2.copy( temp );\n\t\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\tif ( closestDistanceSq === Infinity ) return null;\n\n\t\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\t\tif ( ! target.point ) target.point = temp1$2.clone();\n\t\telse target.point.copy( temp1$2 );\n\t\ttarget.distance = closestDistance,\n\t\ttarget.faceIndex = closestDistanceTriIndex;\n\n\t\treturn target;\n\n\t}\n\n\t// Ripped and modified From THREE.js Mesh raycast\n\t// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\n\tconst _vA = /* @__PURE__ */ new THREE.Vector3();\n\tconst _vB = /* @__PURE__ */ new THREE.Vector3();\n\tconst _vC = /* @__PURE__ */ new THREE.Vector3();\n\n\tconst _uvA = /* @__PURE__ */ new THREE.Vector2();\n\tconst _uvB = /* @__PURE__ */ new THREE.Vector2();\n\tconst _uvC = /* @__PURE__ */ new THREE.Vector2();\n\n\tconst _normalA = /* @__PURE__ */ new THREE.Vector3();\n\tconst _normalB = /* @__PURE__ */ new THREE.Vector3();\n\tconst _normalC = /* @__PURE__ */ new THREE.Vector3();\n\n\tconst _intersectionPoint = /* @__PURE__ */ new THREE.Vector3();\n\tfunction checkIntersection( ray, pA, pB, pC, point, side, near, far ) {\n\n\t\tlet intersect;\n\t\tif ( side === THREE.BackSide ) {\n\n\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t\t} else {\n\n\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== THREE.DoubleSide, point );\n\n\t\t}\n\n\t\tif ( intersect === null ) return null;\n\n\t\tconst distance = ray.origin.distanceTo( point );\n\n\t\tif ( distance < near || distance > far ) return null;\n\n\t\treturn {\n\n\t\t\tdistance: distance,\n\t\t\tpoint: point.clone(),\n\n\t\t};\n\n\t}\n\n\tfunction checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far ) {\n\n\t\t_vA.fromBufferAttribute( position, a );\n\t\t_vB.fromBufferAttribute( position, b );\n\t\t_vC.fromBufferAttribute( position, c );\n\n\t\tconst intersection = checkIntersection( ray, _vA, _vB, _vC, _intersectionPoint, side, near, far );\n\n\t\tif ( intersection ) {\n\n\t\t\tif ( uv ) {\n\n\t\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\t\tintersection.uv = THREE.Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new THREE.Vector2() );\n\n\t\t\t}\n\n\t\t\tif ( uv1 ) {\n\n\t\t\t\t_uvA.fromBufferAttribute( uv1, a );\n\t\t\t\t_uvB.fromBufferAttribute( uv1, b );\n\t\t\t\t_uvC.fromBufferAttribute( uv1, c );\n\n\t\t\t\tintersection.uv1 = THREE.Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new THREE.Vector2() );\n\n\t\t\t}\n\n\t\t\tif ( normal ) {\n\n\t\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\t\tintersection.normal = THREE.Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new THREE.Vector3() );\n\t\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst face = {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tnormal: new THREE.Vector3(),\n\t\t\t\tmaterialIndex: 0\n\t\t\t};\n\n\t\t\tTHREE.Triangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\t\tintersection.face = face;\n\t\t\tintersection.faceIndex = a;\n\n\t\t}\n\n\t\treturn intersection;\n\n\t}\n\n\t// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\n\tfunction intersectTri( geo, side, ray, tri, intersections, near, far ) {\n\n\t\tconst triOffset = tri * 3;\n\t\tlet a = triOffset + 0;\n\t\tlet b = triOffset + 1;\n\t\tlet c = triOffset + 2;\n\n\t\tconst index = geo.index;\n\t\tif ( geo.index ) {\n\n\t\t\ta = index.getX( a );\n\t\t\tb = index.getX( b );\n\t\t\tc = index.getX( c );\n\n\t\t}\n\n\t\tconst { position, normal, uv, uv1 } = geo.attributes;\n\t\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far );\n\n\t\tif ( intersection ) {\n\n\t\t\tintersection.faceIndex = tri;\n\t\t\tif ( intersections ) intersections.push( intersection );\n\t\t\treturn intersection;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// sets the vertices of triangle `tri` with the 3 vertices after i\n\tfunction setTriangle( tri, i, index, pos ) {\n\n\t\tconst ta = tri.a;\n\t\tconst tb = tri.b;\n\t\tconst tc = tri.c;\n\n\t\tlet i0 = i;\n\t\tlet i1 = i + 1;\n\t\tlet i2 = i + 2;\n\t\tif ( index ) {\n\n\t\t\ti0 = index.getX( i0 );\n\t\t\ti1 = index.getX( i1 );\n\t\t\ti2 = index.getX( i2 );\n\n\t\t}\n\n\t\tta.x = pos.getX( i0 );\n\t\tta.y = pos.getY( i0 );\n\t\tta.z = pos.getZ( i0 );\n\n\t\ttb.x = pos.getX( i1 );\n\t\ttb.y = pos.getY( i1 );\n\t\ttb.z = pos.getZ( i1 );\n\n\t\ttc.x = pos.getX( i2 );\n\t\ttc.y = pos.getY( i2 );\n\t\ttc.z = pos.getZ( i2 );\n\n\t}\n\n\tconst tempV1 = /* @__PURE__ */ new THREE.Vector3();\n\tconst tempV2 = /* @__PURE__ */ new THREE.Vector3();\n\tconst tempV3 = /* @__PURE__ */ new THREE.Vector3();\n\tconst tempUV1 = /* @__PURE__ */ new THREE.Vector2();\n\tconst tempUV2 = /* @__PURE__ */ new THREE.Vector2();\n\tconst tempUV3 = /* @__PURE__ */ new THREE.Vector2();\n\n\tfunction getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\t\tconst indices = geometry.getIndex().array;\n\t\tconst positions = geometry.getAttribute( 'position' );\n\t\tconst uvs = geometry.getAttribute( 'uv' );\n\n\t\tconst a = indices[ triangleIndex * 3 ];\n\t\tconst b = indices[ triangleIndex * 3 + 1 ];\n\t\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\t\ttempV1.fromBufferAttribute( positions, a );\n\t\ttempV2.fromBufferAttribute( positions, b );\n\t\ttempV3.fromBufferAttribute( positions, c );\n\n\t\t// find the associated material index\n\t\tlet materialIndex = 0;\n\t\tconst groups = geometry.groups;\n\t\tconst firstVertexIndex = triangleIndex * 3;\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tconst { start, count } = group;\n\t\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\t\tmaterialIndex = group.materialIndex;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// extract uvs\n\t\tlet uv = null;\n\t\tif ( uvs ) {\n\n\t\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\t\tif ( target && target.uv ) uv = target.uv;\n\t\t\telse uv = new THREE.Vector2();\n\n\t\t\tTHREE.Triangle.getInterpolation( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t\t}\n\n\t\t// adjust the provided target or create a new one\n\t\tif ( target ) {\n\n\t\t\tif ( ! target.face ) target.face = { };\n\t\t\ttarget.face.a = a;\n\t\t\ttarget.face.b = b;\n\t\t\ttarget.face.c = c;\n\t\t\ttarget.face.materialIndex = materialIndex;\n\t\t\tif ( ! target.face.normal ) target.face.normal = new THREE.Vector3();\n\t\t\tTHREE.Triangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\t\tif ( uv ) target.uv = uv;\n\n\t\t\treturn target;\n\n\t\t} else {\n\n\t\t\treturn {\n\t\t\t\tface: {\n\t\t\t\t\ta: a,\n\t\t\t\t\tb: b,\n\t\t\t\t\tc: c,\n\t\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\t\tnormal: THREE.Triangle.getNormal( tempV1, tempV2, tempV3, new THREE.Vector3() )\n\t\t\t\t},\n\t\t\t\tuv: uv\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\t/*************************************************************/\n\t/* This file is generated from \"iterationUtils.template.js\". */\n\t/*************************************************************/\n\t/* eslint-disable indent */\n\n\tfunction intersectTris( bvh, side, ray, offset, count, intersections, near, far ) {\n\n\t\tconst { geometry, _indirectBuffer } = bvh;\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\n\t\t\tintersectTri( geometry, side, ray, i, intersections, near, far );\n\n\n\t\t}\n\n\t}\n\n\tfunction intersectClosestTri( bvh, side, ray, offset, count, near, far ) {\n\n\t\tconst { geometry, _indirectBuffer } = bvh;\n\t\tlet dist = Infinity;\n\t\tlet res = null;\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\t\tlet intersection;\n\n\t\t\tintersection = intersectTri( geometry, side, ray, i, null, near, far );\n\n\n\t\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\t\tres = intersection;\n\t\t\t\tdist = intersection.distance;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn res;\n\n\t}\n\n\tfunction iterateOverTriangles(\n\t\toffset,\n\t\tcount,\n\t\tbvh,\n\t\tintersectsTriangleFunc,\n\t\tcontained,\n\t\tdepth,\n\t\ttriangle\n\t) {\n\n\t\tconst { geometry } = bvh;\n\t\tconst { index } = geometry;\n\t\tconst pos = geometry.attributes.position;\n\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\tlet tri;\n\n\t\t\ttri = i;\n\n\t\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\t\ttriangle.needsUpdate = true;\n\n\t\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/****************************************************/\n\t/* This file is generated from \"refit.template.js\". */\n\t/****************************************************/\n\n\tfunction refit( bvh, nodeIndices = null ) {\n\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\t\tnodeIndices = new Set( nodeIndices );\n\n\t\t}\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst indexArr = geometry.index ? geometry.index.array : null;\n\t\tconst posAttr = geometry.attributes.position;\n\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\n\t\tlet byteOffset = 0;\n\t\tconst roots = bvh._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tbuffer = roots[ i ];\n\t\t\tuint32Array = new Uint32Array( buffer );\n\t\t\tuint16Array = new Uint16Array( buffer );\n\t\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t\t_traverse( 0, byteOffset );\n\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t}\n\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\t\tlet minx = Infinity;\n\t\t\t\tlet miny = Infinity;\n\t\t\t\tlet minz = Infinity;\n\t\t\t\tlet maxx = - Infinity;\n\t\t\t\tlet maxy = - Infinity;\n\t\t\t\tlet maxz = - Infinity;\n\n\n\t\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\t\tlet index = indexArr[ i ];\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t\t}\n\n\n\t\t\t\tif (\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t\t) {\n\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst left = node32Index + 8;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\t\tconst offsetRight = right + byteOffset;\n\t\t\t\tlet forceChildren = force;\n\t\t\t\tlet includesLeft = false;\n\t\t\t\tlet includesRight = false;\n\n\t\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tincludesLeft = true;\n\t\t\t\t\tincludesRight = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\t\tlet leftChange = false;\n\t\t\t\tif ( traverseLeft ) {\n\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tlet rightChange = false;\n\t\t\t\tif ( traverseRight ) {\n\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tconst didChange = leftChange || rightChange;\n\t\t\t\tif ( didChange ) {\n\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn didChange;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * This function performs intersection tests similar to Ray.intersectBox in three.js,\n\t * with the difference that the box values are read from an array to improve performance.\n\t */\n\tfunction intersectRay( nodeIndex32, array, ray, near, far ) {\n\n\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tconst invdirx = 1 / ray.direction.x,\n\t\t\tinvdiry = 1 / ray.direction.y,\n\t\t\tinvdirz = 1 / ray.direction.z;\n\n\t\tconst ox = ray.origin.x;\n\t\tconst oy = ray.origin.y;\n\t\tconst oz = ray.origin.z;\n\n\t\tlet minx = array[ nodeIndex32 ];\n\t\tlet maxx = array[ nodeIndex32 + 3 ];\n\n\t\tlet miny = array[ nodeIndex32 + 1 ];\n\t\tlet maxy = array[ nodeIndex32 + 3 + 1 ];\n\n\t\tlet minz = array[ nodeIndex32 + 2 ];\n\t\tlet maxz = array[ nodeIndex32 + 3 + 2 ];\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( minx - ox ) * invdirx;\n\t\t\ttmax = ( maxx - ox ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( maxx - ox ) * invdirx;\n\t\t\ttmax = ( minx - ox ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( miny - oy ) * invdiry;\n\t\t\ttymax = ( maxy - oy ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( maxy - oy ) * invdiry;\n\t\t\ttymax = ( miny - oy ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return false;\n\n\t\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\t\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( minz - oz ) * invdirz;\n\t\t\ttzmax = ( maxz - oz ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( maxz - oz ) * invdirz;\n\t\t\ttzmax = ( minz - oz ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\treturn tmin <= far && tmax >= near;\n\n\t}\n\n\t/*************************************************************/\n\t/* This file is generated from \"iterationUtils.template.js\". */\n\t/*************************************************************/\n\t/* eslint-disable indent */\n\n\tfunction intersectTris_indirect( bvh, side, ray, offset, count, intersections, near, far ) {\n\n\t\tconst { geometry, _indirectBuffer } = bvh;\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\t\tlet vi = _indirectBuffer ? _indirectBuffer[ i ] : i;\n\t\t\tintersectTri( geometry, side, ray, vi, intersections, near, far );\n\n\n\t\t}\n\n\t}\n\n\tfunction intersectClosestTri_indirect( bvh, side, ray, offset, count, near, far ) {\n\n\t\tconst { geometry, _indirectBuffer } = bvh;\n\t\tlet dist = Infinity;\n\t\tlet res = null;\n\t\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\t\tlet intersection;\n\t\t\tintersection = intersectTri( geometry, side, ray, _indirectBuffer ? _indirectBuffer[ i ] : i, null, near, far );\n\n\n\t\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\t\tres = intersection;\n\t\t\t\tdist = intersection.distance;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn res;\n\n\t}\n\n\tfunction iterateOverTriangles_indirect(\n\t\toffset,\n\t\tcount,\n\t\tbvh,\n\t\tintersectsTriangleFunc,\n\t\tcontained,\n\t\tdepth,\n\t\ttriangle\n\t) {\n\n\t\tconst { geometry } = bvh;\n\t\tconst { index } = geometry;\n\t\tconst pos = geometry.attributes.position;\n\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\tlet tri;\n\t\t\ttri = bvh.resolveTriangleIndex( i );\n\n\t\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\t\ttriangle.needsUpdate = true;\n\n\t\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\t/******************************************************/\n\t/* This file is generated from \"raycast.template.js\". */\n\t/******************************************************/\n\n\tfunction raycast( bvh, root, side, ray, intersects, near, far ) {\n\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t\t_raycast$1( 0, bvh, side, ray, intersects, near, far );\n\t\tBufferStack.clearBuffer();\n\n\t}\n\n\tfunction _raycast$1( nodeIndex32, bvh, side, ray, intersects, near, far ) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\t\tintersectTris( bvh, side, ray, offset, count, intersects, near, far );\n\n\n\t\t} else {\n\n\t\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t\t_raycast$1( leftIndex, bvh, side, ray, intersects, near, far );\n\n\t\t\t}\n\n\t\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t\t_raycast$1( rightIndex, bvh, side, ray, intersects, near, far );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/***********************************************************/\n\t/* This file is generated from \"raycastFirst.template.js\". */\n\t/***********************************************************/\n\n\tconst _xyzFields$1 = [ 'x', 'y', 'z' ];\n\n\tfunction raycastFirst( bvh, root, side, ray, near, far ) {\n\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t\tconst result = _raycastFirst$1( 0, bvh, side, ray, near, far );\n\t\tBufferStack.clearBuffer();\n\n\t\treturn result;\n\n\t}\n\n\tfunction _raycastFirst$1( nodeIndex32, bvh, side, ray, near, far ) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\t\t// eslint-disable-next-line no-unreachable\n\t\t\treturn intersectClosestTri( bvh, side, ray, offset, count, near, far );\n\n\n\t\t} else {\n\n\t\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\t\tconst xyzAxis = _xyzFields$1[ splitAxis ];\n\t\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\t\tconst leftToRight = rayDir >= 0;\n\n\t\t\t// c1 is the child to check first\n\t\t\tlet c1, c2;\n\t\t\tif ( leftToRight ) {\n\n\t\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t\t} else {\n\n\t\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t\t}\n\n\t\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\n\t\t\tconst c1Result = c1Intersection ? _raycastFirst$1( c1, bvh, side, ray, near, far ) : null;\n\n\t\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\t\tif ( c1Result ) {\n\n\t\t\t\t// check if the point is within the second bounds\n\t\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\t\tconst isOutside = leftToRight ?\n\t\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\t\tif ( isOutside ) {\n\n\t\t\t\t\treturn c1Result;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\n\t\t\tconst c2Result = c2Intersection ? _raycastFirst$1( c2, bvh, side, ray, near, far ) : null;\n\n\t\t\tif ( c1Result && c2Result ) {\n\n\t\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t\t} else {\n\n\t\t\t\treturn c1Result || c2Result || null;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/*****************************************************************/\n\t/* This file is generated from \"intersectsGeometry.template.js\". */\n\t/*****************************************************************/\n\t/* eslint-disable indent */\n\n\tconst boundingBox$2 = /* @__PURE__ */ new THREE.Box3();\n\tconst triangle$1 = /* @__PURE__ */ new ExtendedTriangle();\n\tconst triangle2$1 = /* @__PURE__ */ new ExtendedTriangle();\n\tconst invertedMat$1 = /* @__PURE__ */ new THREE.Matrix4();\n\n\tconst obb$4 = /* @__PURE__ */ new OrientedBox();\n\tconst obb2$3 = /* @__PURE__ */ new OrientedBox();\n\n\tfunction intersectsGeometry( bvh, root, otherGeometry, geometryToBvh ) {\n\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t\tconst result = _intersectsGeometry$1( 0, bvh, otherGeometry, geometryToBvh );\n\t\tBufferStack.clearBuffer();\n\n\t\treturn result;\n\n\t}\n\n\tfunction _intersectsGeometry$1( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\tif ( cachedObb === null ) {\n\n\t\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\t\totherGeometry.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tobb$4.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\t\tcachedObb = obb$4;\n\n\t\t}\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst thisGeometry = bvh.geometry;\n\t\t\tconst thisIndex = thisGeometry.index;\n\t\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\t\tconst index = otherGeometry.index;\n\t\t\tconst pos = otherGeometry.attributes.position;\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t\t// here.\n\t\t\tinvertedMat$1.copy( geometryToBvh ).invert();\n\n\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t// if there's a bounds tree\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2$3 );\n\t\t\t\tobb2$3.matrix.copy( invertedMat$1 );\n\t\t\t\tobb2$3.needsUpdate = true;\n\n\t\t\t\t// TODO: use a triangle iteration function here\n\t\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\t\tintersectsBounds: box => obb2$3.intersectsBox( box ),\n\n\t\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.needsUpdate = true;\n\n\n\t\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\t\tsetTriangle( triangle2$1, i, thisIndex, thisPos );\n\t\t\t\t\t\t\ttriangle2$1.needsUpdate = true;\n\t\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2$1 ) ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn res;\n\n\t\t\t} else {\n\n\t\t\t\t// if we're just dealing with raw geometry\n\n\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\tsetTriangle( triangle$1, i, thisIndex, thisPos );\n\n\n\t\t\t\t\ttriangle$1.a.applyMatrix4( invertedMat$1 );\n\t\t\t\t\ttriangle$1.b.applyMatrix4( invertedMat$1 );\n\t\t\t\t\ttriangle$1.c.applyMatrix4( invertedMat$1 );\n\t\t\t\t\ttriangle$1.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2$1, i2, index, pos );\n\t\t\t\t\t\ttriangle2$1.needsUpdate = true;\n\n\t\t\t\t\t\tif ( triangle$1.intersectsTriangle( triangle2$1 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = nodeIndex32 + 8;\n\t\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox$2 );\n\t\t\tconst leftIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox$2 ) &&\n\t\t\t\t_intersectsGeometry$1( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( leftIntersection ) return true;\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox$2 );\n\t\t\tconst rightIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox$2 ) &&\n\t\t\t\t_intersectsGeometry$1( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( rightIntersection ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\t/*********************************************************************/\n\t/* This file is generated from \"closestPointToGeometry.template.js\". */\n\t/*********************************************************************/\n\n\tconst tempMatrix$1 = /* @__PURE__ */ new THREE.Matrix4();\n\tconst obb$3 = /* @__PURE__ */ new OrientedBox();\n\tconst obb2$2 = /* @__PURE__ */ new OrientedBox();\n\tconst temp1$1 = /* @__PURE__ */ new THREE.Vector3();\n\tconst temp2$1 = /* @__PURE__ */ new THREE.Vector3();\n\tconst temp3$1 = /* @__PURE__ */ new THREE.Vector3();\n\tconst temp4$1 = /* @__PURE__ */ new THREE.Vector3();\n\n\tfunction closestPointToGeometry(\n\t\tbvh,\n\t\totherGeometry,\n\t\tgeometryToBvh,\n\t\ttarget1 = { },\n\t\ttarget2 = { },\n\t\tminThreshold = 0,\n\t\tmaxThreshold = Infinity,\n\t) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb$3.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tobb$3.needsUpdate = true;\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst pos = geometry.attributes.position;\n\t\tconst index = geometry.index;\n\t\tconst otherPos = otherGeometry.attributes.position;\n\t\tconst otherIndex = otherGeometry.index;\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\t\tlet tempTarget1 = temp1$1;\n\t\tlet tempTargetDest1 = temp2$1;\n\t\tlet tempTarget2 = null;\n\t\tlet tempTargetDest2 = null;\n\n\t\tif ( target2 ) {\n\n\t\t\ttempTarget2 = temp3$1;\n\t\t\ttempTargetDest2 = temp4$1;\n\n\t\t}\n\n\t\tlet closestDistance = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tlet closestDistanceOtherTriIndex = null;\n\t\ttempMatrix$1.copy( geometryToBvh ).invert();\n\t\tobb2$2.matrix.copy( tempMatrix$1 );\n\t\tbvh.shapecast(\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\treturn obb$3.distanceToBox( box );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\t\tobb2$2.min.copy( box.min );\n\t\t\t\t\t\t\tobb2$2.max.copy( box.max );\n\t\t\t\t\t\t\tobb2$2.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\t\treturn obb2$2.distanceToBox( box );\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\t\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\t\tif ( closestDistance === Infinity ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( ! target1.point ) {\n\n\t\t\ttarget1.point = tempTargetDest1.clone();\n\n\t\t} else {\n\n\t\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t\t}\n\n\t\ttarget1.distance = closestDistance,\n\t\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\t\tif ( target2 ) {\n\n\t\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\t\telse target2.point.copy( tempTargetDest2 );\n\t\t\ttarget2.point.applyMatrix4( tempMatrix$1 );\n\t\t\ttempTargetDest1.applyMatrix4( tempMatrix$1 );\n\t\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t\t}\n\n\t\treturn target1;\n\n\t}\n\n\t/****************************************************/\n\t/* This file is generated from \"refit.template.js\". */\n\t/****************************************************/\n\n\tfunction refit_indirect( bvh, nodeIndices = null ) {\n\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\t\tnodeIndices = new Set( nodeIndices );\n\n\t\t}\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst indexArr = geometry.index ? geometry.index.array : null;\n\t\tconst posAttr = geometry.attributes.position;\n\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\n\t\tlet byteOffset = 0;\n\t\tconst roots = bvh._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tbuffer = roots[ i ];\n\t\t\tuint32Array = new Uint32Array( buffer );\n\t\t\tuint16Array = new Uint16Array( buffer );\n\t\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t\t_traverse( 0, byteOffset );\n\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t}\n\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\t\tlet minx = Infinity;\n\t\t\t\tlet miny = Infinity;\n\t\t\t\tlet minz = Infinity;\n\t\t\t\tlet maxx = - Infinity;\n\t\t\t\tlet maxy = - Infinity;\n\t\t\t\tlet maxz = - Infinity;\n\n\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\tconst t = 3 * bvh.resolveTriangleIndex( i );\n\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\tlet index = t + j;\n\t\t\t\t\t\tindex = indexArr ? indexArr[ index ] : index;\n\n\t\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\tif (\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t\t) {\n\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst left = node32Index + 8;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\t\tconst offsetRight = right + byteOffset;\n\t\t\t\tlet forceChildren = force;\n\t\t\t\tlet includesLeft = false;\n\t\t\t\tlet includesRight = false;\n\n\t\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tincludesLeft = true;\n\t\t\t\t\tincludesRight = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\t\tlet leftChange = false;\n\t\t\t\tif ( traverseLeft ) {\n\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tlet rightChange = false;\n\t\t\t\tif ( traverseRight ) {\n\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tconst didChange = leftChange || rightChange;\n\t\t\t\tif ( didChange ) {\n\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn didChange;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/******************************************************/\n\t/* This file is generated from \"raycast.template.js\". */\n\t/******************************************************/\n\n\tfunction raycast_indirect( bvh, root, side, ray, intersects, near, far ) {\n\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t\t_raycast( 0, bvh, side, ray, intersects, near, far );\n\t\tBufferStack.clearBuffer();\n\n\t}\n\n\tfunction _raycast( nodeIndex32, bvh, side, ray, intersects, near, far ) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\tintersectTris_indirect( bvh, side, ray, offset, count, intersects, near, far );\n\n\n\t\t} else {\n\n\t\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t\t_raycast( leftIndex, bvh, side, ray, intersects, near, far );\n\n\t\t\t}\n\n\t\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t\t_raycast( rightIndex, bvh, side, ray, intersects, near, far );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/***********************************************************/\n\t/* This file is generated from \"raycastFirst.template.js\". */\n\t/***********************************************************/\n\n\tconst _xyzFields = [ 'x', 'y', 'z' ];\n\n\tfunction raycastFirst_indirect( bvh, root, side, ray, near, far ) {\n\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t\tconst result = _raycastFirst( 0, bvh, side, ray, near, far );\n\t\tBufferStack.clearBuffer();\n\n\t\treturn result;\n\n\t}\n\n\tfunction _raycastFirst( nodeIndex32, bvh, side, ray, near, far ) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\treturn intersectClosestTri_indirect( bvh, side, ray, offset, count, near, far );\n\n\n\t\t} else {\n\n\t\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\t\tconst leftToRight = rayDir >= 0;\n\n\t\t\t// c1 is the child to check first\n\t\t\tlet c1, c2;\n\t\t\tif ( leftToRight ) {\n\n\t\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t\t} else {\n\n\t\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t\t}\n\n\t\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\n\t\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray, near, far ) : null;\n\n\t\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\t\tif ( c1Result ) {\n\n\t\t\t\t// check if the point is within the second bounds\n\t\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\t\tconst isOutside = leftToRight ?\n\t\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\t\tif ( isOutside ) {\n\n\t\t\t\t\treturn c1Result;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\n\t\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray, near, far ) : null;\n\n\t\t\tif ( c1Result && c2Result ) {\n\n\t\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t\t} else {\n\n\t\t\t\treturn c1Result || c2Result || null;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/*****************************************************************/\n\t/* This file is generated from \"intersectsGeometry.template.js\". */\n\t/*****************************************************************/\n\t/* eslint-disable indent */\n\n\tconst boundingBox$1 = /* @__PURE__ */ new THREE.Box3();\n\tconst triangle = /* @__PURE__ */ new ExtendedTriangle();\n\tconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\n\tconst invertedMat = /* @__PURE__ */ new THREE.Matrix4();\n\n\tconst obb$2 = /* @__PURE__ */ new OrientedBox();\n\tconst obb2$1 = /* @__PURE__ */ new OrientedBox();\n\n\tfunction intersectsGeometry_indirect( bvh, root, otherGeometry, geometryToBvh ) {\n\n\t\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\t\tBufferStack.clearBuffer();\n\n\t\treturn result;\n\n\t}\n\n\tfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\t\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\tif ( cachedObb === null ) {\n\n\t\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\t\totherGeometry.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tobb$2.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\t\tcachedObb = obb$2;\n\n\t\t}\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst thisGeometry = bvh.geometry;\n\t\t\tconst thisIndex = thisGeometry.index;\n\t\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\t\tconst index = otherGeometry.index;\n\t\t\tconst pos = otherGeometry.attributes.position;\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t\t// here.\n\t\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t// if there's a bounds tree\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2$1 );\n\t\t\t\tobb2$1.matrix.copy( invertedMat );\n\t\t\t\tobb2$1.needsUpdate = true;\n\n\t\t\t\t// TODO: use a triangle iteration function here\n\t\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\t\tintersectsBounds: box => obb2$1.intersectsBox( box ),\n\n\t\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * bvh.resolveTriangleIndex( i ), thisIndex, thisPos );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn res;\n\n\t\t\t} else {\n\n\t\t\t\t// if we're just dealing with raw geometry\n\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\tsetTriangle( triangle, 3 * ti, thisIndex, thisPos );\n\n\n\t\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = nodeIndex32 + 8;\n\t\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox$1 );\n\t\t\tconst leftIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox$1 ) &&\n\t\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( leftIntersection ) return true;\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox$1 );\n\t\t\tconst rightIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox$1 ) &&\n\t\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( rightIntersection ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\t/*********************************************************************/\n\t/* This file is generated from \"closestPointToGeometry.template.js\". */\n\t/*********************************************************************/\n\n\tconst tempMatrix = /* @__PURE__ */ new THREE.Matrix4();\n\tconst obb$1 = /* @__PURE__ */ new OrientedBox();\n\tconst obb2 = /* @__PURE__ */ new OrientedBox();\n\tconst temp1 = /* @__PURE__ */ new THREE.Vector3();\n\tconst temp2 = /* @__PURE__ */ new THREE.Vector3();\n\tconst temp3 = /* @__PURE__ */ new THREE.Vector3();\n\tconst temp4 = /* @__PURE__ */ new THREE.Vector3();\n\n\tfunction closestPointToGeometry_indirect(\n\t\tbvh,\n\t\totherGeometry,\n\t\tgeometryToBvh,\n\t\ttarget1 = { },\n\t\ttarget2 = { },\n\t\tminThreshold = 0,\n\t\tmaxThreshold = Infinity,\n\t) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb$1.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tobb$1.needsUpdate = true;\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst pos = geometry.attributes.position;\n\t\tconst index = geometry.index;\n\t\tconst otherPos = otherGeometry.attributes.position;\n\t\tconst otherIndex = otherGeometry.index;\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\t\tlet tempTarget1 = temp1;\n\t\tlet tempTargetDest1 = temp2;\n\t\tlet tempTarget2 = null;\n\t\tlet tempTargetDest2 = null;\n\n\t\tif ( target2 ) {\n\n\t\t\ttempTarget2 = temp3;\n\t\t\ttempTargetDest2 = temp4;\n\n\t\t}\n\n\t\tlet closestDistance = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tlet closestDistanceOtherTriIndex = null;\n\t\ttempMatrix.copy( geometryToBvh ).invert();\n\t\tobb2.matrix.copy( tempMatrix );\n\t\tbvh.shapecast(\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\treturn obb$1.distanceToBox( box );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * ti2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\t\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\t\tif ( closestDistance === Infinity ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( ! target1.point ) {\n\n\t\t\ttarget1.point = tempTargetDest1.clone();\n\n\t\t} else {\n\n\t\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t\t}\n\n\t\ttarget1.distance = closestDistance,\n\t\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\t\tif ( target2 ) {\n\n\t\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\t\telse target2.point.copy( tempTargetDest2 );\n\t\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t\t}\n\n\t\treturn target1;\n\n\t}\n\n\tfunction isSharedArrayBufferSupported() {\n\n\t\treturn typeof SharedArrayBuffer !== 'undefined';\n\n\t}\n\n\tfunction convertToBufferType( array, BufferConstructor ) {\n\n\t\tif ( array === null ) {\n\n\t\t\treturn array;\n\n\t\t} else if ( array.buffer ) {\n\n\t\t\tconst buffer = array.buffer;\n\t\t\tif ( buffer.constructor === BufferConstructor ) {\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tconst ArrayConstructor = array.constructor;\n\t\t\tconst result = new ArrayConstructor( new BufferConstructor( buffer.byteLength ) );\n\t\t\tresult.set( array );\n\t\t\treturn result;\n\n\t\t} else {\n\n\t\t\tif ( array.constructor === BufferConstructor ) {\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tconst result = new BufferConstructor( array.byteLength );\n\t\t\tnew Uint8Array( result ).set( new Uint8Array( array ) );\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n\tconst _bufferStack1 = new BufferStack.constructor();\n\tconst _bufferStack2 = new BufferStack.constructor();\n\tconst _boxPool = new PrimitivePool( () => new THREE.Box3() );\n\tconst _leftBox1 = new THREE.Box3();\n\tconst _rightBox1 = new THREE.Box3();\n\n\tconst _leftBox2 = new THREE.Box3();\n\tconst _rightBox2 = new THREE.Box3();\n\n\tlet _active = false;\n\n\tfunction bvhcast( bvh, otherBvh, matrixToLocal, intersectsRanges ) {\n\n\t\tif ( _active ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Recursive calls to bvhcast not supported.' );\n\n\t\t}\n\n\t\t_active = true;\n\n\t\tconst roots = bvh._roots;\n\t\tconst otherRoots = otherBvh._roots;\n\t\tlet result;\n\t\tlet offset1 = 0;\n\t\tlet offset2 = 0;\n\t\tconst invMat = new THREE.Matrix4().copy( matrixToLocal ).invert();\n\n\t\t// iterate over the first set of roots\n\t\tfor ( let i = 0, il = roots.length; i < il; i ++ ) {\n\n\t\t\t_bufferStack1.setBuffer( roots[ i ] );\n\t\t\toffset2 = 0;\n\n\t\t\t// prep the initial root box\n\t\t\tconst localBox = _boxPool.getPrimitive();\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( 0 ), _bufferStack1.float32Array, localBox );\n\t\t\tlocalBox.applyMatrix4( invMat );\n\n\t\t\t// iterate over the second set of roots\n\t\t\tfor ( let j = 0, jl = otherRoots.length; j < jl; j ++ ) {\n\n\t\t\t\t_bufferStack2.setBuffer( otherRoots[ j ] );\n\n\t\t\t\tresult = _traverse(\n\t\t\t\t\t0, 0, matrixToLocal, invMat, intersectsRanges,\n\t\t\t\t\toffset1, offset2, 0, 0,\n\t\t\t\t\tlocalBox,\n\t\t\t\t);\n\n\t\t\t\t_bufferStack2.clearBuffer();\n\t\t\t\toffset2 += otherRoots[ j ].length;\n\n\t\t\t\tif ( result ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// release stack info\n\t\t\t_boxPool.releasePrimitive( localBox );\n\t\t\t_bufferStack1.clearBuffer();\n\t\t\toffset1 += roots[ i ].length;\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t_active = false;\n\t\treturn result;\n\n\t}\n\n\tfunction _traverse(\n\t\tnode1Index32,\n\t\tnode2Index32,\n\t\tmatrix2to1,\n\t\tmatrix1to2,\n\t\tintersectsRangesFunc,\n\n\t\t// offsets for ids\n\t\tnode1IndexByteOffset = 0,\n\t\tnode2IndexByteOffset = 0,\n\n\t\t// tree depth\n\t\tdepth1 = 0,\n\t\tdepth2 = 0,\n\n\t\tcurrBox = null,\n\t\treversed = false,\n\n\t) {\n\n\t\t// get the buffer stacks associated with the current indices\n\t\tlet bufferStack1, bufferStack2;\n\t\tif ( reversed ) {\n\n\t\t\tbufferStack1 = _bufferStack2;\n\t\t\tbufferStack2 = _bufferStack1;\n\n\t\t} else {\n\n\t\t\tbufferStack1 = _bufferStack1;\n\t\t\tbufferStack2 = _bufferStack2;\n\n\t\t}\n\n\t\t// get the local instances of the typed buffers\n\t\tconst\n\t\t\tfloat32Array1 = bufferStack1.float32Array,\n\t\t\tuint32Array1 = bufferStack1.uint32Array,\n\t\t\tuint16Array1 = bufferStack1.uint16Array,\n\t\t\tfloat32Array2 = bufferStack2.float32Array,\n\t\t\tuint32Array2 = bufferStack2.uint32Array,\n\t\t\tuint16Array2 = bufferStack2.uint16Array;\n\n\t\tconst node1Index16 = node1Index32 * 2;\n\t\tconst node2Index16 = node2Index32 * 2;\n\t\tconst isLeaf1 = IS_LEAF( node1Index16, uint16Array1 );\n\t\tconst isLeaf2 = IS_LEAF( node2Index16, uint16Array2 );\n\t\tlet result = false;\n\t\tif ( isLeaf2 && isLeaf1 ) {\n\n\t\t\t// if both bounds are leaf nodes then fire the callback if the boxes intersect\n\t\t\tif ( reversed ) {\n\n\t\t\t\tresult = intersectsRangesFunc(\n\t\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tresult = intersectsRangesFunc(\n\t\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t} else if ( isLeaf2 ) {\n\n\t\t\t// SWAP\n\t\t\t// If we've traversed to the leaf node on the other bvh then we need to swap over\n\t\t\t// to traverse down the first one\n\n\t\t\t// get the new box to use\n\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( node2Index32 ), float32Array2, newBox );\n\t\t\tnewBox.applyMatrix4( matrix2to1 );\n\n\t\t\t// get the child bounds to check before traversal\n\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\tresult = (\n\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\tnode2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t)\n\t\t\t) || (\n\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\tnode2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t} else {\n\n\t\t\t// if neither are leaves then we should swap if one of the children does not\n\t\t\t// intersect with the current bounds\n\n\t\t\t// get the child bounds to check\n\t\t\tconst cl2 = LEFT_NODE( node2Index32 );\n\t\t\tconst cr2 = RIGHT_NODE( node2Index32, uint32Array2 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl2 ), float32Array2, _leftBox2 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr2 ), float32Array2, _rightBox2 );\n\n\t\t\tconst leftIntersects = currBox.intersectsBox( _leftBox2 );\n\t\t\tconst rightIntersects = currBox.intersectsBox( _rightBox2 );\n\t\t\tif ( leftIntersects && rightIntersects ) {\n\n\t\t\t\t// continue to traverse both children if they both intersect\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t) || _traverse(\n\t\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else if ( leftIntersects ) {\n\n\t\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\t\tresult = _traverse(\n\t\t\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// SWAP\n\t\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\t\tnewBox.copy( _leftBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\t\tresult = (\n\t\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\t\tcl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t\t)\n\t\t\t\t\t) || (\n\t\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\t\tcl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t\t}\n\n\t\t\t} else if ( rightIntersects ) {\n\n\t\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\t\tresult = _traverse(\n\t\t\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// SWAP\n\t\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\t\tnewBox.copy( _rightBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\t\tresult = (\n\t\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\t\tcr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t\t)\n\t\t\t\t\t) || (\n\t\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\t\tcr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tconst obb = /* @__PURE__ */ new OrientedBox();\n\tconst tempBox = /* @__PURE__ */ new THREE.Box3();\n\tconst DEFAULT_OPTIONS = {\n\t\tstrategy: CENTER,\n\t\tmaxDepth: 40,\n\t\tmaxLeafTris: 10,\n\t\tuseSharedArrayBuffer: false,\n\t\tsetBoundingBox: true,\n\t\tonProgress: null,\n\t\tindirect: false,\n\t\tverbose: true,\n\t\trange: null\n\t};\n\n\tclass MeshBVH {\n\n\t\tstatic serialize( bvh, options = {} ) {\n\n\t\t\toptions = {\n\t\t\t\tcloneBuffers: true,\n\t\t\t\t...options,\n\t\t\t};\n\n\t\t\tconst geometry = bvh.geometry;\n\t\t\tconst rootData = bvh._roots;\n\t\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tlet result;\n\t\t\tif ( options.cloneBuffers ) {\n\n\t\t\t\tresult = {\n\t\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\t\tindex: indexAttribute ? indexAttribute.array.slice() : null,\n\t\t\t\t\tindirectBuffer: indirectBuffer ? indirectBuffer.slice() : null,\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tresult = {\n\t\t\t\t\troots: rootData,\n\t\t\t\t\tindex: indexAttribute ? indexAttribute.array : null,\n\t\t\t\t\tindirectBuffer: indirectBuffer,\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\t\toptions = {\n\t\t\t\tsetIndex: true,\n\t\t\t\tindirect: Boolean( data.indirectBuffer ),\n\t\t\t\t...options,\n\t\t\t};\n\n\t\t\tconst { index, roots, indirectBuffer } = data;\n\t\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\t\tbvh._roots = roots;\n\t\t\tbvh._indirectBuffer = indirectBuffer || null;\n\n\t\t\tif ( options.setIndex ) {\n\n\t\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\t\tconst newIndex = new THREE.BufferAttribute( data.index, 1, false );\n\t\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bvh;\n\n\t\t}\n\n\t\tget indirect() {\n\n\t\t\treturn ! ! this._indirectBuffer;\n\n\t\t}\n\n\t\tconstructor( geometry, options = {} ) {\n\n\t\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t\t}\n\n\t\t\t// default options\n\t\t\toptions = Object.assign( {\n\n\t\t\t\t...DEFAULT_OPTIONS,\n\n\t\t\t\t// undocumented options\n\n\t\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t\t}, options );\n\n\t\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t\t}\n\n\t\t\t// retain references to the geometry so we can use them it without having to\n\t\t\t// take a geometry reference in every function.\n\t\t\tthis.geometry = geometry;\n\t\t\tthis._roots = null;\n\t\t\tthis._indirectBuffer = null;\n\t\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\t\tbuildPackedTree( this, options );\n\n\t\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new THREE.Box3() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.resolveTriangleIndex = options.indirect ? i => this._indirectBuffer[ i ] : i => i;\n\n\t\t}\n\n\t\trefit( nodeIndices = null ) {\n\n\t\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\n\t\t\treturn refitFunc( this, nodeIndices );\n\n\t\t}\n\n\t\ttraverse( callback, rootIndex = 0 ) {\n\n\t\t\tconst buffer = this._roots[ rootIndex ];\n\t\t\tconst uint32Array = new Uint32Array( buffer );\n\t\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t\t_traverse( 0 );\n\n\t\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\t\tconst node16Index = node32Index * 2;\n\t\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// TODO: use node functions here\n\t\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/* Core Cast Functions */\n\t\traycast( ray, materialOrSide = THREE.FrontSide, near = 0, far = Infinity ) {\n\n\t\t\tconst roots = this._roots;\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst intersects = [];\n\t\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\t\tconst groups = geometry.groups;\n\t\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\n\t\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\t\tconst startCount = intersects.length;\n\n\t\t\t\traycastFunc( this, i, materialSide, ray, intersects, near, far );\n\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn intersects;\n\n\t\t}\n\n\t\traycastFirst( ray, materialOrSide = THREE.FrontSide, near = 0, far = Infinity ) {\n\n\t\t\tconst roots = this._roots;\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\t\tlet closestResult = null;\n\n\t\t\tconst groups = geometry.groups;\n\t\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n\t\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\t\tconst result = raycastFirstFunc( this, i, materialSide, ray, near, far );\n\t\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\t\tclosestResult = result;\n\t\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn closestResult;\n\n\t\t}\n\n\t\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\t\tlet result = false;\n\t\t\tconst roots = this._roots;\n\t\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n\t\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\n\n\t\t\t\tif ( result ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tshapecast( callbacks ) {\n\n\t\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\t\tconst iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n\t\t\tlet {\n\t\t\t\tboundsTraverseOrder,\n\t\t\t\tintersectsBounds,\n\t\t\t\tintersectsRange,\n\t\t\t\tintersectsTriangle,\n\t\t\t} = callbacks;\n\n\t\t\t// wrap the intersectsRange function\n\t\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else if ( ! intersectsRange ) {\n\n\t\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\t\treturn contained;\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// run shapecast\n\t\t\tlet result = false;\n\t\t\tlet byteOffset = 0;\n\t\t\tconst roots = this._roots;\n\t\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\t\tconst root = roots[ i ];\n\t\t\t\tresult = shapecast( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t\t\t\tif ( result ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tbyteOffset += root.byteLength;\n\n\t\t\t}\n\n\t\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\t\tlet {\n\t\t\t\tintersectsRanges,\n\t\t\t\tintersectsTriangles,\n\t\t\t} = callbacks;\n\n\t\t\tconst triangle1 = ExtendedTrianglePool.getPrimitive();\n\t\t\tconst indexAttr1 = this.geometry.index;\n\t\t\tconst positionAttr1 = this.geometry.attributes.position;\n\t\t\tconst assignTriangle1 = this.indirect ?\n\t\t\t\ti1 => {\n\n\n\t\t\t\t\tconst ti = this.resolveTriangleIndex( i1 );\n\t\t\t\t\tsetTriangle( triangle1, ti * 3, indexAttr1, positionAttr1 );\n\n\t\t\t\t} :\n\t\t\t\ti1 => {\n\n\t\t\t\t\tsetTriangle( triangle1, i1 * 3, indexAttr1, positionAttr1 );\n\n\t\t\t\t};\n\n\t\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\t\t\tconst indexAttr2 = otherBvh.geometry.index;\n\t\t\tconst positionAttr2 = otherBvh.geometry.attributes.position;\n\t\t\tconst assignTriangle2 = otherBvh.indirect ?\n\t\t\t\ti2 => {\n\n\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\tsetTriangle( triangle2, ti2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t\t} :\n\t\t\t\ti2 => {\n\n\t\t\t\t\tsetTriangle( triangle2, i2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t\t};\n\n\t\t\t// generate triangle callback if needed\n\t\t\tif ( intersectsTriangles ) {\n\n\t\t\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) => {\n\n\t\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tassignTriangle2( i2 );\n\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\t\tassignTriangle1( i1 );\n\n\t\t\t\t\t\t\ttriangle1.needsUpdate = true;\n\n\t\t\t\t\t\t\tif ( intersectsTriangles( triangle1, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t};\n\n\t\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bvhcast( this, otherBvh, matrixToLocal, intersectsRanges );\n\n\t\t}\n\n\n\t\t/* Derived Cast Functions */\n\t\tintersectsBox( box, boxToMesh ) {\n\n\t\t\tobb.set( box.min, box.max, boxToMesh );\n\t\t\tobb.needsUpdate = true;\n\n\t\t\treturn this.shapecast(\n\t\t\t\t{\n\t\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\tintersectsSphere( sphere ) {\n\n\t\t\treturn this.shapecast(\n\t\t\t\t{\n\t\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n\t\t\treturn closestPointToGeometryFunc(\n\t\t\t\tthis,\n\t\t\t\totherGeometry,\n\t\t\t\tgeometryToBvh,\n\t\t\t\ttarget1,\n\t\t\t\ttarget2,\n\t\t\t\tminThreshold,\n\t\t\t\tmaxThreshold,\n\t\t\t);\n\n\t\t}\n\n\t\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\t\treturn closestPointToPoint(\n\t\t\t\tthis,\n\t\t\t\tpoint,\n\t\t\t\ttarget,\n\t\t\t\tminThreshold,\n\t\t\t\tmaxThreshold,\n\t\t\t);\n\n\t\t}\n\n\t\tgetBoundingBox( target ) {\n\n\t\t\ttarget.makeEmpty();\n\n\t\t\tconst roots = this._roots;\n\t\t\troots.forEach( buffer => {\n\n\t\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\t\ttarget.union( tempBox );\n\n\t\t\t} );\n\n\t\t\treturn target;\n\n\t\t}\n\n\t}\n\n\tconst boundingBox = /* @__PURE__ */ new THREE.Box3();\n\tconst matrix = /* @__PURE__ */ new THREE.Matrix4();\n\n\tclass MeshBVHRootHelper extends THREE.Object3D {\n\n\t\tget isMesh() {\n\n\t\t\treturn ! this.displayEdges;\n\n\t\t}\n\n\t\tget isLineSegments() {\n\n\t\t\treturn this.displayEdges;\n\n\t\t}\n\n\t\tget isLine() {\n\n\t\t\treturn this.displayEdges;\n\n\t\t}\n\n\t\tgetVertexPosition( ...args ) {\n\n\t\t\t// implement this function so it works with Box3.setFromObject\n\t\t\treturn THREE.Mesh.prototype.getVertexPosition.call( this, ...args );\n\n\t\t}\n\n\t\tconstructor( bvh, material, depth = 10, group = 0 ) {\n\n\t\t\tsuper();\n\n\t\t\tthis.material = material;\n\t\t\tthis.geometry = new THREE.BufferGeometry();\n\t\t\tthis.name = 'MeshBVHRootHelper';\n\t\t\tthis.depth = depth;\n\t\t\tthis.displayParents = false;\n\t\t\tthis.bvh = bvh;\n\t\t\tthis.displayEdges = true;\n\t\t\tthis._group = group;\n\n\t\t}\n\n\t\traycast() {}\n\n\t\tupdate() {\n\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst boundsTree = this.bvh;\n\t\t\tconst group = this._group;\n\t\t\tgeometry.dispose();\n\t\t\tthis.visible = false;\n\t\t\tif ( boundsTree ) {\n\n\t\t\t\t// count the number of bounds required\n\t\t\t\tconst targetDepth = this.depth - 1;\n\t\t\t\tconst displayParents = this.displayParents;\n\t\t\t\tlet boundsCount = 0;\n\t\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\n\n\t\t\t\t\tif ( depth >= targetDepth || isLeaf ) {\n\n\t\t\t\t\t\tboundsCount ++;\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t} else if ( displayParents ) {\n\n\t\t\t\t\t\tboundsCount ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}, group );\n\n\t\t\t\t// fill in the position buffer with the bounds corners\n\t\t\t\tlet posIndex = 0;\n\t\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\n\t\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\n\n\t\t\t\t\tconst terminate = depth >= targetDepth || isLeaf;\n\t\t\t\t\tif ( terminate || displayParents ) {\n\n\t\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\n\n\t\t\t\t\t\tconst { min, max } = boundingBox;\n\t\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\n\t\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\n\t\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\n\t\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\n\t\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\n\t\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\n\n\t\t\t\t\t\t\t\t\tposIndex += 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn terminate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}, group );\n\n\t\t\t\tlet indexArray;\n\t\t\t\tlet indices;\n\t\t\t\tif ( this.displayEdges ) {\n\n\t\t\t\t\t// fill in the index buffer to point to the corner points\n\t\t\t\t\tindices = new Uint8Array( [\n\t\t\t\t\t\t// x axis\n\t\t\t\t\t\t0, 4,\n\t\t\t\t\t\t1, 5,\n\t\t\t\t\t\t2, 6,\n\t\t\t\t\t\t3, 7,\n\n\t\t\t\t\t\t// y axis\n\t\t\t\t\t\t0, 2,\n\t\t\t\t\t\t1, 3,\n\t\t\t\t\t\t4, 6,\n\t\t\t\t\t\t5, 7,\n\n\t\t\t\t\t\t// z axis\n\t\t\t\t\t\t0, 1,\n\t\t\t\t\t\t2, 3,\n\t\t\t\t\t\t4, 5,\n\t\t\t\t\t\t6, 7,\n\t\t\t\t\t] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindices = new Uint8Array( [\n\n\t\t\t\t\t\t// X-, X+\n\t\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t\t2, 1, 3,\n\n\t\t\t\t\t\t4, 6, 5,\n\t\t\t\t\t\t6, 7, 5,\n\n\t\t\t\t\t\t// Y-, Y+\n\t\t\t\t\t\t1, 4, 5,\n\t\t\t\t\t\t0, 4, 1,\n\n\t\t\t\t\t\t2, 3, 6,\n\t\t\t\t\t\t3, 7, 6,\n\n\t\t\t\t\t\t// Z-, Z+\n\t\t\t\t\t\t0, 2, 4,\n\t\t\t\t\t\t2, 6, 4,\n\n\t\t\t\t\t\t1, 5, 3,\n\t\t\t\t\t\t3, 5, 7,\n\n\t\t\t\t\t] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( positionArray.length > 65535 ) {\n\n\t\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\n\n\t\t\t\t}\n\n\t\t\t\tconst indexLength = indices.length;\n\t\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\n\n\t\t\t\t\tconst posOffset = i * 8;\n\t\t\t\t\tconst indexOffset = i * indexLength;\n\t\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\n\n\t\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// update the geometry\n\t\t\t\tgeometry.setIndex(\n\t\t\t\t\tnew THREE.BufferAttribute( indexArray, 1, false ),\n\t\t\t\t);\n\t\t\t\tgeometry.setAttribute(\n\t\t\t\t\t'position',\n\t\t\t\t\tnew THREE.BufferAttribute( positionArray, 3, false ),\n\t\t\t\t);\n\t\t\t\tthis.visible = true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tclass MeshBVHHelper extends THREE.Group {\n\n\t\tget color() {\n\n\t\t\treturn this.edgeMaterial.color;\n\n\t\t}\n\n\t\tget opacity() {\n\n\t\t\treturn this.edgeMaterial.opacity;\n\n\t\t}\n\n\t\tset opacity( v ) {\n\n\t\t\tthis.edgeMaterial.opacity = v;\n\t\t\tthis.meshMaterial.opacity = v;\n\n\t\t}\n\n\t\tconstructor( mesh = null, bvh = null, depth = 10 ) {\n\n\t\t\t// handle bvh, depth signature\n\t\t\tif ( mesh instanceof MeshBVH ) {\n\n\t\t\t\tdepth = bvh || 10;\n\t\t\t\tbvh = mesh;\n\t\t\t\tmesh = null;\n\n\t\t\t}\n\n\t\t\t// handle mesh, depth signature\n\t\t\tif ( typeof bvh === 'number' ) {\n\n\t\t\t\tdepth = bvh;\n\t\t\t\tbvh = null;\n\n\t\t\t}\n\n\t\t\tsuper();\n\n\t\t\tthis.name = 'MeshBVHHelper';\n\t\t\tthis.depth = depth;\n\t\t\tthis.mesh = mesh;\n\t\t\tthis.bvh = bvh;\n\t\t\tthis.displayParents = false;\n\t\t\tthis.displayEdges = true;\n\t\t\tthis.objectIndex = 0;\n\t\t\tthis._roots = [];\n\n\t\t\tconst edgeMaterial = new THREE.LineBasicMaterial( {\n\t\t\t\tcolor: 0x00FF88,\n\t\t\t\ttransparent: true,\n\t\t\t\topacity: 0.3,\n\t\t\t\tdepthWrite: false,\n\t\t\t} );\n\n\t\t\tconst meshMaterial = new THREE.MeshBasicMaterial( {\n\t\t\t\tcolor: 0x00FF88,\n\t\t\t\ttransparent: true,\n\t\t\t\topacity: 0.3,\n\t\t\t\tdepthWrite: false,\n\t\t\t} );\n\n\t\t\tmeshMaterial.color = edgeMaterial.color;\n\n\t\t\tthis.edgeMaterial = edgeMaterial;\n\t\t\tthis.meshMaterial = meshMaterial;\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tupdate() {\n\n\t\t\tconst mesh = this.mesh;\n\t\t\tlet bvh = this.bvh || mesh.geometry.boundsTree || null;\n\t\t\tif ( mesh.isBatchedMesh && mesh.boundsTrees && ! bvh ) {\n\n\t\t\t\t// get the bvh from a batchedMesh if not provided\n\t\t\t\t// TODO: we should have an official way to get the geometry index cleanly\n\t\t\t\tconst drawInfo = mesh._drawInfo[ this.objectIndex ];\n\t\t\t\tif ( drawInfo ) {\n\n\t\t\t\t\tbvh = mesh.boundsTrees[ drawInfo.geometryIndex ] || bvh;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\n\t\t\twhile ( this._roots.length > totalRoots ) {\n\n\t\t\t\tconst root = this._roots.pop();\n\t\t\t\troot.geometry.dispose();\n\t\t\t\tthis.remove( root );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\n\n\t\t\t\tconst { depth, edgeMaterial, meshMaterial, displayParents, displayEdges } = this;\n\n\t\t\t\tif ( i >= this._roots.length ) {\n\n\t\t\t\t\tconst root = new MeshBVHRootHelper( bvh, edgeMaterial, depth, i );\n\t\t\t\t\tthis.add( root );\n\t\t\t\t\tthis._roots.push( root );\n\n\t\t\t\t}\n\n\t\t\t\tconst root = this._roots[ i ];\n\t\t\t\troot.bvh = bvh;\n\t\t\t\troot.depth = depth;\n\t\t\t\troot.displayParents = displayParents;\n\t\t\t\troot.displayEdges = displayEdges;\n\t\t\t\troot.material = displayEdges ? edgeMaterial : meshMaterial;\n\t\t\t\troot.update();\n\n\t\t\t}\n\n\t\t}\n\n\t\tupdateMatrixWorld( ...args ) {\n\n\t\t\tconst mesh = this.mesh;\n\t\t\tconst parent = this.parent;\n\n\t\t\tif ( mesh !== null ) {\n\n\t\t\t\tmesh.updateWorldMatrix( true, false );\n\n\t\t\t\tif ( parent ) {\n\n\t\t\t\t\tthis.matrix\n\t\t\t\t\t\t.copy( parent.matrixWorld )\n\t\t\t\t\t\t.invert()\n\t\t\t\t\t\t.multiply( mesh.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.matrix\n\t\t\t\t\t\t.copy( mesh.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\t// handle batched and instanced mesh bvhs\n\t\t\t\tif ( mesh.isInstancedMesh || mesh.isBatchedMesh ) {\n\n\t\t\t\t\tmesh.getMatrixAt( this.objectIndex, matrix );\n\t\t\t\t\tthis.matrix.multiply( matrix );\n\n\t\t\t\t}\n\n\t\t\t\tthis.matrix.decompose(\n\t\t\t\t\tthis.position,\n\t\t\t\t\tthis.quaternion,\n\t\t\t\t\tthis.scale,\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tsuper.updateMatrixWorld( ...args );\n\n\t\t}\n\n\t\tcopy( source ) {\n\n\t\t\tthis.depth = source.depth;\n\t\t\tthis.mesh = source.mesh;\n\t\t\tthis.bvh = source.bvh;\n\t\t\tthis.opacity = source.opacity;\n\t\t\tthis.color.copy( source.color );\n\n\t\t}\n\n\t\tclone() {\n\n\t\t\treturn new MeshBVHHelper( this.mesh, this.bvh, this.depth );\n\n\t\t}\n\n\t\tdispose() {\n\n\t\t\tthis.edgeMaterial.dispose();\n\t\t\tthis.meshMaterial.dispose();\n\n\t\t\tconst children = this.children;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].geometry.dispose();\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tclass MeshBVHVisualizer extends MeshBVHHelper {\n\n\t\tconstructor( ...args ) {\n\n\t\t\tsuper( ...args );\n\n\t\t\tconsole.warn( 'MeshBVHVisualizer: MeshBVHVisualizer has been deprecated. Use MeshBVHHelper, instead.' );\n\n\t\t}\n\n\t}\n\n\tconst _box1 = /* @__PURE__ */ new THREE.Box3();\n\tconst _box2 = /* @__PURE__ */ new THREE.Box3();\n\tconst _vec = /* @__PURE__ */ new THREE.Vector3();\n\n\t// https://stackoverflow.com/questions/1248302/how-to-get-the-size-of-a-javascript-object\n\tfunction getPrimitiveSize( el ) {\n\n\t\tswitch ( typeof el ) {\n\n\t\t\tcase 'number':\n\t\t\t\treturn 8;\n\t\t\tcase 'string':\n\t\t\t\treturn el.length * 2;\n\t\t\tcase 'boolean':\n\t\t\t\treturn 4;\n\t\t\tdefault:\n\t\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\tfunction isTypedArray( arr ) {\n\n\t\tconst regex = /(Uint|Int|Float)(8|16|32)Array/;\n\t\treturn regex.test( arr.constructor.name );\n\n\t}\n\n\tfunction getRootExtremes( bvh, group ) {\n\n\t\tconst result = {\n\t\t\tnodeCount: 0,\n\t\t\tleafNodeCount: 0,\n\n\t\t\tdepth: {\n\t\t\t\tmin: Infinity, max: - Infinity\n\t\t\t},\n\t\t\ttris: {\n\t\t\t\tmin: Infinity, max: - Infinity\n\t\t\t},\n\t\t\tsplits: [ 0, 0, 0 ],\n\t\t\tsurfaceAreaScore: 0,\n\t\t};\n\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offsetOrSplit, count ) => {\n\n\t\t\tconst l0 = boundingData[ 0 + 3 ] - boundingData[ 0 ];\n\t\t\tconst l1 = boundingData[ 1 + 3 ] - boundingData[ 1 ];\n\t\t\tconst l2 = boundingData[ 2 + 3 ] - boundingData[ 2 ];\n\n\t\t\tconst surfaceArea = 2 * ( l0 * l1 + l1 * l2 + l2 * l0 );\n\n\t\t\tresult.nodeCount ++;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tresult.leafNodeCount ++;\n\n\t\t\t\tresult.depth.min = Math.min( depth, result.depth.min );\n\t\t\t\tresult.depth.max = Math.max( depth, result.depth.max );\n\n\t\t\t\tresult.tris.min = Math.min( count, result.tris.min );\n\t\t\t\tresult.tris.max = Math.max( count, result.tris.max );\n\n\t\t\t\tresult.surfaceAreaScore += surfaceArea * TRIANGLE_INTERSECT_COST * count;\n\n\t\t\t} else {\n\n\t\t\t\tresult.splits[ offsetOrSplit ] ++;\n\n\t\t\t\tresult.surfaceAreaScore += surfaceArea * TRAVERSAL_COST;\n\n\t\t\t}\n\n\t\t}, group );\n\n\t\t// If there are no leaf nodes because the tree hasn't finished generating yet.\n\t\tif ( result.tris.min === Infinity ) {\n\n\t\t\tresult.tris.min = 0;\n\t\t\tresult.tris.max = 0;\n\n\t\t}\n\n\t\tif ( result.depth.min === Infinity ) {\n\n\t\t\tresult.depth.min = 0;\n\t\t\tresult.depth.max = 0;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction getBVHExtremes( bvh ) {\n\n\t\treturn bvh._roots.map( ( root, i ) => getRootExtremes( bvh, i ) );\n\n\t}\n\n\tfunction estimateMemoryInBytes( obj ) {\n\n\t\tconst traversed = new Set();\n\t\tconst stack = [ obj ];\n\t\tlet bytes = 0;\n\n\t\twhile ( stack.length ) {\n\n\t\t\tconst curr = stack.pop();\n\t\t\tif ( traversed.has( curr ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\ttraversed.add( curr );\n\n\t\t\tfor ( let key in curr ) {\n\n\t\t\t\tif ( ! Object.hasOwn( curr, key ) ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tbytes += getPrimitiveSize( key );\n\n\t\t\t\tconst value = curr[ key ];\n\t\t\t\tif ( value && ( typeof value === 'object' || typeof value === 'function' ) ) {\n\n\t\t\t\t\tif ( isTypedArray( value ) ) {\n\n\t\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t\t} else if ( isSharedArrayBufferSupported() && value instanceof SharedArrayBuffer ) {\n\n\t\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t\t} else if ( value instanceof ArrayBuffer ) {\n\n\t\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstack.push( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbytes += getPrimitiveSize( value );\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bytes;\n\n\t}\n\n\tfunction validateBounds( bvh ) {\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst depthStack = [];\n\t\tconst index = geometry.index;\n\t\tconst position = geometry.getAttribute( 'position' );\n\t\tlet passes = true;\n\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\t\tconst info = {\n\t\t\t\tdepth,\n\t\t\t\tisLeaf,\n\t\t\t\tboundingData,\n\t\t\t\toffset,\n\t\t\t\tcount,\n\t\t\t};\n\t\t\tdepthStack[ depth ] = info;\n\n\t\t\tarrayToBox( 0, boundingData, _box1 );\n\t\t\tconst parent = depthStack[ depth - 1 ];\n\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\t// check triangles\n\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\tconst triIndex = bvh.resolveTriangleIndex( i );\n\t\t\t\t\tlet i0 = 3 * triIndex;\n\t\t\t\t\tlet i1 = 3 * triIndex + 1;\n\t\t\t\t\tlet i2 = 3 * triIndex + 2;\n\n\t\t\t\t\tif ( index ) {\n\n\t\t\t\t\t\ti0 = index.getX( i0 );\n\t\t\t\t\t\ti1 = index.getX( i1 );\n\t\t\t\t\t\ti2 = index.getX( i2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet isContained;\n\n\t\t\t\t\t_vec.fromBufferAttribute( position, i0 );\n\t\t\t\t\tisContained = _box1.containsPoint( _vec );\n\n\t\t\t\t\t_vec.fromBufferAttribute( position, i1 );\n\t\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\n\n\t\t\t\t\t_vec.fromBufferAttribute( position, i2 );\n\t\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\n\n\t\t\t\t\tconsole.assert( isContained, 'Leaf bounds does not fully contain triangle.' );\n\t\t\t\t\tpasses = passes && isContained;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( parent ) {\n\n\t\t\t\t// check if my bounds fit in my parents\n\t\t\t\tarrayToBox( 0, boundingData, _box2 );\n\n\t\t\t\tconst isContained = _box2.containsBox( _box1 );\n\t\t\t\tconsole.assert( isContained, 'Parent bounds does not fully contain child.' );\n\t\t\t\tpasses = passes && isContained;\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn passes;\n\n\t}\n\n\t// Returns a simple, human readable object that represents the BVH.\n\tfunction getJSONStructure( bvh ) {\n\n\t\tconst depthStack = [];\n\n\t\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\t\tconst info = {\n\t\t\t\tbounds: arrayToBox( 0, boundingData, new THREE.Box3() ),\n\t\t\t};\n\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tinfo.count = count;\n\t\t\t\tinfo.offset = offset;\n\n\t\t\t} else {\n\n\t\t\t\tinfo.left = null;\n\t\t\t\tinfo.right = null;\n\n\t\t\t}\n\n\t\t\tdepthStack[ depth ] = info;\n\n\t\t\t// traversal hits the left then right node\n\t\t\tconst parent = depthStack[ depth - 1 ];\n\t\t\tif ( parent ) {\n\n\t\t\t\tif ( parent.left === null ) {\n\n\t\t\t\t\tparent.left = info;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tparent.right = info;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn depthStack[ 0 ];\n\n\t}\n\n\t// converts the given BVH raycast intersection to align with the three.js raycast\n\t// structure (include object, world space distance and point).\n\tfunction convertRaycastIntersect( hit, object, raycaster ) {\n\n\t\tif ( hit === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\thit.point.applyMatrix4( object.matrixWorld );\n\t\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\t\thit.object = object;\n\n\t\treturn hit;\n\n\t}\n\n\tconst BatchedMesh = THREE__namespace.BatchedMesh || null; // this is necessary to not break three.js r157-\n\tconst IS_REVISION_166 = parseInt( THREE.REVISION ) >= 166;\n\tconst ray = /* @__PURE__ */ new THREE.Ray();\n\tconst direction = /* @__PURE__ */ new THREE.Vector3();\n\tconst tmpInverseMatrix = /* @__PURE__ */ new THREE.Matrix4();\n\tconst origMeshRaycastFunc = THREE.Mesh.prototype.raycast;\n\tconst origBatchedRaycastFunc = BatchedMesh !== null ? BatchedMesh.prototype.raycast : null;\n\tconst _worldScale = /* @__PURE__ */ new THREE.Vector3();\n\tconst _mesh = /* @__PURE__ */ new THREE.Mesh();\n\tconst _batchIntersects = [];\n\n\tfunction acceleratedRaycast( raycaster, intersects ) {\n\n\t\tif ( this.isBatchedMesh ) {\n\n\t\t\tacceleratedBatchedMeshRaycast.call( this, raycaster, intersects );\n\n\t\t} else {\n\n\t\t\tacceleratedMeshRaycast.call( this, raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\tfunction acceleratedBatchedMeshRaycast( raycaster, intersects ) {\n\n\t\tif ( this.boundsTrees ) {\n\n\t\t\tconst boundsTrees = this.boundsTrees;\n\t\t\tconst drawInfo = this._drawInfo;\n\t\t\tconst drawRanges = this._drawRanges;\n\t\t\tconst matrixWorld = this.matrixWorld;\n\n\t\t\t_mesh.material = this.material;\n\t\t\t_mesh.geometry = this.geometry;\n\n\t\t\tconst oldBoundsTree = _mesh.geometry.boundsTree;\n\t\t\tconst oldDrawRange = _mesh.geometry.drawRange;\n\n\t\t\tif ( _mesh.geometry.boundingSphere === null ) {\n\n\t\t\t\t_mesh.geometry.boundingSphere = new THREE.Sphere();\n\n\t\t\t}\n\n\t\t\t// TODO: provide new method to get instances count instead of 'drawInfo.length'\n\t\t\tfor ( let i = 0, l = drawInfo.length; i < l; i ++ ) {\n\n\t\t\t\tif ( ! this.getVisibleAt( i ) ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// TODO: use getGeometryIndex\n\t\t\t\tconst geometryId = drawInfo[ i ].geometryIndex;\n\n\t\t\t\t_mesh.geometry.boundsTree = boundsTrees[ geometryId ];\n\n\t\t\t\tthis.getMatrixAt( i, _mesh.matrixWorld ).premultiply( matrixWorld );\n\n\t\t\t\tif ( ! _mesh.geometry.boundsTree ) {\n\n\t\t\t\t\tthis.getBoundingBoxAt( geometryId, _mesh.geometry.boundingBox );\n\t\t\t\t\tthis.getBoundingSphereAt( geometryId, _mesh.geometry.boundingSphere );\n\n\t\t\t\t\tconst drawRange = drawRanges[ geometryId ];\n\t\t\t\t\t_mesh.geometry.setDrawRange( drawRange.start, drawRange.count );\n\n\t\t\t\t}\n\n\t\t\t\t_mesh.raycast( raycaster, _batchIntersects );\n\n\t\t\t\tfor ( let j = 0, l = _batchIntersects.length; j < l; j ++ ) {\n\n\t\t\t\t\tconst intersect = _batchIntersects[ j ];\n\t\t\t\t\tintersect.object = this;\n\t\t\t\t\tintersect.batchId = i;\n\t\t\t\t\tintersects.push( intersect );\n\n\t\t\t\t}\n\n\t\t\t\t_batchIntersects.length = 0;\n\n\t\t\t}\n\n\t\t\t_mesh.geometry.boundsTree = oldBoundsTree;\n\t\t\t_mesh.geometry.drawRange = oldDrawRange;\n\t\t\t_mesh.material = null;\n\t\t\t_mesh.geometry = null;\n\n\t\t} else {\n\n\t\t\torigBatchedRaycastFunc.call( this, raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\tfunction acceleratedMeshRaycast( raycaster, intersects ) {\n\n\t\tif ( this.geometry.boundsTree ) {\n\n\t\t\tif ( this.material === undefined ) return;\n\n\t\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\n\n\t\t\t_worldScale.setFromMatrixScale( this.matrixWorld );\n\t\t\tdirection.copy( ray.direction ).multiply( _worldScale );\n\n\t\t\tconst scaleFactor = direction.length();\n\t\t\tconst near = raycaster.near / scaleFactor;\n\t\t\tconst far = raycaster.far / scaleFactor;\n\n\t\t\tconst bvh = this.geometry.boundsTree;\n\t\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material, near, far ), this, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst hits = bvh.raycast( ray, this.material, near, far );\n\t\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\n\t\t\t\t\tif ( hit ) {\n\n\t\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\tfunction computeBoundsTree( options = {} ) {\n\n\t\tthis.boundsTree = new MeshBVH( this, options );\n\t\treturn this.boundsTree;\n\n\t}\n\n\tfunction disposeBoundsTree() {\n\n\t\tthis.boundsTree = null;\n\n\t}\n\n\tfunction computeBatchedBoundsTree( index = - 1, options = {} ) {\n\n\t\tif ( ! IS_REVISION_166 ) {\n\n\t\t\tthrow new Error( 'BatchedMesh: Three r166+ is required to compute bounds trees.' );\n\n\t\t}\n\n\t\tif ( options.indirect ) {\n\n\t\t\tconsole.warn( '\"Indirect\" is set to false because it is not supported for BatchedMesh.' );\n\n\t\t}\n\n\t\toptions = {\n\t\t\t...options,\n\t\t\tindirect: false,\n\t\t\trange: null\n\t\t};\n\n\t\tconst drawRanges = this._drawRanges;\n\t\tconst geometryCount = this._geometryCount;\n\t\tif ( ! this.boundsTrees ) {\n\n\t\t\tthis.boundsTrees = new Array( geometryCount ).fill( null );\n\n\t\t}\n\n\t\tconst boundsTrees = this.boundsTrees;\n\t\twhile ( boundsTrees.length < geometryCount ) {\n\n\t\t\tboundsTrees.push( null );\n\n\t\t}\n\n\t\tif ( index < 0 ) {\n\n\t\t\tfor ( let i = 0; i < geometryCount; i ++ ) {\n\n\t\t\t\toptions.range = drawRanges[ i ];\n\t\t\t\tboundsTrees[ i ] = new MeshBVH( this.geometry, options );\n\n\t\t\t}\n\n\t\t\treturn boundsTrees;\n\n\t\t} else {\n\n\t\t\tif ( index < drawRanges.length ) {\n\n\t\t\t\toptions.range = drawRanges[ index ];\n\t\t\t\tboundsTrees[ index ] = new MeshBVH( this.geometry, options );\n\n\t\t\t}\n\n\t\t\treturn boundsTrees[ index ] || null;\n\n\t\t}\n\n\t}\n\n\tfunction disposeBatchedBoundsTree( index = - 1 ) {\n\n\t\tif ( index < 0 ) {\n\n\t\t\tthis.boundsTrees.fill( null );\n\n\t\t} else {\n\n\t\t\tif ( index < this.boundsTree.length ) {\n\n\t\t\t\tthis.boundsTrees[ index ] = null;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction countToStringFormat( count ) {\n\n\t\tswitch ( count ) {\n\n\t\t\tcase 1: return 'R';\n\t\t\tcase 2: return 'RG';\n\t\t\tcase 3: return 'RGBA';\n\t\t\tcase 4: return 'RGBA';\n\n\t\t}\n\n\t\tthrow new Error();\n\n\t}\n\n\tfunction countToFormat( count ) {\n\n\t\tswitch ( count ) {\n\n\t\t\tcase 1: return THREE.RedFormat;\n\t\t\tcase 2: return THREE.RGFormat;\n\t\t\tcase 3: return THREE.RGBAFormat;\n\t\t\tcase 4: return THREE.RGBAFormat;\n\n\t\t}\n\n\t}\n\n\tfunction countToIntFormat( count ) {\n\n\t\tswitch ( count ) {\n\n\t\t\tcase 1: return THREE.RedIntegerFormat;\n\t\t\tcase 2: return THREE.RGIntegerFormat;\n\t\t\tcase 3: return THREE.RGBAIntegerFormat;\n\t\t\tcase 4: return THREE.RGBAIntegerFormat;\n\n\t\t}\n\n\t}\n\n\tclass VertexAttributeTexture extends THREE.DataTexture {\n\n\t\tconstructor() {\n\n\t\t\tsuper();\n\t\t\tthis.minFilter = THREE.NearestFilter;\n\t\t\tthis.magFilter = THREE.NearestFilter;\n\t\t\tthis.generateMipmaps = false;\n\t\t\tthis.overrideItemSize = null;\n\t\t\tthis._forcedType = null;\n\n\t\t}\n\n\t\tupdateFrom( attr ) {\n\n\t\t\tconst overrideItemSize = this.overrideItemSize;\n\t\t\tconst originalItemSize = attr.itemSize;\n\t\t\tconst originalCount = attr.count;\n\t\t\tif ( overrideItemSize !== null ) {\n\n\t\t\t\tif ( ( originalItemSize * originalCount ) % overrideItemSize !== 0.0 ) {\n\n\t\t\t\t\tthrow new Error( 'VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.' );\n\n\t\t\t\t}\n\n\t\t\t\tattr.itemSize = overrideItemSize;\n\t\t\t\tattr.count = originalCount * originalItemSize / overrideItemSize;\n\n\t\t\t}\n\n\t\t\tconst itemSize = attr.itemSize;\n\t\t\tconst count = attr.count;\n\t\t\tconst normalized = attr.normalized;\n\t\t\tconst originalBufferCons = attr.array.constructor;\n\t\t\tconst byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n\t\t\tlet targetType = this._forcedType;\n\t\t\tlet finalStride = itemSize;\n\n\t\t\t// derive the type of texture this should be in the shader\n\t\t\tif ( targetType === null ) {\n\n\t\t\t\tswitch ( originalBufferCons ) {\n\n\t\t\t\t\tcase Float32Array:\n\t\t\t\t\t\ttargetType = THREE.FloatType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase Uint8Array:\n\t\t\t\t\tcase Uint16Array:\n\t\t\t\t\tcase Uint32Array:\n\t\t\t\t\t\ttargetType = THREE.UnsignedIntType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase Int8Array:\n\t\t\t\t\tcase Int16Array:\n\t\t\t\t\tcase Int32Array:\n\t\t\t\t\t\ttargetType = THREE.IntType;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// get the target format to store the texture as\n\t\t\tlet type, format, normalizeValue, targetBufferCons;\n\t\t\tlet internalFormat = countToStringFormat( itemSize );\n\t\t\tswitch ( targetType ) {\n\n\t\t\t\tcase THREE.FloatType:\n\t\t\t\t\tnormalizeValue = 1.0;\n\t\t\t\t\tformat = countToFormat( itemSize );\n\n\t\t\t\t\tif ( normalized && byteCount === 1 ) {\n\n\t\t\t\t\t\ttargetBufferCons = originalBufferCons;\n\t\t\t\t\t\tinternalFormat += '8';\n\n\t\t\t\t\t\tif ( originalBufferCons === Uint8Array ) {\n\n\t\t\t\t\t\t\ttype = THREE.UnsignedByteType;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttype = THREE.ByteType;\n\t\t\t\t\t\t\tinternalFormat += '_SNORM';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetBufferCons = Float32Array;\n\t\t\t\t\t\tinternalFormat += '32F';\n\t\t\t\t\t\ttype = THREE.FloatType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.IntType:\n\t\t\t\t\tinternalFormat += byteCount * 8 + 'I';\n\t\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\t\ttargetBufferCons = Int8Array;\n\t\t\t\t\t\ttype = THREE.ByteType;\n\n\t\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\t\ttargetBufferCons = Int16Array;\n\t\t\t\t\t\ttype = THREE.ShortType;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetBufferCons = Int32Array;\n\t\t\t\t\t\ttype = THREE.IntType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase THREE.UnsignedIntType:\n\t\t\t\t\tinternalFormat += byteCount * 8 + 'UI';\n\t\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\t\ttargetBufferCons = Uint8Array;\n\t\t\t\t\t\ttype = THREE.UnsignedByteType;\n\n\t\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\t\ttargetBufferCons = Uint16Array;\n\t\t\t\t\t\ttype = THREE.UnsignedShortType;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetBufferCons = Uint32Array;\n\t\t\t\t\t\ttype = THREE.UnsignedIntType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// there will be a mismatch between format length and final length because\n\t\t\t// RGBFormat and RGBIntegerFormat was removed\n\t\t\tif ( finalStride === 3 && ( format === THREE.RGBAFormat || format === THREE.RGBAIntegerFormat ) ) {\n\n\t\t\t\tfinalStride = 4;\n\n\t\t\t}\n\n\t\t\t// copy the data over to the new texture array\n\t\t\tconst dimension = Math.ceil( Math.sqrt( count ) ) || 1;\n\t\t\tconst length = finalStride * dimension * dimension;\n\t\t\tconst dataArray = new targetBufferCons( length );\n\n\t\t\t// temporarily set the normalized state to false since we have custom normalization logic\n\t\t\tconst originalNormalized = attr.normalized;\n\t\t\tattr.normalized = false;\n\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\tconst ii = finalStride * i;\n\t\t\t\tdataArray[ ii ] = attr.getX( i ) / normalizeValue;\n\n\t\t\t\tif ( itemSize >= 2 ) {\n\n\t\t\t\t\tdataArray[ ii + 1 ] = attr.getY( i ) / normalizeValue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( itemSize >= 3 ) {\n\n\t\t\t\t\tdataArray[ ii + 2 ] = attr.getZ( i ) / normalizeValue;\n\n\t\t\t\t\tif ( finalStride === 4 ) {\n\n\t\t\t\t\t\tdataArray[ ii + 3 ] = 1.0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( itemSize >= 4 ) {\n\n\t\t\t\t\tdataArray[ ii + 3 ] = attr.getW( i ) / normalizeValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tattr.normalized = originalNormalized;\n\n\t\t\tthis.internalFormat = internalFormat;\n\t\t\tthis.format = format;\n\t\t\tthis.type = type;\n\t\t\tthis.image.width = dimension;\n\t\t\tthis.image.height = dimension;\n\t\t\tthis.image.data = dataArray;\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.dispose();\n\n\t\t\tattr.itemSize = originalItemSize;\n\t\t\tattr.count = originalCount;\n\n\t\t}\n\n\t}\n\n\tclass UIntVertexAttributeTexture extends VertexAttributeTexture {\n\n\t\tconstructor() {\n\n\t\t\tsuper();\n\t\t\tthis._forcedType = THREE.UnsignedIntType;\n\n\t\t}\n\n\t}\n\n\tclass IntVertexAttributeTexture extends VertexAttributeTexture {\n\n\t\tconstructor() {\n\n\t\t\tsuper();\n\t\t\tthis._forcedType = THREE.IntType;\n\n\t\t}\n\n\n\t}\n\n\tclass FloatVertexAttributeTexture extends VertexAttributeTexture {\n\n\t\tconstructor() {\n\n\t\t\tsuper();\n\t\t\tthis._forcedType = THREE.FloatType;\n\n\t\t}\n\n\t}\n\n\tclass MeshBVHUniformStruct {\n\n\t\tconstructor() {\n\n\t\t\tthis.index = new UIntVertexAttributeTexture();\n\t\t\tthis.position = new FloatVertexAttributeTexture();\n\t\t\tthis.bvhBounds = new THREE.DataTexture();\n\t\t\tthis.bvhContents = new THREE.DataTexture();\n\t\t\tthis._cachedIndexAttr = null;\n\n\t\t\tthis.index.overrideItemSize = 3;\n\n\t\t}\n\n\t\tupdateFrom( bvh ) {\n\n\t\t\tconst { geometry } = bvh;\n\t\t\tbvhToTextures( bvh, this.bvhBounds, this.bvhContents );\n\n\t\t\tthis.position.updateFrom( geometry.attributes.position );\n\n\t\t\t// dereference a new index attribute if we're using indirect storage\n\t\t\tif ( bvh.indirect ) {\n\n\t\t\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\t\t\tif (\n\t\t\t\t\tthis._cachedIndexAttr === null ||\n\t\t\t\t\tthis._cachedIndexAttr.count !== indirectBuffer.length\n\t\t\t\t) {\n\n\t\t\t\t\tif ( geometry.index ) {\n\n\t\t\t\t\t\tthis._cachedIndexAttr = geometry.index.clone();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst array = getIndexArray( getVertexCount( geometry ) );\n\t\t\t\t\t\tthis._cachedIndexAttr = new THREE.BufferAttribute( array, 1, false );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tdereferenceIndex( geometry, indirectBuffer, this._cachedIndexAttr );\n\t\t\t\tthis.index.updateFrom( this._cachedIndexAttr );\n\n\t\t\t} else {\n\n\t\t\t\tthis.index.updateFrom( geometry.index );\n\n\t\t\t}\n\n\t\t}\n\n\t\tdispose() {\n\n\t\t\tconst { index, position, bvhBounds, bvhContents } = this;\n\n\t\t\tif ( index ) index.dispose();\n\t\t\tif ( position ) position.dispose();\n\t\t\tif ( bvhBounds ) bvhBounds.dispose();\n\t\t\tif ( bvhContents ) bvhContents.dispose();\n\n\t\t}\n\n\t}\n\n\tfunction dereferenceIndex( geometry, indirectBuffer, target ) {\n\n\t\tconst unpacked = target.array;\n\t\tconst indexArray = geometry.index ? geometry.index.array : null;\n\t\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\t\tconst i3 = 3 * i;\n\t\t\tconst v3 = 3 * indirectBuffer[ i ];\n\t\t\tfor ( let c = 0; c < 3; c ++ ) {\n\n\t\t\t\tunpacked[ i3 + c ] = indexArray ? indexArray[ v3 + c ] : v3 + c;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction bvhToTextures( bvh, boundsTexture, contentsTexture ) {\n\n\t\tconst roots = bvh._roots;\n\n\t\tif ( roots.length !== 1 ) {\n\n\t\t\tthrow new Error( 'MeshBVHUniformStruct: Multi-root BVHs not supported.' );\n\n\t\t}\n\n\t\tconst root = roots[ 0 ];\n\t\tconst uint16Array = new Uint16Array( root );\n\t\tconst uint32Array = new Uint32Array( root );\n\t\tconst float32Array = new Float32Array( root );\n\n\t\t// Both bounds need two elements per node so compute the height so it's twice as long as\n\t\t// the width so we can expand the row by two and still have a square texture\n\t\tconst nodeCount = root.byteLength / BYTES_PER_NODE;\n\t\tconst boundsDimension = 2 * Math.ceil( Math.sqrt( nodeCount / 2 ) );\n\t\tconst boundsArray = new Float32Array( 4 * boundsDimension * boundsDimension );\n\n\t\tconst contentsDimension = Math.ceil( Math.sqrt( nodeCount ) );\n\t\tconst contentsArray = new Uint32Array( 2 * contentsDimension * contentsDimension );\n\n\t\tfor ( let i = 0; i < nodeCount; i ++ ) {\n\n\t\t\tconst nodeIndex32 = i * BYTES_PER_NODE / 4;\n\t\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\t\tconst boundsIndex = BOUNDING_DATA_INDEX( nodeIndex32 );\n\t\t\tfor ( let b = 0; b < 3; b ++ ) {\n\n\t\t\t\tboundsArray[ 8 * i + 0 + b ] = float32Array[ boundsIndex + 0 + b ];\n\t\t\t\tboundsArray[ 8 * i + 4 + b ] = float32Array[ boundsIndex + 3 + b ];\n\n\t\t\t}\n\n\t\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\n\t\t\t\tconst mergedLeafCount = 0xffff0000 | count;\n\t\t\t\tcontentsArray[ i * 2 + 0 ] = mergedLeafCount;\n\t\t\t\tcontentsArray[ i * 2 + 1 ] = offset;\n\n\t\t\t} else {\n\n\t\t\t\tconst rightIndex = 4 * RIGHT_NODE( nodeIndex32, uint32Array ) / BYTES_PER_NODE;\n\t\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\n\t\t\t\tcontentsArray[ i * 2 + 0 ] = splitAxis;\n\t\t\t\tcontentsArray[ i * 2 + 1 ] = rightIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\tboundsTexture.image.data = boundsArray;\n\t\tboundsTexture.image.width = boundsDimension;\n\t\tboundsTexture.image.height = boundsDimension;\n\t\tboundsTexture.format = THREE.RGBAFormat;\n\t\tboundsTexture.type = THREE.FloatType;\n\t\tboundsTexture.internalFormat = 'RGBA32F';\n\t\tboundsTexture.minFilter = THREE.NearestFilter;\n\t\tboundsTexture.magFilter = THREE.NearestFilter;\n\t\tboundsTexture.generateMipmaps = false;\n\t\tboundsTexture.needsUpdate = true;\n\t\tboundsTexture.dispose();\n\n\t\tcontentsTexture.image.data = contentsArray;\n\t\tcontentsTexture.image.width = contentsDimension;\n\t\tcontentsTexture.image.height = contentsDimension;\n\t\tcontentsTexture.format = THREE.RGIntegerFormat;\n\t\tcontentsTexture.type = THREE.UnsignedIntType;\n\t\tcontentsTexture.internalFormat = 'RG32UI';\n\t\tcontentsTexture.minFilter = THREE.NearestFilter;\n\t\tcontentsTexture.magFilter = THREE.NearestFilter;\n\t\tcontentsTexture.generateMipmaps = false;\n\t\tcontentsTexture.needsUpdate = true;\n\t\tcontentsTexture.dispose();\n\n\t}\n\n\tconst _positionVector = /*@__PURE__*/ new THREE.Vector3();\n\tconst _normalVector = /*@__PURE__*/ new THREE.Vector3();\n\tconst _tangentVector = /*@__PURE__*/ new THREE.Vector3();\n\tconst _tangentVector4 = /*@__PURE__*/ new THREE.Vector4();\n\n\tconst _morphVector = /*@__PURE__*/ new THREE.Vector3();\n\tconst _temp = /*@__PURE__*/ new THREE.Vector3();\n\n\tconst _skinIndex = /*@__PURE__*/ new THREE.Vector4();\n\tconst _skinWeight = /*@__PURE__*/ new THREE.Vector4();\n\tconst _matrix = /*@__PURE__*/ new THREE.Matrix4();\n\tconst _boneMatrix = /*@__PURE__*/ new THREE.Matrix4();\n\n\t// Confirms that the two provided attributes are compatible\n\tfunction validateAttributes( attr1, attr2 ) {\n\n\t\tif ( ! attr1 && ! attr2 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst sameCount = attr1.count === attr2.count;\n\t\tconst sameNormalized = attr1.normalized === attr2.normalized;\n\t\tconst sameType = attr1.array.constructor === attr2.array.constructor;\n\t\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\n\n\t\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\n\n\t\t\tthrow new Error();\n\n\t\t}\n\n\t}\n\n\t// Clones the given attribute with a new compatible buffer attribute but no data\n\tfunction createAttributeClone( attr, countOverride = null ) {\n\n\t\tconst cons = attr.array.constructor;\n\t\tconst normalized = attr.normalized;\n\t\tconst itemSize = attr.itemSize;\n\t\tconst count = countOverride === null ? attr.count : countOverride;\n\n\t\treturn new THREE.BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\n\n\t}\n\n\t// target offset is the number of elements in the target buffer stride to skip before copying the\n\t// attributes contents in to.\n\tfunction copyAttributeContents( attr, target, targetOffset = 0 ) {\n\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tconst itemSize = attr.itemSize;\n\t\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\t\tconst io = i + targetOffset;\n\t\t\t\ttarget.setX( io, attr.getX( i ) );\n\t\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\n\t\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\n\t\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst array = target.array;\n\t\t\tconst cons = array.constructor;\n\t\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n\t\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\n\t\t\ttemp.set( attr.array );\n\n\t\t}\n\n\t}\n\n\t// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\n\tfunction addScaledMatrix( target, matrix, scale ) {\n\n\t\tconst targetArray = target.elements;\n\t\tconst matrixArray = matrix.elements;\n\t\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\n\n\t\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\n\n\t\t}\n\n\t}\n\n\t// A version of \"SkinnedMesh.boneTransform\" for normals\n\tfunction boneNormalTransform( mesh, index, target ) {\n\n\t\tconst skeleton = mesh.skeleton;\n\t\tconst geometry = mesh.geometry;\n\t\tconst bones = skeleton.bones;\n\t\tconst boneInverses = skeleton.boneInverses;\n\n\t\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t\t_matrix.elements.fill( 0 );\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\t\tif ( weight !== 0 ) {\n\n\t\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\t\t\t\t_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );\n\n\t\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\n\t\ttarget.transformDirection( _matrix );\n\n\t\treturn target;\n\n\t}\n\n\t// Applies the morph target data to the target vector\n\tfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\n\n\t\t_morphVector.set( 0, 0, 0 );\n\t\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\n\n\t\t\tconst influence = morphInfluences[ j ];\n\t\t\tconst morphAttribute = morphData[ j ];\n\n\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t_temp.fromBufferAttribute( morphAttribute, i );\n\n\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t_morphVector.addScaledVector( _temp, influence );\n\n\t\t\t} else {\n\n\t\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\n\n\t\t\t}\n\n\t\t}\n\n\t\ttarget.add( _morphVector );\n\n\t}\n\n\t// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\n\tfunction mergeBufferGeometries( geometries, options = { useGroups: false, updateIndex: false, skipAttributes: [] }, targetGeometry = new THREE.BufferGeometry() ) {\n\n\t\tconst isIndexed = geometries[ 0 ].index !== null;\n\t\tconst { useGroups = false, updateIndex = false, skipAttributes = [] } = options;\n\n\t\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\t\tconst attributes = {};\n\n\t\tlet offset = 0;\n\n\t\ttargetGeometry.clearGroups();\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst geometry = geometries[ i ];\n\t\t\tlet attributesCount = 0;\n\n\t\t\t// ensure that all geometries are indexed, or none\n\t\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\n\t\t\t}\n\n\t\t\t// gather attributes, exit early if they're different\n\t\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\n\t\t\t\t}\n\n\t\t\t\tif ( attributes[ name ] === undefined ) {\n\n\t\t\t\t\tattributes[ name ] = [];\n\n\t\t\t\t}\n\n\t\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\t\t\t\tattributesCount ++;\n\n\t\t\t}\n\n\t\t\t// ensure geometries have the same number of attributes\n\t\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: Make sure all geometries have the same number of attributes.' );\n\n\t\t\t}\n\n\t\t\tif ( useGroups ) {\n\n\t\t\t\tlet count;\n\t\t\t\tif ( isIndexed ) {\n\n\t\t\t\t\tcount = geometry.index.count;\n\n\t\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'StaticGeometryGenerator: The geometry must have either an index or a position attribute' );\n\n\t\t\t\t}\n\n\t\t\t\ttargetGeometry.addGroup( offset, count, i );\n\t\t\t\toffset += count;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// merge indices\n\t\tif ( isIndexed ) {\n\n\t\t\tlet forceUpdateIndex = false;\n\t\t\tif ( ! targetGeometry.index ) {\n\n\t\t\t\tlet indexCount = 0;\n\t\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\t\tindexCount += geometries[ i ].index.count;\n\n\t\t\t\t}\n\n\t\t\t\ttargetGeometry.setIndex( new THREE.BufferAttribute( new Uint32Array( indexCount ), 1, false ) );\n\t\t\t\tforceUpdateIndex = true;\n\n\t\t\t}\n\n\t\t\tif ( updateIndex || forceUpdateIndex ) {\n\n\t\t\t\tconst targetIndex = targetGeometry.index;\n\t\t\t\tlet targetOffset = 0;\n\t\t\t\tlet indexOffset = 0;\n\t\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\t\tconst index = geometry.index;\n\t\t\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\t\t\ttargetIndex.setX( targetOffset, index.getX( j ) + indexOffset );\n\t\t\t\t\t\t\ttargetOffset ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindexOffset += geometry.attributes.position.count;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// merge attributes\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attrList = attributes[ name ];\n\t\t\tif ( ! ( name in targetGeometry.attributes ) ) {\n\n\t\t\t\tlet count = 0;\n\t\t\t\tfor ( const key in attrList ) {\n\n\t\t\t\t\tcount += attrList[ key ].count;\n\n\t\t\t\t}\n\n\t\t\t\ttargetGeometry.setAttribute( name, createAttributeClone( attributes[ name ][ 0 ], count ) );\n\n\t\t\t}\n\n\t\t\tconst targetAttribute = targetGeometry.attributes[ name ];\n\t\t\tlet offset = 0;\n\t\t\tfor ( let i = 0, l = attrList.length; i < l; i ++ ) {\n\n\t\t\t\tconst attr = attrList[ i ];\n\t\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\n\n\t\t\t\t}\n\n\t\t\t\toffset += attr.count;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n\tfunction checkTypedArrayEquality( a, b ) {\n\n\t\tif ( a === null || b === null ) {\n\n\t\t\treturn a === b;\n\n\t\t}\n\n\t\tif ( a.length !== b.length ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\t\tif ( a[ i ] !== b[ i ] ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction invertGeometry( geometry ) {\n\n\t\tconst { index, attributes } = geometry;\n\t\tif ( index ) {\n\n\t\t\tfor ( let i = 0, l = index.count; i < l; i += 3 ) {\n\n\t\t\t\tconst v0 = index.getX( i );\n\t\t\t\tconst v2 = index.getX( i + 2 );\n\t\t\t\tindex.setX( i, v2 );\n\t\t\t\tindex.setX( i + 2, v0 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( const key in attributes ) {\n\n\t\t\t\tconst attr = attributes[ key ];\n\t\t\t\tconst itemSize = attr.itemSize;\n\t\t\t\tfor ( let i = 0, l = attr.count; i < l; i += 3 ) {\n\n\t\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\t\tconst v0 = attr.getComponent( i, j );\n\t\t\t\t\t\tconst v2 = attr.getComponent( i + 2, j );\n\t\t\t\t\t\tattr.setComponent( i, j, v2 );\n\t\t\t\t\t\tattr.setComponent( i + 2, j, v0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometry;\n\n\n\t}\n\n\t// Checks whether the geometry changed between this and last evaluation\n\tclass GeometryDiff {\n\n\t\tconstructor( mesh ) {\n\n\t\t\tthis.matrixWorld = new THREE.Matrix4();\n\t\t\tthis.geometryHash = null;\n\t\t\tthis.boneMatrices = null;\n\t\t\tthis.primitiveCount = - 1;\n\t\t\tthis.mesh = mesh;\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tupdate() {\n\n\t\t\tconst mesh = this.mesh;\n\t\t\tconst geometry = mesh.geometry;\n\t\t\tconst skeleton = mesh.skeleton;\n\t\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\t\tthis.matrixWorld.copy( mesh.matrixWorld );\n\t\t\tthis.geometryHash = geometry.attributes.position.version;\n\t\t\tthis.primitiveCount = primitiveCount;\n\n\t\t\tif ( skeleton ) {\n\n\t\t\t\t// ensure the bone matrix array is updated to the appropriate length\n\t\t\t\tif ( ! skeleton.boneTexture ) {\n\n\t\t\t\t\tskeleton.computeBoneTexture();\n\n\t\t\t\t}\n\n\t\t\t\tskeleton.update();\n\n\t\t\t\t// copy data if possible otherwise clone it\n\t\t\t\tconst boneMatrices = skeleton.boneMatrices;\n\t\t\t\tif ( ! this.boneMatrices || this.boneMatrices.length !== boneMatrices.length ) {\n\n\t\t\t\t\tthis.boneMatrices = boneMatrices.slice();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.boneMatrices.set( boneMatrices );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.boneMatrices = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdidChange() {\n\n\t\t\tconst mesh = this.mesh;\n\t\t\tconst geometry = mesh.geometry;\n\t\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\t\tconst identical =\n\t\t\t\tthis.matrixWorld.equals( mesh.matrixWorld ) &&\n\t\t\t\tthis.geometryHash === geometry.attributes.position.version &&\n\t\t\t\tcheckTypedArrayEquality( mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices ) &&\n\t\t\t\tthis.primitiveCount === primitiveCount;\n\n\t\t\treturn ! identical;\n\n\t\t}\n\n\t}\n\n\tclass StaticGeometryGenerator {\n\n\t\tconstructor( meshes ) {\n\n\t\t\tif ( ! Array.isArray( meshes ) ) {\n\n\t\t\t\tmeshes = [ meshes ];\n\n\t\t\t}\n\n\t\t\tconst finalMeshes = [];\n\t\t\tmeshes.forEach( object => {\n\n\t\t\t\tobject.traverseVisible( c => {\n\n\t\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\t\tfinalMeshes.push( c );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t} );\n\n\t\t\tthis.meshes = finalMeshes;\n\t\t\tthis.useGroups = true;\n\t\t\tthis.applyWorldTransforms = true;\n\t\t\tthis.attributes = [ 'position', 'normal', 'color', 'tangent', 'uv', 'uv2' ];\n\t\t\tthis._intermediateGeometry = new Array( finalMeshes.length ).fill().map( () => new THREE.BufferGeometry() );\n\t\t\tthis._diffMap = new WeakMap();\n\n\t\t}\n\n\t\tgetMaterials() {\n\n\t\t\tconst materials = [];\n\t\t\tthis.meshes.forEach( mesh => {\n\n\t\t\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\t\t\tmaterials.push( ...mesh.material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterials.push( mesh.material );\n\n\t\t\t\t}\n\n\t\t\t} );\n\t\t\treturn materials;\n\n\t\t}\n\n\t\tgenerate( targetGeometry = new THREE.BufferGeometry() ) {\n\n\t\t\t// track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n\t\t\tlet skipAttributes = [];\n\t\t\tconst { meshes, useGroups, _intermediateGeometry, _diffMap } = this;\n\t\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\t\tconst mesh = meshes[ i ];\n\t\t\t\tconst geom = _intermediateGeometry[ i ];\n\t\t\t\tconst diff = _diffMap.get( mesh );\n\t\t\t\tif ( ! diff || diff.didChange( mesh ) ) {\n\n\t\t\t\t\tthis._convertToStaticGeometry( mesh, geom );\n\t\t\t\t\tskipAttributes.push( false );\n\n\t\t\t\t\tif ( ! diff ) {\n\n\t\t\t\t\t\t_diffMap.set( mesh, new GeometryDiff( mesh ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdiff.update();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tskipAttributes.push( true );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( _intermediateGeometry.length === 0 ) {\n\n\t\t\t\t// if there are no geometries then just create a fake empty geometry to provide\n\t\t\t\ttargetGeometry.setIndex( null );\n\n\t\t\t\t// remove all geometry\n\t\t\t\tconst attrs = targetGeometry.attributes;\n\t\t\t\tfor ( const key in attrs ) {\n\n\t\t\t\t\ttargetGeometry.deleteAttribute( key );\n\n\t\t\t\t}\n\n\t\t\t\t// create dummy attributes\n\t\t\t\tfor ( const key in this.attributes ) {\n\n\t\t\t\t\ttargetGeometry.setAttribute( this.attributes[ key ], new THREE.BufferAttribute( new Float32Array( 0 ), 4, false ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tmergeBufferGeometries( _intermediateGeometry, { useGroups, skipAttributes }, targetGeometry );\n\n\t\t\t}\n\n\t\t\tfor ( const key in targetGeometry.attributes ) {\n\n\t\t\t\ttargetGeometry.attributes[ key ].needsUpdate = true;\n\n\t\t\t}\n\n\t\t\treturn targetGeometry;\n\n\t\t}\n\n\t\t_convertToStaticGeometry( mesh, targetGeometry = new THREE.BufferGeometry() ) {\n\n\t\t\tconst geometry = mesh.geometry;\n\t\t\tconst applyWorldTransforms = this.applyWorldTransforms;\n\t\t\tconst includeNormal = this.attributes.includes( 'normal' );\n\t\t\tconst includeTangent = this.attributes.includes( 'tangent' );\n\t\t\tconst attributes = geometry.attributes;\n\t\t\tconst targetAttributes = targetGeometry.attributes;\n\n\t\t\t// initialize the attributes if they don't exist\n\t\t\tif ( ! targetGeometry.index && geometry.index ) {\n\n\t\t\t\ttargetGeometry.index = geometry.index.clone();\n\n\t\t\t}\n\n\t\t\tif ( ! targetAttributes.position ) {\n\n\t\t\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\n\n\t\t\t}\n\n\t\t\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\n\n\t\t\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\n\n\t\t\t}\n\n\t\t\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\n\n\t\t\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\n\n\t\t\t}\n\n\t\t\t// ensure the attributes are consistent\n\t\t\tvalidateAttributes( geometry.index, targetGeometry.index );\n\t\t\tvalidateAttributes( attributes.position, targetAttributes.position );\n\n\t\t\tif ( includeNormal ) {\n\n\t\t\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\n\n\t\t\t}\n\n\t\t\tif ( includeTangent ) {\n\n\t\t\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\n\n\t\t\t}\n\n\t\t\t// generate transformed vertex attribute data\n\t\t\tconst position = attributes.position;\n\t\t\tconst normal = includeNormal ? attributes.normal : null;\n\t\t\tconst tangent = includeTangent ? attributes.tangent : null;\n\t\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\t\tconst morphNormal = geometry.morphAttributes.normal;\n\t\t\tconst morphTangent = geometry.morphAttributes.tangent;\n\t\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\t\tconst morphInfluences = mesh.morphTargetInfluences;\n\t\t\tconst normalMatrix = new THREE.Matrix3();\n\t\t\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t// copy the index\n\t\t\tif ( geometry.index ) {\n\n\t\t\t\ttargetGeometry.index.array.set( geometry.index.array );\n\n\t\t\t}\n\n\t\t\t// copy and apply other attributes\n\t\t\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\n\n\t\t\t\t_positionVector.fromBufferAttribute( position, i );\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\t_normalVector.fromBufferAttribute( normal, i );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\n\t\t\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\n\n\t\t\t\t}\n\n\t\t\t\t// apply morph target transform\n\t\t\t\tif ( morphInfluences ) {\n\n\t\t\t\t\tif ( morphPosition ) {\n\n\t\t\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( morphNormal ) {\n\n\t\t\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( morphTangent ) {\n\n\t\t\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// apply bone transform\n\t\t\t\tif ( mesh.isSkinnedMesh ) {\n\n\t\t\t\t\tmesh.applyBoneTransform( i, _positionVector );\n\t\t\t\t\tif ( normal ) {\n\n\t\t\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// update the vectors of the attributes\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\n\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// copy other attributes over\n\t\t\tfor ( const i in this.attributes ) {\n\n\t\t\t\tconst key = this.attributes[ i ];\n\t\t\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetAttributes[ key ] ) {\n\n\t\t\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\n\t\t\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\n\n\t\t\t}\n\n\t\t\tif ( mesh.matrixWorld.determinant() < 0 ) {\n\n\t\t\t\tinvertGeometry( targetGeometry );\n\n\t\t\t}\n\n\t\t\treturn targetGeometry;\n\n\t\t}\n\n\t}\n\n\tconst common_functions = /* glsl */`\n\n// A stack of uint32 indices can can store the indices for\n// a perfectly balanced tree with a depth up to 31. Lower stack\n// depth gets higher performance.\n//\n// However not all trees are balanced. Best value to set this to\n// is the trees max depth.\n#ifndef BVH_STACK_DEPTH\n#define BVH_STACK_DEPTH 60\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n`;\n\n\t// Distance to Point\n\tconst bvh_distance_functions = /* glsl */`\n\nfloat dot2( vec3 v ) {\n\n\treturn dot( v, v );\n\n}\n\n// https://www.shadertoy.com/view/ttfGWl\nvec3 closestPointToTriangle( vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 barycoord ) {\n\n    vec3 v10 = v1 - v0;\n    vec3 v21 = v2 - v1;\n    vec3 v02 = v0 - v2;\n\n\tvec3 p0 = p - v0;\n\tvec3 p1 = p - v1;\n\tvec3 p2 = p - v2;\n\n    vec3 nor = cross( v10, v02 );\n\n    // method 2, in barycentric space\n    vec3  q = cross( nor, p0 );\n    float d = 1.0 / dot2( nor );\n    float u = d * dot( q, v02 );\n    float v = d * dot( q, v10 );\n    float w = 1.0 - u - v;\n\n\tif( u < 0.0 ) {\n\n\t\tw = clamp( dot( p2, v02 ) / dot2( v02 ), 0.0, 1.0 );\n\t\tu = 0.0;\n\t\tv = 1.0 - w;\n\n\t} else if( v < 0.0 ) {\n\n\t\tu = clamp( dot( p0, v10 ) / dot2( v10 ), 0.0, 1.0 );\n\t\tv = 0.0;\n\t\tw = 1.0 - u;\n\n\t} else if( w < 0.0 ) {\n\n\t\tv = clamp( dot( p1, v21 ) / dot2( v21 ), 0.0, 1.0 );\n\t\tw = 0.0;\n\t\tu = 1.0-v;\n\n\t}\n\n\tbarycoord = vec3( u, v, w );\n    return u * v1 + v * v2 + w * v0;\n\n}\n\nfloat distanceToTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// point and cut off range\n\tvec3 point, float closestDistanceSquared,\n\n\t// outputs\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord, inout float side, inout vec3 outPoint\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\t// get the closest point and barycoord\n\t\tvec3 closestPoint = closestPointToTriangle( point, a, b, c, localBarycoord );\n\t\tvec3 delta = point - closestPoint;\n\t\tfloat sqDist = dot2( delta );\n\t\tif ( sqDist < closestDistanceSquared ) {\n\n\t\t\t// set the output results\n\t\t\tclosestDistanceSquared = sqDist;\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = normalize( cross( a - b, b - c ) );\n\t\t\tbarycoord = localBarycoord;\n\t\t\toutPoint = closestPoint;\n\t\t\tside = sign( dot( faceNormal, delta ) );\n\n\t\t}\n\n\t}\n\n\treturn closestDistanceSquared;\n\n}\n\nfloat distanceSqToBounds( vec3 point, vec3 boundsMin, vec3 boundsMax ) {\n\n\tvec3 clampedPoint = clamp( point, boundsMin, boundsMax );\n\tvec3 delta = point - clampedPoint;\n\treturn dot( delta, delta );\n\n}\n\nfloat distanceSqToBVHNodeBoundsPoint( vec3 point, sampler2D bvhBounds, uint currNodeIndex ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn distanceSqToBounds( point, boundsMin, boundsMax );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhClosestPointToPoint(\\\n\t\tbvh,\\\n\t\tpoint, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\\\n\t_bvhClosestPointToPoint(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\tpoint, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\n\nfloat _bvhClosestPointToPoint(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// point to check\n\tvec3 point,\n\n\t// output variables\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout vec3 outPoint\n ) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat closestDistanceSquared = pow( 100000.0, 2.0 );\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, currNodeIndex );\n\t\tif ( boundsHitDistance > closestDistanceSquared ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\t\t\tclosestDistanceSquared = distanceToTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count, point, closestDistanceSquared,\n\n\t\t\t\t// outputs\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, outPoint\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\t\t\tbool leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, rightIndex );//rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn sqrt( closestDistanceSquared );\n\n}\n`;\n\n\tconst bvh_ray_functions = /* glsl */`\n\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n// Raycasting\nbool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tdist = max( t0, 0.0 );\n\n\treturn t1 >= dist;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// outputs\n\tinout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nbool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhIntersectFirstHit(\\\n\t\tbvh,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\\\n\t_bvhIntersectFirstHit(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\n\nbool _bvhIntersectFirstHit(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables split into separate variables due to output precision\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = INFINITY;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance;\n\t\tif (\n\t\t\t! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )\n\t\t\t|| boundsHitDistance > triangleDistance\n\t\t) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count,\n\t\t\t\trayOrigin, rayDirection, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n`;\n\n\t// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\n\t// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\n\t// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\n\tconst bvh_struct_definitions = /* glsl */`\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n`;\n\n\tvar BVHShaderGLSL = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tbvh_distance_functions: bvh_distance_functions,\n\t\tbvh_ray_functions: bvh_ray_functions,\n\t\tbvh_struct_definitions: bvh_struct_definitions,\n\t\tcommon_functions: common_functions\n\t});\n\n\tconst shaderStructs = bvh_struct_definitions;\n\tconst shaderDistanceFunction = bvh_distance_functions;\n\tconst shaderIntersectFunction = `\n\t${ common_functions }\n\t${ bvh_ray_functions }\n`;\n\n\texports.AVERAGE = AVERAGE;\n\texports.BVHShaderGLSL = BVHShaderGLSL;\n\texports.CENTER = CENTER;\n\texports.CONTAINED = CONTAINED;\n\texports.ExtendedTriangle = ExtendedTriangle;\n\texports.FloatVertexAttributeTexture = FloatVertexAttributeTexture;\n\texports.INTERSECTED = INTERSECTED;\n\texports.IntVertexAttributeTexture = IntVertexAttributeTexture;\n\texports.MeshBVH = MeshBVH;\n\texports.MeshBVHHelper = MeshBVHHelper;\n\texports.MeshBVHUniformStruct = MeshBVHUniformStruct;\n\texports.NOT_INTERSECTED = NOT_INTERSECTED;\n\texports.OrientedBox = OrientedBox;\n\texports.SAH = SAH;\n\texports.StaticGeometryGenerator = StaticGeometryGenerator;\n\texports.UIntVertexAttributeTexture = UIntVertexAttributeTexture;\n\texports.VertexAttributeTexture = VertexAttributeTexture;\n\texports.acceleratedRaycast = acceleratedRaycast;\n\texports.computeBatchedBoundsTree = computeBatchedBoundsTree;\n\texports.computeBoundsTree = computeBoundsTree;\n\texports.disposeBatchedBoundsTree = disposeBatchedBoundsTree;\n\texports.disposeBoundsTree = disposeBoundsTree;\n\texports.estimateMemoryInBytes = estimateMemoryInBytes;\n\texports.getBVHExtremes = getBVHExtremes;\n\texports.getJSONStructure = getJSONStructure;\n\texports.getTriangleHitPointInfo = getTriangleHitPointInfo;\n\texports.shaderDistanceFunction = shaderDistanceFunction;\n\texports.shaderIntersectFunction = shaderIntersectFunction;\n\texports.shaderStructs = shaderStructs;\n\texports.validateBounds = validateBounds;\n\n}));\n//# sourceMappingURL=index.umd.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvYnVpbGQvaW5kZXgudW1kLmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLENBQUMsS0FBNEQsb0JBQW9CLG1CQUFPLENBQUMseURBQU87QUFDaEcsQ0FBQyxDQUM4STtBQUMvSSxDQUFDLHFDQUFxQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCOztBQUVyQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLG1CQUFtQixpQ0FBaUM7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBELFNBQVM7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCLHNCQUFzQjs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLFFBQVE7O0FBRTdCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixPQUFPOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVU7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix1QkFBdUIsT0FBTzs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDJCQUEyQixVQUFVOztBQUVyQztBQUNBLHdCQUF3QixpQkFBaUI7O0FBRXpDO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCLGlCQUFpQjs7QUFFeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0Esc0JBQXNCLGVBQWU7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixPQUFPOztBQUU5QjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCLFVBQVU7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTs7QUFFMUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0JBQXNCLG1CQUFtQjs7QUFFekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSiwyREFBMkQsV0FBVzs7QUFFdEU7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLFNBQVM7O0FBRXZEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBLHFCQUFxQixPQUFPOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0EscUJBQXFCLE9BQU87O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHFCQUFxQixPQUFPOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsdUVBQXVFLFlBQVk7O0FBRW5GO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87O0FBRXJEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDLFdBQVc7QUFDeEQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87O0FBRTlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFROztBQUU1QixxQkFBcUIsUUFBUTs7QUFFN0Isc0JBQXNCLFFBQVE7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87O0FBRTNCLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87O0FBRTVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTzs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsT0FBTzs7QUFFNUI7QUFDQSx1QkFBdUIsUUFBUTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CLE9BQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFROztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFFBQVE7O0FBRTVCLHFCQUFxQixRQUFROztBQUU3QixzQkFBc0IsUUFBUTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0I7QUFDQSxzQkFBc0IsUUFBUTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPOztBQUUzQixzQkFBc0IsU0FBUzs7QUFFL0IsdUJBQXVCLFNBQVM7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsUUFBUTs7QUFFNUIscUJBQXFCLFFBQVE7O0FBRTdCLHNCQUFzQixRQUFROztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsUUFBUTs7QUFFNUI7QUFDQSxzQkFBc0IsU0FBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHlDQUF5QztBQUNuRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVksMkJBQTJCO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxZQUFZLDJCQUEyQjtBQUN2Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLFVBQVUsNEJBQTRCO0FBQ3RDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87O0FBRTdDO0FBQ0EsV0FBVyxlQUFlO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFVBQVUsNEJBQTRCO0FBQ3RDLDhDQUE4QyxTQUFTOzs7QUFHdkQ7OztBQUdBOztBQUVBOztBQUVBOztBQUVBLFVBQVUsNEJBQTRCO0FBQ3RDO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUzs7QUFFdkQ7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsV0FBVztBQUNyQixVQUFVLFFBQVE7QUFDbEI7QUFDQSw0Q0FBNEMsT0FBTzs7QUFFbkQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPOztBQUU1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsMERBQTBELE9BQU87O0FBRWpFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLE9BQU87O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVLDRCQUE0QjtBQUN0Qyw4Q0FBOEMsU0FBUzs7QUFFdkQ7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUEsVUFBVSw0QkFBNEI7QUFDdEM7QUFDQTtBQUNBLDhDQUE4QyxTQUFTOztBQUV2RDtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLFdBQVc7QUFDckIsVUFBVSxRQUFRO0FBQ2xCO0FBQ0EsNENBQTRDLE9BQU87O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFVBQVUseUNBQXlDO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7O0FBR0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVLHlDQUF5QztBQUNuRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBLElBQUk7O0FBRUosaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsVUFBVSx5Q0FBeUM7QUFDbkQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsNERBQTRELE9BQU87O0FBRW5FO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBLEtBQUs7O0FBRUw7O0FBRUEsMERBQTBELE9BQU87O0FBRWpFO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTOztBQUVsRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7O0FBR0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUE7O0FBRUEsUUFBUTs7QUFFUjs7QUFFQSxtRUFBbUUsU0FBUzs7O0FBRzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxPQUFPOzs7QUFHMUQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxRQUFRO0FBQ1IsUUFBUTs7QUFFUixPQUFPOztBQUVQO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUzs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsT0FBTzs7O0FBR3hEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLE9BQU87O0FBRXJEO0FBQ0Esc0JBQXNCLE9BQU87O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU07O0FBRU47QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixPQUFPOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFVBQVUseUNBQXlDO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFVBQVUseUNBQXlDO0FBQ25EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSTs7QUFFSixpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDs7QUFFbEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVLHlDQUF5QztBQUNuRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRCxPQUFPOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLE9BQU87O0FBRXJEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxRQUFROztBQUVSOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7O0FBRUEsbUVBQW1FLFNBQVM7O0FBRTVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1ELE9BQU87O0FBRTFEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxRQUFRO0FBQ1IsUUFBUTs7QUFFUixPQUFPOztBQUVQO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUzs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsT0FBTzs7QUFFeEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLFFBQVE7O0FBRTlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsUUFBUTs7QUFFcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLCtCQUErQjtBQUMxQyx3Q0FBd0Msd0NBQXdDO0FBQ2hGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE1BQU07O0FBRU47QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0M7O0FBRXRDOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87O0FBRTdDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx1REFBdUQsUUFBUTs7QUFFL0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPOztBQUU3QztBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG9EQUFvRCxTQUFTOztBQUU3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQsU0FBUzs7QUFFOUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxRUFBcUUsZUFBZTs7QUFFcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGNBQWMsV0FBVztBQUN6Qix5QkFBeUIsUUFBUTs7QUFFakM7QUFDQSwwQkFBMEIsUUFBUTs7QUFFbEM7QUFDQSwyQkFBMkIsUUFBUTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0EscUJBQXFCLGlCQUFpQjs7QUFFdEM7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7O0FBRXZDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixnQkFBZ0I7O0FBRXBDLFlBQVksa0VBQWtFOztBQUU5RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLE9BQU87O0FBRWhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQSxPQUFPOztBQUVQOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4Q0FBOEMsT0FBTzs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHlDQUF5QyxPQUFPOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxrREFBa0QsT0FBTzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0Esc0NBQXNDLE9BQU87O0FBRTdDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTs7QUFFQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsOERBQThEOztBQUU5RDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLG9CQUFvQixtQkFBbUI7O0FBRXZDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVzs7QUFFL0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVyxXQUFXO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFdBQVcsMENBQTBDOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87O0FBRXJEO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0I7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixlQUFlOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTzs7QUFFM0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DLE9BQU87O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQyxPQUFPOztBQUVsRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFFBQVE7O0FBRWxEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHlEQUF5RCwwREFBMEQ7O0FBRW5IO0FBQ0EsVUFBVSw4REFBOEQ7O0FBRXhFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUIsdUJBQXVCOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0ZBQStGOztBQUUvRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGdHQUFnRzs7QUFFaEc7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQSxNQUFNOztBQUVOOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLHVCQUF1Qjs7QUFFNUM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCOztBQUU1QztBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGlCQUFpQjs7QUFFeEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87O0FBRWhEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaUNBQWlDLE9BQU87O0FBRXhDOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLFVBQVUsb0JBQW9CO0FBQzlCOztBQUVBLHFDQUFxQyxPQUFPOztBQUU1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTzs7QUFFNUMsc0JBQXNCLGNBQWM7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxNQUFNOztBQUVOLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcscURBQXFEO0FBQ2hFLHVDQUF1QyxPQUFPOztBQUU5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUEsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUwsb0RBQW9ELDJCQUEyQjs7QUFFL0U7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLG1EQUFtRCxPQUFPOztBQUUxRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTzs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLDZKQUE2SjtBQUM3SjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLXN0YXJ0ZXItcHJpc21pYy1taW5pbWFsLy4vbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL2J1aWxkL2luZGV4LnVtZC5janM/NTdmYyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ3RocmVlJykpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICd0aHJlZSddLCBmYWN0b3J5KSA6XG5cdChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLk1lc2hCVkhMaWIgPSBnbG9iYWwuTWVzaEJWSExpYiB8fCB7fSwgZ2xvYmFsLlRIUkVFKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIFRIUkVFKSB7ICd1c2Ugc3RyaWN0JztcblxuXHRmdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZURlZmF1bHQoZSkge1xuXHRcdHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRpZiAoZSkge1xuXHRcdFx0T2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRcdFx0XHRpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG5cdFx0XHRcdFx0dmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG5cdFx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRuLmRlZmF1bHQgPSBlO1xuXHRcdHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xuXHR9XG5cblx0dmFyIFRIUkVFX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KFRIUkVFKTtcblxuXHQvLyBTcGxpdCBzdHJhdGVneSBjb25zdGFudHNcblx0Y29uc3QgQ0VOVEVSID0gMDtcblx0Y29uc3QgQVZFUkFHRSA9IDE7XG5cdGNvbnN0IFNBSCA9IDI7XG5cblx0Ly8gVHJhdmVyc2FsIGNvbnN0YW50c1xuXHRjb25zdCBOT1RfSU5URVJTRUNURUQgPSAwO1xuXHRjb25zdCBJTlRFUlNFQ1RFRCA9IDE7XG5cdGNvbnN0IENPTlRBSU5FRCA9IDI7XG5cblx0Ly8gU0FIIGNvc3QgY29uc3RhbnRzXG5cdC8vIFRPRE86IGhvbmUgdGhlc2UgY29zdHMgbW9yZS4gVGhlIHJlbGF0aXZlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGVtIHNob3VsZCBiZSB0aGVcblx0Ly8gZGlmZmVyZW5jZSBpbiBtZWFzdXJlZCB0aW1lIHRvIHBlcmZvcm0gYSB0cmlhbmdsZSBpbnRlcnNlY3Rpb24gdnMgdHJhdmVyc2luZ1xuXHQvLyBib3VuZHMuXG5cdGNvbnN0IFRSSUFOR0xFX0lOVEVSU0VDVF9DT1NUID0gMS4yNTtcblx0Y29uc3QgVFJBVkVSU0FMX0NPU1QgPSAxO1xuXG5cblx0Ly8gQnVpbGQgY29uc3RhbnRzXG5cdGNvbnN0IEJZVEVTX1BFUl9OT0RFID0gNiAqIDQgKyA0ICsgNDtcblx0Y29uc3QgSVNfTEVBRk5PREVfRkxBRyA9IDB4RkZGRjtcblxuXHQvLyBFUFNJTE9OIGZvciBjb21wdXRpbmcgZmxvYXRpbmcgcG9pbnQgZXJyb3IgZHVyaW5nIGJ1aWxkXG5cdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hY2hpbmVfZXBzaWxvbiNWYWx1ZXNfZm9yX3N0YW5kYXJkX2hhcmR3YXJlX2Zsb2F0aW5nX3BvaW50X2FyaXRobWV0aWNzXG5cdGNvbnN0IEZMT0FUMzJfRVBTSUxPTiA9IE1hdGgucG93KCAyLCAtIDI0ICk7XG5cblx0Y29uc3QgU0tJUF9HRU5FUkFUSU9OID0gU3ltYm9sKCAnU0tJUF9HRU5FUkFUSU9OJyApO1xuXG5cdGZ1bmN0aW9uIGdldFZlcnRleENvdW50KCBnZW8gKSB7XG5cblx0XHRyZXR1cm4gZ2VvLmluZGV4ID8gZ2VvLmluZGV4LmNvdW50IDogZ2VvLmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFRyaUNvdW50KCBnZW8gKSB7XG5cblx0XHRyZXR1cm4gZ2V0VmVydGV4Q291bnQoIGdlbyApIC8gMztcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SW5kZXhBcnJheSggdmVydGV4Q291bnQsIEJ1ZmZlckNvbnN0cnVjdG9yID0gQXJyYXlCdWZmZXIgKSB7XG5cblx0XHRpZiAoIHZlcnRleENvdW50ID4gNjU1MzUgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgVWludDMyQXJyYXkoIG5ldyBCdWZmZXJDb25zdHJ1Y3RvciggNCAqIHZlcnRleENvdW50ICkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBuZXcgVWludDE2QXJyYXkoIG5ldyBCdWZmZXJDb25zdHJ1Y3RvciggMiAqIHZlcnRleENvdW50ICkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gZW5zdXJlcyB0aGF0IGFuIGluZGV4IGlzIHByZXNlbnQgb24gdGhlIGdlb21ldHJ5XG5cdGZ1bmN0aW9uIGVuc3VyZUluZGV4KCBnZW8sIG9wdGlvbnMgKSB7XG5cblx0XHRpZiAoICEgZ2VvLmluZGV4ICkge1xuXG5cdFx0XHRjb25zdCB2ZXJ0ZXhDb3VudCA9IGdlby5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O1xuXHRcdFx0Y29uc3QgQnVmZmVyQ29uc3RydWN0b3IgPSBvcHRpb25zLnVzZVNoYXJlZEFycmF5QnVmZmVyID8gU2hhcmVkQXJyYXlCdWZmZXIgOiBBcnJheUJ1ZmZlcjtcblx0XHRcdGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhBcnJheSggdmVydGV4Q291bnQsIEJ1ZmZlckNvbnN0cnVjdG9yICk7XG5cdFx0XHRnZW8uc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGV4LCAxICkgKTtcblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0aW5kZXhbIGkgXSA9IGk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gQ29tcHV0ZXMgdGhlIHNldCBvZiB7IG9mZnNldCwgY291bnQgfSByYW5nZXMgd2hpY2ggbmVlZCBpbmRlcGVuZGVudCBCVkggcm9vdHMuIEVhY2hcblx0Ly8gcmVnaW9uIGluIHRoZSBnZW9tZXRyeSBpbmRleCB0aGF0IGJlbG9uZ3MgdG8gYSBkaWZmZXJlbnQgc2V0IG9mIG1hdGVyaWFsIGdyb3VwcyByZXF1aXJlc1xuXHQvLyBhIHNlcGFyYXRlIEJWSCByb290LCBzbyB0aGF0IHRyaWFuZ2xlcyBpbmRpY2VzIGJlbG9uZ2luZyB0byBvbmUgZ3JvdXAgbmV2ZXIgZ2V0IHN3YXBwZWRcblx0Ly8gd2l0aCB0cmlhbmdsZSBpbmRpY2VzIGJlbG9uZ3MgdG8gYW5vdGhlciBncm91cC4gRm9yIGV4YW1wbGUsIGlmIHRoZSBncm91cHMgd2VyZSBsaWtlIHRoaXM6XG5cdC8vXG5cdC8vIFstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXVxuXHQvLyB8X19fX19fX19fX19fX19fX19ffFxuXHQvLyAgIGcwID0gWzAsIDIwXSAgfF9fX19fX19fX19fX19fX19fX19fX198fF9fX19fX19fX19fX19fX19fX19fX3xcblx0Ly8gICAgICAgICAgICAgICAgICAgICAgZzEgPSBbMTYsIDQwXSAgICAgICAgICAgZzIgPSBbNDEsIDYwXVxuXHQvL1xuXHQvLyB3ZSB3b3VsZCBuZWVkIGZvdXIgQlZIIHJvb3RzOiBbMCwgMTVdLCBbMTYsIDIwXSwgWzIxLCA0MF0sIFs0MSwgNjBdLlxuXHRmdW5jdGlvbiBnZXRGdWxsR2VvbWV0cnlSYW5nZSggZ2VvLCByYW5nZSApIHtcblxuXHRcdGNvbnN0IHRyaUNvdW50ID0gZ2V0VHJpQ291bnQoIGdlbyApO1xuXHRcdGNvbnN0IGRyYXdSYW5nZSA9IHJhbmdlID8gcmFuZ2UgOiBnZW8uZHJhd1JhbmdlO1xuXHRcdGNvbnN0IHN0YXJ0ID0gZHJhd1JhbmdlLnN0YXJ0IC8gMztcblx0XHRjb25zdCBlbmQgPSAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApIC8gMztcblxuXHRcdGNvbnN0IG9mZnNldCA9IE1hdGgubWF4KCAwLCBzdGFydCApO1xuXHRcdGNvbnN0IGNvdW50ID0gTWF0aC5taW4oIHRyaUNvdW50LCBlbmQgKSAtIG9mZnNldDtcblx0XHRyZXR1cm4gWyB7XG5cdFx0XHRvZmZzZXQ6IE1hdGguZmxvb3IoIG9mZnNldCApLFxuXHRcdFx0Y291bnQ6IE1hdGguZmxvb3IoIGNvdW50ICksXG5cdFx0fSBdO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRSb290SW5kZXhSYW5nZXMoIGdlbywgcmFuZ2UgKSB7XG5cblx0XHRpZiAoICEgZ2VvLmdyb3VwcyB8fCAhIGdlby5ncm91cHMubGVuZ3RoICkge1xuXG5cdFx0XHRyZXR1cm4gZ2V0RnVsbEdlb21ldHJ5UmFuZ2UoIGdlbywgcmFuZ2UgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHJhbmdlcyA9IFtdO1xuXHRcdGNvbnN0IHJhbmdlQm91bmRhcmllcyA9IG5ldyBTZXQoKTtcblxuXHRcdGNvbnN0IGRyYXdSYW5nZSA9IHJhbmdlID8gcmFuZ2UgOiBnZW8uZHJhd1JhbmdlO1xuXHRcdGNvbnN0IGRyYXdSYW5nZVN0YXJ0ID0gZHJhd1JhbmdlLnN0YXJ0IC8gMztcblx0XHRjb25zdCBkcmF3UmFuZ2VFbmQgPSAoIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCApIC8gMztcblx0XHRmb3IgKCBjb25zdCBncm91cCBvZiBnZW8uZ3JvdXBzICkge1xuXG5cdFx0XHRjb25zdCBncm91cFN0YXJ0ID0gZ3JvdXAuc3RhcnQgLyAzO1xuXHRcdFx0Y29uc3QgZ3JvdXBFbmQgPSAoIGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQgKSAvIDM7XG5cdFx0XHRyYW5nZUJvdW5kYXJpZXMuYWRkKCBNYXRoLm1heCggZHJhd1JhbmdlU3RhcnQsIGdyb3VwU3RhcnQgKSApO1xuXHRcdFx0cmFuZ2VCb3VuZGFyaWVzLmFkZCggTWF0aC5taW4oIGRyYXdSYW5nZUVuZCwgZ3JvdXBFbmQgKSApO1xuXG5cdFx0fVxuXG5cblx0XHQvLyBub3RlIHRoYXQgaWYgeW91IGRvbid0IHBhc3MgaW4gYSBjb21wYXJhdG9yLCBpdCBzb3J0cyB0aGVtIGxleGljb2dyYXBoaWNhbGx5IGFzIHN0cmluZ3MgOi0oXG5cdFx0Y29uc3Qgc29ydGVkQm91bmRhcmllcyA9IEFycmF5LmZyb20oIHJhbmdlQm91bmRhcmllcy52YWx1ZXMoKSApLnNvcnQoICggYSwgYiApID0+IGEgLSBiICk7XG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgc29ydGVkQm91bmRhcmllcy5sZW5ndGggLSAxOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBzdGFydCA9IHNvcnRlZEJvdW5kYXJpZXNbIGkgXTtcblx0XHRcdGNvbnN0IGVuZCA9IHNvcnRlZEJvdW5kYXJpZXNbIGkgKyAxIF07XG5cblx0XHRcdHJhbmdlcy5wdXNoKCB7XG5cdFx0XHRcdG9mZnNldDogTWF0aC5mbG9vciggc3RhcnQgKSxcblx0XHRcdFx0Y291bnQ6IE1hdGguZmxvb3IoIGVuZCAtIHN0YXJ0ICksXG5cdFx0XHR9ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmFuZ2VzO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBoYXNHcm91cEdhcHMoIGdlb21ldHJ5LCByYW5nZSApIHtcblxuXHRcdGNvbnN0IHZlcnRleENvdW50ID0gZ2V0VHJpQ291bnQoIGdlb21ldHJ5ICk7XG5cdFx0Y29uc3QgZ3JvdXBzID0gZ2V0Um9vdEluZGV4UmFuZ2VzKCBnZW9tZXRyeSwgcmFuZ2UgKVxuXHRcdFx0LnNvcnQoICggYSwgYiApID0+IGEub2Zmc2V0IC0gYi5vZmZzZXQgKTtcblxuXHRcdGNvbnN0IGZpbmFsR3JvdXAgPSBncm91cHNbIGdyb3Vwcy5sZW5ndGggLSAxIF07XG5cdFx0ZmluYWxHcm91cC5jb3VudCA9IE1hdGgubWluKCB2ZXJ0ZXhDb3VudCAtIGZpbmFsR3JvdXAub2Zmc2V0LCBmaW5hbEdyb3VwLmNvdW50ICk7XG5cblx0XHRsZXQgdG90YWwgPSAwO1xuXHRcdGdyb3Vwcy5mb3JFYWNoKCAoIHsgY291bnQgfSApID0+IHRvdGFsICs9IGNvdW50ICk7XG5cdFx0cmV0dXJuIHZlcnRleENvdW50ICE9PSB0b3RhbDtcblxuXHR9XG5cblx0Ly8gY29tcHV0ZXMgdGhlIHVuaW9uIG9mIHRoZSBib3VuZHMgb2YgYWxsIG9mIHRoZSBnaXZlbiB0cmlhbmdsZXMgYW5kIHB1dHMgdGhlIHJlc3VsdGluZyBib3ggaW4gXCJ0YXJnZXRcIi5cblx0Ly8gQSBib3VuZGluZyBib3ggaXMgY29tcHV0ZWQgZm9yIHRoZSBjZW50cm9pZHMgb2YgdGhlIHRyaWFuZ2xlcywgYXMgd2VsbCwgYW5kIHBsYWNlZCBpbiBcImNlbnRyb2lkVGFyZ2V0XCIuXG5cdC8vIFRoZXNlIGFyZSBjb21wdXRlZCB0b2dldGhlciB0byBhdm9pZCByZWR1bmRhbnQgYWNjZXNzZXMgdG8gYm91bmRzIGFycmF5LlxuXHRmdW5jdGlvbiBnZXRCb3VuZHMoIHRyaWFuZ2xlQm91bmRzLCBvZmZzZXQsIGNvdW50LCB0YXJnZXQsIGNlbnRyb2lkVGFyZ2V0ICkge1xuXG5cdFx0bGV0IG1pbnggPSBJbmZpbml0eTtcblx0XHRsZXQgbWlueSA9IEluZmluaXR5O1xuXHRcdGxldCBtaW56ID0gSW5maW5pdHk7XG5cdFx0bGV0IG1heHggPSAtIEluZmluaXR5O1xuXHRcdGxldCBtYXh5ID0gLSBJbmZpbml0eTtcblx0XHRsZXQgbWF4eiA9IC0gSW5maW5pdHk7XG5cblx0XHRsZXQgY21pbnggPSBJbmZpbml0eTtcblx0XHRsZXQgY21pbnkgPSBJbmZpbml0eTtcblx0XHRsZXQgY21pbnogPSBJbmZpbml0eTtcblx0XHRsZXQgY21heHggPSAtIEluZmluaXR5O1xuXHRcdGxldCBjbWF4eSA9IC0gSW5maW5pdHk7XG5cdFx0bGV0IGNtYXh6ID0gLSBJbmZpbml0eTtcblxuXHRcdGZvciAoIGxldCBpID0gb2Zmc2V0ICogNiwgZW5kID0gKCBvZmZzZXQgKyBjb3VudCApICogNjsgaSA8IGVuZDsgaSArPSA2ICkge1xuXG5cdFx0XHRjb25zdCBjeCA9IHRyaWFuZ2xlQm91bmRzWyBpICsgMCBdO1xuXHRcdFx0Y29uc3QgaHggPSB0cmlhbmdsZUJvdW5kc1sgaSArIDEgXTtcblx0XHRcdGNvbnN0IGx4ID0gY3ggLSBoeDtcblx0XHRcdGNvbnN0IHJ4ID0gY3ggKyBoeDtcblx0XHRcdGlmICggbHggPCBtaW54ICkgbWlueCA9IGx4O1xuXHRcdFx0aWYgKCByeCA+IG1heHggKSBtYXh4ID0gcng7XG5cdFx0XHRpZiAoIGN4IDwgY21pbnggKSBjbWlueCA9IGN4O1xuXHRcdFx0aWYgKCBjeCA+IGNtYXh4ICkgY21heHggPSBjeDtcblxuXHRcdFx0Y29uc3QgY3kgPSB0cmlhbmdsZUJvdW5kc1sgaSArIDIgXTtcblx0XHRcdGNvbnN0IGh5ID0gdHJpYW5nbGVCb3VuZHNbIGkgKyAzIF07XG5cdFx0XHRjb25zdCBseSA9IGN5IC0gaHk7XG5cdFx0XHRjb25zdCByeSA9IGN5ICsgaHk7XG5cdFx0XHRpZiAoIGx5IDwgbWlueSApIG1pbnkgPSBseTtcblx0XHRcdGlmICggcnkgPiBtYXh5ICkgbWF4eSA9IHJ5O1xuXHRcdFx0aWYgKCBjeSA8IGNtaW55ICkgY21pbnkgPSBjeTtcblx0XHRcdGlmICggY3kgPiBjbWF4eSApIGNtYXh5ID0gY3k7XG5cblx0XHRcdGNvbnN0IGN6ID0gdHJpYW5nbGVCb3VuZHNbIGkgKyA0IF07XG5cdFx0XHRjb25zdCBoeiA9IHRyaWFuZ2xlQm91bmRzWyBpICsgNSBdO1xuXHRcdFx0Y29uc3QgbHogPSBjeiAtIGh6O1xuXHRcdFx0Y29uc3QgcnogPSBjeiArIGh6O1xuXHRcdFx0aWYgKCBseiA8IG1pbnogKSBtaW56ID0gbHo7XG5cdFx0XHRpZiAoIHJ6ID4gbWF4eiApIG1heHogPSByejtcblx0XHRcdGlmICggY3ogPCBjbWlueiApIGNtaW56ID0gY3o7XG5cdFx0XHRpZiAoIGN6ID4gY21heHogKSBjbWF4eiA9IGN6O1xuXG5cdFx0fVxuXG5cdFx0dGFyZ2V0WyAwIF0gPSBtaW54O1xuXHRcdHRhcmdldFsgMSBdID0gbWlueTtcblx0XHR0YXJnZXRbIDIgXSA9IG1pbno7XG5cblx0XHR0YXJnZXRbIDMgXSA9IG1heHg7XG5cdFx0dGFyZ2V0WyA0IF0gPSBtYXh5O1xuXHRcdHRhcmdldFsgNSBdID0gbWF4ejtcblxuXHRcdGNlbnRyb2lkVGFyZ2V0WyAwIF0gPSBjbWlueDtcblx0XHRjZW50cm9pZFRhcmdldFsgMSBdID0gY21pbnk7XG5cdFx0Y2VudHJvaWRUYXJnZXRbIDIgXSA9IGNtaW56O1xuXG5cdFx0Y2VudHJvaWRUYXJnZXRbIDMgXSA9IGNtYXh4O1xuXHRcdGNlbnRyb2lkVGFyZ2V0WyA0IF0gPSBjbWF4eTtcblx0XHRjZW50cm9pZFRhcmdldFsgNSBdID0gY21heHo7XG5cblx0fVxuXG5cdC8vIHByZWNvbXB1dGVzIHRoZSBib3VuZGluZyBib3ggZm9yIGVhY2ggdHJpYW5nbGU7IHJlcXVpcmVkIGZvciBxdWlja2x5IGNhbGN1bGF0aW5nIHRyZWUgc3BsaXRzLlxuXHQvLyByZXN1bHQgaXMgYW4gYXJyYXkgb2Ygc2l6ZSB0cmlzLmxlbmd0aCAqIDYgd2hlcmUgdHJpYW5nbGUgaSBtYXBzIHRvIGFcblx0Ly8gW3hfY2VudGVyLCB4X2RlbHRhLCB5X2NlbnRlciwgeV9kZWx0YSwgel9jZW50ZXIsIHpfZGVsdGFdIHR1cGxlIHN0YXJ0aW5nIGF0IGluZGV4IGkgKiA2LFxuXHQvLyByZXByZXNlbnRpbmcgdGhlIGNlbnRlciBhbmQgaGFsZi1leHRlbnQgaW4gZWFjaCBkaW1lbnNpb24gb2YgdHJpYW5nbGUgaVxuXHRmdW5jdGlvbiBjb21wdXRlVHJpYW5nbGVCb3VuZHMoIGdlbywgdGFyZ2V0ID0gbnVsbCwgb2Zmc2V0ID0gbnVsbCwgY291bnQgPSBudWxsICkge1xuXG5cdFx0Y29uc3QgcG9zQXR0ciA9IGdlby5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGNvbnN0IGluZGV4ID0gZ2VvLmluZGV4ID8gZ2VvLmluZGV4LmFycmF5IDogbnVsbDtcblx0XHRjb25zdCB0cmlDb3VudCA9IGdldFRyaUNvdW50KCBnZW8gKTtcblx0XHRjb25zdCBub3JtYWxpemVkID0gcG9zQXR0ci5ub3JtYWxpemVkO1xuXHRcdGxldCB0cmlhbmdsZUJvdW5kcztcblx0XHRpZiAoIHRhcmdldCA9PT0gbnVsbCApIHtcblxuXHRcdFx0dHJpYW5nbGVCb3VuZHMgPSBuZXcgRmxvYXQzMkFycmF5KCB0cmlDb3VudCAqIDYgKiA0ICk7XG5cdFx0XHRvZmZzZXQgPSAwO1xuXHRcdFx0Y291bnQgPSB0cmlDb3VudDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRyaWFuZ2xlQm91bmRzID0gdGFyZ2V0O1xuXHRcdFx0b2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cdFx0XHRjb3VudCA9IGNvdW50IHx8IHRyaUNvdW50O1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXNlZCBmb3Igbm9uLW5vcm1hbGl6ZWQgcG9zaXRpb25zXG5cdFx0Y29uc3QgcG9zQXJyID0gcG9zQXR0ci5hcnJheTtcblxuXHRcdC8vIHN1cHBvcnQgZm9yIGFuIGludGVybGVhdmVkIHBvc2l0aW9uIGJ1ZmZlclxuXHRcdGNvbnN0IGJ1ZmZlck9mZnNldCA9IHBvc0F0dHIub2Zmc2V0IHx8IDA7XG5cdFx0bGV0IHN0cmlkZSA9IDM7XG5cdFx0aWYgKCBwb3NBdHRyLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdHN0cmlkZSA9IHBvc0F0dHIuZGF0YS5zdHJpZGU7XG5cblx0XHR9XG5cblx0XHQvLyB1c2VkIGZvciBub3JtYWxpemVkIHBvc2l0aW9uc1xuXHRcdGNvbnN0IGdldHRlcnMgPSBbICdnZXRYJywgJ2dldFknLCAnZ2V0WicgXTtcblxuXHRcdGZvciAoIGxldCB0cmkgPSBvZmZzZXQ7IHRyaSA8IG9mZnNldCArIGNvdW50OyB0cmkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHRyaTMgPSB0cmkgKiAzO1xuXHRcdFx0Y29uc3QgdHJpNiA9IHRyaSAqIDY7XG5cblx0XHRcdGxldCBhaSA9IHRyaTMgKyAwO1xuXHRcdFx0bGV0IGJpID0gdHJpMyArIDE7XG5cdFx0XHRsZXQgY2kgPSB0cmkzICsgMjtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblxuXHRcdFx0XHRhaSA9IGluZGV4WyBhaSBdO1xuXHRcdFx0XHRiaSA9IGluZGV4WyBiaSBdO1xuXHRcdFx0XHRjaSA9IGluZGV4WyBjaSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHdlIGFkZCB0aGUgc3RyaWRlIGFuZCBvZmZzZXQgaGVyZSBzaW5jZSB3ZSBhY2Nlc3MgdGhlIGFycmF5IGRpcmVjdGx5XG5cdFx0XHQvLyBiZWxvdyBmb3IgdGhlIHNha2Ugb2YgcGVyZm9ybWFuY2Vcblx0XHRcdGlmICggISBub3JtYWxpemVkICkge1xuXG5cdFx0XHRcdGFpID0gYWkgKiBzdHJpZGUgKyBidWZmZXJPZmZzZXQ7XG5cdFx0XHRcdGJpID0gYmkgKiBzdHJpZGUgKyBidWZmZXJPZmZzZXQ7XG5cdFx0XHRcdGNpID0gY2kgKiBzdHJpZGUgKyBidWZmZXJPZmZzZXQ7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IGVsID0gMDsgZWwgPCAzOyBlbCArKyApIHtcblxuXHRcdFx0XHRsZXQgYSwgYiwgYztcblxuXHRcdFx0XHRpZiAoIG5vcm1hbGl6ZWQgKSB7XG5cblx0XHRcdFx0XHRhID0gcG9zQXR0clsgZ2V0dGVyc1sgZWwgXSBdKCBhaSApO1xuXHRcdFx0XHRcdGIgPSBwb3NBdHRyWyBnZXR0ZXJzWyBlbCBdIF0oIGJpICk7XG5cdFx0XHRcdFx0YyA9IHBvc0F0dHJbIGdldHRlcnNbIGVsIF0gXSggY2kgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0YSA9IHBvc0FyclsgYWkgKyBlbCBdO1xuXHRcdFx0XHRcdGIgPSBwb3NBcnJbIGJpICsgZWwgXTtcblx0XHRcdFx0XHRjID0gcG9zQXJyWyBjaSArIGVsIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBtaW4gPSBhO1xuXHRcdFx0XHRpZiAoIGIgPCBtaW4gKSBtaW4gPSBiO1xuXHRcdFx0XHRpZiAoIGMgPCBtaW4gKSBtaW4gPSBjO1xuXG5cdFx0XHRcdGxldCBtYXggPSBhO1xuXHRcdFx0XHRpZiAoIGIgPiBtYXggKSBtYXggPSBiO1xuXHRcdFx0XHRpZiAoIGMgPiBtYXggKSBtYXggPSBjO1xuXG5cdFx0XHRcdC8vIEluY3JlYXNlIHRoZSBib3VuZHMgc2l6ZSBieSBmbG9hdDMyIGVwc2lsb24gdG8gYXZvaWQgcHJlY2lzaW9uIGVycm9ycyB3aGVuXG5cdFx0XHRcdC8vIGNvbnZlcnRpbmcgdG8gMzIgYml0IGZsb2F0LiBTY2FsZSB0aGUgZXBzaWxvbiBieSB0aGUgc2l6ZSBvZiB0aGUgbnVtYmVycyBiZWluZ1xuXHRcdFx0XHQvLyB3b3JrZWQgd2l0aC5cblx0XHRcdFx0Y29uc3QgaGFsZkV4dGVudHMgPSAoIG1heCAtIG1pbiApIC8gMjtcblx0XHRcdFx0Y29uc3QgZWwyID0gZWwgKiAyO1xuXHRcdFx0XHR0cmlhbmdsZUJvdW5kc1sgdHJpNiArIGVsMiArIDAgXSA9IG1pbiArIGhhbGZFeHRlbnRzO1xuXHRcdFx0XHR0cmlhbmdsZUJvdW5kc1sgdHJpNiArIGVsMiArIDEgXSA9IGhhbGZFeHRlbnRzICsgKCBNYXRoLmFicyggbWluICkgKyBoYWxmRXh0ZW50cyApICogRkxPQVQzMl9FUFNJTE9OO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJpYW5nbGVCb3VuZHM7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGFycmF5VG9Cb3goIG5vZGVJbmRleDMyLCBhcnJheSwgdGFyZ2V0ICkge1xuXG5cdFx0dGFyZ2V0Lm1pbi54ID0gYXJyYXlbIG5vZGVJbmRleDMyIF07XG5cdFx0dGFyZ2V0Lm1pbi55ID0gYXJyYXlbIG5vZGVJbmRleDMyICsgMSBdO1xuXHRcdHRhcmdldC5taW4ueiA9IGFycmF5WyBub2RlSW5kZXgzMiArIDIgXTtcblxuXHRcdHRhcmdldC5tYXgueCA9IGFycmF5WyBub2RlSW5kZXgzMiArIDMgXTtcblx0XHR0YXJnZXQubWF4LnkgPSBhcnJheVsgbm9kZUluZGV4MzIgKyA0IF07XG5cdFx0dGFyZ2V0Lm1heC56ID0gYXJyYXlbIG5vZGVJbmRleDMyICsgNSBdO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZUVtcHR5Qm91bmRzKCB0YXJnZXQgKSB7XG5cblx0XHR0YXJnZXRbIDAgXSA9IHRhcmdldFsgMSBdID0gdGFyZ2V0WyAyIF0gPSBJbmZpbml0eTtcblx0XHR0YXJnZXRbIDMgXSA9IHRhcmdldFsgNCBdID0gdGFyZ2V0WyA1IF0gPSAtIEluZmluaXR5O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRMb25nZXN0RWRnZUluZGV4KCBib3VuZHMgKSB7XG5cblx0XHRsZXQgc3BsaXREaW1JZHggPSAtIDE7XG5cdFx0bGV0IHNwbGl0RGlzdCA9IC0gSW5maW5pdHk7XG5cblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBkaXN0ID0gYm91bmRzWyBpICsgMyBdIC0gYm91bmRzWyBpIF07XG5cdFx0XHRpZiAoIGRpc3QgPiBzcGxpdERpc3QgKSB7XG5cblx0XHRcdFx0c3BsaXREaXN0ID0gZGlzdDtcblx0XHRcdFx0c3BsaXREaW1JZHggPSBpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gc3BsaXREaW1JZHg7XG5cblx0fVxuXG5cdC8vIGNvcGllcyBib3VuZHMgYSBpbnRvIGJvdW5kcyBiXG5cdGZ1bmN0aW9uIGNvcHlCb3VuZHMoIHNvdXJjZSwgdGFyZ2V0ICkge1xuXG5cdFx0dGFyZ2V0LnNldCggc291cmNlICk7XG5cblx0fVxuXG5cdC8vIHNldHMgYm91bmRzIHRhcmdldCB0byB0aGUgdW5pb24gb2YgYm91bmRzIGEgYW5kIGJcblx0ZnVuY3Rpb24gdW5pb25Cb3VuZHMoIGEsIGIsIHRhcmdldCApIHtcblxuXHRcdGxldCBhVmFsLCBiVmFsO1xuXHRcdGZvciAoIGxldCBkID0gMDsgZCA8IDM7IGQgKysgKSB7XG5cblx0XHRcdGNvbnN0IGQzID0gZCArIDM7XG5cblx0XHRcdC8vIHNldCB0aGUgbWluaW11bSB2YWx1ZXNcblx0XHRcdGFWYWwgPSBhWyBkIF07XG5cdFx0XHRiVmFsID0gYlsgZCBdO1xuXHRcdFx0dGFyZ2V0WyBkIF0gPSBhVmFsIDwgYlZhbCA/IGFWYWwgOiBiVmFsO1xuXG5cdFx0XHQvLyBzZXQgdGhlIG1heCB2YWx1ZXNcblx0XHRcdGFWYWwgPSBhWyBkMyBdO1xuXHRcdFx0YlZhbCA9IGJbIGQzIF07XG5cdFx0XHR0YXJnZXRbIGQzIF0gPSBhVmFsID4gYlZhbCA/IGFWYWwgOiBiVmFsO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBleHBhbmRzIHRoZSBnaXZlbiBib3VuZHMgYnkgdGhlIHByb3ZpZGVkIHRyaWFuZ2xlIGJvdW5kc1xuXHRmdW5jdGlvbiBleHBhbmRCeVRyaWFuZ2xlQm91bmRzKCBzdGFydEluZGV4LCB0cmlhbmdsZUJvdW5kcywgYm91bmRzICkge1xuXG5cdFx0Zm9yICggbGV0IGQgPSAwOyBkIDwgMzsgZCArKyApIHtcblxuXHRcdFx0Y29uc3QgdENlbnRlciA9IHRyaWFuZ2xlQm91bmRzWyBzdGFydEluZGV4ICsgMiAqIGQgXTtcblx0XHRcdGNvbnN0IHRIYWxmID0gdHJpYW5nbGVCb3VuZHNbIHN0YXJ0SW5kZXggKyAyICogZCArIDEgXTtcblxuXHRcdFx0Y29uc3QgdE1pbiA9IHRDZW50ZXIgLSB0SGFsZjtcblx0XHRcdGNvbnN0IHRNYXggPSB0Q2VudGVyICsgdEhhbGY7XG5cblx0XHRcdGlmICggdE1pbiA8IGJvdW5kc1sgZCBdICkge1xuXG5cdFx0XHRcdGJvdW5kc1sgZCBdID0gdE1pbjtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRNYXggPiBib3VuZHNbIGQgKyAzIF0gKSB7XG5cblx0XHRcdFx0Ym91bmRzWyBkICsgMyBdID0gdE1heDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBjb21wdXRlIGJvdW5kcyBzdXJmYWNlIGFyZWFcblx0ZnVuY3Rpb24gY29tcHV0ZVN1cmZhY2VBcmVhKCBib3VuZHMgKSB7XG5cblx0XHRjb25zdCBkMCA9IGJvdW5kc1sgMyBdIC0gYm91bmRzWyAwIF07XG5cdFx0Y29uc3QgZDEgPSBib3VuZHNbIDQgXSAtIGJvdW5kc1sgMSBdO1xuXHRcdGNvbnN0IGQyID0gYm91bmRzWyA1IF0gLSBib3VuZHNbIDIgXTtcblxuXHRcdHJldHVybiAyICogKCBkMCAqIGQxICsgZDEgKiBkMiArIGQyICogZDAgKTtcblxuXHR9XG5cblx0Y29uc3QgQklOX0NPVU5UID0gMzI7XG5cdGNvbnN0IGJpbnNTb3J0ID0gKCBhLCBiICkgPT4gYS5jYW5kaWRhdGUgLSBiLmNhbmRpZGF0ZTtcblx0Y29uc3Qgc2FoQmlucyA9IG5ldyBBcnJheSggQklOX0NPVU5UICkuZmlsbCgpLm1hcCggKCkgPT4ge1xuXG5cdFx0cmV0dXJuIHtcblxuXHRcdFx0Y291bnQ6IDAsXG5cdFx0XHRib3VuZHM6IG5ldyBGbG9hdDMyQXJyYXkoIDYgKSxcblx0XHRcdHJpZ2h0Q2FjaGVCb3VuZHM6IG5ldyBGbG9hdDMyQXJyYXkoIDYgKSxcblx0XHRcdGxlZnRDYWNoZUJvdW5kczogbmV3IEZsb2F0MzJBcnJheSggNiApLFxuXHRcdFx0Y2FuZGlkYXRlOiAwLFxuXG5cdFx0fTtcblxuXHR9ICk7XG5cdGNvbnN0IGxlZnRCb3VuZHMgPSBuZXcgRmxvYXQzMkFycmF5KCA2ICk7XG5cblx0ZnVuY3Rpb24gZ2V0T3B0aW1hbFNwbGl0KCBub2RlQm91bmRpbmdEYXRhLCBjZW50cm9pZEJvdW5kaW5nRGF0YSwgdHJpYW5nbGVCb3VuZHMsIG9mZnNldCwgY291bnQsIHN0cmF0ZWd5ICkge1xuXG5cdFx0bGV0IGF4aXMgPSAtIDE7XG5cdFx0bGV0IHBvcyA9IDA7XG5cblx0XHQvLyBDZW50ZXJcblx0XHRpZiAoIHN0cmF0ZWd5ID09PSBDRU5URVIgKSB7XG5cblx0XHRcdGF4aXMgPSBnZXRMb25nZXN0RWRnZUluZGV4KCBjZW50cm9pZEJvdW5kaW5nRGF0YSApO1xuXHRcdFx0aWYgKCBheGlzICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0cG9zID0gKCBjZW50cm9pZEJvdW5kaW5nRGF0YVsgYXhpcyBdICsgY2VudHJvaWRCb3VuZGluZ0RhdGFbIGF4aXMgKyAzIF0gKSAvIDI7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHN0cmF0ZWd5ID09PSBBVkVSQUdFICkge1xuXG5cdFx0XHRheGlzID0gZ2V0TG9uZ2VzdEVkZ2VJbmRleCggbm9kZUJvdW5kaW5nRGF0YSApO1xuXHRcdFx0aWYgKCBheGlzICE9PSAtIDEgKSB7XG5cblx0XHRcdFx0cG9zID0gZ2V0QXZlcmFnZSggdHJpYW5nbGVCb3VuZHMsIG9mZnNldCwgY291bnQsIGF4aXMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggc3RyYXRlZ3kgPT09IFNBSCApIHtcblxuXHRcdFx0Y29uc3Qgcm9vdFN1cmZhY2VBcmVhID0gY29tcHV0ZVN1cmZhY2VBcmVhKCBub2RlQm91bmRpbmdEYXRhICk7XG5cdFx0XHRsZXQgYmVzdENvc3QgPSBUUklBTkdMRV9JTlRFUlNFQ1RfQ09TVCAqIGNvdW50O1xuXG5cdFx0XHQvLyBpdGVyYXRlIG92ZXIgYWxsIGF4ZXNcblx0XHRcdGNvbnN0IGNTdGFydCA9IG9mZnNldCAqIDY7XG5cdFx0XHRjb25zdCBjRW5kID0gKCBvZmZzZXQgKyBjb3VudCApICogNjtcblx0XHRcdGZvciAoIGxldCBhID0gMDsgYSA8IDM7IGEgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYXhpc0xlZnQgPSBjZW50cm9pZEJvdW5kaW5nRGF0YVsgYSBdO1xuXHRcdFx0XHRjb25zdCBheGlzUmlnaHQgPSBjZW50cm9pZEJvdW5kaW5nRGF0YVsgYSArIDMgXTtcblx0XHRcdFx0Y29uc3QgYXhpc0xlbmd0aCA9IGF4aXNSaWdodCAtIGF4aXNMZWZ0O1xuXHRcdFx0XHRjb25zdCBiaW5XaWR0aCA9IGF4aXNMZW5ndGggLyBCSU5fQ09VTlQ7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBmZXdlciB0cmlhbmdsZXMgdGhhbiB3ZSdyZSBwbGFubmluZyB0byBzcGxpdCB0aGVuIGp1c3QgY2hlY2sgYWxsXG5cdFx0XHRcdC8vIHRoZSB0cmlhbmdsZSBwb3NpdGlvbnMgYmVjYXVzZSBpdCB3aWxsIGJlIGZhc3Rlci5cblx0XHRcdFx0aWYgKCBjb3VudCA8IEJJTl9DT1VOVCAvIDQgKSB7XG5cblx0XHRcdFx0XHQvLyBpbml0aWFsaXplIHRoZSBiaW4gY2FuZGlkYXRlc1xuXHRcdFx0XHRcdGNvbnN0IHRydW5jYXRlZEJpbnMgPSBbIC4uLnNhaEJpbnMgXTtcblx0XHRcdFx0XHR0cnVuY2F0ZWRCaW5zLmxlbmd0aCA9IGNvdW50O1xuXG5cdFx0XHRcdFx0Ly8gc2V0IHRoZSBjYW5kaWRhdGVzXG5cdFx0XHRcdFx0bGV0IGIgPSAwO1xuXHRcdFx0XHRcdGZvciAoIGxldCBjID0gY1N0YXJ0OyBjIDwgY0VuZDsgYyArPSA2LCBiICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBiaW4gPSB0cnVuY2F0ZWRCaW5zWyBiIF07XG5cdFx0XHRcdFx0XHRiaW4uY2FuZGlkYXRlID0gdHJpYW5nbGVCb3VuZHNbIGMgKyAyICogYSBdO1xuXHRcdFx0XHRcdFx0YmluLmNvdW50ID0gMDtcblxuXHRcdFx0XHRcdFx0Y29uc3Qge1xuXHRcdFx0XHRcdFx0XHRib3VuZHMsXG5cdFx0XHRcdFx0XHRcdGxlZnRDYWNoZUJvdW5kcyxcblx0XHRcdFx0XHRcdFx0cmlnaHRDYWNoZUJvdW5kcyxcblx0XHRcdFx0XHRcdH0gPSBiaW47XG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgZCA9IDA7IGQgPCAzOyBkICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHJpZ2h0Q2FjaGVCb3VuZHNbIGQgXSA9IEluZmluaXR5O1xuXHRcdFx0XHRcdFx0XHRyaWdodENhY2hlQm91bmRzWyBkICsgMyBdID0gLSBJbmZpbml0eTtcblxuXHRcdFx0XHRcdFx0XHRsZWZ0Q2FjaGVCb3VuZHNbIGQgXSA9IEluZmluaXR5O1xuXHRcdFx0XHRcdFx0XHRsZWZ0Q2FjaGVCb3VuZHNbIGQgKyAzIF0gPSAtIEluZmluaXR5O1xuXG5cdFx0XHRcdFx0XHRcdGJvdW5kc1sgZCBdID0gSW5maW5pdHk7XG5cdFx0XHRcdFx0XHRcdGJvdW5kc1sgZCArIDMgXSA9IC0gSW5maW5pdHk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZXhwYW5kQnlUcmlhbmdsZUJvdW5kcyggYywgdHJpYW5nbGVCb3VuZHMsIGJvdW5kcyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dHJ1bmNhdGVkQmlucy5zb3J0KCBiaW5zU29ydCApO1xuXG5cdFx0XHRcdFx0Ly8gcmVtb3ZlIHJlZHVuZGFudCBzcGxpdHNcblx0XHRcdFx0XHRsZXQgc3BsaXRDb3VudCA9IGNvdW50O1xuXHRcdFx0XHRcdGZvciAoIGxldCBiaSA9IDA7IGJpIDwgc3BsaXRDb3VudDsgYmkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGJpbiA9IHRydW5jYXRlZEJpbnNbIGJpIF07XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGJpICsgMSA8IHNwbGl0Q291bnQgJiYgdHJ1bmNhdGVkQmluc1sgYmkgKyAxIF0uY2FuZGlkYXRlID09PSBiaW4uY2FuZGlkYXRlICkge1xuXG5cdFx0XHRcdFx0XHRcdHRydW5jYXRlZEJpbnMuc3BsaWNlKCBiaSArIDEsIDEgKTtcblx0XHRcdFx0XHRcdFx0c3BsaXRDb3VudCAtLTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gZmluZCB0aGUgYXBwcm9wcmlhdGUgYmluIGZvciBlYWNoIHRyaWFuZ2xlIGFuZCBleHBhbmQgdGhlIGJvdW5kcy5cblx0XHRcdFx0XHRmb3IgKCBsZXQgYyA9IGNTdGFydDsgYyA8IGNFbmQ7IGMgKz0gNiApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgY2VudGVyID0gdHJpYW5nbGVCb3VuZHNbIGMgKyAyICogYSBdO1xuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGJpID0gMDsgYmkgPCBzcGxpdENvdW50OyBiaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBiaW4gPSB0cnVuY2F0ZWRCaW5zWyBiaSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNlbnRlciA+PSBiaW4uY2FuZGlkYXRlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0ZXhwYW5kQnlUcmlhbmdsZUJvdW5kcyggYywgdHJpYW5nbGVCb3VuZHMsIGJpbi5yaWdodENhY2hlQm91bmRzICk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdGV4cGFuZEJ5VHJpYW5nbGVCb3VuZHMoIGMsIHRyaWFuZ2xlQm91bmRzLCBiaW4ubGVmdENhY2hlQm91bmRzICk7XG5cdFx0XHRcdFx0XHRcdFx0YmluLmNvdW50ICsrO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gZXhwYW5kIGFsbCB0aGUgYm91bmRzXG5cdFx0XHRcdFx0Zm9yICggbGV0IGJpID0gMDsgYmkgPCBzcGxpdENvdW50OyBiaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYmluID0gdHJ1bmNhdGVkQmluc1sgYmkgXTtcblx0XHRcdFx0XHRcdGNvbnN0IGxlZnRDb3VudCA9IGJpbi5jb3VudDtcblx0XHRcdFx0XHRcdGNvbnN0IHJpZ2h0Q291bnQgPSBjb3VudCAtIGJpbi5jb3VudDtcblxuXHRcdFx0XHRcdFx0Ly8gY2hlY2sgdGhlIGNvc3Qgb2YgdGhpcyBzcGxpdFxuXHRcdFx0XHRcdFx0Y29uc3QgbGVmdEJvdW5kcyA9IGJpbi5sZWZ0Q2FjaGVCb3VuZHM7XG5cdFx0XHRcdFx0XHRjb25zdCByaWdodEJvdW5kcyA9IGJpbi5yaWdodENhY2hlQm91bmRzO1xuXG5cdFx0XHRcdFx0XHRsZXQgbGVmdFByb2IgPSAwO1xuXHRcdFx0XHRcdFx0aWYgKCBsZWZ0Q291bnQgIT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0bGVmdFByb2IgPSBjb21wdXRlU3VyZmFjZUFyZWEoIGxlZnRCb3VuZHMgKSAvIHJvb3RTdXJmYWNlQXJlYTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRsZXQgcmlnaHRQcm9iID0gMDtcblx0XHRcdFx0XHRcdGlmICggcmlnaHRDb3VudCAhPT0gMCApIHtcblxuXHRcdFx0XHRcdFx0XHRyaWdodFByb2IgPSBjb21wdXRlU3VyZmFjZUFyZWEoIHJpZ2h0Qm91bmRzICkgLyByb290U3VyZmFjZUFyZWE7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc3QgY29zdCA9IFRSQVZFUlNBTF9DT1NUICsgVFJJQU5HTEVfSU5URVJTRUNUX0NPU1QgKiAoXG5cdFx0XHRcdFx0XHRcdGxlZnRQcm9iICogbGVmdENvdW50ICsgcmlnaHRQcm9iICogcmlnaHRDb3VudFxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0aWYgKCBjb3N0IDwgYmVzdENvc3QgKSB7XG5cblx0XHRcdFx0XHRcdFx0YXhpcyA9IGE7XG5cdFx0XHRcdFx0XHRcdGJlc3RDb3N0ID0gY29zdDtcblx0XHRcdFx0XHRcdFx0cG9zID0gYmluLmNhbmRpZGF0ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyByZXNldCB0aGUgYmluc1xuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IEJJTl9DT1VOVDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYmluID0gc2FoQmluc1sgaSBdO1xuXHRcdFx0XHRcdFx0YmluLmNvdW50ID0gMDtcblx0XHRcdFx0XHRcdGJpbi5jYW5kaWRhdGUgPSBheGlzTGVmdCArIGJpbldpZHRoICsgaSAqIGJpbldpZHRoO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBib3VuZHMgPSBiaW4uYm91bmRzO1xuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGQgPSAwOyBkIDwgMzsgZCArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRib3VuZHNbIGQgXSA9IEluZmluaXR5O1xuXHRcdFx0XHRcdFx0XHRib3VuZHNbIGQgKyAzIF0gPSAtIEluZmluaXR5O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBpdGVyYXRlIG92ZXIgYWxsIGNlbnRlciBwb3NpdGlvbnNcblx0XHRcdFx0XHRmb3IgKCBsZXQgYyA9IGNTdGFydDsgYyA8IGNFbmQ7IGMgKz0gNiApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgdHJpQ2VudGVyID0gdHJpYW5nbGVCb3VuZHNbIGMgKyAyICogYSBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgcmVsYXRpdmVDZW50ZXIgPSB0cmlDZW50ZXIgLSBheGlzTGVmdDtcblxuXHRcdFx0XHRcdFx0Ly8gaW4gdGhlIHBhcnRpdGlvbiBmdW5jdGlvbiBpZiB0aGUgY2VudHJvaWQgbGllcyBvbiB0aGUgc3BsaXQgcGxhbmUgdGhlbiBpdCBpc1xuXHRcdFx0XHRcdFx0Ly8gY29uc2lkZXJlZCB0byBiZSBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgc3BsaXRcblx0XHRcdFx0XHRcdGxldCBiaW5JbmRleCA9IH4gfiAoIHJlbGF0aXZlQ2VudGVyIC8gYmluV2lkdGggKTtcblx0XHRcdFx0XHRcdGlmICggYmluSW5kZXggPj0gQklOX0NPVU5UICkgYmluSW5kZXggPSBCSU5fQ09VTlQgLSAxO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBiaW4gPSBzYWhCaW5zWyBiaW5JbmRleCBdO1xuXHRcdFx0XHRcdFx0YmluLmNvdW50ICsrO1xuXG5cdFx0XHRcdFx0XHRleHBhbmRCeVRyaWFuZ2xlQm91bmRzKCBjLCB0cmlhbmdsZUJvdW5kcywgYmluLmJvdW5kcyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gY2FjaGUgdGhlIHVuaW9uZWQgYm91bmRzIGZyb20gcmlnaHQgdG8gbGVmdCBzbyB3ZSBkb24ndCBoYXZlIHRvIHJlZ2VuZXJhdGUgdGhlbSBlYWNoIHRpbWVcblx0XHRcdFx0XHRjb25zdCBsYXN0QmluID0gc2FoQmluc1sgQklOX0NPVU5UIC0gMSBdO1xuXHRcdFx0XHRcdGNvcHlCb3VuZHMoIGxhc3RCaW4uYm91bmRzLCBsYXN0QmluLnJpZ2h0Q2FjaGVCb3VuZHMgKTtcblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IEJJTl9DT1VOVCAtIDI7IGkgPj0gMDsgaSAtLSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYmluID0gc2FoQmluc1sgaSBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgbmV4dEJpbiA9IHNhaEJpbnNbIGkgKyAxIF07XG5cdFx0XHRcdFx0XHR1bmlvbkJvdW5kcyggYmluLmJvdW5kcywgbmV4dEJpbi5yaWdodENhY2hlQm91bmRzLCBiaW4ucmlnaHRDYWNoZUJvdW5kcyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGV0IGxlZnRDb3VudCA9IDA7XG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgQklOX0NPVU5UIC0gMTsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYmluID0gc2FoQmluc1sgaSBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgYmluQ291bnQgPSBiaW4uY291bnQ7XG5cdFx0XHRcdFx0XHRjb25zdCBib3VuZHMgPSBiaW4uYm91bmRzO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBuZXh0QmluID0gc2FoQmluc1sgaSArIDEgXTtcblx0XHRcdFx0XHRcdGNvbnN0IHJpZ2h0Qm91bmRzID0gbmV4dEJpbi5yaWdodENhY2hlQm91bmRzO1xuXG5cdFx0XHRcdFx0XHQvLyBkb24ndCBkbyBhbnl0aGluZyB3aXRoIHRoZSBib3VuZHMgaWYgdGhlIG5ldyBib3VuZHMgaGF2ZSBubyB0cmlhbmdsZXNcblx0XHRcdFx0XHRcdGlmICggYmluQ291bnQgIT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBsZWZ0Q291bnQgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb3B5Qm91bmRzKCBib3VuZHMsIGxlZnRCb3VuZHMgKTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0dW5pb25Cb3VuZHMoIGJvdW5kcywgbGVmdEJvdW5kcywgbGVmdEJvdW5kcyApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRsZWZ0Q291bnQgKz0gYmluQ291bnQ7XG5cblx0XHRcdFx0XHRcdC8vIGNoZWNrIHRoZSBjb3N0IG9mIHRoaXMgc3BsaXRcblx0XHRcdFx0XHRcdGxldCBsZWZ0UHJvYiA9IDA7XG5cdFx0XHRcdFx0XHRsZXQgcmlnaHRQcm9iID0gMDtcblxuXHRcdFx0XHRcdFx0aWYgKCBsZWZ0Q291bnQgIT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0bGVmdFByb2IgPSBjb21wdXRlU3VyZmFjZUFyZWEoIGxlZnRCb3VuZHMgKSAvIHJvb3RTdXJmYWNlQXJlYTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjb25zdCByaWdodENvdW50ID0gY291bnQgLSBsZWZ0Q291bnQ7XG5cdFx0XHRcdFx0XHRpZiAoIHJpZ2h0Q291bnQgIT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0cmlnaHRQcm9iID0gY29tcHV0ZVN1cmZhY2VBcmVhKCByaWdodEJvdW5kcyApIC8gcm9vdFN1cmZhY2VBcmVhO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbnN0IGNvc3QgPSBUUkFWRVJTQUxfQ09TVCArIFRSSUFOR0xFX0lOVEVSU0VDVF9DT1NUICogKFxuXHRcdFx0XHRcdFx0XHRsZWZ0UHJvYiAqIGxlZnRDb3VudCArIHJpZ2h0UHJvYiAqIHJpZ2h0Q291bnRcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGlmICggY29zdCA8IGJlc3RDb3N0ICkge1xuXG5cdFx0XHRcdFx0XHRcdGF4aXMgPSBhO1xuXHRcdFx0XHRcdFx0XHRiZXN0Q29zdCA9IGNvc3Q7XG5cdFx0XHRcdFx0XHRcdHBvcyA9IGJpbi5jYW5kaWRhdGU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggYE1lc2hCVkg6IEludmFsaWQgYnVpbGQgc3RyYXRlZ3kgdmFsdWUgJHsgc3RyYXRlZ3kgfSB1c2VkLmAgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB7IGF4aXMsIHBvcyB9O1xuXG5cdH1cblxuXHQvLyByZXR1cm5zIHRoZSBhdmVyYWdlIGNvb3JkaW5hdGUgb24gdGhlIHNwZWNpZmllZCBheGlzIG9mIHRoZSBhbGwgdGhlIHByb3ZpZGVkIHRyaWFuZ2xlc1xuXHRmdW5jdGlvbiBnZXRBdmVyYWdlKCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgYXhpcyApIHtcblxuXHRcdGxldCBhdmcgPSAwO1xuXHRcdGZvciAoIGxldCBpID0gb2Zmc2V0LCBlbmQgPSBvZmZzZXQgKyBjb3VudDsgaSA8IGVuZDsgaSArKyApIHtcblxuXHRcdFx0YXZnICs9IHRyaWFuZ2xlQm91bmRzWyBpICogNiArIGF4aXMgKiAyIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYXZnIC8gY291bnQ7XG5cblx0fVxuXG5cdGNsYXNzIE1lc2hCVkhOb2RlIHtcblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0XHQvLyBpbnRlcm5hbCBub2RlcyBoYXZlIGJvdW5kaW5nRGF0YSwgbGVmdCwgcmlnaHQsIGFuZCBzcGxpdEF4aXNcblx0XHRcdC8vIGxlYWYgbm9kZXMgaGF2ZSBvZmZzZXQgYW5kIGNvdW50IChyZWZlcnJpbmcgdG8gcHJpbWl0aXZlcyBpbiB0aGUgbWVzaCBnZW9tZXRyeSlcblxuXHRcdFx0dGhpcy5ib3VuZGluZ0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KCA2ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwic29ydFV0aWxzLnRlbXBsYXRlLmpzXCIuICovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0Ly8gcmVvcmRlcnMgYHRyaXNgIHN1Y2ggdGhhdCBmb3IgYGNvdW50YCBlbGVtZW50cyBhZnRlciBgb2Zmc2V0YCwgZWxlbWVudHMgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgc3BsaXRcblx0Ly8gd2lsbCBiZSBvbiB0aGUgbGVmdCBhbmQgZWxlbWVudHMgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHNwbGl0IHdpbGwgYmUgb24gdGhlIHJpZ2h0LiByZXR1cm5zIHRoZSBpbmRleFxuXHQvLyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvbiB0aGUgcmlnaHQgc2lkZSwgb3Igb2Zmc2V0ICsgY291bnQgaWYgdGhlcmUgYXJlIG5vIGVsZW1lbnRzIG9uIHRoZSByaWdodCBzaWRlLlxuXHRmdW5jdGlvbiBwYXJ0aXRpb24oIGluZGlyZWN0QnVmZmVyLCBpbmRleCwgdHJpYW5nbGVCb3VuZHMsIG9mZnNldCwgY291bnQsIHNwbGl0ICkge1xuXG5cdFx0bGV0IGxlZnQgPSBvZmZzZXQ7XG5cdFx0bGV0IHJpZ2h0ID0gb2Zmc2V0ICsgY291bnQgLSAxO1xuXHRcdGNvbnN0IHBvcyA9IHNwbGl0LnBvcztcblx0XHRjb25zdCBheGlzT2Zmc2V0ID0gc3BsaXQuYXhpcyAqIDI7XG5cblx0XHQvLyBob2FyZSBwYXJ0aXRpb25pbmcsIHNlZSBlLmcuIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1F1aWNrc29ydCNIb2FyZV9wYXJ0aXRpb25fc2NoZW1lXG5cdFx0d2hpbGUgKCB0cnVlICkge1xuXG5cdFx0XHR3aGlsZSAoIGxlZnQgPD0gcmlnaHQgJiYgdHJpYW5nbGVCb3VuZHNbIGxlZnQgKiA2ICsgYXhpc09mZnNldCBdIDwgcG9zICkge1xuXG5cdFx0XHRcdGxlZnQgKys7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaWYgYSB0cmlhbmdsZSBjZW50ZXIgbGllcyBvbiB0aGUgcGFydGl0aW9uIHBsYW5lIGl0IGlzIGNvbnNpZGVyZWQgdG8gYmUgb24gdGhlIHJpZ2h0IHNpZGVcblx0XHRcdHdoaWxlICggbGVmdCA8PSByaWdodCAmJiB0cmlhbmdsZUJvdW5kc1sgcmlnaHQgKiA2ICsgYXhpc09mZnNldCBdID49IHBvcyApIHtcblxuXHRcdFx0XHRyaWdodCAtLTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGxlZnQgPCByaWdodCApIHtcblxuXHRcdFx0XHQvLyB3ZSBuZWVkIHRvIHN3YXAgYWxsIG9mIHRoZSBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIHRyaWFuZ2xlcyBhdCBpbmRleFxuXHRcdFx0XHQvLyBsZWZ0IGFuZCByaWdodDsgdGhhdCdzIHRoZSB2ZXJ0cyBpbiB0aGUgZ2VvbWV0cnkgaW5kZXgsIHRoZSBib3VuZHMsXG5cdFx0XHRcdC8vIGFuZCBwZXJoYXBzIHRoZSBTQUggcGxhbmVzXG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRcdGxldCB0MCA9IGluZGV4WyBsZWZ0ICogMyArIGkgXTtcblx0XHRcdFx0XHRpbmRleFsgbGVmdCAqIDMgKyBpIF0gPSBpbmRleFsgcmlnaHQgKiAzICsgaSBdO1xuXHRcdFx0XHRcdGluZGV4WyByaWdodCAqIDMgKyBpIF0gPSB0MDtcblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHQvLyBzd2FwIGJvdW5kc1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdFx0bGV0IHRiID0gdHJpYW5nbGVCb3VuZHNbIGxlZnQgKiA2ICsgaSBdO1xuXHRcdFx0XHRcdHRyaWFuZ2xlQm91bmRzWyBsZWZ0ICogNiArIGkgXSA9IHRyaWFuZ2xlQm91bmRzWyByaWdodCAqIDYgKyBpIF07XG5cdFx0XHRcdFx0dHJpYW5nbGVCb3VuZHNbIHJpZ2h0ICogNiArIGkgXSA9IHRiO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsZWZ0ICsrO1xuXHRcdFx0XHRyaWdodCAtLTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gbGVmdDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcInNvcnRVdGlscy50ZW1wbGF0ZS5qc1wiLiAqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8vIHJlb3JkZXJzIGB0cmlzYCBzdWNoIHRoYXQgZm9yIGBjb3VudGAgZWxlbWVudHMgYWZ0ZXIgYG9mZnNldGAsIGVsZW1lbnRzIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHNwbGl0XG5cdC8vIHdpbGwgYmUgb24gdGhlIGxlZnQgYW5kIGVsZW1lbnRzIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBzcGxpdCB3aWxsIGJlIG9uIHRoZSByaWdodC4gcmV0dXJucyB0aGUgaW5kZXhcblx0Ly8gb2YgdGhlIGZpcnN0IGVsZW1lbnQgb24gdGhlIHJpZ2h0IHNpZGUsIG9yIG9mZnNldCArIGNvdW50IGlmIHRoZXJlIGFyZSBubyBlbGVtZW50cyBvbiB0aGUgcmlnaHQgc2lkZS5cblx0ZnVuY3Rpb24gcGFydGl0aW9uX2luZGlyZWN0KCBpbmRpcmVjdEJ1ZmZlciwgaW5kZXgsIHRyaWFuZ2xlQm91bmRzLCBvZmZzZXQsIGNvdW50LCBzcGxpdCApIHtcblxuXHRcdGxldCBsZWZ0ID0gb2Zmc2V0O1xuXHRcdGxldCByaWdodCA9IG9mZnNldCArIGNvdW50IC0gMTtcblx0XHRjb25zdCBwb3MgPSBzcGxpdC5wb3M7XG5cdFx0Y29uc3QgYXhpc09mZnNldCA9IHNwbGl0LmF4aXMgKiAyO1xuXG5cdFx0Ly8gaG9hcmUgcGFydGl0aW9uaW5nLCBzZWUgZS5nLiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9RdWlja3NvcnQjSG9hcmVfcGFydGl0aW9uX3NjaGVtZVxuXHRcdHdoaWxlICggdHJ1ZSApIHtcblxuXHRcdFx0d2hpbGUgKCBsZWZ0IDw9IHJpZ2h0ICYmIHRyaWFuZ2xlQm91bmRzWyBsZWZ0ICogNiArIGF4aXNPZmZzZXQgXSA8IHBvcyApIHtcblxuXHRcdFx0XHRsZWZ0ICsrO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIGEgdHJpYW5nbGUgY2VudGVyIGxpZXMgb24gdGhlIHBhcnRpdGlvbiBwbGFuZSBpdCBpcyBjb25zaWRlcmVkIHRvIGJlIG9uIHRoZSByaWdodCBzaWRlXG5cdFx0XHR3aGlsZSAoIGxlZnQgPD0gcmlnaHQgJiYgdHJpYW5nbGVCb3VuZHNbIHJpZ2h0ICogNiArIGF4aXNPZmZzZXQgXSA+PSBwb3MgKSB7XG5cblx0XHRcdFx0cmlnaHQgLS07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBsZWZ0IDwgcmlnaHQgKSB7XG5cblx0XHRcdFx0Ly8gd2UgbmVlZCB0byBzd2FwIGFsbCBvZiB0aGUgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSB0cmlhbmdsZXMgYXQgaW5kZXhcblx0XHRcdFx0Ly8gbGVmdCBhbmQgcmlnaHQ7IHRoYXQncyB0aGUgdmVydHMgaW4gdGhlIGdlb21ldHJ5IGluZGV4LCB0aGUgYm91bmRzLFxuXHRcdFx0XHQvLyBhbmQgcGVyaGFwcyB0aGUgU0FIIHBsYW5lc1xuXHRcdFx0XHRsZXQgdCA9IGluZGlyZWN0QnVmZmVyWyBsZWZ0IF07XG5cdFx0XHRcdGluZGlyZWN0QnVmZmVyWyBsZWZ0IF0gPSBpbmRpcmVjdEJ1ZmZlclsgcmlnaHQgXTtcblx0XHRcdFx0aW5kaXJlY3RCdWZmZXJbIHJpZ2h0IF0gPSB0O1xuXG5cblx0XHRcdFx0Ly8gc3dhcCBib3VuZHNcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRcdGxldCB0YiA9IHRyaWFuZ2xlQm91bmRzWyBsZWZ0ICogNiArIGkgXTtcblx0XHRcdFx0XHR0cmlhbmdsZUJvdW5kc1sgbGVmdCAqIDYgKyBpIF0gPSB0cmlhbmdsZUJvdW5kc1sgcmlnaHQgKiA2ICsgaSBdO1xuXHRcdFx0XHRcdHRyaWFuZ2xlQm91bmRzWyByaWdodCAqIDYgKyBpIF0gPSB0YjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGVmdCArKztcblx0XHRcdFx0cmlnaHQgLS07XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIGxlZnQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gSVNfTEVBRiggbjE2LCB1aW50MTZBcnJheSApIHtcblxuXHRcdHJldHVybiB1aW50MTZBcnJheVsgbjE2ICsgMTUgXSA9PT0gMHhGRkZGO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBPRkZTRVQoIG4zMiwgdWludDMyQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gdWludDMyQXJyYXlbIG4zMiArIDYgXTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gQ09VTlQoIG4xNiwgdWludDE2QXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gdWludDE2QXJyYXlbIG4xNiArIDE0IF07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIExFRlRfTk9ERSggbjMyICkge1xuXG5cdFx0cmV0dXJuIG4zMiArIDg7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIFJJR0hUX05PREUoIG4zMiwgdWludDMyQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gdWludDMyQXJyYXlbIG4zMiArIDYgXTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gU1BMSVRfQVhJUyggbjMyLCB1aW50MzJBcnJheSApIHtcblxuXHRcdHJldHVybiB1aW50MzJBcnJheVsgbjMyICsgNyBdO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBCT1VORElOR19EQVRBX0lOREVYKCBuMzIgKSB7XG5cblx0XHRyZXR1cm4gbjMyO1xuXG5cdH1cblxuXHRsZXQgZmxvYXQzMkFycmF5LCB1aW50MzJBcnJheSwgdWludDE2QXJyYXksIHVpbnQ4QXJyYXk7XG5cdGNvbnN0IE1BWF9QT0lOVEVSID0gTWF0aC5wb3coIDIsIDMyICk7XG5cblx0ZnVuY3Rpb24gY291bnROb2Rlcyggbm9kZSApIHtcblxuXHRcdGlmICggJ2NvdW50JyBpbiBub2RlICkge1xuXG5cdFx0XHRyZXR1cm4gMTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiAxICsgY291bnROb2Rlcyggbm9kZS5sZWZ0ICkgKyBjb3VudE5vZGVzKCBub2RlLnJpZ2h0ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHBvcHVsYXRlQnVmZmVyKCBieXRlT2Zmc2V0LCBub2RlLCBidWZmZXIgKSB7XG5cblx0XHRmbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBidWZmZXIgKTtcblx0XHR1aW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSggYnVmZmVyICk7XG5cdFx0dWludDE2QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoIGJ1ZmZlciApO1xuXHRcdHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSggYnVmZmVyICk7XG5cblx0XHRyZXR1cm4gX3BvcHVsYXRlQnVmZmVyKCBieXRlT2Zmc2V0LCBub2RlICk7XG5cblx0fVxuXG5cdC8vIHBhY2sgc3RydWN0dXJlXG5cdC8vIGJvdW5kaW5nRGF0YSAgXHRcdFx0XHQ6IDYgZmxvYXQzMlxuXHQvLyByaWdodCAvIG9mZnNldCBcdFx0XHRcdDogMSB1aW50MzJcblx0Ly8gc3BsaXRBeGlzIC8gaXNMZWFmICsgY291bnQgXHQ6IDEgdWludDMyIC8gMiB1aW50MTZcblx0ZnVuY3Rpb24gX3BvcHVsYXRlQnVmZmVyKCBieXRlT2Zmc2V0LCBub2RlICkge1xuXG5cdFx0Y29uc3Qgc3RyaWRlNE9mZnNldCA9IGJ5dGVPZmZzZXQgLyA0O1xuXHRcdGNvbnN0IHN0cmlkZTJPZmZzZXQgPSBieXRlT2Zmc2V0IC8gMjtcblx0XHRjb25zdCBpc0xlYWYgPSAnY291bnQnIGluIG5vZGU7XG5cdFx0Y29uc3QgYm91bmRpbmdEYXRhID0gbm9kZS5ib3VuZGluZ0RhdGE7XG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0ZmxvYXQzMkFycmF5WyBzdHJpZGU0T2Zmc2V0ICsgaSBdID0gYm91bmRpbmdEYXRhWyBpIF07XG5cblx0XHR9XG5cblx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0aWYgKCBub2RlLmJ1ZmZlciApIHtcblxuXHRcdFx0XHRjb25zdCBidWZmZXIgPSBub2RlLmJ1ZmZlcjtcblx0XHRcdFx0dWludDhBcnJheS5zZXQoIG5ldyBVaW50OEFycmF5KCBidWZmZXIgKSwgYnl0ZU9mZnNldCApO1xuXG5cdFx0XHRcdGZvciAoIGxldCBvZmZzZXQgPSBieXRlT2Zmc2V0LCBsID0gYnl0ZU9mZnNldCArIGJ1ZmZlci5ieXRlTGVuZ3RoOyBvZmZzZXQgPCBsOyBvZmZzZXQgKz0gQllURVNfUEVSX05PREUgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBvZmZzZXQyID0gb2Zmc2V0IC8gMjtcblx0XHRcdFx0XHRpZiAoICEgSVNfTEVBRiggb2Zmc2V0MiwgdWludDE2QXJyYXkgKSApIHtcblxuXHRcdFx0XHRcdFx0dWludDMyQXJyYXlbICggb2Zmc2V0IC8gNCApICsgNiBdICs9IHN0cmlkZTRPZmZzZXQ7XG5cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGJ5dGVPZmZzZXQgKyBidWZmZXIuYnl0ZUxlbmd0aDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zdCBvZmZzZXQgPSBub2RlLm9mZnNldDtcblx0XHRcdFx0Y29uc3QgY291bnQgPSBub2RlLmNvdW50O1xuXHRcdFx0XHR1aW50MzJBcnJheVsgc3RyaWRlNE9mZnNldCArIDYgXSA9IG9mZnNldDtcblx0XHRcdFx0dWludDE2QXJyYXlbIHN0cmlkZTJPZmZzZXQgKyAxNCBdID0gY291bnQ7XG5cdFx0XHRcdHVpbnQxNkFycmF5WyBzdHJpZGUyT2Zmc2V0ICsgMTUgXSA9IElTX0xFQUZOT0RFX0ZMQUc7XG5cdFx0XHRcdHJldHVybiBieXRlT2Zmc2V0ICsgQllURVNfUEVSX05PREU7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGxlZnQgPSBub2RlLmxlZnQ7XG5cdFx0XHRjb25zdCByaWdodCA9IG5vZGUucmlnaHQ7XG5cdFx0XHRjb25zdCBzcGxpdEF4aXMgPSBub2RlLnNwbGl0QXhpcztcblxuXHRcdFx0bGV0IG5leHRVbnVzZWRQb2ludGVyO1xuXHRcdFx0bmV4dFVudXNlZFBvaW50ZXIgPSBfcG9wdWxhdGVCdWZmZXIoIGJ5dGVPZmZzZXQgKyBCWVRFU19QRVJfTk9ERSwgbGVmdCApO1xuXG5cdFx0XHRpZiAoICggbmV4dFVudXNlZFBvaW50ZXIgLyA0ICkgPiBNQVhfUE9JTlRFUiApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdNZXNoQlZIOiBDYW5ub3Qgc3RvcmUgY2hpbGQgcG9pbnRlciBncmVhdGVyIHRoYW4gMzIgYml0cy4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dWludDMyQXJyYXlbIHN0cmlkZTRPZmZzZXQgKyA2IF0gPSBuZXh0VW51c2VkUG9pbnRlciAvIDQ7XG5cdFx0XHRuZXh0VW51c2VkUG9pbnRlciA9IF9wb3B1bGF0ZUJ1ZmZlciggbmV4dFVudXNlZFBvaW50ZXIsIHJpZ2h0ICk7XG5cblx0XHRcdHVpbnQzMkFycmF5WyBzdHJpZGU0T2Zmc2V0ICsgNyBdID0gc3BsaXRBeGlzO1xuXHRcdFx0cmV0dXJuIG5leHRVbnVzZWRQb2ludGVyO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBnZW5lcmF0ZUluZGlyZWN0QnVmZmVyKCBnZW9tZXRyeSwgdXNlU2hhcmVkQXJyYXlCdWZmZXIgKSB7XG5cblx0XHRjb25zdCB0cmlDb3VudCA9ICggZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS5pbmRleC5jb3VudCA6IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQgKSAvIDM7XG5cdFx0Y29uc3QgdXNlVWludDMyID0gdHJpQ291bnQgPiAyICoqIDE2O1xuXHRcdGNvbnN0IGJ5dGVDb3VudCA9IHVzZVVpbnQzMiA/IDQgOiAyO1xuXG5cdFx0Y29uc3QgYnVmZmVyID0gdXNlU2hhcmVkQXJyYXlCdWZmZXIgPyBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoIHRyaUNvdW50ICogYnl0ZUNvdW50ICkgOiBuZXcgQXJyYXlCdWZmZXIoIHRyaUNvdW50ICogYnl0ZUNvdW50ICk7XG5cdFx0Y29uc3QgaW5kaXJlY3RCdWZmZXIgPSB1c2VVaW50MzIgPyBuZXcgVWludDMyQXJyYXkoIGJ1ZmZlciApIDogbmV3IFVpbnQxNkFycmF5KCBidWZmZXIgKTtcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBpbmRpcmVjdEJ1ZmZlci5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRpbmRpcmVjdEJ1ZmZlclsgaSBdID0gaTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBpbmRpcmVjdEJ1ZmZlcjtcblxuXHR9XG5cblx0ZnVuY3Rpb24gYnVpbGRUcmVlKCBidmgsIHRyaWFuZ2xlQm91bmRzLCBvZmZzZXQsIGNvdW50LCBvcHRpb25zICkge1xuXG5cdFx0Ly8gZXB4YW5kIHZhcmlhYmxlc1xuXHRcdGNvbnN0IHtcblx0XHRcdG1heERlcHRoLFxuXHRcdFx0dmVyYm9zZSxcblx0XHRcdG1heExlYWZUcmlzLFxuXHRcdFx0c3RyYXRlZ3ksXG5cdFx0XHRvblByb2dyZXNzLFxuXHRcdFx0aW5kaXJlY3QsXG5cdFx0fSA9IG9wdGlvbnM7XG5cdFx0Y29uc3QgaW5kaXJlY3RCdWZmZXIgPSBidmguX2luZGlyZWN0QnVmZmVyO1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRcdGNvbnN0IGluZGV4QXJyYXkgPSBnZW9tZXRyeS5pbmRleCA/IGdlb21ldHJ5LmluZGV4LmFycmF5IDogbnVsbDtcblx0XHRjb25zdCBwYXJ0aW9uRnVuYyA9IGluZGlyZWN0ID8gcGFydGl0aW9uX2luZGlyZWN0IDogcGFydGl0aW9uO1xuXG5cdFx0Ly8gZ2VuZXJhdGUgaW50ZXJtZWRpYXRlIHZhcmlhYmxlc1xuXHRcdGNvbnN0IHRvdGFsVHJpYW5nbGVzID0gZ2V0VHJpQ291bnQoIGdlb21ldHJ5ICk7XG5cdFx0Y29uc3QgY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoIDYgKTtcblx0XHRsZXQgcmVhY2hlZE1heERlcHRoID0gZmFsc2U7XG5cblx0XHRjb25zdCByb290ID0gbmV3IE1lc2hCVkhOb2RlKCk7XG5cdFx0Z2V0Qm91bmRzKCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgcm9vdC5ib3VuZGluZ0RhdGEsIGNhY2hlQ2VudHJvaWRCb3VuZGluZ0RhdGEgKTtcblx0XHRzcGxpdE5vZGUoIHJvb3QsIG9mZnNldCwgY291bnQsIGNhY2hlQ2VudHJvaWRCb3VuZGluZ0RhdGEgKTtcblx0XHRyZXR1cm4gcm9vdDtcblxuXHRcdGZ1bmN0aW9uIHRyaWdnZXJQcm9ncmVzcyggdHJpYW5nbGVzUHJvY2Vzc2VkICkge1xuXG5cdFx0XHRpZiAoIG9uUHJvZ3Jlc3MgKSB7XG5cblx0XHRcdFx0b25Qcm9ncmVzcyggdHJpYW5nbGVzUHJvY2Vzc2VkIC8gdG90YWxUcmlhbmdsZXMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZWl0aGVyIHJlY3Vyc2l2ZWx5IHNwbGl0cyB0aGUgZ2l2ZW4gbm9kZSwgY3JlYXRpbmcgbGVmdCBhbmQgcmlnaHQgc3VidHJlZXMgZm9yIGl0LCBvciBtYWtlcyBpdCBhIGxlYWYgbm9kZSxcblx0XHQvLyByZWNvcmRpbmcgdGhlIG9mZnNldCBhbmQgY291bnQgb2YgaXRzIHRyaWFuZ2xlcyBhbmQgd3JpdGluZyB0aGVtIGludG8gdGhlIHJlb3JkZXJlZCBnZW9tZXRyeSBpbmRleC5cblx0XHRmdW5jdGlvbiBzcGxpdE5vZGUoIG5vZGUsIG9mZnNldCwgY291bnQsIGNlbnRyb2lkQm91bmRpbmdEYXRhID0gbnVsbCwgZGVwdGggPSAwICkge1xuXG5cdFx0XHRpZiAoICEgcmVhY2hlZE1heERlcHRoICYmIGRlcHRoID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdHJlYWNoZWRNYXhEZXB0aCA9IHRydWU7XG5cdFx0XHRcdGlmICggdmVyYm9zZSApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggYE1lc2hCVkg6IE1heCBkZXB0aCBvZiAkeyBtYXhEZXB0aCB9IHJlYWNoZWQgd2hlbiBnZW5lcmF0aW5nIEJWSC4gQ29uc2lkZXIgaW5jcmVhc2luZyBtYXhEZXB0aC5gICk7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCBnZW9tZXRyeSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBlYXJseSBvdXQgaWYgd2UndmUgbWV0IG91ciBjYXBhY2l0eVxuXHRcdFx0aWYgKCBjb3VudCA8PSBtYXhMZWFmVHJpcyB8fCBkZXB0aCA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHR0cmlnZ2VyUHJvZ3Jlc3MoIG9mZnNldCArIGNvdW50ICk7XG5cdFx0XHRcdG5vZGUub2Zmc2V0ID0gb2Zmc2V0O1xuXHRcdFx0XHRub2RlLmNvdW50ID0gY291bnQ7XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIEZpbmQgd2hlcmUgdG8gc3BsaXQgdGhlIHZvbHVtZVxuXHRcdFx0Y29uc3Qgc3BsaXQgPSBnZXRPcHRpbWFsU3BsaXQoIG5vZGUuYm91bmRpbmdEYXRhLCBjZW50cm9pZEJvdW5kaW5nRGF0YSwgdHJpYW5nbGVCb3VuZHMsIG9mZnNldCwgY291bnQsIHN0cmF0ZWd5ICk7XG5cdFx0XHRpZiAoIHNwbGl0LmF4aXMgPT09IC0gMSApIHtcblxuXHRcdFx0XHR0cmlnZ2VyUHJvZ3Jlc3MoIG9mZnNldCArIGNvdW50ICk7XG5cdFx0XHRcdG5vZGUub2Zmc2V0ID0gb2Zmc2V0O1xuXHRcdFx0XHRub2RlLmNvdW50ID0gY291bnQ7XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNwbGl0T2Zmc2V0ID0gcGFydGlvbkZ1bmMoIGluZGlyZWN0QnVmZmVyLCBpbmRleEFycmF5LCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgc3BsaXQgKTtcblxuXHRcdFx0Ly8gY3JlYXRlIHRoZSB0d28gbmV3IGNoaWxkIG5vZGVzXG5cdFx0XHRpZiAoIHNwbGl0T2Zmc2V0ID09PSBvZmZzZXQgfHwgc3BsaXRPZmZzZXQgPT09IG9mZnNldCArIGNvdW50ICkge1xuXG5cdFx0XHRcdHRyaWdnZXJQcm9ncmVzcyggb2Zmc2V0ICsgY291bnQgKTtcblx0XHRcdFx0bm9kZS5vZmZzZXQgPSBvZmZzZXQ7XG5cdFx0XHRcdG5vZGUuY291bnQgPSBjb3VudDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRub2RlLnNwbGl0QXhpcyA9IHNwbGl0LmF4aXM7XG5cblx0XHRcdFx0Ly8gY3JlYXRlIHRoZSBsZWZ0IGNoaWxkIGFuZCBjb21wdXRlIGl0cyBib3VuZGluZyBib3hcblx0XHRcdFx0Y29uc3QgbGVmdCA9IG5ldyBNZXNoQlZITm9kZSgpO1xuXHRcdFx0XHRjb25zdCBsc3RhcnQgPSBvZmZzZXQ7XG5cdFx0XHRcdGNvbnN0IGxjb3VudCA9IHNwbGl0T2Zmc2V0IC0gb2Zmc2V0O1xuXHRcdFx0XHRub2RlLmxlZnQgPSBsZWZ0O1xuXG5cdFx0XHRcdGdldEJvdW5kcyggdHJpYW5nbGVCb3VuZHMsIGxzdGFydCwgbGNvdW50LCBsZWZ0LmJvdW5kaW5nRGF0YSwgY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSApO1xuXHRcdFx0XHRzcGxpdE5vZGUoIGxlZnQsIGxzdGFydCwgbGNvdW50LCBjYWNoZUNlbnRyb2lkQm91bmRpbmdEYXRhLCBkZXB0aCArIDEgKTtcblxuXHRcdFx0XHQvLyByZXBlYXQgZm9yIHJpZ2h0XG5cdFx0XHRcdGNvbnN0IHJpZ2h0ID0gbmV3IE1lc2hCVkhOb2RlKCk7XG5cdFx0XHRcdGNvbnN0IHJzdGFydCA9IHNwbGl0T2Zmc2V0O1xuXHRcdFx0XHRjb25zdCByY291bnQgPSBjb3VudCAtIGxjb3VudDtcblx0XHRcdFx0bm9kZS5yaWdodCA9IHJpZ2h0O1xuXG5cdFx0XHRcdGdldEJvdW5kcyggdHJpYW5nbGVCb3VuZHMsIHJzdGFydCwgcmNvdW50LCByaWdodC5ib3VuZGluZ0RhdGEsIGNhY2hlQ2VudHJvaWRCb3VuZGluZ0RhdGEgKTtcblx0XHRcdFx0c3BsaXROb2RlKCByaWdodCwgcnN0YXJ0LCByY291bnQsIGNhY2hlQ2VudHJvaWRCb3VuZGluZ0RhdGEsIGRlcHRoICsgMSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBidWlsZFBhY2tlZFRyZWUoIGJ2aCwgb3B0aW9ucyApIHtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRcdGlmICggb3B0aW9ucy5pbmRpcmVjdCApIHtcblxuXHRcdFx0YnZoLl9pbmRpcmVjdEJ1ZmZlciA9IGdlbmVyYXRlSW5kaXJlY3RCdWZmZXIoIGdlb21ldHJ5LCBvcHRpb25zLnVzZVNoYXJlZEFycmF5QnVmZmVyICk7XG5cblx0XHRcdGlmICggaGFzR3JvdXBHYXBzKCBnZW9tZXRyeSwgb3B0aW9ucy5yYW5nZSApICYmICEgb3B0aW9ucy52ZXJib3NlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XHQnTWVzaEJWSDogUHJvdmlkZWQgZ2VvbWV0cnkgY29udGFpbnMgZ3JvdXBzIG9yIGEgcmFuZ2UgdGhhdCBkbyBub3QgZnVsbHkgc3BhbiB0aGUgdmVydGV4IGNvbnRlbnRzIHdoaWxlIHVzaW5nIHRoZSBcImluZGlyZWN0XCIgb3B0aW9uLiAnICtcblx0XHRcdFx0XHQnQlZIIG1heSBpbmNvcnJlY3RseSByZXBvcnQgaW50ZXJzZWN0aW9ucyBvbiB1bnJlbmRlcmVkIHBvcnRpb25zIG9mIHRoZSBnZW9tZXRyeS4nXG5cdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggISBidmguX2luZGlyZWN0QnVmZmVyICkge1xuXG5cdFx0XHRlbnN1cmVJbmRleCggZ2VvbWV0cnksIG9wdGlvbnMgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IEJ1ZmZlckNvbnN0cnVjdG9yID0gb3B0aW9ucy51c2VTaGFyZWRBcnJheUJ1ZmZlciA/IFNoYXJlZEFycmF5QnVmZmVyIDogQXJyYXlCdWZmZXI7XG5cblx0XHRjb25zdCB0cmlhbmdsZUJvdW5kcyA9IGNvbXB1dGVUcmlhbmdsZUJvdW5kcyggZ2VvbWV0cnkgKTtcblx0XHRjb25zdCBnZW9tZXRyeVJhbmdlcyA9IG9wdGlvbnMuaW5kaXJlY3QgPyBnZXRGdWxsR2VvbWV0cnlSYW5nZSggZ2VvbWV0cnksIG9wdGlvbnMucmFuZ2UgKSA6IGdldFJvb3RJbmRleFJhbmdlcyggZ2VvbWV0cnksIG9wdGlvbnMucmFuZ2UgKTtcblx0XHRidmguX3Jvb3RzID0gZ2VvbWV0cnlSYW5nZXMubWFwKCByYW5nZSA9PiB7XG5cblx0XHRcdGNvbnN0IHJvb3QgPSBidWlsZFRyZWUoIGJ2aCwgdHJpYW5nbGVCb3VuZHMsIHJhbmdlLm9mZnNldCwgcmFuZ2UuY291bnQsIG9wdGlvbnMgKTtcblx0XHRcdGNvbnN0IG5vZGVDb3VudCA9IGNvdW50Tm9kZXMoIHJvb3QgKTtcblx0XHRcdGNvbnN0IGJ1ZmZlciA9IG5ldyBCdWZmZXJDb25zdHJ1Y3RvciggQllURVNfUEVSX05PREUgKiBub2RlQ291bnQgKTtcblx0XHRcdHBvcHVsYXRlQnVmZmVyKCAwLCByb290LCBidWZmZXIgKTtcblx0XHRcdHJldHVybiBidWZmZXI7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdGNsYXNzIFNlcGFyYXRpbmdBeGlzQm91bmRzIHtcblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0XHR0aGlzLm1pbiA9IEluZmluaXR5O1xuXHRcdFx0dGhpcy5tYXggPSAtIEluZmluaXR5O1xuXG5cdFx0fVxuXG5cdFx0c2V0RnJvbVBvaW50c0ZpZWxkKCBwb2ludHMsIGZpZWxkICkge1xuXG5cdFx0XHRsZXQgbWluID0gSW5maW5pdHk7XG5cdFx0XHRsZXQgbWF4ID0gLSBJbmZpbml0eTtcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHAgPSBwb2ludHNbIGkgXTtcblx0XHRcdFx0Y29uc3QgdmFsID0gcFsgZmllbGQgXTtcblx0XHRcdFx0bWluID0gdmFsIDwgbWluID8gdmFsIDogbWluO1xuXHRcdFx0XHRtYXggPSB2YWwgPiBtYXggPyB2YWwgOiBtYXg7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5taW4gPSBtaW47XG5cdFx0XHR0aGlzLm1heCA9IG1heDtcblxuXHRcdH1cblxuXHRcdHNldEZyb21Qb2ludHMoIGF4aXMsIHBvaW50cyApIHtcblxuXHRcdFx0bGV0IG1pbiA9IEluZmluaXR5O1xuXHRcdFx0bGV0IG1heCA9IC0gSW5maW5pdHk7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBwID0gcG9pbnRzWyBpIF07XG5cdFx0XHRcdGNvbnN0IHZhbCA9IGF4aXMuZG90KCBwICk7XG5cdFx0XHRcdG1pbiA9IHZhbCA8IG1pbiA/IHZhbCA6IG1pbjtcblx0XHRcdFx0bWF4ID0gdmFsID4gbWF4ID8gdmFsIDogbWF4O1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubWluID0gbWluO1xuXHRcdFx0dGhpcy5tYXggPSBtYXg7XG5cblx0XHR9XG5cblx0XHRpc1NlcGFyYXRlZCggb3RoZXIgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLm1pbiA+IG90aGVyLm1heCB8fCBvdGhlci5taW4gPiB0aGlzLm1heDtcblxuXHRcdH1cblxuXHR9XG5cblx0U2VwYXJhdGluZ0F4aXNCb3VuZHMucHJvdG90eXBlLnNldEZyb21Cb3ggPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnN0IHAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHJldHVybiBmdW5jdGlvbiBzZXRGcm9tQm94KCBheGlzLCBib3ggKSB7XG5cblx0XHRcdGNvbnN0IGJveE1pbiA9IGJveC5taW47XG5cdFx0XHRjb25zdCBib3hNYXggPSBib3gubWF4O1xuXHRcdFx0bGV0IG1pbiA9IEluZmluaXR5O1xuXHRcdFx0bGV0IG1heCA9IC0gSW5maW5pdHk7XG5cdFx0XHRmb3IgKCBsZXQgeCA9IDA7IHggPD0gMTsgeCArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgeSA9IDA7IHkgPD0gMTsgeSArKyApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCB6ID0gMDsgeiA8PSAxOyB6ICsrICkge1xuXG5cdFx0XHRcdFx0XHRwLnggPSBib3hNaW4ueCAqIHggKyBib3hNYXgueCAqICggMSAtIHggKTtcblx0XHRcdFx0XHRcdHAueSA9IGJveE1pbi55ICogeSArIGJveE1heC55ICogKCAxIC0geSApO1xuXHRcdFx0XHRcdFx0cC56ID0gYm94TWluLnogKiB6ICsgYm94TWF4LnogKiAoIDEgLSB6ICk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHZhbCA9IGF4aXMuZG90KCBwICk7XG5cdFx0XHRcdFx0XHRtaW4gPSBNYXRoLm1pbiggdmFsLCBtaW4gKTtcblx0XHRcdFx0XHRcdG1heCA9IE1hdGgubWF4KCB2YWwsIG1heCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm1pbiA9IG1pbjtcblx0XHRcdHRoaXMubWF4ID0gbWF4O1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHRjb25zdCBhcmVJbnRlcnNlY3RpbmcgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnN0IGNhY2hlU2F0Qm91bmRzID0gbmV3IFNlcGFyYXRpbmdBeGlzQm91bmRzKCk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGFyZUludGVyc2VjdGluZyggc2hhcGUxLCBzaGFwZTIgKSB7XG5cblx0XHRcdGNvbnN0IHBvaW50czEgPSBzaGFwZTEucG9pbnRzO1xuXHRcdFx0Y29uc3Qgc2F0QXhlczEgPSBzaGFwZTEuc2F0QXhlcztcblx0XHRcdGNvbnN0IHNhdEJvdW5kczEgPSBzaGFwZTEuc2F0Qm91bmRzO1xuXG5cdFx0XHRjb25zdCBwb2ludHMyID0gc2hhcGUyLnBvaW50cztcblx0XHRcdGNvbnN0IHNhdEF4ZXMyID0gc2hhcGUyLnNhdEF4ZXM7XG5cdFx0XHRjb25zdCBzYXRCb3VuZHMyID0gc2hhcGUyLnNhdEJvdW5kcztcblxuXHRcdFx0Ly8gY2hlY2sgYXhlcyBvZiB0aGUgZmlyc3Qgc2hhcGVcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2IgPSBzYXRCb3VuZHMxWyBpIF07XG5cdFx0XHRcdGNvbnN0IHNhID0gc2F0QXhlczFbIGkgXTtcblx0XHRcdFx0Y2FjaGVTYXRCb3VuZHMuc2V0RnJvbVBvaW50cyggc2EsIHBvaW50czIgKTtcblx0XHRcdFx0aWYgKCBzYi5pc1NlcGFyYXRlZCggY2FjaGVTYXRCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBheGVzIG9mIHRoZSBzZWNvbmQgc2hhcGVcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2IgPSBzYXRCb3VuZHMyWyBpIF07XG5cdFx0XHRcdGNvbnN0IHNhID0gc2F0QXhlczJbIGkgXTtcblx0XHRcdFx0Y2FjaGVTYXRCb3VuZHMuc2V0RnJvbVBvaW50cyggc2EsIHBvaW50czEgKTtcblx0XHRcdFx0aWYgKCBzYi5pc1NlcGFyYXRlZCggY2FjaGVTYXRCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHRjb25zdCBjbG9zZXN0UG9pbnRMaW5lVG9MaW5lID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vanVqL01hdGhHZW9MaWIvYmxvYi9tYXN0ZXIvc3JjL0dlb21ldHJ5L0xpbmUuY3BwI0w1NlxuXHRcdGNvbnN0IGRpcjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IGRpcjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IHYwMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNsb3Nlc3RQb2ludExpbmVUb0xpbmUoIGwxLCBsMiwgcmVzdWx0ICkge1xuXG5cdFx0XHRjb25zdCB2MCA9IGwxLnN0YXJ0O1xuXHRcdFx0Y29uc3QgdjEwID0gZGlyMTtcblx0XHRcdGNvbnN0IHYyID0gbDIuc3RhcnQ7XG5cdFx0XHRjb25zdCB2MzIgPSBkaXIyO1xuXG5cdFx0XHR2MDIuc3ViVmVjdG9ycyggdjAsIHYyICk7XG5cdFx0XHRkaXIxLnN1YlZlY3RvcnMoIGwxLmVuZCwgbDEuc3RhcnQgKTtcblx0XHRcdGRpcjIuc3ViVmVjdG9ycyggbDIuZW5kLCBsMi5zdGFydCApO1xuXG5cdFx0XHQvLyBmbG9hdCBkMDIzMiA9IHYwMi5Eb3QodjMyKTtcblx0XHRcdGNvbnN0IGQwMjMyID0gdjAyLmRvdCggdjMyICk7XG5cblx0XHRcdC8vIGZsb2F0IGQzMjEwID0gdjMyLkRvdCh2MTApO1xuXHRcdFx0Y29uc3QgZDMyMTAgPSB2MzIuZG90KCB2MTAgKTtcblxuXHRcdFx0Ly8gZmxvYXQgZDMyMzIgPSB2MzIuRG90KHYzMik7XG5cdFx0XHRjb25zdCBkMzIzMiA9IHYzMi5kb3QoIHYzMiApO1xuXG5cdFx0XHQvLyBmbG9hdCBkMDIxMCA9IHYwMi5Eb3QodjEwKTtcblx0XHRcdGNvbnN0IGQwMjEwID0gdjAyLmRvdCggdjEwICk7XG5cblx0XHRcdC8vIGZsb2F0IGQxMDEwID0gdjEwLkRvdCh2MTApO1xuXHRcdFx0Y29uc3QgZDEwMTAgPSB2MTAuZG90KCB2MTAgKTtcblxuXHRcdFx0Ly8gZmxvYXQgZGVub20gPSBkMTAxMCpkMzIzMiAtIGQzMjEwKmQzMjEwO1xuXHRcdFx0Y29uc3QgZGVub20gPSBkMTAxMCAqIGQzMjMyIC0gZDMyMTAgKiBkMzIxMDtcblxuXHRcdFx0bGV0IGQsIGQyO1xuXHRcdFx0aWYgKCBkZW5vbSAhPT0gMCApIHtcblxuXHRcdFx0XHRkID0gKCBkMDIzMiAqIGQzMjEwIC0gZDAyMTAgKiBkMzIzMiApIC8gZGVub207XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZCA9IDA7XG5cblx0XHRcdH1cblxuXHRcdFx0ZDIgPSAoIGQwMjMyICsgZCAqIGQzMjEwICkgLyBkMzIzMjtcblxuXHRcdFx0cmVzdWx0LnggPSBkO1xuXHRcdFx0cmVzdWx0LnkgPSBkMjtcblxuXHRcdH07XG5cblx0fSApKCk7XG5cblx0Y29uc3QgY2xvc2VzdFBvaW50c1NlZ21lbnRUb1NlZ21lbnQgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qdWovTWF0aEdlb0xpYi9ibG9iL21hc3Rlci9zcmMvR2VvbWV0cnkvTGluZVNlZ21lbnQuY3BwI0wxODdcblx0XHRjb25zdCBwYXJhbVJlc3VsdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdFx0Y29uc3QgdGVtcDEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IHRlbXAyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gY2xvc2VzdFBvaW50c1NlZ21lbnRUb1NlZ21lbnQoIGwxLCBsMiwgdGFyZ2V0MSwgdGFyZ2V0MiApIHtcblxuXHRcdFx0Y2xvc2VzdFBvaW50TGluZVRvTGluZSggbDEsIGwyLCBwYXJhbVJlc3VsdCApO1xuXG5cdFx0XHRsZXQgZCA9IHBhcmFtUmVzdWx0Lng7XG5cdFx0XHRsZXQgZDIgPSBwYXJhbVJlc3VsdC55O1xuXHRcdFx0aWYgKCBkID49IDAgJiYgZCA8PSAxICYmIGQyID49IDAgJiYgZDIgPD0gMSApIHtcblxuXHRcdFx0XHRsMS5hdCggZCwgdGFyZ2V0MSApO1xuXHRcdFx0XHRsMi5hdCggZDIsIHRhcmdldDIgKTtcblxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH0gZWxzZSBpZiAoIGQgPj0gMCAmJiBkIDw9IDEgKSB7XG5cblx0XHRcdFx0Ly8gT25seSBkMiBpcyBvdXQgb2YgYm91bmRzLlxuXHRcdFx0XHRpZiAoIGQyIDwgMCApIHtcblxuXHRcdFx0XHRcdGwyLmF0KCAwLCB0YXJnZXQyICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGwyLmF0KCAxLCB0YXJnZXQyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGwxLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHRhcmdldDIsIHRydWUsIHRhcmdldDEgKTtcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBkMiA+PSAwICYmIGQyIDw9IDEgKSB7XG5cblx0XHRcdFx0Ly8gT25seSBkIGlzIG91dCBvZiBib3VuZHMuXG5cdFx0XHRcdGlmICggZCA8IDAgKSB7XG5cblx0XHRcdFx0XHRsMS5hdCggMCwgdGFyZ2V0MSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRsMS5hdCggMSwgdGFyZ2V0MSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsMi5jbG9zZXN0UG9pbnRUb1BvaW50KCB0YXJnZXQxLCB0cnVlLCB0YXJnZXQyICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBCb3RoIHUgYW5kIHUyIGFyZSBvdXQgb2YgYm91bmRzLlxuXHRcdFx0XHRsZXQgcDtcblx0XHRcdFx0aWYgKCBkIDwgMCApIHtcblxuXHRcdFx0XHRcdHAgPSBsMS5zdGFydDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cCA9IGwxLmVuZDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGV0IHAyO1xuXHRcdFx0XHRpZiAoIGQyIDwgMCApIHtcblxuXHRcdFx0XHRcdHAyID0gbDIuc3RhcnQ7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHAyID0gbDIuZW5kO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBjbG9zZXN0UG9pbnQgPSB0ZW1wMTtcblx0XHRcdFx0Y29uc3QgY2xvc2VzdFBvaW50MiA9IHRlbXAyO1xuXHRcdFx0XHRsMS5jbG9zZXN0UG9pbnRUb1BvaW50KCBwMiwgdHJ1ZSwgdGVtcDEgKTtcblx0XHRcdFx0bDIuY2xvc2VzdFBvaW50VG9Qb2ludCggcCwgdHJ1ZSwgdGVtcDIgKTtcblxuXHRcdFx0XHRpZiAoIGNsb3Nlc3RQb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggcDIgKSA8PSBjbG9zZXN0UG9pbnQyLmRpc3RhbmNlVG9TcXVhcmVkKCBwICkgKSB7XG5cblx0XHRcdFx0XHR0YXJnZXQxLmNvcHkoIGNsb3Nlc3RQb2ludCApO1xuXHRcdFx0XHRcdHRhcmdldDIuY29weSggcDIgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRhcmdldDEuY29weSggcCApO1xuXHRcdFx0XHRcdHRhcmdldDIuY29weSggY2xvc2VzdFBvaW50MiApO1xuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fSApKCk7XG5cblxuXHRjb25zdCBzcGhlcmVJbnRlcnNlY3RUcmlhbmdsZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzQwNDM5NTUvZGV0ZWN0LWNvbGxpc2lvbi1iZXR3ZWVuLXNwaGVyZS1hbmQtdHJpYW5nbGUtaW4tdGhyZWUtanNcblx0XHRjb25zdCBjbG9zZXN0UG9pbnRUZW1wID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRjb25zdCBwcm9qZWN0ZWRQb2ludFRlbXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IHBsYW5lVGVtcCA9IG5ldyBUSFJFRS5QbGFuZSgpO1xuXHRcdGNvbnN0IGxpbmVUZW1wID0gbmV3IFRIUkVFLkxpbmUzKCk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHNwaGVyZUludGVyc2VjdFRyaWFuZ2xlKCBzcGhlcmUsIHRyaWFuZ2xlICkge1xuXG5cdFx0XHRjb25zdCB7IHJhZGl1cywgY2VudGVyIH0gPSBzcGhlcmU7XG5cdFx0XHRjb25zdCB7IGEsIGIsIGMgfSA9IHRyaWFuZ2xlO1xuXG5cdFx0XHQvLyBwaGFzZSAxXG5cdFx0XHRsaW5lVGVtcC5zdGFydCA9IGE7XG5cdFx0XHRsaW5lVGVtcC5lbmQgPSBiO1xuXHRcdFx0Y29uc3QgY2xvc2VzdFBvaW50MSA9IGxpbmVUZW1wLmNsb3Nlc3RQb2ludFRvUG9pbnQoIGNlbnRlciwgdHJ1ZSwgY2xvc2VzdFBvaW50VGVtcCApO1xuXHRcdFx0aWYgKCBjbG9zZXN0UG9pbnQxLmRpc3RhbmNlVG8oIGNlbnRlciApIDw9IHJhZGl1cyApIHJldHVybiB0cnVlO1xuXG5cdFx0XHRsaW5lVGVtcC5zdGFydCA9IGE7XG5cdFx0XHRsaW5lVGVtcC5lbmQgPSBjO1xuXHRcdFx0Y29uc3QgY2xvc2VzdFBvaW50MiA9IGxpbmVUZW1wLmNsb3Nlc3RQb2ludFRvUG9pbnQoIGNlbnRlciwgdHJ1ZSwgY2xvc2VzdFBvaW50VGVtcCApO1xuXHRcdFx0aWYgKCBjbG9zZXN0UG9pbnQyLmRpc3RhbmNlVG8oIGNlbnRlciApIDw9IHJhZGl1cyApIHJldHVybiB0cnVlO1xuXG5cdFx0XHRsaW5lVGVtcC5zdGFydCA9IGI7XG5cdFx0XHRsaW5lVGVtcC5lbmQgPSBjO1xuXHRcdFx0Y29uc3QgY2xvc2VzdFBvaW50MyA9IGxpbmVUZW1wLmNsb3Nlc3RQb2ludFRvUG9pbnQoIGNlbnRlciwgdHJ1ZSwgY2xvc2VzdFBvaW50VGVtcCApO1xuXHRcdFx0aWYgKCBjbG9zZXN0UG9pbnQzLmRpc3RhbmNlVG8oIGNlbnRlciApIDw9IHJhZGl1cyApIHJldHVybiB0cnVlO1xuXG5cdFx0XHQvLyBwaGFzZSAyXG5cdFx0XHRjb25zdCBwbGFuZSA9IHRyaWFuZ2xlLmdldFBsYW5lKCBwbGFuZVRlbXAgKTtcblx0XHRcdGNvbnN0IGRwID0gTWF0aC5hYnMoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggY2VudGVyICkgKTtcblx0XHRcdGlmICggZHAgPD0gcmFkaXVzICkge1xuXG5cdFx0XHRcdGNvbnN0IHBwID0gcGxhbmUucHJvamVjdFBvaW50KCBjZW50ZXIsIHByb2plY3RlZFBvaW50VGVtcCApO1xuXHRcdFx0XHRjb25zdCBjcCA9IHRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQoIHBwICk7XG5cdFx0XHRcdGlmICggY3AgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cdGNvbnN0IFpFUk9fRVBTSUxPTiA9IDFlLTE1O1xuXHRmdW5jdGlvbiBpc05lYXJaZXJvKCB2YWx1ZSApIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdmFsdWUgKSA8IFpFUk9fRVBTSUxPTjtcblxuXHR9XG5cblx0Y2xhc3MgRXh0ZW5kZWRUcmlhbmdsZSBleHRlbmRzIFRIUkVFLlRyaWFuZ2xlIHtcblxuXHRcdGNvbnN0cnVjdG9yKCAuLi5hcmdzICkge1xuXG5cdFx0XHRzdXBlciggLi4uYXJncyApO1xuXG5cdFx0XHR0aGlzLmlzRXh0ZW5kZWRUcmlhbmdsZSA9IHRydWU7XG5cdFx0XHR0aGlzLnNhdEF4ZXMgPSBuZXcgQXJyYXkoIDQgKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgVEhSRUUuVmVjdG9yMygpICk7XG5cdFx0XHR0aGlzLnNhdEJvdW5kcyA9IG5ldyBBcnJheSggNCApLmZpbGwoKS5tYXAoICgpID0+IG5ldyBTZXBhcmF0aW5nQXhpc0JvdW5kcygpICk7XG5cdFx0XHR0aGlzLnBvaW50cyA9IFsgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyBdO1xuXHRcdFx0dGhpcy5zcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cdFx0XHR0aGlzLnBsYW5lID0gbmV3IFRIUkVFLlBsYW5lKCk7XG5cdFx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApIHtcblxuXHRcdFx0cmV0dXJuIHNwaGVyZUludGVyc2VjdFRyaWFuZ2xlKCBzcGhlcmUsIHRoaXMgKTtcblxuXHRcdH1cblxuXHRcdHVwZGF0ZSgpIHtcblxuXHRcdFx0Y29uc3QgYSA9IHRoaXMuYTtcblx0XHRcdGNvbnN0IGIgPSB0aGlzLmI7XG5cdFx0XHRjb25zdCBjID0gdGhpcy5jO1xuXHRcdFx0Y29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cblx0XHRcdGNvbnN0IHNhdEF4ZXMgPSB0aGlzLnNhdEF4ZXM7XG5cdFx0XHRjb25zdCBzYXRCb3VuZHMgPSB0aGlzLnNhdEJvdW5kcztcblxuXHRcdFx0Y29uc3QgYXhpczAgPSBzYXRBeGVzWyAwIF07XG5cdFx0XHRjb25zdCBzYWIwID0gc2F0Qm91bmRzWyAwIF07XG5cdFx0XHR0aGlzLmdldE5vcm1hbCggYXhpczAgKTtcblx0XHRcdHNhYjAuc2V0RnJvbVBvaW50cyggYXhpczAsIHBvaW50cyApO1xuXG5cdFx0XHRjb25zdCBheGlzMSA9IHNhdEF4ZXNbIDEgXTtcblx0XHRcdGNvbnN0IHNhYjEgPSBzYXRCb3VuZHNbIDEgXTtcblx0XHRcdGF4aXMxLnN1YlZlY3RvcnMoIGEsIGIgKTtcblx0XHRcdHNhYjEuc2V0RnJvbVBvaW50cyggYXhpczEsIHBvaW50cyApO1xuXG5cdFx0XHRjb25zdCBheGlzMiA9IHNhdEF4ZXNbIDIgXTtcblx0XHRcdGNvbnN0IHNhYjIgPSBzYXRCb3VuZHNbIDIgXTtcblx0XHRcdGF4aXMyLnN1YlZlY3RvcnMoIGIsIGMgKTtcblx0XHRcdHNhYjIuc2V0RnJvbVBvaW50cyggYXhpczIsIHBvaW50cyApO1xuXG5cdFx0XHRjb25zdCBheGlzMyA9IHNhdEF4ZXNbIDMgXTtcblx0XHRcdGNvbnN0IHNhYjMgPSBzYXRCb3VuZHNbIDMgXTtcblx0XHRcdGF4aXMzLnN1YlZlY3RvcnMoIGMsIGEgKTtcblx0XHRcdHNhYjMuc2V0RnJvbVBvaW50cyggYXhpczMsIHBvaW50cyApO1xuXG5cdFx0XHR0aGlzLnNwaGVyZS5zZXRGcm9tUG9pbnRzKCB0aGlzLnBvaW50cyApO1xuXHRcdFx0dGhpcy5wbGFuZS5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCggYXhpczAsIGEgKTtcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdH1cblxuXHR9XG5cblx0RXh0ZW5kZWRUcmlhbmdsZS5wcm90b3R5cGUuY2xvc2VzdFBvaW50VG9TZWdtZW50ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zdCBwb2ludDEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IHBvaW50MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0Y29uc3QgZWRnZSA9IG5ldyBUSFJFRS5MaW5lMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlVG9TZWdtZW50KCBzZWdtZW50LCB0YXJnZXQxID0gbnVsbCwgdGFyZ2V0MiA9IG51bGwgKSB7XG5cblx0XHRcdGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gc2VnbWVudDtcblx0XHRcdGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdFx0bGV0IGRpc3RTcTtcblx0XHRcdGxldCBjbG9zZXN0RGlzdGFuY2VTcSA9IEluZmluaXR5O1xuXG5cdFx0XHQvLyBjaGVjayB0aGUgdHJpYW5nbGUgZWRnZXNcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgbmV4dGkgPSAoIGkgKyAxICkgJSAzO1xuXHRcdFx0XHRlZGdlLnN0YXJ0LmNvcHkoIHBvaW50c1sgaSBdICk7XG5cdFx0XHRcdGVkZ2UuZW5kLmNvcHkoIHBvaW50c1sgbmV4dGkgXSApO1xuXG5cdFx0XHRcdGNsb3Nlc3RQb2ludHNTZWdtZW50VG9TZWdtZW50KCBlZGdlLCBzZWdtZW50LCBwb2ludDEsIHBvaW50MiApO1xuXG5cdFx0XHRcdGRpc3RTcSA9IHBvaW50MS5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQyICk7XG5cdFx0XHRcdGlmICggZGlzdFNxIDwgY2xvc2VzdERpc3RhbmNlU3EgKSB7XG5cblx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3RTcTtcblx0XHRcdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHBvaW50MSApO1xuXHRcdFx0XHRcdGlmICggdGFyZ2V0MiApIHRhcmdldDIuY29weSggcG9pbnQyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoZWNrIGVuZCBwb2ludHNcblx0XHRcdHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludCggc3RhcnQsIHBvaW50MSApO1xuXHRcdFx0ZGlzdFNxID0gc3RhcnQuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50MSApO1xuXHRcdFx0aWYgKCBkaXN0U3EgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3RTcTtcblx0XHRcdFx0aWYgKCB0YXJnZXQxICkgdGFyZ2V0MS5jb3B5KCBwb2ludDEgKTtcblx0XHRcdFx0aWYgKCB0YXJnZXQyICkgdGFyZ2V0Mi5jb3B5KCBzdGFydCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludCggZW5kLCBwb2ludDEgKTtcblx0XHRcdGRpc3RTcSA9IGVuZC5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQxICk7XG5cdFx0XHRpZiAoIGRpc3RTcSA8IGNsb3Nlc3REaXN0YW5jZVNxICkge1xuXG5cdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxID0gZGlzdFNxO1xuXHRcdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHBvaW50MSApO1xuXHRcdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIGVuZCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBNYXRoLnNxcnQoIGNsb3Nlc3REaXN0YW5jZVNxICk7XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cdEV4dGVuZGVkVHJpYW5nbGUucHJvdG90eXBlLmludGVyc2VjdHNUcmlhbmdsZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc3Qgc2FUcmkyID0gbmV3IEV4dGVuZGVkVHJpYW5nbGUoKTtcblx0XHRjb25zdCBhcnIxID0gbmV3IEFycmF5KCAzICk7XG5cdFx0Y29uc3QgYXJyMiA9IG5ldyBBcnJheSggMyApO1xuXHRcdGNvbnN0IGNhY2hlZFNhdEJvdW5kcyA9IG5ldyBTZXBhcmF0aW5nQXhpc0JvdW5kcygpO1xuXHRcdGNvbnN0IGNhY2hlZFNhdEJvdW5kczIgPSBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKTtcblx0XHRjb25zdCBjYWNoZWRBeGlzID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRjb25zdCBkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IGRpcjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IGRpcjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IHRlbXBEaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IGVkZ2UgPSBuZXcgVEhSRUUuTGluZTMoKTtcblx0XHRjb25zdCBlZGdlMSA9IG5ldyBUSFJFRS5MaW5lMygpO1xuXHRcdGNvbnN0IGVkZ2UyID0gbmV3IFRIUkVFLkxpbmUzKCk7XG5cdFx0Y29uc3QgdGVtcFBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdGZ1bmN0aW9uIHRyaUludGVyc2VjdFBsYW5lKCB0cmksIHBsYW5lLCB0YXJnZXRFZGdlICkge1xuXG5cdFx0XHQvLyBmaW5kIHRoZSBlZGdlIHRoYXQgaW50ZXJzZWN0cyB0aGUgb3RoZXIgdHJpYW5nbGUgcGxhbmVcblx0XHRcdGNvbnN0IHBvaW50cyA9IHRyaS5wb2ludHM7XG5cdFx0XHRsZXQgY291bnQgPSAwO1xuXHRcdFx0bGV0IHN0YXJ0UG9pbnRJbnRlcnNlY3Rpb24gPSAtIDE7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gZWRnZTtcblx0XHRcdFx0c3RhcnQuY29weSggcG9pbnRzWyBpIF0gKTtcblx0XHRcdFx0ZW5kLmNvcHkoIHBvaW50c1sgKCBpICsgMSApICUgMyBdICk7XG5cdFx0XHRcdGVkZ2UuZGVsdGEoIGRpciApO1xuXG5cdFx0XHRcdGNvbnN0IHN0YXJ0SW50ZXJzZWN0cyA9IGlzTmVhclplcm8oIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggc3RhcnQgKSApO1xuXHRcdFx0XHRpZiAoIGlzTmVhclplcm8oIHBsYW5lLm5vcm1hbC5kb3QoIGRpciApICkgJiYgc3RhcnRJbnRlcnNlY3RzICkge1xuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlIGVkZ2UgbGllcyBvbiB0aGUgcGxhbmUgdGhlbiB0YWtlIHRoZSBsaW5lXG5cdFx0XHRcdFx0dGFyZ2V0RWRnZS5jb3B5KCBlZGdlICk7XG5cdFx0XHRcdFx0Y291bnQgPSAyO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgc3RhcnQgcG9pbnQgaXMgbmVhciB0aGUgcGxhbmUgYmVjYXVzZSBcImludGVyc2VjdExpbmVcIiBpcyBub3Qgcm9idXN0IHRvIHRoYXQgY2FzZVxuXHRcdFx0XHRjb25zdCBkb2VzSW50ZXJzZWN0ID0gcGxhbmUuaW50ZXJzZWN0TGluZSggZWRnZSwgdGVtcFBvaW50ICk7XG5cdFx0XHRcdGlmICggISBkb2VzSW50ZXJzZWN0ICYmIHN0YXJ0SW50ZXJzZWN0cyApIHtcblxuXHRcdFx0XHRcdHRlbXBQb2ludC5jb3B5KCBzdGFydCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZ25vcmUgdGhlIGVuZCBwb2ludFxuXHRcdFx0XHRpZiAoICggZG9lc0ludGVyc2VjdCB8fCBzdGFydEludGVyc2VjdHMgKSAmJiAhIGlzTmVhclplcm8oIHRlbXBQb2ludC5kaXN0YW5jZVRvKCBlbmQgKSApICkge1xuXG5cdFx0XHRcdFx0aWYgKCBjb3VudCA8PSAxICkge1xuXG5cdFx0XHRcdFx0XHQvLyBhc3NpZ24gdG8gdGhlIHN0YXJ0IG9yIGVuZCBwb2ludCBhbmQgc2F2ZSB3aGljaCBpbmRleCB3YXMgc25hcHBlZCB0b1xuXHRcdFx0XHRcdFx0Ly8gdGhlIHN0YXJ0IHBvaW50IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFx0Y29uc3QgcG9pbnQgPSBjb3VudCA9PT0gMSA/IHRhcmdldEVkZ2Uuc3RhcnQgOiB0YXJnZXRFZGdlLmVuZDtcblx0XHRcdFx0XHRcdHBvaW50LmNvcHkoIHRlbXBQb2ludCApO1xuXHRcdFx0XHRcdFx0aWYgKCBzdGFydEludGVyc2VjdHMgKSB7XG5cblx0XHRcdFx0XHRcdFx0c3RhcnRQb2ludEludGVyc2VjdGlvbiA9IGNvdW50O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb3VudCA+PSAyICkge1xuXG5cdFx0XHRcdFx0XHQvLyBpZiB3ZSdyZSBoZXJlIHRoYXQgbWVhbnMgdGhhdCB0aGVyZSBtdXN0IGhhdmUgYmVlbiBvbmUgcG9pbnQgdGhhdCBoYWRcblx0XHRcdFx0XHRcdC8vIHNuYXBwZWQgdG8gdGhlIHN0YXJ0IHBvaW50IHNvIHJlcGxhY2UgaXQgaGVyZVxuXHRcdFx0XHRcdFx0Y29uc3QgcG9pbnQgPSBzdGFydFBvaW50SW50ZXJzZWN0aW9uID09PSAxID8gdGFyZ2V0RWRnZS5zdGFydCA6IHRhcmdldEVkZ2UuZW5kO1xuXHRcdFx0XHRcdFx0cG9pbnQuY29weSggdGVtcFBvaW50ICk7XG5cdFx0XHRcdFx0XHRjb3VudCA9IDI7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvdW50ICsrO1xuXHRcdFx0XHRcdGlmICggY291bnQgPT09IDIgJiYgc3RhcnRQb2ludEludGVyc2VjdGlvbiA9PT0gLSAxICkge1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNvdW50O1xuXG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogSWYgdGhlIHRyaWFuZ2xlcyBhcmUgY29wbGFuYXIgYW5kIGludGVyc2VjdGluZyB0aGUgdGFyZ2V0IGlzIG5vbnNlbnNpY2FsLiBJdCBzaG91bGQgYXQgbGVhc3Rcblx0XHQvLyBiZSBhIGxpbmUgY29udGFpbmVkIGJ5IGJvdGggdHJpYW5nbGVzIGlmIG5vdCBhIGRpZmZlcmVudCBzcGVjaWFsIGNhc2Ugc29tZWhvdyByZXByZXNlbnRlZCBpbiB0aGUgcmV0dXJuIHJlc3VsdC5cblx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c1RyaWFuZ2xlKCBvdGhlciwgdGFyZ2V0ID0gbnVsbCwgc3VwcHJlc3NMb2cgPSBmYWxzZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhIG90aGVyLmlzRXh0ZW5kZWRUcmlhbmdsZSApIHtcblxuXHRcdFx0XHRzYVRyaTIuY29weSggb3RoZXIgKTtcblx0XHRcdFx0c2FUcmkyLnVwZGF0ZSgpO1xuXHRcdFx0XHRvdGhlciA9IHNhVHJpMjtcblxuXHRcdFx0fSBlbHNlIGlmICggb3RoZXIubmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdFx0b3RoZXIudXBkYXRlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcGxhbmUxID0gdGhpcy5wbGFuZTtcblx0XHRcdGNvbnN0IHBsYW5lMiA9IG90aGVyLnBsYW5lO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBwbGFuZTEubm9ybWFsLmRvdCggcGxhbmUyLm5vcm1hbCApICkgPiAxLjAgLSAxZS0xMCApIHtcblxuXHRcdFx0XHQvLyBwZXJmb3JtIHNlcGFyYXRpbmcgYXhpcyBpbnRlcnNlY3Rpb24gdGVzdCBvbmx5IGZvciBjb3BsYW5hciB0cmlhbmdsZXNcblx0XHRcdFx0Y29uc3Qgc2F0Qm91bmRzMSA9IHRoaXMuc2F0Qm91bmRzO1xuXHRcdFx0XHRjb25zdCBzYXRBeGVzMSA9IHRoaXMuc2F0QXhlcztcblx0XHRcdFx0YXJyMlsgMCBdID0gb3RoZXIuYTtcblx0XHRcdFx0YXJyMlsgMSBdID0gb3RoZXIuYjtcblx0XHRcdFx0YXJyMlsgMiBdID0gb3RoZXIuYztcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHNiID0gc2F0Qm91bmRzMVsgaSBdO1xuXHRcdFx0XHRcdGNvbnN0IHNhID0gc2F0QXhlczFbIGkgXTtcblx0XHRcdFx0XHRjYWNoZWRTYXRCb3VuZHMuc2V0RnJvbVBvaW50cyggc2EsIGFycjIgKTtcblx0XHRcdFx0XHRpZiAoIHNiLmlzU2VwYXJhdGVkKCBjYWNoZWRTYXRCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3Qgc2F0Qm91bmRzMiA9IG90aGVyLnNhdEJvdW5kcztcblx0XHRcdFx0Y29uc3Qgc2F0QXhlczIgPSBvdGhlci5zYXRBeGVzO1xuXHRcdFx0XHRhcnIxWyAwIF0gPSB0aGlzLmE7XG5cdFx0XHRcdGFycjFbIDEgXSA9IHRoaXMuYjtcblx0XHRcdFx0YXJyMVsgMiBdID0gdGhpcy5jO1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA0OyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3Qgc2IgPSBzYXRCb3VuZHMyWyBpIF07XG5cdFx0XHRcdFx0Y29uc3Qgc2EgPSBzYXRBeGVzMlsgaSBdO1xuXHRcdFx0XHRcdGNhY2hlZFNhdEJvdW5kcy5zZXRGcm9tUG9pbnRzKCBzYSwgYXJyMSApO1xuXHRcdFx0XHRcdGlmICggc2IuaXNTZXBhcmF0ZWQoIGNhY2hlZFNhdEJvdW5kcyApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjaGVjayBjcm9zc2VkIGF4ZXNcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHNhMSA9IHNhdEF4ZXMxWyBpIF07XG5cdFx0XHRcdFx0Zm9yICggbGV0IGkyID0gMDsgaTIgPCA0OyBpMiArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3Qgc2EyID0gc2F0QXhlczJbIGkyIF07XG5cdFx0XHRcdFx0XHRjYWNoZWRBeGlzLmNyb3NzVmVjdG9ycyggc2ExLCBzYTIgKTtcblx0XHRcdFx0XHRcdGNhY2hlZFNhdEJvdW5kcy5zZXRGcm9tUG9pbnRzKCBjYWNoZWRBeGlzLCBhcnIxICk7XG5cdFx0XHRcdFx0XHRjYWNoZWRTYXRCb3VuZHMyLnNldEZyb21Qb2ludHMoIGNhY2hlZEF4aXMsIGFycjIgKTtcblx0XHRcdFx0XHRcdGlmICggY2FjaGVkU2F0Qm91bmRzLmlzU2VwYXJhdGVkKCBjYWNoZWRTYXRCb3VuZHMyICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdGFyZ2V0ICkge1xuXG5cdFx0XHRcdFx0Ly8gVE9ETyBmaW5kIHR3byBwb2ludHMgdGhhdCBpbnRlcnNlY3Qgb24gdGhlIGVkZ2VzIGFuZCBtYWtlIHRoYXQgdGhlIHJlc3VsdFxuXHRcdFx0XHRcdGlmICggISBzdXBwcmVzc0xvZyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnRXh0ZW5kZWRUcmlhbmdsZS5pbnRlcnNlY3RzVHJpYW5nbGU6IFRyaWFuZ2xlcyBhcmUgY29wbGFuYXIgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBhbiBvdXRwdXQgZWRnZS4gU2V0dGluZyBlZGdlIHRvIDAsIDAsIDAuJyApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGFyZ2V0LnN0YXJ0LnNldCggMCwgMCwgMCApO1xuXHRcdFx0XHRcdHRhcmdldC5lbmQuc2V0KCAwLCAwLCAwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIGZpbmQgdGhlIGVkZ2UgdGhhdCBpbnRlcnNlY3RzIHRoZSBvdGhlciB0cmlhbmdsZSBwbGFuZVxuXHRcdFx0XHRjb25zdCBjb3VudDEgPSB0cmlJbnRlcnNlY3RQbGFuZSggdGhpcywgcGxhbmUyLCBlZGdlMSApO1xuXHRcdFx0XHRpZiAoIGNvdW50MSA9PT0gMSAmJiBvdGhlci5jb250YWluc1BvaW50KCBlZGdlMS5lbmQgKSApIHtcblxuXHRcdFx0XHRcdGlmICggdGFyZ2V0ICkge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXQuc3RhcnQuY29weSggZWRnZTEuZW5kICk7XG5cdFx0XHRcdFx0XHR0YXJnZXQuZW5kLmNvcHkoIGVkZ2UxLmVuZCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggY291bnQxICE9PSAyICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBmaW5kIHRoZSBvdGhlciB0cmlhbmdsZXMgZWRnZSB0aGF0IGludGVyc2VjdHMgdGhpcyBwbGFuZVxuXHRcdFx0XHRjb25zdCBjb3VudDIgPSB0cmlJbnRlcnNlY3RQbGFuZSggb3RoZXIsIHBsYW5lMSwgZWRnZTIgKTtcblx0XHRcdFx0aWYgKCBjb3VudDIgPT09IDEgJiYgdGhpcy5jb250YWluc1BvaW50KCBlZGdlMi5lbmQgKSApIHtcblxuXHRcdFx0XHRcdGlmICggdGFyZ2V0ICkge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXQuc3RhcnQuY29weSggZWRnZTIuZW5kICk7XG5cdFx0XHRcdFx0XHR0YXJnZXQuZW5kLmNvcHkoIGVkZ2UyLmVuZCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggY291bnQyICE9PSAyICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBmaW5kIHN3YXAgdGhlIHNlY29uZCBlZGdlIHNvIGJvdGggbGluZXMgYXJlIHJ1bm5pbmcgdGhlIHNhbWUgZGlyZWN0aW9uXG5cdFx0XHRcdGVkZ2UxLmRlbHRhKCBkaXIxICk7XG5cdFx0XHRcdGVkZ2UyLmRlbHRhKCBkaXIyICk7XG5cblx0XHRcdFx0aWYgKCBkaXIxLmRvdCggZGlyMiApIDwgMCApIHtcblxuXHRcdFx0XHRcdGxldCB0bXAgPSBlZGdlMi5zdGFydDtcblx0XHRcdFx0XHRlZGdlMi5zdGFydCA9IGVkZ2UyLmVuZDtcblx0XHRcdFx0XHRlZGdlMi5lbmQgPSB0bXA7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNoZWNrIGlmIHRoZSBlZGdlcyBhcmUgb3ZlcmxhcHBpbmdcblx0XHRcdFx0Y29uc3QgczEgPSBlZGdlMS5zdGFydC5kb3QoIGRpcjEgKTtcblx0XHRcdFx0Y29uc3QgZTEgPSBlZGdlMS5lbmQuZG90KCBkaXIxICk7XG5cdFx0XHRcdGNvbnN0IHMyID0gZWRnZTIuc3RhcnQuZG90KCBkaXIxICk7XG5cdFx0XHRcdGNvbnN0IGUyID0gZWRnZTIuZW5kLmRvdCggZGlyMSApO1xuXHRcdFx0XHRjb25zdCBzZXBhcmF0ZWQxID0gZTEgPCBzMjtcblx0XHRcdFx0Y29uc3Qgc2VwYXJhdGVkMiA9IHMxIDwgZTI7XG5cblx0XHRcdFx0aWYgKCBzMSAhPT0gZTIgJiYgczIgIT09IGUxICYmIHNlcGFyYXRlZDEgPT09IHNlcGFyYXRlZDIgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFzc2lnbiB0aGUgdGFyZ2V0IG91dHB1dFxuXHRcdFx0XHRpZiAoIHRhcmdldCApIHtcblxuXHRcdFx0XHRcdHRlbXBEaXIuc3ViVmVjdG9ycyggZWRnZTEuc3RhcnQsIGVkZ2UyLnN0YXJ0ICk7XG5cdFx0XHRcdFx0aWYgKCB0ZW1wRGlyLmRvdCggZGlyMSApID4gMCApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0LnN0YXJ0LmNvcHkoIGVkZ2UxLnN0YXJ0ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXQuc3RhcnQuY29weSggZWRnZTIuc3RhcnQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRlbXBEaXIuc3ViVmVjdG9ycyggZWRnZTEuZW5kLCBlZGdlMi5lbmQgKTtcblx0XHRcdFx0XHRpZiAoIHRlbXBEaXIuZG90KCBkaXIxICkgPCAwICkge1xuXG5cdFx0XHRcdFx0XHR0YXJnZXQuZW5kLmNvcHkoIGVkZ2UxLmVuZCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0LmVuZC5jb3B5KCBlZGdlMi5lbmQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fSApKCk7XG5cblxuXHRFeHRlbmRlZFRyaWFuZ2xlLnByb3RvdHlwZS5kaXN0YW5jZVRvUG9pbnQgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnN0IHRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XG5cblx0XHRcdHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQsIHRhcmdldCApO1xuXHRcdFx0cmV0dXJuIHBvaW50LmRpc3RhbmNlVG8oIHRhcmdldCApO1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXG5cdEV4dGVuZGVkVHJpYW5nbGUucHJvdG90eXBlLmRpc3RhbmNlVG9UcmlhbmdsZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc3QgcG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IHBvaW50MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0Y29uc3QgY29ybmVyRmllbGRzID0gWyAnYScsICdiJywgJ2MnIF07XG5cdFx0Y29uc3QgbGluZTEgPSBuZXcgVEhSRUUuTGluZTMoKTtcblx0XHRjb25zdCBsaW5lMiA9IG5ldyBUSFJFRS5MaW5lMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlVG9UcmlhbmdsZSggb3RoZXIsIHRhcmdldDEgPSBudWxsLCB0YXJnZXQyID0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgbGluZVRhcmdldCA9IHRhcmdldDEgfHwgdGFyZ2V0MiA/IGxpbmUxIDogbnVsbDtcblx0XHRcdGlmICggdGhpcy5pbnRlcnNlY3RzVHJpYW5nbGUoIG90aGVyLCBsaW5lVGFyZ2V0ICkgKSB7XG5cblx0XHRcdFx0aWYgKCB0YXJnZXQxIHx8IHRhcmdldDIgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHRhcmdldDEgKSBsaW5lVGFyZ2V0LmdldENlbnRlciggdGFyZ2V0MSApO1xuXHRcdFx0XHRcdGlmICggdGFyZ2V0MiApIGxpbmVUYXJnZXQuZ2V0Q2VudGVyKCB0YXJnZXQyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAwO1xuXG5cdFx0XHR9XG5cblx0XHRcdGxldCBjbG9zZXN0RGlzdGFuY2VTcSA9IEluZmluaXR5O1xuXG5cdFx0XHQvLyBjaGVjayBhbGwgcG9pbnQgZGlzdGFuY2VzXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGxldCBkaXN0O1xuXHRcdFx0XHRjb25zdCBmaWVsZCA9IGNvcm5lckZpZWxkc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBvdGhlclZlYyA9IG90aGVyWyBmaWVsZCBdO1xuXHRcdFx0XHR0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnQoIG90aGVyVmVjLCBwb2ludCApO1xuXG5cdFx0XHRcdGRpc3QgPSBvdGhlclZlYy5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuXHRcdFx0XHRpZiAoIGRpc3QgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxID0gZGlzdDtcblx0XHRcdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHBvaW50ICk7XG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQyICkgdGFyZ2V0Mi5jb3B5KCBvdGhlclZlYyApO1xuXG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdGNvbnN0IHRoaXNWZWMgPSB0aGlzWyBmaWVsZCBdO1xuXHRcdFx0XHRvdGhlci5jbG9zZXN0UG9pbnRUb1BvaW50KCB0aGlzVmVjLCBwb2ludCApO1xuXG5cdFx0XHRcdGRpc3QgPSB0aGlzVmVjLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG5cdFx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZVNxICkge1xuXG5cdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlU3EgPSBkaXN0O1xuXHRcdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggdGhpc1ZlYyApO1xuXHRcdFx0XHRcdGlmICggdGFyZ2V0MiApIHRhcmdldDIuY29weSggcG9pbnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBmMTEgPSBjb3JuZXJGaWVsZHNbIGkgXTtcblx0XHRcdFx0Y29uc3QgZjEyID0gY29ybmVyRmllbGRzWyAoIGkgKyAxICkgJSAzIF07XG5cdFx0XHRcdGxpbmUxLnNldCggdGhpc1sgZjExIF0sIHRoaXNbIGYxMiBdICk7XG5cdFx0XHRcdGZvciAoIGxldCBpMiA9IDA7IGkyIDwgMzsgaTIgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBmMjEgPSBjb3JuZXJGaWVsZHNbIGkyIF07XG5cdFx0XHRcdFx0Y29uc3QgZjIyID0gY29ybmVyRmllbGRzWyAoIGkyICsgMSApICUgMyBdO1xuXHRcdFx0XHRcdGxpbmUyLnNldCggb3RoZXJbIGYyMSBdLCBvdGhlclsgZjIyIF0gKTtcblxuXHRcdFx0XHRcdGNsb3Nlc3RQb2ludHNTZWdtZW50VG9TZWdtZW50KCBsaW5lMSwgbGluZTIsIHBvaW50LCBwb2ludDIgKTtcblxuXHRcdFx0XHRcdGNvbnN0IGRpc3QgPSBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQyICk7XG5cdFx0XHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlU3EgKSB7XG5cblx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxID0gZGlzdDtcblx0XHRcdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggcG9pbnQgKTtcblx0XHRcdFx0XHRcdGlmICggdGFyZ2V0MiApIHRhcmdldDIuY29weSggcG9pbnQyICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBNYXRoLnNxcnQoIGNsb3Nlc3REaXN0YW5jZVNxICk7XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cdGNsYXNzIE9yaWVudGVkQm94IHtcblxuXHRcdGNvbnN0cnVjdG9yKCBtaW4sIG1heCwgbWF0cml4ICkge1xuXG5cdFx0XHR0aGlzLmlzT3JpZW50ZWRCb3ggPSB0cnVlO1xuXHRcdFx0dGhpcy5taW4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0dGhpcy5tYXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0dGhpcy5tYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRcdFx0dGhpcy5pbnZNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRcdFx0dGhpcy5wb2ludHMgPSBuZXcgQXJyYXkoIDggKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgVEhSRUUuVmVjdG9yMygpICk7XG5cdFx0XHR0aGlzLnNhdEF4ZXMgPSBuZXcgQXJyYXkoIDMgKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgVEhSRUUuVmVjdG9yMygpICk7XG5cdFx0XHR0aGlzLnNhdEJvdW5kcyA9IG5ldyBBcnJheSggMyApLmZpbGwoKS5tYXAoICgpID0+IG5ldyBTZXBhcmF0aW5nQXhpc0JvdW5kcygpICk7XG5cdFx0XHR0aGlzLmFsaWduZWRTYXRCb3VuZHMgPSBuZXcgQXJyYXkoIDMgKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKSApO1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoIG1pbiApIHRoaXMubWluLmNvcHkoIG1pbiApO1xuXHRcdFx0aWYgKCBtYXggKSB0aGlzLm1heC5jb3B5KCBtYXggKTtcblx0XHRcdGlmICggbWF0cml4ICkgdGhpcy5tYXRyaXguY29weSggbWF0cml4ICk7XG5cblx0XHR9XG5cblx0XHRzZXQoIG1pbiwgbWF4LCBtYXRyaXggKSB7XG5cblx0XHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xuXHRcdFx0dGhpcy5tYXguY29weSggbWF4ICk7XG5cdFx0XHR0aGlzLm1hdHJpeC5jb3B5KCBtYXRyaXggKTtcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0Y29weSggb3RoZXIgKSB7XG5cblx0XHRcdHRoaXMubWluLmNvcHkoIG90aGVyLm1pbiApO1xuXHRcdFx0dGhpcy5tYXguY29weSggb3RoZXIubWF4ICk7XG5cdFx0XHR0aGlzLm1hdHJpeC5jb3B5KCBvdGhlci5tYXRyaXggKTtcblx0XHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRPcmllbnRlZEJveC5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG5cdFx0XHRjb25zdCBtYXRyaXggPSB0aGlzLm1hdHJpeDtcblx0XHRcdGNvbnN0IG1pbiA9IHRoaXMubWluO1xuXHRcdFx0Y29uc3QgbWF4ID0gdGhpcy5tYXg7XG5cblx0XHRcdGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdFx0Zm9yICggbGV0IHggPSAwOyB4IDw9IDE7IHggKysgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IHkgPSAwOyB5IDw9IDE7IHkgKysgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgeiA9IDA7IHogPD0gMTsgeiArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgaSA9ICggKCAxIDw8IDAgKSAqIHggKSB8ICggKCAxIDw8IDEgKSAqIHkgKSB8ICggKCAxIDw8IDIgKSAqIHogKTtcblx0XHRcdFx0XHRcdGNvbnN0IHYgPSBwb2ludHNbIGkgXTtcblx0XHRcdFx0XHRcdHYueCA9IHggPyBtYXgueCA6IG1pbi54O1xuXHRcdFx0XHRcdFx0di55ID0geSA/IG1heC55IDogbWluLnk7XG5cdFx0XHRcdFx0XHR2LnogPSB6ID8gbWF4LnogOiBtaW4uejtcblxuXHRcdFx0XHRcdFx0di5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzYXRCb3VuZHMgPSB0aGlzLnNhdEJvdW5kcztcblx0XHRcdGNvbnN0IHNhdEF4ZXMgPSB0aGlzLnNhdEF4ZXM7XG5cdFx0XHRjb25zdCBtaW5WZWMgPSBwb2ludHNbIDAgXTtcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYXhpcyA9IHNhdEF4ZXNbIGkgXTtcblx0XHRcdFx0Y29uc3Qgc2IgPSBzYXRCb3VuZHNbIGkgXTtcblx0XHRcdFx0Y29uc3QgaW5kZXggPSAxIDw8IGk7XG5cdFx0XHRcdGNvbnN0IHBpID0gcG9pbnRzWyBpbmRleCBdO1xuXG5cdFx0XHRcdGF4aXMuc3ViVmVjdG9ycyggbWluVmVjLCBwaSApO1xuXHRcdFx0XHRzYi5zZXRGcm9tUG9pbnRzKCBheGlzLCBwb2ludHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBhbGlnbmVkU2F0Qm91bmRzID0gdGhpcy5hbGlnbmVkU2F0Qm91bmRzO1xuXHRcdFx0YWxpZ25lZFNhdEJvdW5kc1sgMCBdLnNldEZyb21Qb2ludHNGaWVsZCggcG9pbnRzLCAneCcgKTtcblx0XHRcdGFsaWduZWRTYXRCb3VuZHNbIDEgXS5zZXRGcm9tUG9pbnRzRmllbGQoIHBvaW50cywgJ3knICk7XG5cdFx0XHRhbGlnbmVkU2F0Qm91bmRzWyAyIF0uc2V0RnJvbVBvaW50c0ZpZWxkKCBwb2ludHMsICd6JyApO1xuXG5cdFx0XHR0aGlzLmludk1hdHJpeC5jb3B5KCB0aGlzLm1hdHJpeCApLmludmVydCgpO1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHRPcmllbnRlZEJveC5wcm90b3R5cGUuaW50ZXJzZWN0c0JveCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc3QgYWFiYkJvdW5kcyA9IG5ldyBTZXBhcmF0aW5nQXhpc0JvdW5kcygpO1xuXHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cblx0XHRcdC8vIFRPRE86IHNob3VsZCB0aGlzIGJlIGRvaW5nIFNBVCBhZ2FpbnN0IHRoZSBBQUJCP1xuXHRcdFx0aWYgKCB0aGlzLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbWluID0gYm94Lm1pbjtcblx0XHRcdGNvbnN0IG1heCA9IGJveC5tYXg7XG5cdFx0XHRjb25zdCBzYXRCb3VuZHMgPSB0aGlzLnNhdEJvdW5kcztcblx0XHRcdGNvbnN0IHNhdEF4ZXMgPSB0aGlzLnNhdEF4ZXM7XG5cdFx0XHRjb25zdCBhbGlnbmVkU2F0Qm91bmRzID0gdGhpcy5hbGlnbmVkU2F0Qm91bmRzO1xuXG5cdFx0XHRhYWJiQm91bmRzLm1pbiA9IG1pbi54O1xuXHRcdFx0YWFiYkJvdW5kcy5tYXggPSBtYXgueDtcblx0XHRcdGlmICggYWxpZ25lZFNhdEJvdW5kc1sgMCBdLmlzU2VwYXJhdGVkKCBhYWJiQm91bmRzICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdGFhYmJCb3VuZHMubWluID0gbWluLnk7XG5cdFx0XHRhYWJiQm91bmRzLm1heCA9IG1heC55O1xuXHRcdFx0aWYgKCBhbGlnbmVkU2F0Qm91bmRzWyAxIF0uaXNTZXBhcmF0ZWQoIGFhYmJCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0YWFiYkJvdW5kcy5taW4gPSBtaW4uejtcblx0XHRcdGFhYmJCb3VuZHMubWF4ID0gbWF4Lno7XG5cdFx0XHRpZiAoIGFsaWduZWRTYXRCb3VuZHNbIDIgXS5pc1NlcGFyYXRlZCggYWFiYkJvdW5kcyApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGF4aXMgPSBzYXRBeGVzWyBpIF07XG5cdFx0XHRcdGNvbnN0IHNiID0gc2F0Qm91bmRzWyBpIF07XG5cdFx0XHRcdGFhYmJCb3VuZHMuc2V0RnJvbUJveCggYXhpcywgYm94ICk7XG5cdFx0XHRcdGlmICggc2IuaXNTZXBhcmF0ZWQoIGFhYmJCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH07XG5cblx0fSApKCk7XG5cblx0T3JpZW50ZWRCb3gucHJvdG90eXBlLmludGVyc2VjdHNUcmlhbmdsZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc3Qgc2FUcmkgPSBuZXcgRXh0ZW5kZWRUcmlhbmdsZSgpO1xuXHRcdGNvbnN0IHBvaW50c0FyciA9IG5ldyBBcnJheSggMyApO1xuXHRcdGNvbnN0IGNhY2hlZFNhdEJvdW5kcyA9IG5ldyBTZXBhcmF0aW5nQXhpc0JvdW5kcygpO1xuXHRcdGNvbnN0IGNhY2hlZFNhdEJvdW5kczIgPSBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKTtcblx0XHRjb25zdCBjYWNoZWRBeGlzID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c1RyaWFuZ2xlKCB0cmlhbmdsZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhIHRyaWFuZ2xlLmlzRXh0ZW5kZWRUcmlhbmdsZSApIHtcblxuXHRcdFx0XHRzYVRyaS5jb3B5KCB0cmlhbmdsZSApO1xuXHRcdFx0XHRzYVRyaS51cGRhdGUoKTtcblx0XHRcdFx0dHJpYW5nbGUgPSBzYVRyaTtcblxuXHRcdFx0fSBlbHNlIGlmICggdHJpYW5nbGUubmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdFx0dHJpYW5nbGUudXBkYXRlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2F0Qm91bmRzID0gdGhpcy5zYXRCb3VuZHM7XG5cdFx0XHRjb25zdCBzYXRBeGVzID0gdGhpcy5zYXRBeGVzO1xuXG5cdFx0XHRwb2ludHNBcnJbIDAgXSA9IHRyaWFuZ2xlLmE7XG5cdFx0XHRwb2ludHNBcnJbIDEgXSA9IHRyaWFuZ2xlLmI7XG5cdFx0XHRwb2ludHNBcnJbIDIgXSA9IHRyaWFuZ2xlLmM7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2IgPSBzYXRCb3VuZHNbIGkgXTtcblx0XHRcdFx0Y29uc3Qgc2EgPSBzYXRBeGVzWyBpIF07XG5cdFx0XHRcdGNhY2hlZFNhdEJvdW5kcy5zZXRGcm9tUG9pbnRzKCBzYSwgcG9pbnRzQXJyICk7XG5cdFx0XHRcdGlmICggc2IuaXNTZXBhcmF0ZWQoIGNhY2hlZFNhdEJvdW5kcyApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHRyaVNhdEJvdW5kcyA9IHRyaWFuZ2xlLnNhdEJvdW5kcztcblx0XHRcdGNvbnN0IHRyaVNhdEF4ZXMgPSB0cmlhbmdsZS5zYXRBeGVzO1xuXHRcdFx0Y29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNiID0gdHJpU2F0Qm91bmRzWyBpIF07XG5cdFx0XHRcdGNvbnN0IHNhID0gdHJpU2F0QXhlc1sgaSBdO1xuXHRcdFx0XHRjYWNoZWRTYXRCb3VuZHMuc2V0RnJvbVBvaW50cyggc2EsIHBvaW50cyApO1xuXHRcdFx0XHRpZiAoIHNiLmlzU2VwYXJhdGVkKCBjYWNoZWRTYXRCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBjcm9zc2VkIGF4ZXNcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2ExID0gc2F0QXhlc1sgaSBdO1xuXHRcdFx0XHRmb3IgKCBsZXQgaTIgPSAwOyBpMiA8IDQ7IGkyICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3Qgc2EyID0gdHJpU2F0QXhlc1sgaTIgXTtcblx0XHRcdFx0XHRjYWNoZWRBeGlzLmNyb3NzVmVjdG9ycyggc2ExLCBzYTIgKTtcblx0XHRcdFx0XHRjYWNoZWRTYXRCb3VuZHMuc2V0RnJvbVBvaW50cyggY2FjaGVkQXhpcywgcG9pbnRzQXJyICk7XG5cdFx0XHRcdFx0Y2FjaGVkU2F0Qm91bmRzMi5zZXRGcm9tUG9pbnRzKCBjYWNoZWRBeGlzLCBwb2ludHMgKTtcblx0XHRcdFx0XHRpZiAoIGNhY2hlZFNhdEJvdW5kcy5pc1NlcGFyYXRlZCggY2FjaGVkU2F0Qm91bmRzMiApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH07XG5cblx0fSApKCk7XG5cblx0T3JpZW50ZWRCb3gucHJvdG90eXBlLmNsb3Nlc3RQb2ludFRvUG9pbnQgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBjbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCwgdGFyZ2V0MSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGFyZ2V0MVxuXHRcdFx0XHQuY29weSggcG9pbnQgKVxuXHRcdFx0XHQuYXBwbHlNYXRyaXg0KCB0aGlzLmludk1hdHJpeCApXG5cdFx0XHRcdC5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4IClcblx0XHRcdFx0LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXggKTtcblxuXHRcdFx0cmV0dXJuIHRhcmdldDE7XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cdE9yaWVudGVkQm94LnByb3RvdHlwZS5kaXN0YW5jZVRvUG9pbnQgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnN0IHRhcmdldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XG5cblx0XHRcdHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQsIHRhcmdldCApO1xuXHRcdFx0cmV0dXJuIHBvaW50LmRpc3RhbmNlVG8oIHRhcmdldCApO1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHRPcmllbnRlZEJveC5wcm90b3R5cGUuZGlzdGFuY2VUb0JveCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc3QgeHl6RmllbGRzID0gWyAneCcsICd5JywgJ3onIF07XG5cdFx0Y29uc3Qgc2VnbWVudHMxID0gbmV3IEFycmF5KCAxMiApLmZpbGwoKS5tYXAoICgpID0+IG5ldyBUSFJFRS5MaW5lMygpICk7XG5cdFx0Y29uc3Qgc2VnbWVudHMyID0gbmV3IEFycmF5KCAxMiApLmZpbGwoKS5tYXAoICgpID0+IG5ldyBUSFJFRS5MaW5lMygpICk7XG5cblx0XHRjb25zdCBwb2ludDEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGNvbnN0IHBvaW50MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHQvLyBlYXJseSBvdXQgaWYgd2UgZmluZCBhIHZhbHVlIGJlbG93IHRocmVzaG9sZFxuXHRcdHJldHVybiBmdW5jdGlvbiBkaXN0YW5jZVRvQm94KCBib3gsIHRocmVzaG9sZCA9IDAsIHRhcmdldDEgPSBudWxsLCB0YXJnZXQyID0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCB0aGlzLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLmludGVyc2VjdHNCb3goIGJveCApICkge1xuXG5cdFx0XHRcdGlmICggdGFyZ2V0MSB8fCB0YXJnZXQyICkge1xuXG5cdFx0XHRcdFx0Ym94LmdldENlbnRlciggcG9pbnQyICk7XG5cdFx0XHRcdFx0dGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludDIsIHBvaW50MSApO1xuXHRcdFx0XHRcdGJveC5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludDEsIHBvaW50MiApO1xuXG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQxICkgdGFyZ2V0MS5jb3B5KCBwb2ludDEgKTtcblx0XHRcdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIHBvaW50MiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gMDtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0aHJlc2hvbGQyID0gdGhyZXNob2xkICogdGhyZXNob2xkO1xuXHRcdFx0Y29uc3QgbWluID0gYm94Lm1pbjtcblx0XHRcdGNvbnN0IG1heCA9IGJveC5tYXg7XG5cdFx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcblxuXG5cdFx0XHQvLyBpdGVyYXRlIG92ZXIgZXZlcnkgZWRnZSBhbmQgY29tcGFyZSBkaXN0YW5jZXNcblx0XHRcdGxldCBjbG9zZXN0RGlzdGFuY2VTcSA9IEluZmluaXR5O1xuXG5cdFx0XHQvLyBjaGVjayBvdmVyIGFsbCB0aGVzZSBwb2ludHNcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDg7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgcCA9IHBvaW50c1sgaSBdO1xuXHRcdFx0XHRwb2ludDIuY29weSggcCApLmNsYW1wKCBtaW4sIG1heCApO1xuXG5cdFx0XHRcdGNvbnN0IGRpc3QgPSBwLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludDIgKTtcblx0XHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlU3EgKSB7XG5cblx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3Q7XG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQxICkgdGFyZ2V0MS5jb3B5KCBwICk7XG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQyICkgdGFyZ2V0Mi5jb3B5KCBwb2ludDIgKTtcblxuXHRcdFx0XHRcdGlmICggZGlzdCA8IHRocmVzaG9sZDIgKSByZXR1cm4gTWF0aC5zcXJ0KCBkaXN0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGdlbmVyYXRlIGFuZCBjaGVjayBhbGwgbGluZSBzZWdtZW50IGRpc3RhbmNlc1xuXHRcdFx0bGV0IGNvdW50ID0gMDtcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkxID0gMDsgaTEgPD0gMTsgaTEgKysgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaTIgPSAwOyBpMiA8PSAxOyBpMiArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgbmV4dEluZGV4ID0gKCBpICsgMSApICUgMztcblx0XHRcdFx0XHRcdGNvbnN0IG5leHRJbmRleDIgPSAoIGkgKyAyICkgJSAzO1xuXG5cdFx0XHRcdFx0XHQvLyBnZXQgb2JiIGxpbmUgc2VnbWVudHNcblx0XHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gaTEgPDwgbmV4dEluZGV4IHwgaTIgPDwgbmV4dEluZGV4Mjtcblx0XHRcdFx0XHRcdGNvbnN0IGluZGV4MiA9IDEgPDwgaSB8IGkxIDw8IG5leHRJbmRleCB8IGkyIDw8IG5leHRJbmRleDI7XG5cdFx0XHRcdFx0XHRjb25zdCBwMSA9IHBvaW50c1sgaW5kZXggXTtcblx0XHRcdFx0XHRcdGNvbnN0IHAyID0gcG9pbnRzWyBpbmRleDIgXTtcblx0XHRcdFx0XHRcdGNvbnN0IGxpbmUxID0gc2VnbWVudHMxWyBjb3VudCBdO1xuXHRcdFx0XHRcdFx0bGluZTEuc2V0KCBwMSwgcDIgKTtcblxuXG5cdFx0XHRcdFx0XHQvLyBnZXQgYWFiYiBsaW5lIHNlZ21lbnRzXG5cdFx0XHRcdFx0XHRjb25zdCBmMSA9IHh5ekZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgZjIgPSB4eXpGaWVsZHNbIG5leHRJbmRleCBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgZjMgPSB4eXpGaWVsZHNbIG5leHRJbmRleDIgXTtcblx0XHRcdFx0XHRcdGNvbnN0IGxpbmUyID0gc2VnbWVudHMyWyBjb3VudCBdO1xuXHRcdFx0XHRcdFx0Y29uc3Qgc3RhcnQgPSBsaW5lMi5zdGFydDtcblx0XHRcdFx0XHRcdGNvbnN0IGVuZCA9IGxpbmUyLmVuZDtcblxuXHRcdFx0XHRcdFx0c3RhcnRbIGYxIF0gPSBtaW5bIGYxIF07XG5cdFx0XHRcdFx0XHRzdGFydFsgZjIgXSA9IGkxID8gbWluWyBmMiBdIDogbWF4WyBmMiBdO1xuXHRcdFx0XHRcdFx0c3RhcnRbIGYzIF0gPSBpMiA/IG1pblsgZjMgXSA6IG1heFsgZjIgXTtcblxuXHRcdFx0XHRcdFx0ZW5kWyBmMSBdID0gbWF4WyBmMSBdO1xuXHRcdFx0XHRcdFx0ZW5kWyBmMiBdID0gaTEgPyBtaW5bIGYyIF0gOiBtYXhbIGYyIF07XG5cdFx0XHRcdFx0XHRlbmRbIGYzIF0gPSBpMiA/IG1pblsgZjMgXSA6IG1heFsgZjIgXTtcblxuXHRcdFx0XHRcdFx0Y291bnQgKys7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoZWNrIGFsbCB0aGUgb3RoZXIgYm94ZXMgcG9pbnRcblx0XHRcdGZvciAoIGxldCB4ID0gMDsgeCA8PSAxOyB4ICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCB5ID0gMDsgeSA8PSAxOyB5ICsrICkge1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IHogPSAwOyB6IDw9IDE7IHogKysgKSB7XG5cblx0XHRcdFx0XHRcdHBvaW50Mi54ID0geCA/IG1heC54IDogbWluLng7XG5cdFx0XHRcdFx0XHRwb2ludDIueSA9IHkgPyBtYXgueSA6IG1pbi55O1xuXHRcdFx0XHRcdFx0cG9pbnQyLnogPSB6ID8gbWF4LnogOiBtaW4uejtcblxuXHRcdFx0XHRcdFx0dGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludDIsIHBvaW50MSApO1xuXHRcdFx0XHRcdFx0Y29uc3QgZGlzdCA9IHBvaW50Mi5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQxICk7XG5cdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggcG9pbnQxICk7XG5cdFx0XHRcdFx0XHRcdGlmICggdGFyZ2V0MiApIHRhcmdldDIuY29weSggcG9pbnQyICk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgdGhyZXNob2xkMiApIHJldHVybiBNYXRoLnNxcnQoIGRpc3QgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAxMjsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCBsMSA9IHNlZ21lbnRzMVsgaSBdO1xuXHRcdFx0XHRmb3IgKCBsZXQgaTIgPSAwOyBpMiA8IDEyOyBpMiArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGwyID0gc2VnbWVudHMyWyBpMiBdO1xuXHRcdFx0XHRcdGNsb3Nlc3RQb2ludHNTZWdtZW50VG9TZWdtZW50KCBsMSwgbDIsIHBvaW50MSwgcG9pbnQyICk7XG5cdFx0XHRcdFx0Y29uc3QgZGlzdCA9IHBvaW50MS5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQyICk7XG5cdFx0XHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlU3EgKSB7XG5cblx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxID0gZGlzdDtcblx0XHRcdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggcG9pbnQxICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIHBvaW50MiApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCB0aHJlc2hvbGQyICkgcmV0dXJuIE1hdGguc3FydCggZGlzdCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCBjbG9zZXN0RGlzdGFuY2VTcSApO1xuXG5cdFx0fTtcblxuXHR9ICkoKTtcblxuXHRjbGFzcyBQcmltaXRpdmVQb29sIHtcblxuXHRcdGNvbnN0cnVjdG9yKCBnZXROZXdQcmltaXRpdmUgKSB7XG5cblx0XHRcdHRoaXMuX2dldE5ld1ByaW1pdGl2ZSA9IGdldE5ld1ByaW1pdGl2ZTtcblx0XHRcdHRoaXMuX3ByaW1pdGl2ZXMgPSBbXTtcblxuXHRcdH1cblxuXHRcdGdldFByaW1pdGl2ZSgpIHtcblxuXHRcdFx0Y29uc3QgcHJpbWl0aXZlcyA9IHRoaXMuX3ByaW1pdGl2ZXM7XG5cdFx0XHRpZiAoIHByaW1pdGl2ZXMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLl9nZXROZXdQcmltaXRpdmUoKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gcHJpbWl0aXZlcy5wb3AoKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmVsZWFzZVByaW1pdGl2ZSggcHJpbWl0aXZlICkge1xuXG5cdFx0XHR0aGlzLl9wcmltaXRpdmVzLnB1c2goIHByaW1pdGl2ZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBFeHRlbmRlZFRyaWFuZ2xlUG9vbEJhc2UgZXh0ZW5kcyBQcmltaXRpdmVQb29sIHtcblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0XHRzdXBlciggKCkgPT4gbmV3IEV4dGVuZGVkVHJpYW5nbGUoKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCBFeHRlbmRlZFRyaWFuZ2xlUG9vbCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRXh0ZW5kZWRUcmlhbmdsZVBvb2xCYXNlKCk7XG5cblx0Y2xhc3MgX0J1ZmZlclN0YWNrIHtcblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0XHR0aGlzLmZsb2F0MzJBcnJheSA9IG51bGw7XG5cdFx0XHR0aGlzLnVpbnQxNkFycmF5ID0gbnVsbDtcblx0XHRcdHRoaXMudWludDMyQXJyYXkgPSBudWxsO1xuXG5cdFx0XHRjb25zdCBzdGFjayA9IFtdO1xuXHRcdFx0bGV0IHByZXZCdWZmZXIgPSBudWxsO1xuXHRcdFx0dGhpcy5zZXRCdWZmZXIgPSBidWZmZXIgPT4ge1xuXG5cdFx0XHRcdGlmICggcHJldkJ1ZmZlciApIHtcblxuXHRcdFx0XHRcdHN0YWNrLnB1c2goIHByZXZCdWZmZXIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cHJldkJ1ZmZlciA9IGJ1ZmZlcjtcblx0XHRcdFx0dGhpcy5mbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBidWZmZXIgKTtcblx0XHRcdFx0dGhpcy51aW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheSggYnVmZmVyICk7XG5cdFx0XHRcdHRoaXMudWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoIGJ1ZmZlciApO1xuXG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLmNsZWFyQnVmZmVyID0gKCkgPT4ge1xuXG5cdFx0XHRcdHByZXZCdWZmZXIgPSBudWxsO1xuXHRcdFx0XHR0aGlzLmZsb2F0MzJBcnJheSA9IG51bGw7XG5cdFx0XHRcdHRoaXMudWludDE2QXJyYXkgPSBudWxsO1xuXHRcdFx0XHR0aGlzLnVpbnQzMkFycmF5ID0gbnVsbDtcblxuXHRcdFx0XHRpZiAoIHN0YWNrLmxlbmd0aCAhPT0gMCApIHtcblxuXHRcdFx0XHRcdHRoaXMuc2V0QnVmZmVyKCBzdGFjay5wb3AoKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgQnVmZmVyU3RhY2sgPSBuZXcgX0J1ZmZlclN0YWNrKCk7XG5cblx0bGV0IF9ib3gxJDEsIF9ib3gyJDE7XG5cdGNvbnN0IGJveFN0YWNrID0gW107XG5cdGNvbnN0IGJveFBvb2wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFByaW1pdGl2ZVBvb2woICgpID0+IG5ldyBUSFJFRS5Cb3gzKCkgKTtcblxuXHRmdW5jdGlvbiBzaGFwZWNhc3QoIGJ2aCwgcm9vdCwgaW50ZXJzZWN0c0JvdW5kcywgaW50ZXJzZWN0c1JhbmdlLCBib3VuZHNUcmF2ZXJzZU9yZGVyLCBieXRlT2Zmc2V0ICkge1xuXG5cdFx0Ly8gc2V0dXBcblx0XHRfYm94MSQxID0gYm94UG9vbC5nZXRQcmltaXRpdmUoKTtcblx0XHRfYm94MiQxID0gYm94UG9vbC5nZXRQcmltaXRpdmUoKTtcblx0XHRib3hTdGFjay5wdXNoKCBfYm94MSQxLCBfYm94MiQxICk7XG5cdFx0QnVmZmVyU3RhY2suc2V0QnVmZmVyKCBidmguX3Jvb3RzWyByb290IF0gKTtcblxuXHRcdGNvbnN0IHJlc3VsdCA9IHNoYXBlY2FzdFRyYXZlcnNlKCAwLCBidmguZ2VvbWV0cnksIGludGVyc2VjdHNCb3VuZHMsIGludGVyc2VjdHNSYW5nZSwgYm91bmRzVHJhdmVyc2VPcmRlciwgYnl0ZU9mZnNldCApO1xuXG5cdFx0Ly8gY2xlYW51cFxuXHRcdEJ1ZmZlclN0YWNrLmNsZWFyQnVmZmVyKCk7XG5cdFx0Ym94UG9vbC5yZWxlYXNlUHJpbWl0aXZlKCBfYm94MSQxICk7XG5cdFx0Ym94UG9vbC5yZWxlYXNlUHJpbWl0aXZlKCBfYm94MiQxICk7XG5cdFx0Ym94U3RhY2sucG9wKCk7XG5cdFx0Ym94U3RhY2sucG9wKCk7XG5cblx0XHRjb25zdCBsZW5ndGggPSBib3hTdGFjay5sZW5ndGg7XG5cdFx0aWYgKCBsZW5ndGggPiAwICkge1xuXG5cdFx0XHRfYm94MiQxID0gYm94U3RhY2tbIGxlbmd0aCAtIDEgXTtcblx0XHRcdF9ib3gxJDEgPSBib3hTdGFja1sgbGVuZ3RoIC0gMiBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2hhcGVjYXN0VHJhdmVyc2UoXG5cdFx0bm9kZUluZGV4MzIsXG5cdFx0Z2VvbWV0cnksXG5cdFx0aW50ZXJzZWN0c0JvdW5kc0Z1bmMsXG5cdFx0aW50ZXJzZWN0c1JhbmdlRnVuYyxcblx0XHRub2RlU2NvcmVGdW5jID0gbnVsbCxcblx0XHRub2RlSW5kZXhCeXRlT2Zmc2V0ID0gMCwgLy8gb2Zmc2V0IGZvciB1bmlxdWUgbm9kZSBpZGVudGlmaWVyXG5cdFx0ZGVwdGggPSAwXG5cdCkge1xuXG5cdFx0Y29uc3QgeyBmbG9hdDMyQXJyYXksIHVpbnQxNkFycmF5LCB1aW50MzJBcnJheSB9ID0gQnVmZmVyU3RhY2s7XG5cdFx0bGV0IG5vZGVJbmRleDE2ID0gbm9kZUluZGV4MzIgKiAyO1xuXG5cdFx0Y29uc3QgaXNMZWFmID0gSVNfTEVBRiggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cdFx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRcdGNvbnN0IG9mZnNldCA9IE9GRlNFVCggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0XHRjb25zdCBjb3VudCA9IENPVU5UKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIG5vZGVJbmRleDMyICksIGZsb2F0MzJBcnJheSwgX2JveDEkMSApO1xuXHRcdFx0cmV0dXJuIGludGVyc2VjdHNSYW5nZUZ1bmMoIG9mZnNldCwgY291bnQsIGZhbHNlLCBkZXB0aCwgbm9kZUluZGV4Qnl0ZU9mZnNldCArIG5vZGVJbmRleDMyLCBfYm94MSQxICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBsZWZ0ID0gTEVGVF9OT0RFKCBub2RlSW5kZXgzMiApO1xuXHRcdFx0Y29uc3QgcmlnaHQgPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdGxldCBjMSA9IGxlZnQ7XG5cdFx0XHRsZXQgYzIgPSByaWdodDtcblxuXHRcdFx0bGV0IHNjb3JlMSwgc2NvcmUyO1xuXHRcdFx0bGV0IGJveDEsIGJveDI7XG5cdFx0XHRpZiAoIG5vZGVTY29yZUZ1bmMgKSB7XG5cblx0XHRcdFx0Ym94MSA9IF9ib3gxJDE7XG5cdFx0XHRcdGJveDIgPSBfYm94MiQxO1xuXG5cdFx0XHRcdC8vIGJvdW5kaW5nIGRhdGEgaXMgbm90IG9mZnNldFxuXHRcdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjMSApLCBmbG9hdDMyQXJyYXksIGJveDEgKTtcblx0XHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggYzIgKSwgZmxvYXQzMkFycmF5LCBib3gyICk7XG5cblx0XHRcdFx0c2NvcmUxID0gbm9kZVNjb3JlRnVuYyggYm94MSApO1xuXHRcdFx0XHRzY29yZTIgPSBub2RlU2NvcmVGdW5jKCBib3gyICk7XG5cblx0XHRcdFx0aWYgKCBzY29yZTIgPCBzY29yZTEgKSB7XG5cblx0XHRcdFx0XHRjMSA9IHJpZ2h0O1xuXHRcdFx0XHRcdGMyID0gbGVmdDtcblxuXHRcdFx0XHRcdGNvbnN0IHRlbXAgPSBzY29yZTE7XG5cdFx0XHRcdFx0c2NvcmUxID0gc2NvcmUyO1xuXHRcdFx0XHRcdHNjb3JlMiA9IHRlbXA7XG5cblx0XHRcdFx0XHRib3gxID0gYm94Mjtcblx0XHRcdFx0XHQvLyBib3gyIGlzIGFsd2F5cyBzZXQgYmVmb3JlIHVzZSBiZWxvd1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVjayBib3ggMSBpbnRlcnNlY3Rpb25cblx0XHRcdGlmICggISBib3gxICkge1xuXG5cdFx0XHRcdGJveDEgPSBfYm94MSQxO1xuXHRcdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjMSApLCBmbG9hdDMyQXJyYXksIGJveDEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBpc0MxTGVhZiA9IElTX0xFQUYoIGMxICogMiwgdWludDE2QXJyYXkgKTtcblx0XHRcdGNvbnN0IGMxSW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0c0JvdW5kc0Z1bmMoIGJveDEsIGlzQzFMZWFmLCBzY29yZTEsIGRlcHRoICsgMSwgbm9kZUluZGV4Qnl0ZU9mZnNldCArIGMxICk7XG5cblx0XHRcdGxldCBjMVN0b3BUcmF2ZXJzYWw7XG5cdFx0XHRpZiAoIGMxSW50ZXJzZWN0aW9uID09PSBDT05UQUlORUQgKSB7XG5cblx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gZ2V0TGVmdE9mZnNldCggYzEgKTtcblx0XHRcdFx0Y29uc3QgZW5kID0gZ2V0UmlnaHRFbmRPZmZzZXQoIGMxICk7XG5cdFx0XHRcdGNvbnN0IGNvdW50ID0gZW5kIC0gb2Zmc2V0O1xuXG5cdFx0XHRcdGMxU3RvcFRyYXZlcnNhbCA9IGludGVyc2VjdHNSYW5nZUZ1bmMoIG9mZnNldCwgY291bnQsIHRydWUsIGRlcHRoICsgMSwgbm9kZUluZGV4Qnl0ZU9mZnNldCArIGMxLCBib3gxICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YzFTdG9wVHJhdmVyc2FsID1cblx0XHRcdFx0XHRjMUludGVyc2VjdGlvbiAmJlxuXHRcdFx0XHRcdHNoYXBlY2FzdFRyYXZlcnNlKFxuXHRcdFx0XHRcdFx0YzEsXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSxcblx0XHRcdFx0XHRcdGludGVyc2VjdHNCb3VuZHNGdW5jLFxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlRnVuYyxcblx0XHRcdFx0XHRcdG5vZGVTY29yZUZ1bmMsXG5cdFx0XHRcdFx0XHRub2RlSW5kZXhCeXRlT2Zmc2V0LFxuXHRcdFx0XHRcdFx0ZGVwdGggKyAxXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGMxU3RvcFRyYXZlcnNhbCApIHJldHVybiB0cnVlO1xuXG5cdFx0XHQvLyBDaGVjayBib3ggMiBpbnRlcnNlY3Rpb25cblx0XHRcdC8vIGNhY2hlZCBib3gyIHdpbGwgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuIGJ5IHByZXZpb3VzIHRyYXZlcnNhbFxuXHRcdFx0Ym94MiA9IF9ib3gyJDE7XG5cdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjMiApLCBmbG9hdDMyQXJyYXksIGJveDIgKTtcblxuXHRcdFx0Y29uc3QgaXNDMkxlYWYgPSBJU19MRUFGKCBjMiAqIDIsIHVpbnQxNkFycmF5ICk7XG5cdFx0XHRjb25zdCBjMkludGVyc2VjdGlvbiA9IGludGVyc2VjdHNCb3VuZHNGdW5jKCBib3gyLCBpc0MyTGVhZiwgc2NvcmUyLCBkZXB0aCArIDEsIG5vZGVJbmRleEJ5dGVPZmZzZXQgKyBjMiApO1xuXG5cdFx0XHRsZXQgYzJTdG9wVHJhdmVyc2FsO1xuXHRcdFx0aWYgKCBjMkludGVyc2VjdGlvbiA9PT0gQ09OVEFJTkVEICkge1xuXG5cdFx0XHRcdGNvbnN0IG9mZnNldCA9IGdldExlZnRPZmZzZXQoIGMyICk7XG5cdFx0XHRcdGNvbnN0IGVuZCA9IGdldFJpZ2h0RW5kT2Zmc2V0KCBjMiApO1xuXHRcdFx0XHRjb25zdCBjb3VudCA9IGVuZCAtIG9mZnNldDtcblxuXHRcdFx0XHRjMlN0b3BUcmF2ZXJzYWwgPSBpbnRlcnNlY3RzUmFuZ2VGdW5jKCBvZmZzZXQsIGNvdW50LCB0cnVlLCBkZXB0aCArIDEsIG5vZGVJbmRleEJ5dGVPZmZzZXQgKyBjMiwgYm94MiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGMyU3RvcFRyYXZlcnNhbCA9XG5cdFx0XHRcdFx0YzJJbnRlcnNlY3Rpb24gJiZcblx0XHRcdFx0XHRzaGFwZWNhc3RUcmF2ZXJzZShcblx0XHRcdFx0XHRcdGMyLFxuXHRcdFx0XHRcdFx0Z2VvbWV0cnksXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzRnVuYyxcblx0XHRcdFx0XHRcdGludGVyc2VjdHNSYW5nZUZ1bmMsXG5cdFx0XHRcdFx0XHRub2RlU2NvcmVGdW5jLFxuXHRcdFx0XHRcdFx0bm9kZUluZGV4Qnl0ZU9mZnNldCxcblx0XHRcdFx0XHRcdGRlcHRoICsgMVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjMlN0b3BUcmF2ZXJzYWwgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHQvLyBEZWZpbmUgdGhlc2UgaW5zaWRlIHRoZSBmdW5jdGlvbiBzbyBpdCBoYXMgYWNjZXNzIHRvIHRoZSBsb2NhbCB2YXJpYWJsZXMgbmVlZGVkXG5cdFx0XHQvLyB3aGVuIGNvbnZlcnRpbmcgdG8gdGhlIGJ1ZmZlciBlcXVpdmFsZW50c1xuXHRcdFx0ZnVuY3Rpb24gZ2V0TGVmdE9mZnNldCggbm9kZUluZGV4MzIgKSB7XG5cblx0XHRcdFx0Y29uc3QgeyB1aW50MTZBcnJheSwgdWludDMyQXJyYXkgfSA9IEJ1ZmZlclN0YWNrO1xuXHRcdFx0XHRsZXQgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cblx0XHRcdFx0Ly8gdHJhdmVyc2UgdW50aWwgd2UgZmluZCBhIGxlYWZcblx0XHRcdFx0d2hpbGUgKCAhIElTX0xFQUYoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApICkge1xuXG5cdFx0XHRcdFx0bm9kZUluZGV4MzIgPSBMRUZUX05PREUoIG5vZGVJbmRleDMyICk7XG5cdFx0XHRcdFx0bm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBPRkZTRVQoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGdldFJpZ2h0RW5kT2Zmc2V0KCBub2RlSW5kZXgzMiApIHtcblxuXHRcdFx0XHRjb25zdCB7IHVpbnQxNkFycmF5LCB1aW50MzJBcnJheSB9ID0gQnVmZmVyU3RhY2s7XG5cdFx0XHRcdGxldCBub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMjtcblxuXHRcdFx0XHQvLyB0cmF2ZXJzZSB1bnRpbCB3ZSBmaW5kIGEgbGVhZlxuXHRcdFx0XHR3aGlsZSAoICEgSVNfTEVBRiggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICkgKSB7XG5cblx0XHRcdFx0XHQvLyBhZGp1c3Qgb2Zmc2V0IHRvIHBvaW50IHRvIHRoZSByaWdodCBub2RlXG5cdFx0XHRcdFx0bm9kZUluZGV4MzIgPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdFx0XHRub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmV0dXJuIHRoZSBlbmQgb2Zmc2V0IG9mIHRoZSB0cmlhbmdsZSByYW5nZVxuXHRcdFx0XHRyZXR1cm4gT0ZGU0VUKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKSArIENPVU5UKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjb25zdCB0ZW1wID0gLyogQF9fUFVSRV9fICovIG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdGNvbnN0IHRlbXAxJDIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRmdW5jdGlvbiBjbG9zZXN0UG9pbnRUb1BvaW50KFxuXHRcdGJ2aCxcblx0XHRwb2ludCxcblx0XHR0YXJnZXQgPSB7IH0sXG5cdFx0bWluVGhyZXNob2xkID0gMCxcblx0XHRtYXhUaHJlc2hvbGQgPSBJbmZpbml0eSxcblx0KSB7XG5cblx0XHQvLyBlYXJseSBvdXQgaWYgdW5kZXIgbWluVGhyZXNob2xkXG5cdFx0Ly8gc2tpcCBjaGVja2luZyBpZiBvdmVyIG1heFRocmVzaG9sZFxuXHRcdC8vIHNldCBtaW5UaHJlc2hvbGQgPSBtYXhUaHJlc2hvbGQgdG8gcXVpY2tseSBjaGVjayBpZiBhIHBvaW50IGlzIHdpdGhpbiBhIHRocmVzaG9sZFxuXHRcdC8vIHJldHVybnMgSW5maW5pdHkgaWYgbm8gdmFsdWUgZm91bmRcblx0XHRjb25zdCBtaW5UaHJlc2hvbGRTcSA9IG1pblRocmVzaG9sZCAqIG1pblRocmVzaG9sZDtcblx0XHRjb25zdCBtYXhUaHJlc2hvbGRTcSA9IG1heFRocmVzaG9sZCAqIG1heFRocmVzaG9sZDtcblx0XHRsZXQgY2xvc2VzdERpc3RhbmNlU3EgPSBJbmZpbml0eTtcblx0XHRsZXQgY2xvc2VzdERpc3RhbmNlVHJpSW5kZXggPSBudWxsO1xuXHRcdGJ2aC5zaGFwZWNhc3QoXG5cblx0XHRcdHtcblxuXHRcdFx0XHRib3VuZHNUcmF2ZXJzZU9yZGVyOiBib3ggPT4ge1xuXG5cdFx0XHRcdFx0dGVtcC5jb3B5KCBwb2ludCApLmNsYW1wKCBib3gubWluLCBib3gubWF4ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRlbXAuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzOiAoIGJveCwgaXNMZWFmLCBzY29yZSApID0+IHtcblxuXHRcdFx0XHRcdHJldHVybiBzY29yZSA8IGNsb3Nlc3REaXN0YW5jZVNxICYmIHNjb3JlIDwgbWF4VGhyZXNob2xkU3E7XG5cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGU6ICggdHJpLCB0cmlJbmRleCApID0+IHtcblxuXHRcdFx0XHRcdHRyaS5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCwgdGVtcCApO1xuXHRcdFx0XHRcdGNvbnN0IGRpc3RTcSA9IHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCB0ZW1wICk7XG5cdFx0XHRcdFx0aWYgKCBkaXN0U3EgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0XHRcdFx0dGVtcDEkMi5jb3B5KCB0ZW1wICk7XG5cdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3RTcTtcblx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVRyaUluZGV4ID0gdHJpSW5kZXg7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGRpc3RTcSA8IG1pblRocmVzaG9sZFNxICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9LFxuXG5cdFx0XHR9XG5cblx0XHQpO1xuXG5cdFx0aWYgKCBjbG9zZXN0RGlzdGFuY2VTcSA9PT0gSW5maW5pdHkgKSByZXR1cm4gbnVsbDtcblxuXHRcdGNvbnN0IGNsb3Nlc3REaXN0YW5jZSA9IE1hdGguc3FydCggY2xvc2VzdERpc3RhbmNlU3EgKTtcblxuXHRcdGlmICggISB0YXJnZXQucG9pbnQgKSB0YXJnZXQucG9pbnQgPSB0ZW1wMSQyLmNsb25lKCk7XG5cdFx0ZWxzZSB0YXJnZXQucG9pbnQuY29weSggdGVtcDEkMiApO1xuXHRcdHRhcmdldC5kaXN0YW5jZSA9IGNsb3Nlc3REaXN0YW5jZSxcblx0XHR0YXJnZXQuZmFjZUluZGV4ID0gY2xvc2VzdERpc3RhbmNlVHJpSW5kZXg7XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXG5cdH1cblxuXHQvLyBSaXBwZWQgYW5kIG1vZGlmaWVkIEZyb20gVEhSRUUuanMgTWVzaCByYXljYXN0XG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi8wYWE4N2M5OTlmZTYxZTIxNmMxMTMzZmJhN2E5NTc3MmI1MDNlZGRmL3NyYy9vYmplY3RzL01lc2guanMjTDExNVxuXHRjb25zdCBfdkEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgX3ZCID0gLyogQF9fUFVSRV9fICovIG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdGNvbnN0IF92QyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdGNvbnN0IF91dkEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0Y29uc3QgX3V2QiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHRjb25zdCBfdXZDID0gLyogQF9fUFVSRV9fICovIG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0Y29uc3QgX25vcm1hbEEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgX25vcm1hbEIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgX25vcm1hbEMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRjb25zdCBfaW50ZXJzZWN0aW9uUG9pbnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0ZnVuY3Rpb24gY2hlY2tJbnRlcnNlY3Rpb24oIHJheSwgcEEsIHBCLCBwQywgcG9pbnQsIHNpZGUsIG5lYXIsIGZhciApIHtcblxuXHRcdGxldCBpbnRlcnNlY3Q7XG5cdFx0aWYgKCBzaWRlID09PSBUSFJFRS5CYWNrU2lkZSApIHtcblxuXHRcdFx0aW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBwQywgcEIsIHBBLCB0cnVlLCBwb2ludCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBwQSwgcEIsIHBDLCBzaWRlICE9PSBUSFJFRS5Eb3VibGVTaWRlLCBwb2ludCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpbnRlcnNlY3QgPT09IG51bGwgKSByZXR1cm4gbnVsbDtcblxuXHRcdGNvbnN0IGRpc3RhbmNlID0gcmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBwb2ludCApO1xuXG5cdFx0aWYgKCBkaXN0YW5jZSA8IG5lYXIgfHwgZGlzdGFuY2UgPiBmYXIgKSByZXR1cm4gbnVsbDtcblxuXHRcdHJldHVybiB7XG5cblx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcblx0XHRcdHBvaW50OiBwb2ludC5jbG9uZSgpLFxuXG5cdFx0fTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbiggcmF5LCBwb3NpdGlvbiwgbm9ybWFsLCB1diwgdXYxLCBhLCBiLCBjLCBzaWRlLCBuZWFyLCBmYXIgKSB7XG5cblx0XHRfdkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGEgKTtcblx0XHRfdkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGIgKTtcblx0XHRfdkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGMgKTtcblxuXHRcdGNvbnN0IGludGVyc2VjdGlvbiA9IGNoZWNrSW50ZXJzZWN0aW9uKCByYXksIF92QSwgX3ZCLCBfdkMsIF9pbnRlcnNlY3Rpb25Qb2ludCwgc2lkZSwgbmVhciwgZmFyICk7XG5cblx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcblxuXHRcdFx0aWYgKCB1diApIHtcblxuXHRcdFx0XHRfdXZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2LCBhICk7XG5cdFx0XHRcdF91dkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYsIGIgKTtcblx0XHRcdFx0X3V2Qy5mcm9tQnVmZmVyQXR0cmlidXRlKCB1diwgYyApO1xuXG5cdFx0XHRcdGludGVyc2VjdGlvbi51diA9IFRIUkVFLlRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIF9pbnRlcnNlY3Rpb25Qb2ludCwgX3ZBLCBfdkIsIF92QywgX3V2QSwgX3V2QiwgX3V2QywgbmV3IFRIUkVFLlZlY3RvcjIoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdXYxICkge1xuXG5cdFx0XHRcdF91dkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYxLCBhICk7XG5cdFx0XHRcdF91dkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYxLCBiICk7XG5cdFx0XHRcdF91dkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYxLCBjICk7XG5cblx0XHRcdFx0aW50ZXJzZWN0aW9uLnV2MSA9IFRIUkVFLlRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIF9pbnRlcnNlY3Rpb25Qb2ludCwgX3ZBLCBfdkIsIF92QywgX3V2QSwgX3V2QiwgX3V2QywgbmV3IFRIUkVFLlZlY3RvcjIoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbm9ybWFsICkge1xuXG5cdFx0XHRcdF9ub3JtYWxBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbCwgYSApO1xuXHRcdFx0XHRfbm9ybWFsQi5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWwsIGIgKTtcblx0XHRcdFx0X25vcm1hbEMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFsLCBjICk7XG5cblx0XHRcdFx0aW50ZXJzZWN0aW9uLm5vcm1hbCA9IFRIUkVFLlRyaWFuZ2xlLmdldEludGVycG9sYXRpb24oIF9pbnRlcnNlY3Rpb25Qb2ludCwgX3ZBLCBfdkIsIF92QywgX25vcm1hbEEsIF9ub3JtYWxCLCBfbm9ybWFsQywgbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuXHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbi5ub3JtYWwuZG90KCByYXkuZGlyZWN0aW9uICkgPiAwICkge1xuXG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uLm5vcm1hbC5tdWx0aXBseVNjYWxhciggLSAxICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGZhY2UgPSB7XG5cdFx0XHRcdGE6IGEsXG5cdFx0XHRcdGI6IGIsXG5cdFx0XHRcdGM6IGMsXG5cdFx0XHRcdG5vcm1hbDogbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdFx0bWF0ZXJpYWxJbmRleDogMFxuXHRcdFx0fTtcblxuXHRcdFx0VEhSRUUuVHJpYW5nbGUuZ2V0Tm9ybWFsKCBfdkEsIF92QiwgX3ZDLCBmYWNlLm5vcm1hbCApO1xuXG5cdFx0XHRpbnRlcnNlY3Rpb24uZmFjZSA9IGZhY2U7XG5cdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gYTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBpbnRlcnNlY3Rpb247XG5cblx0fVxuXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi8wYWE4N2M5OTlmZTYxZTIxNmMxMTMzZmJhN2E5NTc3MmI1MDNlZGRmL3NyYy9vYmplY3RzL01lc2guanMjTDI1OFxuXHRmdW5jdGlvbiBpbnRlcnNlY3RUcmkoIGdlbywgc2lkZSwgcmF5LCB0cmksIGludGVyc2VjdGlvbnMsIG5lYXIsIGZhciApIHtcblxuXHRcdGNvbnN0IHRyaU9mZnNldCA9IHRyaSAqIDM7XG5cdFx0bGV0IGEgPSB0cmlPZmZzZXQgKyAwO1xuXHRcdGxldCBiID0gdHJpT2Zmc2V0ICsgMTtcblx0XHRsZXQgYyA9IHRyaU9mZnNldCArIDI7XG5cblx0XHRjb25zdCBpbmRleCA9IGdlby5pbmRleDtcblx0XHRpZiAoIGdlby5pbmRleCApIHtcblxuXHRcdFx0YSA9IGluZGV4LmdldFgoIGEgKTtcblx0XHRcdGIgPSBpbmRleC5nZXRYKCBiICk7XG5cdFx0XHRjID0gaW5kZXguZ2V0WCggYyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgeyBwb3NpdGlvbiwgbm9ybWFsLCB1diwgdXYxIH0gPSBnZW8uYXR0cmlidXRlcztcblx0XHRjb25zdCBpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCByYXksIHBvc2l0aW9uLCBub3JtYWwsIHV2LCB1djEsIGEsIGIsIGMsIHNpZGUsIG5lYXIsIGZhciApO1xuXG5cdFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XG5cblx0XHRcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSB0cmk7XG5cdFx0XHRpZiAoIGludGVyc2VjdGlvbnMgKSBpbnRlcnNlY3Rpb25zLnB1c2goIGludGVyc2VjdGlvbiApO1xuXHRcdFx0cmV0dXJuIGludGVyc2VjdGlvbjtcblxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXG5cdH1cblxuXHQvLyBzZXRzIHRoZSB2ZXJ0aWNlcyBvZiB0cmlhbmdsZSBgdHJpYCB3aXRoIHRoZSAzIHZlcnRpY2VzIGFmdGVyIGlcblx0ZnVuY3Rpb24gc2V0VHJpYW5nbGUoIHRyaSwgaSwgaW5kZXgsIHBvcyApIHtcblxuXHRcdGNvbnN0IHRhID0gdHJpLmE7XG5cdFx0Y29uc3QgdGIgPSB0cmkuYjtcblx0XHRjb25zdCB0YyA9IHRyaS5jO1xuXG5cdFx0bGV0IGkwID0gaTtcblx0XHRsZXQgaTEgPSBpICsgMTtcblx0XHRsZXQgaTIgPSBpICsgMjtcblx0XHRpZiAoIGluZGV4ICkge1xuXG5cdFx0XHRpMCA9IGluZGV4LmdldFgoIGkwICk7XG5cdFx0XHRpMSA9IGluZGV4LmdldFgoIGkxICk7XG5cdFx0XHRpMiA9IGluZGV4LmdldFgoIGkyICk7XG5cblx0XHR9XG5cblx0XHR0YS54ID0gcG9zLmdldFgoIGkwICk7XG5cdFx0dGEueSA9IHBvcy5nZXRZKCBpMCApO1xuXHRcdHRhLnogPSBwb3MuZ2V0WiggaTAgKTtcblxuXHRcdHRiLnggPSBwb3MuZ2V0WCggaTEgKTtcblx0XHR0Yi55ID0gcG9zLmdldFkoIGkxICk7XG5cdFx0dGIueiA9IHBvcy5nZXRaKCBpMSApO1xuXG5cdFx0dGMueCA9IHBvcy5nZXRYKCBpMiApO1xuXHRcdHRjLnkgPSBwb3MuZ2V0WSggaTIgKTtcblx0XHR0Yy56ID0gcG9zLmdldFooIGkyICk7XG5cblx0fVxuXG5cdGNvbnN0IHRlbXBWMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRjb25zdCB0ZW1wVjIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgdGVtcFYzID0gLyogQF9fUFVSRV9fICovIG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdGNvbnN0IHRlbXBVVjEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0Y29uc3QgdGVtcFVWMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHRjb25zdCB0ZW1wVVYzID0gLyogQF9fUFVSRV9fICovIG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0ZnVuY3Rpb24gZ2V0VHJpYW5nbGVIaXRQb2ludEluZm8oIHBvaW50LCBnZW9tZXRyeSwgdHJpYW5nbGVJbmRleCwgdGFyZ2V0ICkge1xuXG5cdFx0Y29uc3QgaW5kaWNlcyA9IGdlb21ldHJ5LmdldEluZGV4KCkuYXJyYXk7XG5cdFx0Y29uc3QgcG9zaXRpb25zID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XG5cdFx0Y29uc3QgdXZzID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAndXYnICk7XG5cblx0XHRjb25zdCBhID0gaW5kaWNlc1sgdHJpYW5nbGVJbmRleCAqIDMgXTtcblx0XHRjb25zdCBiID0gaW5kaWNlc1sgdHJpYW5nbGVJbmRleCAqIDMgKyAxIF07XG5cdFx0Y29uc3QgYyA9IGluZGljZXNbIHRyaWFuZ2xlSW5kZXggKiAzICsgMiBdO1xuXG5cdFx0dGVtcFYxLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgYSApO1xuXHRcdHRlbXBWMi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIGIgKTtcblx0XHR0ZW1wVjMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCBjICk7XG5cblx0XHQvLyBmaW5kIHRoZSBhc3NvY2lhdGVkIG1hdGVyaWFsIGluZGV4XG5cdFx0bGV0IG1hdGVyaWFsSW5kZXggPSAwO1xuXHRcdGNvbnN0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3Vwcztcblx0XHRjb25zdCBmaXJzdFZlcnRleEluZGV4ID0gdHJpYW5nbGVJbmRleCAqIDM7XG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cdFx0XHRjb25zdCB7IHN0YXJ0LCBjb3VudCB9ID0gZ3JvdXA7XG5cdFx0XHRpZiAoIGZpcnN0VmVydGV4SW5kZXggPj0gc3RhcnQgJiYgZmlyc3RWZXJ0ZXhJbmRleCA8IHN0YXJ0ICsgY291bnQgKSB7XG5cblx0XHRcdFx0bWF0ZXJpYWxJbmRleCA9IGdyb3VwLm1hdGVyaWFsSW5kZXg7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBleHRyYWN0IHV2c1xuXHRcdGxldCB1diA9IG51bGw7XG5cdFx0aWYgKCB1dnMgKSB7XG5cblx0XHRcdHRlbXBVVjEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXZzLCBhICk7XG5cdFx0XHR0ZW1wVVYyLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2cywgYiApO1xuXHRcdFx0dGVtcFVWMy5mcm9tQnVmZmVyQXR0cmlidXRlKCB1dnMsIGMgKTtcblxuXHRcdFx0aWYgKCB0YXJnZXQgJiYgdGFyZ2V0LnV2ICkgdXYgPSB0YXJnZXQudXY7XG5cdFx0XHRlbHNlIHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuXHRcdFx0VEhSRUUuVHJpYW5nbGUuZ2V0SW50ZXJwb2xhdGlvbiggcG9pbnQsIHRlbXBWMSwgdGVtcFYyLCB0ZW1wVjMsIHRlbXBVVjEsIHRlbXBVVjIsIHRlbXBVVjMsIHV2ICk7XG5cblx0XHR9XG5cblx0XHQvLyBhZGp1c3QgdGhlIHByb3ZpZGVkIHRhcmdldCBvciBjcmVhdGUgYSBuZXcgb25lXG5cdFx0aWYgKCB0YXJnZXQgKSB7XG5cblx0XHRcdGlmICggISB0YXJnZXQuZmFjZSApIHRhcmdldC5mYWNlID0geyB9O1xuXHRcdFx0dGFyZ2V0LmZhY2UuYSA9IGE7XG5cdFx0XHR0YXJnZXQuZmFjZS5iID0gYjtcblx0XHRcdHRhcmdldC5mYWNlLmMgPSBjO1xuXHRcdFx0dGFyZ2V0LmZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XG5cdFx0XHRpZiAoICEgdGFyZ2V0LmZhY2Uubm9ybWFsICkgdGFyZ2V0LmZhY2Uubm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdFRIUkVFLlRyaWFuZ2xlLmdldE5vcm1hbCggdGVtcFYxLCB0ZW1wVjIsIHRlbXBWMywgdGFyZ2V0LmZhY2Uubm9ybWFsICk7XG5cblx0XHRcdGlmICggdXYgKSB0YXJnZXQudXYgPSB1djtcblxuXHRcdFx0cmV0dXJuIHRhcmdldDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGZhY2U6IHtcblx0XHRcdFx0XHRhOiBhLFxuXHRcdFx0XHRcdGI6IGIsXG5cdFx0XHRcdFx0YzogYyxcblx0XHRcdFx0XHRtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4LFxuXHRcdFx0XHRcdG5vcm1hbDogVEhSRUUuVHJpYW5nbGUuZ2V0Tm9ybWFsKCB0ZW1wVjEsIHRlbXBWMiwgdGVtcFYzLCBuZXcgVEhSRUUuVmVjdG9yMygpIClcblx0XHRcdFx0fSxcblx0XHRcdFx0dXY6IHV2XG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwiaXRlcmF0aW9uVXRpbHMudGVtcGxhdGUuanNcIi4gKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuXG5cdGZ1bmN0aW9uIGludGVyc2VjdFRyaXMoIGJ2aCwgc2lkZSwgcmF5LCBvZmZzZXQsIGNvdW50LCBpbnRlcnNlY3Rpb25zLCBuZWFyLCBmYXIgKSB7XG5cblx0XHRjb25zdCB7IGdlb21ldHJ5LCBfaW5kaXJlY3RCdWZmZXIgfSA9IGJ2aDtcblx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgZW5kID0gb2Zmc2V0ICsgY291bnQ7IGkgPCBlbmQ7IGkgKysgKSB7XG5cblxuXHRcdFx0aW50ZXJzZWN0VHJpKCBnZW9tZXRyeSwgc2lkZSwgcmF5LCBpLCBpbnRlcnNlY3Rpb25zLCBuZWFyLCBmYXIgKTtcblxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBpbnRlcnNlY3RDbG9zZXN0VHJpKCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCwgbmVhciwgZmFyICkge1xuXG5cdFx0Y29uc3QgeyBnZW9tZXRyeSwgX2luZGlyZWN0QnVmZmVyIH0gPSBidmg7XG5cdFx0bGV0IGRpc3QgPSBJbmZpbml0eTtcblx0XHRsZXQgcmVzID0gbnVsbDtcblx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgZW5kID0gb2Zmc2V0ICsgY291bnQ7IGkgPCBlbmQ7IGkgKysgKSB7XG5cblx0XHRcdGxldCBpbnRlcnNlY3Rpb247XG5cblx0XHRcdGludGVyc2VjdGlvbiA9IGludGVyc2VjdFRyaSggZ2VvbWV0cnksIHNpZGUsIHJheSwgaSwgbnVsbCwgbmVhciwgZmFyICk7XG5cblxuXHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24gJiYgaW50ZXJzZWN0aW9uLmRpc3RhbmNlIDwgZGlzdCApIHtcblxuXHRcdFx0XHRyZXMgPSBpbnRlcnNlY3Rpb247XG5cdFx0XHRcdGRpc3QgPSBpbnRlcnNlY3Rpb24uZGlzdGFuY2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiByZXM7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGl0ZXJhdGVPdmVyVHJpYW5nbGVzKFxuXHRcdG9mZnNldCxcblx0XHRjb3VudCxcblx0XHRidmgsXG5cdFx0aW50ZXJzZWN0c1RyaWFuZ2xlRnVuYyxcblx0XHRjb250YWluZWQsXG5cdFx0ZGVwdGgsXG5cdFx0dHJpYW5nbGVcblx0KSB7XG5cblx0XHRjb25zdCB7IGdlb21ldHJ5IH0gPSBidmg7XG5cdFx0Y29uc3QgeyBpbmRleCB9ID0gZ2VvbWV0cnk7XG5cdFx0Y29uc3QgcG9zID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgbCA9IGNvdW50ICsgb2Zmc2V0OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0bGV0IHRyaTtcblxuXHRcdFx0dHJpID0gaTtcblxuXHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlLCB0cmkgKiAzLCBpbmRleCwgcG9zICk7XG5cdFx0XHR0cmlhbmdsZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdGlmICggaW50ZXJzZWN0c1RyaWFuZ2xlRnVuYyggdHJpYW5nbGUsIHRyaSwgY29udGFpbmVkLCBkZXB0aCApICkge1xuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fVxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJyZWZpdC50ZW1wbGF0ZS5qc1wiLiAqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRmdW5jdGlvbiByZWZpdCggYnZoLCBub2RlSW5kaWNlcyA9IG51bGwgKSB7XG5cblx0XHRpZiAoIG5vZGVJbmRpY2VzICYmIEFycmF5LmlzQXJyYXkoIG5vZGVJbmRpY2VzICkgKSB7XG5cblx0XHRcdG5vZGVJbmRpY2VzID0gbmV3IFNldCggbm9kZUluZGljZXMgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRcdGNvbnN0IGluZGV4QXJyID0gZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS5pbmRleC5hcnJheSA6IG51bGw7XG5cdFx0Y29uc3QgcG9zQXR0ciA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRsZXQgYnVmZmVyLCB1aW50MzJBcnJheSwgdWludDE2QXJyYXksIGZsb2F0MzJBcnJheTtcblx0XHRsZXQgYnl0ZU9mZnNldCA9IDA7XG5cdFx0Y29uc3Qgcm9vdHMgPSBidmguX3Jvb3RzO1xuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHJvb3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGJ1ZmZlciA9IHJvb3RzWyBpIF07XG5cdFx0XHR1aW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSggYnVmZmVyICk7XG5cdFx0XHR1aW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheSggYnVmZmVyICk7XG5cdFx0XHRmbG9hdDMyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBidWZmZXIgKTtcblxuXHRcdFx0X3RyYXZlcnNlKCAwLCBieXRlT2Zmc2V0ICk7XG5cdFx0XHRieXRlT2Zmc2V0ICs9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gX3RyYXZlcnNlKCBub2RlMzJJbmRleCwgYnl0ZU9mZnNldCwgZm9yY2UgPSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc3Qgbm9kZTE2SW5kZXggPSBub2RlMzJJbmRleCAqIDI7XG5cdFx0XHRjb25zdCBpc0xlYWYgPSB1aW50MTZBcnJheVsgbm9kZTE2SW5kZXggKyAxNSBdID09PSBJU19MRUFGTk9ERV9GTEFHO1xuXHRcdFx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRcdFx0Y29uc3Qgb2Zmc2V0ID0gdWludDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNiBdO1xuXHRcdFx0XHRjb25zdCBjb3VudCA9IHVpbnQxNkFycmF5WyBub2RlMTZJbmRleCArIDE0IF07XG5cblx0XHRcdFx0bGV0IG1pbnggPSBJbmZpbml0eTtcblx0XHRcdFx0bGV0IG1pbnkgPSBJbmZpbml0eTtcblx0XHRcdFx0bGV0IG1pbnogPSBJbmZpbml0eTtcblx0XHRcdFx0bGV0IG1heHggPSAtIEluZmluaXR5O1xuXHRcdFx0XHRsZXQgbWF4eSA9IC0gSW5maW5pdHk7XG5cdFx0XHRcdGxldCBtYXh6ID0gLSBJbmZpbml0eTtcblxuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMyAqIG9mZnNldCwgbCA9IDMgKiAoIG9mZnNldCArIGNvdW50ICk7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0bGV0IGluZGV4ID0gaW5kZXhBcnJbIGkgXTtcblx0XHRcdFx0XHRjb25zdCB4ID0gcG9zQXR0ci5nZXRYKCBpbmRleCApO1xuXHRcdFx0XHRcdGNvbnN0IHkgPSBwb3NBdHRyLmdldFkoIGluZGV4ICk7XG5cdFx0XHRcdFx0Y29uc3QgeiA9IHBvc0F0dHIuZ2V0WiggaW5kZXggKTtcblxuXHRcdFx0XHRcdGlmICggeCA8IG1pbnggKSBtaW54ID0geDtcblx0XHRcdFx0XHRpZiAoIHggPiBtYXh4ICkgbWF4eCA9IHg7XG5cblx0XHRcdFx0XHRpZiAoIHkgPCBtaW55ICkgbWlueSA9IHk7XG5cdFx0XHRcdFx0aWYgKCB5ID4gbWF4eSApIG1heHkgPSB5O1xuXG5cdFx0XHRcdFx0aWYgKCB6IDwgbWlueiApIG1pbnogPSB6O1xuXHRcdFx0XHRcdGlmICggeiA+IG1heHogKSBtYXh6ID0gejtcblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDAgXSAhPT0gbWlueCB8fFxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAxIF0gIT09IG1pbnkgfHxcblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMiBdICE9PSBtaW56IHx8XG5cblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMyBdICE9PSBtYXh4IHx8XG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDQgXSAhPT0gbWF4eSB8fFxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyA1IF0gIT09IG1heHpcblx0XHRcdFx0KSB7XG5cblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMCBdID0gbWlueDtcblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMSBdID0gbWlueTtcblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMiBdID0gbWluejtcblxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAzIF0gPSBtYXh4O1xuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyA0IF0gPSBtYXh5O1xuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyA1IF0gPSBtYXh6O1xuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgbGVmdCA9IG5vZGUzMkluZGV4ICsgODtcblx0XHRcdFx0Y29uc3QgcmlnaHQgPSB1aW50MzJBcnJheVsgbm9kZTMySW5kZXggKyA2IF07XG5cblx0XHRcdFx0Ly8gdGhlIGlkZW50aWZ5aW5nIG5vZGUgaW5kaWNlcyBwcm92aWRlZCBieSB0aGUgc2hhcGVjYXN0IGZ1bmN0aW9uIGluY2x1ZGUgb2Zmc2V0cyBvZiBhbGxcblx0XHRcdFx0Ly8gcm9vdCBidWZmZXJzIHRvIGd1YXJhbnRlZSB0aGV5J3JlIHVuaXF1ZSBiZXR3ZWVuIHJvb3RzIHNvIG9mZnNldCBsZWZ0IGFuZCByaWdodCBpbmRpY2VzIGhlcmUuXG5cdFx0XHRcdGNvbnN0IG9mZnNldExlZnQgPSBsZWZ0ICsgYnl0ZU9mZnNldDtcblx0XHRcdFx0Y29uc3Qgb2Zmc2V0UmlnaHQgPSByaWdodCArIGJ5dGVPZmZzZXQ7XG5cdFx0XHRcdGxldCBmb3JjZUNoaWxkcmVuID0gZm9yY2U7XG5cdFx0XHRcdGxldCBpbmNsdWRlc0xlZnQgPSBmYWxzZTtcblx0XHRcdFx0bGV0IGluY2x1ZGVzUmlnaHQgPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAoIG5vZGVJbmRpY2VzICkge1xuXG5cdFx0XHRcdFx0Ly8gaWYgd2Ugc2VlIHRoYXQgbmVpdGhlciB0aGUgbGVmdCBvciByaWdodCBjaGlsZCBhcmUgaW5jbHVkZWQgaW4gdGhlIHNldCB0aGF0IG5lZWQgdG8gYmUgdXBkYXRlZFxuXHRcdFx0XHRcdC8vIHRoZW4gd2UgYXNzdW1lIHRoYXQgYWxsIGNoaWxkcmVuIG5lZWQgdG8gYmUgdXBkYXRlZC5cblx0XHRcdFx0XHRpZiAoICEgZm9yY2VDaGlsZHJlbiApIHtcblxuXHRcdFx0XHRcdFx0aW5jbHVkZXNMZWZ0ID0gbm9kZUluZGljZXMuaGFzKCBvZmZzZXRMZWZ0ICk7XG5cdFx0XHRcdFx0XHRpbmNsdWRlc1JpZ2h0ID0gbm9kZUluZGljZXMuaGFzKCBvZmZzZXRSaWdodCApO1xuXHRcdFx0XHRcdFx0Zm9yY2VDaGlsZHJlbiA9ICEgaW5jbHVkZXNMZWZ0ICYmICEgaW5jbHVkZXNSaWdodDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aW5jbHVkZXNMZWZ0ID0gdHJ1ZTtcblx0XHRcdFx0XHRpbmNsdWRlc1JpZ2h0ID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgdHJhdmVyc2VMZWZ0ID0gZm9yY2VDaGlsZHJlbiB8fCBpbmNsdWRlc0xlZnQ7XG5cdFx0XHRcdGNvbnN0IHRyYXZlcnNlUmlnaHQgPSBmb3JjZUNoaWxkcmVuIHx8IGluY2x1ZGVzUmlnaHQ7XG5cblx0XHRcdFx0bGV0IGxlZnRDaGFuZ2UgPSBmYWxzZTtcblx0XHRcdFx0aWYgKCB0cmF2ZXJzZUxlZnQgKSB7XG5cblx0XHRcdFx0XHRsZWZ0Q2hhbmdlID0gX3RyYXZlcnNlKCBsZWZ0LCBieXRlT2Zmc2V0LCBmb3JjZUNoaWxkcmVuICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCByaWdodENoYW5nZSA9IGZhbHNlO1xuXHRcdFx0XHRpZiAoIHRyYXZlcnNlUmlnaHQgKSB7XG5cblx0XHRcdFx0XHRyaWdodENoYW5nZSA9IF90cmF2ZXJzZSggcmlnaHQsIGJ5dGVPZmZzZXQsIGZvcmNlQ2hpbGRyZW4gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgZGlkQ2hhbmdlID0gbGVmdENoYW5nZSB8fCByaWdodENoYW5nZTtcblx0XHRcdFx0aWYgKCBkaWRDaGFuZ2UgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCBsZWZ0aSA9IGxlZnQgKyBpO1xuXHRcdFx0XHRcdFx0Y29uc3QgcmlnaHRpID0gcmlnaHQgKyBpO1xuXHRcdFx0XHRcdFx0Y29uc3QgbWluTGVmdFZhbHVlID0gZmxvYXQzMkFycmF5WyBsZWZ0aSBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgbWF4TGVmdFZhbHVlID0gZmxvYXQzMkFycmF5WyBsZWZ0aSArIDMgXTtcblx0XHRcdFx0XHRcdGNvbnN0IG1pblJpZ2h0VmFsdWUgPSBmbG9hdDMyQXJyYXlbIHJpZ2h0aSBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgbWF4UmlnaHRWYWx1ZSA9IGZsb2F0MzJBcnJheVsgcmlnaHRpICsgMyBdO1xuXG5cdFx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgaSBdID0gbWluTGVmdFZhbHVlIDwgbWluUmlnaHRWYWx1ZSA/IG1pbkxlZnRWYWx1ZSA6IG1pblJpZ2h0VmFsdWU7XG5cdFx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgaSArIDMgXSA9IG1heExlZnRWYWx1ZSA+IG1heFJpZ2h0VmFsdWUgPyBtYXhMZWZ0VmFsdWUgOiBtYXhSaWdodFZhbHVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZGlkQ2hhbmdlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBUaGlzIGZ1bmN0aW9uIHBlcmZvcm1zIGludGVyc2VjdGlvbiB0ZXN0cyBzaW1pbGFyIHRvIFJheS5pbnRlcnNlY3RCb3ggaW4gdGhyZWUuanMsXG5cdCAqIHdpdGggdGhlIGRpZmZlcmVuY2UgdGhhdCB0aGUgYm94IHZhbHVlcyBhcmUgcmVhZCBmcm9tIGFuIGFycmF5IHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBpbnRlcnNlY3RSYXkoIG5vZGVJbmRleDMyLCBhcnJheSwgcmF5LCBuZWFyLCBmYXIgKSB7XG5cblx0XHRsZXQgdG1pbiwgdG1heCwgdHltaW4sIHR5bWF4LCB0em1pbiwgdHptYXg7XG5cblx0XHRjb25zdCBpbnZkaXJ4ID0gMSAvIHJheS5kaXJlY3Rpb24ueCxcblx0XHRcdGludmRpcnkgPSAxIC8gcmF5LmRpcmVjdGlvbi55LFxuXHRcdFx0aW52ZGlyeiA9IDEgLyByYXkuZGlyZWN0aW9uLno7XG5cblx0XHRjb25zdCBveCA9IHJheS5vcmlnaW4ueDtcblx0XHRjb25zdCBveSA9IHJheS5vcmlnaW4ueTtcblx0XHRjb25zdCBveiA9IHJheS5vcmlnaW4uejtcblxuXHRcdGxldCBtaW54ID0gYXJyYXlbIG5vZGVJbmRleDMyIF07XG5cdFx0bGV0IG1heHggPSBhcnJheVsgbm9kZUluZGV4MzIgKyAzIF07XG5cblx0XHRsZXQgbWlueSA9IGFycmF5WyBub2RlSW5kZXgzMiArIDEgXTtcblx0XHRsZXQgbWF4eSA9IGFycmF5WyBub2RlSW5kZXgzMiArIDMgKyAxIF07XG5cblx0XHRsZXQgbWlueiA9IGFycmF5WyBub2RlSW5kZXgzMiArIDIgXTtcblx0XHRsZXQgbWF4eiA9IGFycmF5WyBub2RlSW5kZXgzMiArIDMgKyAyIF07XG5cblx0XHRpZiAoIGludmRpcnggPj0gMCApIHtcblxuXHRcdFx0dG1pbiA9ICggbWlueCAtIG94ICkgKiBpbnZkaXJ4O1xuXHRcdFx0dG1heCA9ICggbWF4eCAtIG94ICkgKiBpbnZkaXJ4O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dG1pbiA9ICggbWF4eCAtIG94ICkgKiBpbnZkaXJ4O1xuXHRcdFx0dG1heCA9ICggbWlueCAtIG94ICkgKiBpbnZkaXJ4O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpbnZkaXJ5ID49IDAgKSB7XG5cblx0XHRcdHR5bWluID0gKCBtaW55IC0gb3kgKSAqIGludmRpcnk7XG5cdFx0XHR0eW1heCA9ICggbWF4eSAtIG95ICkgKiBpbnZkaXJ5O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dHltaW4gPSAoIG1heHkgLSBveSApICogaW52ZGlyeTtcblx0XHRcdHR5bWF4ID0gKCBtaW55IC0gb3kgKSAqIGludmRpcnk7XG5cblx0XHR9XG5cblx0XHRpZiAoICggdG1pbiA+IHR5bWF4ICkgfHwgKCB0eW1pbiA+IHRtYXggKSApIHJldHVybiBmYWxzZTtcblxuXHRcdGlmICggdHltaW4gPiB0bWluIHx8IGlzTmFOKCB0bWluICkgKSB0bWluID0gdHltaW47XG5cblx0XHRpZiAoIHR5bWF4IDwgdG1heCB8fCBpc05hTiggdG1heCApICkgdG1heCA9IHR5bWF4O1xuXG5cdFx0aWYgKCBpbnZkaXJ6ID49IDAgKSB7XG5cblx0XHRcdHR6bWluID0gKCBtaW56IC0gb3ogKSAqIGludmRpcno7XG5cdFx0XHR0em1heCA9ICggbWF4eiAtIG96ICkgKiBpbnZkaXJ6O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dHptaW4gPSAoIG1heHogLSBveiApICogaW52ZGlyejtcblx0XHRcdHR6bWF4ID0gKCBtaW56IC0gb3ogKSAqIGludmRpcno7XG5cblx0XHR9XG5cblx0XHRpZiAoICggdG1pbiA+IHR6bWF4ICkgfHwgKCB0em1pbiA+IHRtYXggKSApIHJldHVybiBmYWxzZTtcblxuXHRcdGlmICggdHptaW4gPiB0bWluIHx8IHRtaW4gIT09IHRtaW4gKSB0bWluID0gdHptaW47XG5cblx0XHRpZiAoIHR6bWF4IDwgdG1heCB8fCB0bWF4ICE9PSB0bWF4ICkgdG1heCA9IHR6bWF4O1xuXG5cdFx0Ly9yZXR1cm4gcG9pbnQgY2xvc2VzdCB0byB0aGUgcmF5IChwb3NpdGl2ZSBzaWRlKVxuXG5cdFx0cmV0dXJuIHRtaW4gPD0gZmFyICYmIHRtYXggPj0gbmVhcjtcblxuXHR9XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcIml0ZXJhdGlvblV0aWxzLnRlbXBsYXRlLmpzXCIuICovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cblxuXHRmdW5jdGlvbiBpbnRlcnNlY3RUcmlzX2luZGlyZWN0KCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCwgaW50ZXJzZWN0aW9ucywgbmVhciwgZmFyICkge1xuXG5cdFx0Y29uc3QgeyBnZW9tZXRyeSwgX2luZGlyZWN0QnVmZmVyIH0gPSBidmg7XG5cdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGVuZCA9IG9mZnNldCArIGNvdW50OyBpIDwgZW5kOyBpICsrICkge1xuXG5cdFx0XHRsZXQgdmkgPSBfaW5kaXJlY3RCdWZmZXIgPyBfaW5kaXJlY3RCdWZmZXJbIGkgXSA6IGk7XG5cdFx0XHRpbnRlcnNlY3RUcmkoIGdlb21ldHJ5LCBzaWRlLCByYXksIHZpLCBpbnRlcnNlY3Rpb25zLCBuZWFyLCBmYXIgKTtcblxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBpbnRlcnNlY3RDbG9zZXN0VHJpX2luZGlyZWN0KCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCwgbmVhciwgZmFyICkge1xuXG5cdFx0Y29uc3QgeyBnZW9tZXRyeSwgX2luZGlyZWN0QnVmZmVyIH0gPSBidmg7XG5cdFx0bGV0IGRpc3QgPSBJbmZpbml0eTtcblx0XHRsZXQgcmVzID0gbnVsbDtcblx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgZW5kID0gb2Zmc2V0ICsgY291bnQ7IGkgPCBlbmQ7IGkgKysgKSB7XG5cblx0XHRcdGxldCBpbnRlcnNlY3Rpb247XG5cdFx0XHRpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RUcmkoIGdlb21ldHJ5LCBzaWRlLCByYXksIF9pbmRpcmVjdEJ1ZmZlciA/IF9pbmRpcmVjdEJ1ZmZlclsgaSBdIDogaSwgbnVsbCwgbmVhciwgZmFyICk7XG5cblxuXHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24gJiYgaW50ZXJzZWN0aW9uLmRpc3RhbmNlIDwgZGlzdCApIHtcblxuXHRcdFx0XHRyZXMgPSBpbnRlcnNlY3Rpb247XG5cdFx0XHRcdGRpc3QgPSBpbnRlcnNlY3Rpb24uZGlzdGFuY2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiByZXM7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGl0ZXJhdGVPdmVyVHJpYW5nbGVzX2luZGlyZWN0KFxuXHRcdG9mZnNldCxcblx0XHRjb3VudCxcblx0XHRidmgsXG5cdFx0aW50ZXJzZWN0c1RyaWFuZ2xlRnVuYyxcblx0XHRjb250YWluZWQsXG5cdFx0ZGVwdGgsXG5cdFx0dHJpYW5nbGVcblx0KSB7XG5cblx0XHRjb25zdCB7IGdlb21ldHJ5IH0gPSBidmg7XG5cdFx0Y29uc3QgeyBpbmRleCB9ID0gZ2VvbWV0cnk7XG5cdFx0Y29uc3QgcG9zID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgbCA9IGNvdW50ICsgb2Zmc2V0OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0bGV0IHRyaTtcblx0XHRcdHRyaSA9IGJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaSApO1xuXG5cdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUsIHRyaSAqIDMsIGluZGV4LCBwb3MgKTtcblx0XHRcdHRyaWFuZ2xlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCBpbnRlcnNlY3RzVHJpYW5nbGVGdW5jKCB0cmlhbmdsZSwgdHJpLCBjb250YWluZWQsIGRlcHRoICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwicmF5Y2FzdC50ZW1wbGF0ZS5qc1wiLiAqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdGZ1bmN0aW9uIHJheWNhc3QoIGJ2aCwgcm9vdCwgc2lkZSwgcmF5LCBpbnRlcnNlY3RzLCBuZWFyLCBmYXIgKSB7XG5cblx0XHRCdWZmZXJTdGFjay5zZXRCdWZmZXIoIGJ2aC5fcm9vdHNbIHJvb3QgXSApO1xuXHRcdF9yYXljYXN0JDEoIDAsIGJ2aCwgc2lkZSwgcmF5LCBpbnRlcnNlY3RzLCBuZWFyLCBmYXIgKTtcblx0XHRCdWZmZXJTdGFjay5jbGVhckJ1ZmZlcigpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBfcmF5Y2FzdCQxKCBub2RlSW5kZXgzMiwgYnZoLCBzaWRlLCByYXksIGludGVyc2VjdHMsIG5lYXIsIGZhciApIHtcblxuXHRcdGNvbnN0IHsgZmxvYXQzMkFycmF5LCB1aW50MTZBcnJheSwgdWludDMyQXJyYXkgfSA9IEJ1ZmZlclN0YWNrO1xuXHRcdGNvbnN0IG5vZGVJbmRleDE2ID0gbm9kZUluZGV4MzIgKiAyO1xuXHRcdGNvbnN0IGlzTGVhZiA9IElTX0xFQUYoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRjb25zdCBvZmZzZXQgPSBPRkZTRVQoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdFx0Y29uc3QgY291bnQgPSBDT1VOVCggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cblxuXHRcdFx0aW50ZXJzZWN0VHJpcyggYnZoLCBzaWRlLCByYXksIG9mZnNldCwgY291bnQsIGludGVyc2VjdHMsIG5lYXIsIGZhciApO1xuXG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBsZWZ0SW5kZXggPSBMRUZUX05PREUoIG5vZGVJbmRleDMyICk7XG5cdFx0XHRpZiAoIGludGVyc2VjdFJheSggbGVmdEluZGV4LCBmbG9hdDMyQXJyYXksIHJheSwgbmVhciwgZmFyICkgKSB7XG5cblx0XHRcdFx0X3JheWNhc3QkMSggbGVmdEluZGV4LCBidmgsIHNpZGUsIHJheSwgaW50ZXJzZWN0cywgbmVhciwgZmFyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcmlnaHRJbmRleCA9IFJJR0hUX05PREUoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdFx0aWYgKCBpbnRlcnNlY3RSYXkoIHJpZ2h0SW5kZXgsIGZsb2F0MzJBcnJheSwgcmF5LCBuZWFyLCBmYXIgKSApIHtcblxuXHRcdFx0XHRfcmF5Y2FzdCQxKCByaWdodEluZGV4LCBidmgsIHNpZGUsIHJheSwgaW50ZXJzZWN0cywgbmVhciwgZmFyICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJyYXljYXN0Rmlyc3QudGVtcGxhdGUuanNcIi4gKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdGNvbnN0IF94eXpGaWVsZHMkMSA9IFsgJ3gnLCAneScsICd6JyBdO1xuXG5cdGZ1bmN0aW9uIHJheWNhc3RGaXJzdCggYnZoLCByb290LCBzaWRlLCByYXksIG5lYXIsIGZhciApIHtcblxuXHRcdEJ1ZmZlclN0YWNrLnNldEJ1ZmZlciggYnZoLl9yb290c1sgcm9vdCBdICk7XG5cdFx0Y29uc3QgcmVzdWx0ID0gX3JheWNhc3RGaXJzdCQxKCAwLCBidmgsIHNpZGUsIHJheSwgbmVhciwgZmFyICk7XG5cdFx0QnVmZmVyU3RhY2suY2xlYXJCdWZmZXIoKTtcblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIF9yYXljYXN0Rmlyc3QkMSggbm9kZUluZGV4MzIsIGJ2aCwgc2lkZSwgcmF5LCBuZWFyLCBmYXIgKSB7XG5cblx0XHRjb25zdCB7IGZsb2F0MzJBcnJheSwgdWludDE2QXJyYXksIHVpbnQzMkFycmF5IH0gPSBCdWZmZXJTdGFjaztcblx0XHRsZXQgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cblx0XHRjb25zdCBpc0xlYWYgPSBJU19MRUFGKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gT0ZGU0VUKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdGNvbnN0IGNvdW50ID0gQ09VTlQoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXG5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuXHRcdFx0cmV0dXJuIGludGVyc2VjdENsb3Nlc3RUcmkoIGJ2aCwgc2lkZSwgcmF5LCBvZmZzZXQsIGNvdW50LCBuZWFyLCBmYXIgKTtcblxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gY29uc2lkZXIgdGhlIHBvc2l0aW9uIG9mIHRoZSBzcGxpdCBwbGFuZSB3aXRoIHJlc3BlY3QgdG8gdGhlIG9uY29taW5nIHJheTsgd2hpY2hldmVyIGRpcmVjdGlvblxuXHRcdFx0Ly8gdGhlIHJheSBpcyBjb21pbmcgZnJvbSwgbG9vayBmb3IgYW4gaW50ZXJzZWN0aW9uIGFtb25nIHRoYXQgc2lkZSBvZiB0aGUgdHJlZSBmaXJzdFxuXHRcdFx0Y29uc3Qgc3BsaXRBeGlzID0gU1BMSVRfQVhJUyggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0XHRjb25zdCB4eXpBeGlzID0gX3h5ekZpZWxkcyQxWyBzcGxpdEF4aXMgXTtcblx0XHRcdGNvbnN0IHJheURpciA9IHJheS5kaXJlY3Rpb25bIHh5ekF4aXMgXTtcblx0XHRcdGNvbnN0IGxlZnRUb1JpZ2h0ID0gcmF5RGlyID49IDA7XG5cblx0XHRcdC8vIGMxIGlzIHRoZSBjaGlsZCB0byBjaGVjayBmaXJzdFxuXHRcdFx0bGV0IGMxLCBjMjtcblx0XHRcdGlmICggbGVmdFRvUmlnaHQgKSB7XG5cblx0XHRcdFx0YzEgPSBMRUZUX05PREUoIG5vZGVJbmRleDMyICk7XG5cdFx0XHRcdGMyID0gUklHSFRfTk9ERSggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YzEgPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdFx0YzIgPSBMRUZUX05PREUoIG5vZGVJbmRleDMyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYzFJbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RSYXkoIGMxLCBmbG9hdDMyQXJyYXksIHJheSwgbmVhciwgZmFyICk7XG5cdFx0XHRjb25zdCBjMVJlc3VsdCA9IGMxSW50ZXJzZWN0aW9uID8gX3JheWNhc3RGaXJzdCQxKCBjMSwgYnZoLCBzaWRlLCByYXksIG5lYXIsIGZhciApIDogbnVsbDtcblxuXHRcdFx0Ly8gaWYgd2UgZ290IGFuIGludGVyc2VjdGlvbiBpbiB0aGUgZmlyc3Qgbm9kZSBhbmQgaXQncyBjbG9zZXIgdGhhbiB0aGUgc2Vjb25kIG5vZGUncyBib3VuZGluZ1xuXHRcdFx0Ly8gYm94LCB3ZSBkb24ndCBuZWVkIHRvIGNvbnNpZGVyIHRoZSBzZWNvbmQgbm9kZSBiZWNhdXNlIGl0IGNvdWxkbid0IHBvc3NpYmx5IGJlIGEgYmV0dGVyIHJlc3VsdFxuXHRcdFx0aWYgKCBjMVJlc3VsdCApIHtcblxuXHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSBzZWNvbmQgYm91bmRzXG5cdFx0XHRcdC8vIFwicG9pbnRcIiBpcyBpbiB0aGUgbG9jYWwgZnJhbWUgb2YgdGhlIGJ2aFxuXHRcdFx0XHRjb25zdCBwb2ludCA9IGMxUmVzdWx0LnBvaW50WyB4eXpBeGlzIF07XG5cdFx0XHRcdGNvbnN0IGlzT3V0c2lkZSA9IGxlZnRUb1JpZ2h0ID9cblx0XHRcdFx0XHRwb2ludCA8PSBmbG9hdDMyQXJyYXlbIGMyICsgc3BsaXRBeGlzIF0gOiAvLyBtaW4gYm91bmRpbmcgZGF0YVxuXHRcdFx0XHRcdHBvaW50ID49IGZsb2F0MzJBcnJheVsgYzIgKyBzcGxpdEF4aXMgKyAzIF07IC8vIG1heCBib3VuZGluZyBkYXRhXG5cblx0XHRcdFx0aWYgKCBpc091dHNpZGUgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gYzFSZXN1bHQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGVpdGhlciB0aGVyZSB3YXMgbm8gaW50ZXJzZWN0aW9uIGluIHRoZSBmaXJzdCBub2RlLCBvciB0aGVyZSBjb3VsZCBzdGlsbCBiZSBhIGNsb3NlclxuXHRcdFx0Ly8gaW50ZXJzZWN0aW9uIGluIHRoZSBzZWNvbmQsIHNvIGNoZWNrIHRoZSBzZWNvbmQgbm9kZSBhbmQgdGhlbiB0YWtlIHRoZSBiZXR0ZXIgb2YgdGhlIHR3b1xuXHRcdFx0Y29uc3QgYzJJbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RSYXkoIGMyLCBmbG9hdDMyQXJyYXksIHJheSwgbmVhciwgZmFyICk7XG5cdFx0XHRjb25zdCBjMlJlc3VsdCA9IGMySW50ZXJzZWN0aW9uID8gX3JheWNhc3RGaXJzdCQxKCBjMiwgYnZoLCBzaWRlLCByYXksIG5lYXIsIGZhciApIDogbnVsbDtcblxuXHRcdFx0aWYgKCBjMVJlc3VsdCAmJiBjMlJlc3VsdCApIHtcblxuXHRcdFx0XHRyZXR1cm4gYzFSZXN1bHQuZGlzdGFuY2UgPD0gYzJSZXN1bHQuZGlzdGFuY2UgPyBjMVJlc3VsdCA6IGMyUmVzdWx0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBjMVJlc3VsdCB8fCBjMlJlc3VsdCB8fCBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwiaW50ZXJzZWN0c0dlb21ldHJ5LnRlbXBsYXRlLmpzXCIuICovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogZXNsaW50LWRpc2FibGUgaW5kZW50ICovXG5cblx0Y29uc3QgYm91bmRpbmdCb3gkMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuQm94MygpO1xuXHRjb25zdCB0cmlhbmdsZSQxID0gLyogQF9fUFVSRV9fICovIG5ldyBFeHRlbmRlZFRyaWFuZ2xlKCk7XG5cdGNvbnN0IHRyaWFuZ2xlMiQxID0gLyogQF9fUFVSRV9fICovIG5ldyBFeHRlbmRlZFRyaWFuZ2xlKCk7XG5cdGNvbnN0IGludmVydGVkTWF0JDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRjb25zdCBvYmIkNCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgT3JpZW50ZWRCb3goKTtcblx0Y29uc3Qgb2JiMiQzID0gLyogQF9fUFVSRV9fICovIG5ldyBPcmllbnRlZEJveCgpO1xuXG5cdGZ1bmN0aW9uIGludGVyc2VjdHNHZW9tZXRyeSggYnZoLCByb290LCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoICkge1xuXG5cdFx0QnVmZmVyU3RhY2suc2V0QnVmZmVyKCBidmguX3Jvb3RzWyByb290IF0gKTtcblx0XHRjb25zdCByZXN1bHQgPSBfaW50ZXJzZWN0c0dlb21ldHJ5JDEoIDAsIGJ2aCwgb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCApO1xuXHRcdEJ1ZmZlclN0YWNrLmNsZWFyQnVmZmVyKCk7XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBfaW50ZXJzZWN0c0dlb21ldHJ5JDEoIG5vZGVJbmRleDMyLCBidmgsIG90aGVyR2VvbWV0cnksIGdlb21ldHJ5VG9CdmgsIGNhY2hlZE9iYiA9IG51bGwgKSB7XG5cblx0XHRjb25zdCB7IGZsb2F0MzJBcnJheSwgdWludDE2QXJyYXksIHVpbnQzMkFycmF5IH0gPSBCdWZmZXJTdGFjaztcblx0XHRsZXQgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cblx0XHRpZiAoIGNhY2hlZE9iYiA9PT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCAhIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3ggKSB7XG5cblx0XHRcdFx0b3RoZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvYmIkNC5zZXQoIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3gubWluLCBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94Lm1heCwgZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0Y2FjaGVkT2JiID0gb2JiJDQ7XG5cblx0XHR9XG5cblx0XHRjb25zdCBpc0xlYWYgPSBJU19MRUFGKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0Y29uc3QgdGhpc0dlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRcdFx0Y29uc3QgdGhpc0luZGV4ID0gdGhpc0dlb21ldHJ5LmluZGV4O1xuXHRcdFx0Y29uc3QgdGhpc1BvcyA9IHRoaXNHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRjb25zdCBpbmRleCA9IG90aGVyR2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRjb25zdCBwb3MgPSBvdGhlckdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdGNvbnN0IG9mZnNldCA9IE9GRlNFVCggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0XHRjb25zdCBjb3VudCA9IENPVU5UKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblxuXHRcdFx0Ly8gZ2V0IHRoZSBpbnZlcnNlIG9mIHRoZSBnZW9tZXRyeSBtYXRyaXggc28gd2UgY2FuIHRyYW5zZm9ybSBvdXIgdHJpYW5nbGVzIGludG8gdGhlXG5cdFx0XHQvLyBnZW9tZXRyeSBzcGFjZSB3ZSdyZSB0cnlpbmcgdG8gdGVzdC4gV2UgYXNzdW1lIHRoZXJlIGFyZSBmZXdlciB0cmlhbmdsZXMgYmVpbmcgY2hlY2tlZFxuXHRcdFx0Ly8gaGVyZS5cblx0XHRcdGludmVydGVkTWF0JDEuY29weSggZ2VvbWV0cnlUb0J2aCApLmludmVydCgpO1xuXG5cdFx0XHRpZiAoIG90aGVyR2VvbWV0cnkuYm91bmRzVHJlZSApIHtcblxuXHRcdFx0XHQvLyBpZiB0aGVyZSdzIGEgYm91bmRzIHRyZWVcblx0XHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggbm9kZUluZGV4MzIgKSwgZmxvYXQzMkFycmF5LCBvYmIyJDMgKTtcblx0XHRcdFx0b2JiMiQzLm1hdHJpeC5jb3B5KCBpbnZlcnRlZE1hdCQxICk7XG5cdFx0XHRcdG9iYjIkMy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0Ly8gVE9ETzogdXNlIGEgdHJpYW5nbGUgaXRlcmF0aW9uIGZ1bmN0aW9uIGhlcmVcblx0XHRcdFx0Y29uc3QgcmVzID0gb3RoZXJHZW9tZXRyeS5ib3VuZHNUcmVlLnNoYXBlY2FzdCgge1xuXG5cdFx0XHRcdFx0aW50ZXJzZWN0c0JvdW5kczogYm94ID0+IG9iYjIkMy5pbnRlcnNlY3RzQm94KCBib3ggKSxcblxuXHRcdFx0XHRcdGludGVyc2VjdHNUcmlhbmdsZTogdHJpID0+IHtcblxuXHRcdFx0XHRcdFx0dHJpLmEuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHR0cmkuYi5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdHRyaS5jLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0dHJpLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCAqIDMsIGwgPSAoIGNvdW50ICsgb2Zmc2V0ICkgKiAzOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIHRoaXMgdHJpYW5nbGUgbmVlZHMgdG8gYmUgdHJhbnNmb3JtZWQgaW50byB0aGUgY3VycmVudCBCVkggY29vcmRpbmF0ZSBmcmFtZVxuXHRcdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUyJDEsIGksIHRoaXNJbmRleCwgdGhpc1BvcyApO1xuXHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIkMS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGlmICggdHJpLmludGVyc2VjdHNUcmlhbmdsZSggdHJpYW5nbGUyJDEgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0cmV0dXJuIHJlcztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBpZiB3ZSdyZSBqdXN0IGRlYWxpbmcgd2l0aCByYXcgZ2VvbWV0cnlcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCAqIDMsIGwgPSAoIGNvdW50ICsgb2Zmc2V0ICkgKiAzOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0Ly8gdGhpcyB0cmlhbmdsZSBuZWVkcyB0byBiZSB0cmFuc2Zvcm1lZCBpbnRvIHRoZSBjdXJyZW50IEJWSCBjb29yZGluYXRlIGZyYW1lXG5cdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlJDEsIGksIHRoaXNJbmRleCwgdGhpc1BvcyApO1xuXG5cblx0XHRcdFx0XHR0cmlhbmdsZSQxLmEuYXBwbHlNYXRyaXg0KCBpbnZlcnRlZE1hdCQxICk7XG5cdFx0XHRcdFx0dHJpYW5nbGUkMS5iLmFwcGx5TWF0cml4NCggaW52ZXJ0ZWRNYXQkMSApO1xuXHRcdFx0XHRcdHRyaWFuZ2xlJDEuYy5hcHBseU1hdHJpeDQoIGludmVydGVkTWF0JDEgKTtcblx0XHRcdFx0XHR0cmlhbmdsZSQxLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpMiA9IDAsIGwyID0gaW5kZXguY291bnQ7IGkyIDwgbDI7IGkyICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZTIkMSwgaTIsIGluZGV4LCBwb3MgKTtcblx0XHRcdFx0XHRcdHRyaWFuZ2xlMiQxLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0aWYgKCB0cmlhbmdsZSQxLmludGVyc2VjdHNUcmlhbmdsZSggdHJpYW5nbGUyJDEgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0fVxuXG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGxlZnQgPSBub2RlSW5kZXgzMiArIDg7XG5cdFx0XHRjb25zdCByaWdodCA9IHVpbnQzMkFycmF5WyBub2RlSW5kZXgzMiArIDYgXTtcblxuXHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggbGVmdCApLCBmbG9hdDMyQXJyYXksIGJvdW5kaW5nQm94JDIgKTtcblx0XHRcdGNvbnN0IGxlZnRJbnRlcnNlY3Rpb24gPVxuXHRcdFx0XHRjYWNoZWRPYmIuaW50ZXJzZWN0c0JveCggYm91bmRpbmdCb3gkMiApICYmXG5cdFx0XHRcdF9pbnRlcnNlY3RzR2VvbWV0cnkkMSggbGVmdCwgYnZoLCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoLCBjYWNoZWRPYmIgKTtcblxuXHRcdFx0aWYgKCBsZWZ0SW50ZXJzZWN0aW9uICkgcmV0dXJuIHRydWU7XG5cblx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIHJpZ2h0ICksIGZsb2F0MzJBcnJheSwgYm91bmRpbmdCb3gkMiApO1xuXHRcdFx0Y29uc3QgcmlnaHRJbnRlcnNlY3Rpb24gPVxuXHRcdFx0XHRjYWNoZWRPYmIuaW50ZXJzZWN0c0JveCggYm91bmRpbmdCb3gkMiApICYmXG5cdFx0XHRcdF9pbnRlcnNlY3RzR2VvbWV0cnkkMSggcmlnaHQsIGJ2aCwgb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCwgY2FjaGVkT2JiICk7XG5cblx0XHRcdGlmICggcmlnaHRJbnRlcnNlY3Rpb24gKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJjbG9zZXN0UG9pbnRUb0dlb21ldHJ5LnRlbXBsYXRlLmpzXCIuICovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0Y29uc3QgdGVtcE1hdHJpeCQxID0gLyogQF9fUFVSRV9fICovIG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cdGNvbnN0IG9iYiQzID0gLyogQF9fUFVSRV9fICovIG5ldyBPcmllbnRlZEJveCgpO1xuXHRjb25zdCBvYmIyJDIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE9yaWVudGVkQm94KCk7XG5cdGNvbnN0IHRlbXAxJDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgdGVtcDIkMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRjb25zdCB0ZW1wMyQxID0gLyogQF9fUFVSRV9fICovIG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdGNvbnN0IHRlbXA0JDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRmdW5jdGlvbiBjbG9zZXN0UG9pbnRUb0dlb21ldHJ5KFxuXHRcdGJ2aCxcblx0XHRvdGhlckdlb21ldHJ5LFxuXHRcdGdlb21ldHJ5VG9CdmgsXG5cdFx0dGFyZ2V0MSA9IHsgfSxcblx0XHR0YXJnZXQyID0geyB9LFxuXHRcdG1pblRocmVzaG9sZCA9IDAsXG5cdFx0bWF4VGhyZXNob2xkID0gSW5maW5pdHksXG5cdCkge1xuXG5cdFx0aWYgKCAhIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3ggKSB7XG5cblx0XHRcdG90aGVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHR9XG5cblx0XHRvYmIkMy5zZXQoIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3gubWluLCBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94Lm1heCwgZ2VvbWV0cnlUb0J2aCApO1xuXHRcdG9iYiQzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRcdGNvbnN0IHBvcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCBvdGhlclBvcyA9IG90aGVyR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRjb25zdCBvdGhlckluZGV4ID0gb3RoZXJHZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCB0cmlhbmdsZSA9IEV4dGVuZGVkVHJpYW5nbGVQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdGNvbnN0IHRyaWFuZ2xlMiA9IEV4dGVuZGVkVHJpYW5nbGVQb29sLmdldFByaW1pdGl2ZSgpO1xuXG5cdFx0bGV0IHRlbXBUYXJnZXQxID0gdGVtcDEkMTtcblx0XHRsZXQgdGVtcFRhcmdldERlc3QxID0gdGVtcDIkMTtcblx0XHRsZXQgdGVtcFRhcmdldDIgPSBudWxsO1xuXHRcdGxldCB0ZW1wVGFyZ2V0RGVzdDIgPSBudWxsO1xuXG5cdFx0aWYgKCB0YXJnZXQyICkge1xuXG5cdFx0XHR0ZW1wVGFyZ2V0MiA9IHRlbXAzJDE7XG5cdFx0XHR0ZW1wVGFyZ2V0RGVzdDIgPSB0ZW1wNCQxO1xuXG5cdFx0fVxuXG5cdFx0bGV0IGNsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuXHRcdGxldCBjbG9zZXN0RGlzdGFuY2VUcmlJbmRleCA9IG51bGw7XG5cdFx0bGV0IGNsb3Nlc3REaXN0YW5jZU90aGVyVHJpSW5kZXggPSBudWxsO1xuXHRcdHRlbXBNYXRyaXgkMS5jb3B5KCBnZW9tZXRyeVRvQnZoICkuaW52ZXJ0KCk7XG5cdFx0b2JiMiQyLm1hdHJpeC5jb3B5KCB0ZW1wTWF0cml4JDEgKTtcblx0XHRidmguc2hhcGVjYXN0KFxuXHRcdFx0e1xuXG5cdFx0XHRcdGJvdW5kc1RyYXZlcnNlT3JkZXI6IGJveCA9PiB7XG5cblx0XHRcdFx0XHRyZXR1cm4gb2JiJDMuZGlzdGFuY2VUb0JveCggYm94ICk7XG5cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzOiAoIGJveCwgaXNMZWFmLCBzY29yZSApID0+IHtcblxuXHRcdFx0XHRcdGlmICggc2NvcmUgPCBjbG9zZXN0RGlzdGFuY2UgJiYgc2NvcmUgPCBtYXhUaHJlc2hvbGQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGlmIHdlIGtub3cgdGhlIHRyaWFuZ2xlcyBvZiB0aGlzIGJvdW5kcyB3aWxsIGJlIGludGVyc2VjdGVkIG5leHQgdGhlblxuXHRcdFx0XHRcdFx0Ly8gc2F2ZSB0aGUgYm91bmRzIHRvIHVzZSBkdXJpbmcgdHJpYW5nbGUgY2hlY2tzLlxuXHRcdFx0XHRcdFx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRcdFx0XHRcdFx0b2JiMiQyLm1pbi5jb3B5KCBib3gubWluICk7XG5cdFx0XHRcdFx0XHRcdG9iYjIkMi5tYXguY29weSggYm94Lm1heCApO1xuXHRcdFx0XHRcdFx0XHRvYmIyJDIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlOiAoIG9mZnNldCwgY291bnQgKSA9PiB7XG5cblx0XHRcdFx0XHRpZiAoIG90aGVyR2VvbWV0cnkuYm91bmRzVHJlZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlIG90aGVyIGdlb21ldHJ5IGhhcyBhIGJ2aCB0aGVuIHVzZSB0aGUgYWNjZWxlcmF0ZWQgcGF0aCB3aGVyZSB3ZSB1c2Ugc2hhcGVjYXN0IHRvIGZpbmRcblx0XHRcdFx0XHRcdC8vIHRoZSBjbG9zZXN0IGJvdW5kcyBpbiB0aGUgb3RoZXIgZ2VvbWV0cnkgdG8gY2hlY2suXG5cdFx0XHRcdFx0XHRjb25zdCBvdGhlckJ2aCA9IG90aGVyR2VvbWV0cnkuYm91bmRzVHJlZTtcblx0XHRcdFx0XHRcdHJldHVybiBvdGhlckJ2aC5zaGFwZWNhc3QoIHtcblx0XHRcdFx0XHRcdFx0Ym91bmRzVHJhdmVyc2VPcmRlcjogYm94ID0+IHtcblxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBvYmIyJDIuZGlzdGFuY2VUb0JveCggYm94ICk7XG5cblx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzOiAoIGJveCwgaXNMZWFmLCBzY29yZSApID0+IHtcblxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBzY29yZSA8IGNsb3Nlc3REaXN0YW5jZSAmJiBzY29yZSA8IG1heFRocmVzaG9sZDtcblxuXHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdHNSYW5nZTogKCBvdGhlck9mZnNldCwgb3RoZXJDb3VudCApID0+IHtcblxuXHRcdFx0XHRcdFx0XHRcdGZvciAoIGxldCBpMiA9IG90aGVyT2Zmc2V0LCBsMiA9IG90aGVyT2Zmc2V0ICsgb3RoZXJDb3VudDsgaTIgPCBsMjsgaTIgKysgKSB7XG5cblxuXHRcdFx0XHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgMyAqIGkyLCBvdGhlckluZGV4LCBvdGhlclBvcyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIuYS5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5iLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLmMuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgbCA9IG9mZnNldCArIGNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZSwgMyAqIGksIGluZGV4LCBwb3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgZGlzdCA9IHRyaWFuZ2xlLmRpc3RhbmNlVG9UcmlhbmdsZSggdHJpYW5nbGUyLCB0ZW1wVGFyZ2V0MSwgdGVtcFRhcmdldDIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRhcmdldERlc3QxLmNvcHkoIHRlbXBUYXJnZXQxICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHRlbXBUYXJnZXREZXN0MiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRhcmdldERlc3QyLmNvcHkoIHRlbXBUYXJnZXQyICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2UgPSBkaXN0O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVRyaUluZGV4ID0gaTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4ID0gaTI7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIHN0b3AgdHJhdmVyc2FsIGlmIHdlIGZpbmQgYSBwb2ludCB0aGF0J3MgdW5kZXIgdGhlIGdpdmVuIHRocmVzaG9sZFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCBtaW5UaHJlc2hvbGQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgbm8gYm91bmRzIHRyZWUgdGhlbiB3ZSdsbCBqdXN0IGNoZWNrIGV2ZXJ5IHRyaWFuZ2xlLlxuXHRcdFx0XHRcdFx0Y29uc3QgdHJpQ291bnQgPSBnZXRUcmlDb3VudCggb3RoZXJHZW9tZXRyeSApO1xuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGkyID0gMCwgbDIgPSB0cmlDb3VudDsgaTIgPCBsMjsgaTIgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgMyAqIGkyLCBvdGhlckluZGV4LCBvdGhlclBvcyApO1xuXHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIuYS5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLmIuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5jLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIGxldCBpID0gb2Zmc2V0LCBsID0gb2Zmc2V0ICsgY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cblx0XHRcdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUsIDMgKiBpLCBpbmRleCwgcG9zICk7XG5cblx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zdCBkaXN0ID0gdHJpYW5nbGUuZGlzdGFuY2VUb1RyaWFuZ2xlKCB0cmlhbmdsZTIsIHRlbXBUYXJnZXQxLCB0ZW1wVGFyZ2V0MiApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRhcmdldERlc3QxLmNvcHkoIHRlbXBUYXJnZXQxICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggdGVtcFRhcmdldERlc3QyICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRlbXBUYXJnZXREZXN0Mi5jb3B5KCB0ZW1wVGFyZ2V0MiApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZSA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VUcmlJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4ID0gaTI7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBzdG9wIHRyYXZlcnNhbCBpZiB3ZSBmaW5kIGEgcG9pbnQgdGhhdCdzIHVuZGVyIHRoZSBnaXZlbiB0aHJlc2hvbGRcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCBtaW5UaHJlc2hvbGQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0sXG5cblx0XHRcdH1cblxuXHRcdCk7XG5cblx0XHRFeHRlbmRlZFRyaWFuZ2xlUG9vbC5yZWxlYXNlUHJpbWl0aXZlKCB0cmlhbmdsZSApO1xuXHRcdEV4dGVuZGVkVHJpYW5nbGVQb29sLnJlbGVhc2VQcmltaXRpdmUoIHRyaWFuZ2xlMiApO1xuXG5cdFx0aWYgKCBjbG9zZXN0RGlzdGFuY2UgPT09IEluZmluaXR5ICkge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdGlmICggISB0YXJnZXQxLnBvaW50ICkge1xuXG5cdFx0XHR0YXJnZXQxLnBvaW50ID0gdGVtcFRhcmdldERlc3QxLmNsb25lKCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0YXJnZXQxLnBvaW50LmNvcHkoIHRlbXBUYXJnZXREZXN0MSApO1xuXG5cdFx0fVxuXG5cdFx0dGFyZ2V0MS5kaXN0YW5jZSA9IGNsb3Nlc3REaXN0YW5jZSxcblx0XHR0YXJnZXQxLmZhY2VJbmRleCA9IGNsb3Nlc3REaXN0YW5jZVRyaUluZGV4O1xuXG5cdFx0aWYgKCB0YXJnZXQyICkge1xuXG5cdFx0XHRpZiAoICEgdGFyZ2V0Mi5wb2ludCApIHRhcmdldDIucG9pbnQgPSB0ZW1wVGFyZ2V0RGVzdDIuY2xvbmUoKTtcblx0XHRcdGVsc2UgdGFyZ2V0Mi5wb2ludC5jb3B5KCB0ZW1wVGFyZ2V0RGVzdDIgKTtcblx0XHRcdHRhcmdldDIucG9pbnQuYXBwbHlNYXRyaXg0KCB0ZW1wTWF0cml4JDEgKTtcblx0XHRcdHRlbXBUYXJnZXREZXN0MS5hcHBseU1hdHJpeDQoIHRlbXBNYXRyaXgkMSApO1xuXHRcdFx0dGFyZ2V0Mi5kaXN0YW5jZSA9IHRlbXBUYXJnZXREZXN0MS5zdWIoIHRhcmdldDIucG9pbnQgKS5sZW5ndGgoKTtcblx0XHRcdHRhcmdldDIuZmFjZUluZGV4ID0gY2xvc2VzdERpc3RhbmNlT3RoZXJUcmlJbmRleDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQxO1xuXG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwicmVmaXQudGVtcGxhdGUuanNcIi4gKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0ZnVuY3Rpb24gcmVmaXRfaW5kaXJlY3QoIGJ2aCwgbm9kZUluZGljZXMgPSBudWxsICkge1xuXG5cdFx0aWYgKCBub2RlSW5kaWNlcyAmJiBBcnJheS5pc0FycmF5KCBub2RlSW5kaWNlcyApICkge1xuXG5cdFx0XHRub2RlSW5kaWNlcyA9IG5ldyBTZXQoIG5vZGVJbmRpY2VzICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IGJ2aC5nZW9tZXRyeTtcblx0XHRjb25zdCBpbmRleEFyciA9IGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnkuaW5kZXguYXJyYXkgOiBudWxsO1xuXHRcdGNvbnN0IHBvc0F0dHIgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0bGV0IGJ1ZmZlciwgdWludDMyQXJyYXksIHVpbnQxNkFycmF5LCBmbG9hdDMyQXJyYXk7XG5cdFx0bGV0IGJ5dGVPZmZzZXQgPSAwO1xuXHRcdGNvbnN0IHJvb3RzID0gYnZoLl9yb290cztcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSByb290cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRidWZmZXIgPSByb290c1sgaSBdO1xuXHRcdFx0dWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoIGJ1ZmZlciApO1xuXHRcdFx0dWludDE2QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoIGJ1ZmZlciApO1xuXHRcdFx0ZmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggYnVmZmVyICk7XG5cblx0XHRcdF90cmF2ZXJzZSggMCwgYnl0ZU9mZnNldCApO1xuXHRcdFx0Ynl0ZU9mZnNldCArPSBidWZmZXIuYnl0ZUxlbmd0aDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIF90cmF2ZXJzZSggbm9kZTMySW5kZXgsIGJ5dGVPZmZzZXQsIGZvcmNlID0gZmFsc2UgKSB7XG5cblx0XHRcdGNvbnN0IG5vZGUxNkluZGV4ID0gbm9kZTMySW5kZXggKiAyO1xuXHRcdFx0Y29uc3QgaXNMZWFmID0gdWludDE2QXJyYXlbIG5vZGUxNkluZGV4ICsgMTUgXSA9PT0gSVNfTEVBRk5PREVfRkxBRztcblx0XHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRcdGNvbnN0IG9mZnNldCA9IHVpbnQzMkFycmF5WyBub2RlMzJJbmRleCArIDYgXTtcblx0XHRcdFx0Y29uc3QgY291bnQgPSB1aW50MTZBcnJheVsgbm9kZTE2SW5kZXggKyAxNCBdO1xuXG5cdFx0XHRcdGxldCBtaW54ID0gSW5maW5pdHk7XG5cdFx0XHRcdGxldCBtaW55ID0gSW5maW5pdHk7XG5cdFx0XHRcdGxldCBtaW56ID0gSW5maW5pdHk7XG5cdFx0XHRcdGxldCBtYXh4ID0gLSBJbmZpbml0eTtcblx0XHRcdFx0bGV0IG1heHkgPSAtIEluZmluaXR5O1xuXHRcdFx0XHRsZXQgbWF4eiA9IC0gSW5maW5pdHk7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGwgPSBvZmZzZXQgKyBjb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCB0ID0gMyAqIGJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaSApO1xuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdGxldCBpbmRleCA9IHQgKyBqO1xuXHRcdFx0XHRcdFx0aW5kZXggPSBpbmRleEFyciA/IGluZGV4QXJyWyBpbmRleCBdIDogaW5kZXg7XG5cblx0XHRcdFx0XHRcdGNvbnN0IHggPSBwb3NBdHRyLmdldFgoIGluZGV4ICk7XG5cdFx0XHRcdFx0XHRjb25zdCB5ID0gcG9zQXR0ci5nZXRZKCBpbmRleCApO1xuXHRcdFx0XHRcdFx0Y29uc3QgeiA9IHBvc0F0dHIuZ2V0WiggaW5kZXggKTtcblxuXHRcdFx0XHRcdFx0aWYgKCB4IDwgbWlueCApIG1pbnggPSB4O1xuXHRcdFx0XHRcdFx0aWYgKCB4ID4gbWF4eCApIG1heHggPSB4O1xuXG5cdFx0XHRcdFx0XHRpZiAoIHkgPCBtaW55ICkgbWlueSA9IHk7XG5cdFx0XHRcdFx0XHRpZiAoIHkgPiBtYXh5ICkgbWF4eSA9IHk7XG5cblx0XHRcdFx0XHRcdGlmICggeiA8IG1pbnogKSBtaW56ID0gejtcblx0XHRcdFx0XHRcdGlmICggeiA+IG1heHogKSBtYXh6ID0gejtcblxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMCBdICE9PSBtaW54IHx8XG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDEgXSAhPT0gbWlueSB8fFxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAyIF0gIT09IG1pbnogfHxcblxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAzIF0gIT09IG1heHggfHxcblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNCBdICE9PSBtYXh5IHx8XG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDUgXSAhPT0gbWF4elxuXHRcdFx0XHQpIHtcblxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAwIF0gPSBtaW54O1xuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAxIF0gPSBtaW55O1xuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAyIF0gPSBtaW56O1xuXG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDMgXSA9IG1heHg7XG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDQgXSA9IG1heHk7XG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDUgXSA9IG1heHo7XG5cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zdCBsZWZ0ID0gbm9kZTMySW5kZXggKyA4O1xuXHRcdFx0XHRjb25zdCByaWdodCA9IHVpbnQzMkFycmF5WyBub2RlMzJJbmRleCArIDYgXTtcblxuXHRcdFx0XHQvLyB0aGUgaWRlbnRpZnlpbmcgbm9kZSBpbmRpY2VzIHByb3ZpZGVkIGJ5IHRoZSBzaGFwZWNhc3QgZnVuY3Rpb24gaW5jbHVkZSBvZmZzZXRzIG9mIGFsbFxuXHRcdFx0XHQvLyByb290IGJ1ZmZlcnMgdG8gZ3VhcmFudGVlIHRoZXkncmUgdW5pcXVlIGJldHdlZW4gcm9vdHMgc28gb2Zmc2V0IGxlZnQgYW5kIHJpZ2h0IGluZGljZXMgaGVyZS5cblx0XHRcdFx0Y29uc3Qgb2Zmc2V0TGVmdCA9IGxlZnQgKyBieXRlT2Zmc2V0O1xuXHRcdFx0XHRjb25zdCBvZmZzZXRSaWdodCA9IHJpZ2h0ICsgYnl0ZU9mZnNldDtcblx0XHRcdFx0bGV0IGZvcmNlQ2hpbGRyZW4gPSBmb3JjZTtcblx0XHRcdFx0bGV0IGluY2x1ZGVzTGVmdCA9IGZhbHNlO1xuXHRcdFx0XHRsZXQgaW5jbHVkZXNSaWdodCA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmICggbm9kZUluZGljZXMgKSB7XG5cblx0XHRcdFx0XHQvLyBpZiB3ZSBzZWUgdGhhdCBuZWl0aGVyIHRoZSBsZWZ0IG9yIHJpZ2h0IGNoaWxkIGFyZSBpbmNsdWRlZCBpbiB0aGUgc2V0IHRoYXQgbmVlZCB0byBiZSB1cGRhdGVkXG5cdFx0XHRcdFx0Ly8gdGhlbiB3ZSBhc3N1bWUgdGhhdCBhbGwgY2hpbGRyZW4gbmVlZCB0byBiZSB1cGRhdGVkLlxuXHRcdFx0XHRcdGlmICggISBmb3JjZUNoaWxkcmVuICkge1xuXG5cdFx0XHRcdFx0XHRpbmNsdWRlc0xlZnQgPSBub2RlSW5kaWNlcy5oYXMoIG9mZnNldExlZnQgKTtcblx0XHRcdFx0XHRcdGluY2x1ZGVzUmlnaHQgPSBub2RlSW5kaWNlcy5oYXMoIG9mZnNldFJpZ2h0ICk7XG5cdFx0XHRcdFx0XHRmb3JjZUNoaWxkcmVuID0gISBpbmNsdWRlc0xlZnQgJiYgISBpbmNsdWRlc1JpZ2h0O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpbmNsdWRlc0xlZnQgPSB0cnVlO1xuXHRcdFx0XHRcdGluY2x1ZGVzUmlnaHQgPSB0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCB0cmF2ZXJzZUxlZnQgPSBmb3JjZUNoaWxkcmVuIHx8IGluY2x1ZGVzTGVmdDtcblx0XHRcdFx0Y29uc3QgdHJhdmVyc2VSaWdodCA9IGZvcmNlQ2hpbGRyZW4gfHwgaW5jbHVkZXNSaWdodDtcblxuXHRcdFx0XHRsZXQgbGVmdENoYW5nZSA9IGZhbHNlO1xuXHRcdFx0XHRpZiAoIHRyYXZlcnNlTGVmdCApIHtcblxuXHRcdFx0XHRcdGxlZnRDaGFuZ2UgPSBfdHJhdmVyc2UoIGxlZnQsIGJ5dGVPZmZzZXQsIGZvcmNlQ2hpbGRyZW4gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGV0IHJpZ2h0Q2hhbmdlID0gZmFsc2U7XG5cdFx0XHRcdGlmICggdHJhdmVyc2VSaWdodCApIHtcblxuXHRcdFx0XHRcdHJpZ2h0Q2hhbmdlID0gX3RyYXZlcnNlKCByaWdodCwgYnl0ZU9mZnNldCwgZm9yY2VDaGlsZHJlbiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBkaWRDaGFuZ2UgPSBsZWZ0Q2hhbmdlIHx8IHJpZ2h0Q2hhbmdlO1xuXHRcdFx0XHRpZiAoIGRpZENoYW5nZSApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGxlZnRpID0gbGVmdCArIGk7XG5cdFx0XHRcdFx0XHRjb25zdCByaWdodGkgPSByaWdodCArIGk7XG5cdFx0XHRcdFx0XHRjb25zdCBtaW5MZWZ0VmFsdWUgPSBmbG9hdDMyQXJyYXlbIGxlZnRpIF07XG5cdFx0XHRcdFx0XHRjb25zdCBtYXhMZWZ0VmFsdWUgPSBmbG9hdDMyQXJyYXlbIGxlZnRpICsgMyBdO1xuXHRcdFx0XHRcdFx0Y29uc3QgbWluUmlnaHRWYWx1ZSA9IGZsb2F0MzJBcnJheVsgcmlnaHRpIF07XG5cdFx0XHRcdFx0XHRjb25zdCBtYXhSaWdodFZhbHVlID0gZmxvYXQzMkFycmF5WyByaWdodGkgKyAzIF07XG5cblx0XHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyBpIF0gPSBtaW5MZWZ0VmFsdWUgPCBtaW5SaWdodFZhbHVlID8gbWluTGVmdFZhbHVlIDogbWluUmlnaHRWYWx1ZTtcblx0XHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyBpICsgMyBdID0gbWF4TGVmdFZhbHVlID4gbWF4UmlnaHRWYWx1ZSA/IG1heExlZnRWYWx1ZSA6IG1heFJpZ2h0VmFsdWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBkaWRDaGFuZ2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwicmF5Y2FzdC50ZW1wbGF0ZS5qc1wiLiAqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdGZ1bmN0aW9uIHJheWNhc3RfaW5kaXJlY3QoIGJ2aCwgcm9vdCwgc2lkZSwgcmF5LCBpbnRlcnNlY3RzLCBuZWFyLCBmYXIgKSB7XG5cblx0XHRCdWZmZXJTdGFjay5zZXRCdWZmZXIoIGJ2aC5fcm9vdHNbIHJvb3QgXSApO1xuXHRcdF9yYXljYXN0KCAwLCBidmgsIHNpZGUsIHJheSwgaW50ZXJzZWN0cywgbmVhciwgZmFyICk7XG5cdFx0QnVmZmVyU3RhY2suY2xlYXJCdWZmZXIoKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gX3JheWNhc3QoIG5vZGVJbmRleDMyLCBidmgsIHNpZGUsIHJheSwgaW50ZXJzZWN0cywgbmVhciwgZmFyICkge1xuXG5cdFx0Y29uc3QgeyBmbG9hdDMyQXJyYXksIHVpbnQxNkFycmF5LCB1aW50MzJBcnJheSB9ID0gQnVmZmVyU3RhY2s7XG5cdFx0Y29uc3Qgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cdFx0Y29uc3QgaXNMZWFmID0gSVNfTEVBRiggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cdFx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRcdGNvbnN0IG9mZnNldCA9IE9GRlNFVCggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0XHRjb25zdCBjb3VudCA9IENPVU5UKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblxuXHRcdFx0aW50ZXJzZWN0VHJpc19pbmRpcmVjdCggYnZoLCBzaWRlLCByYXksIG9mZnNldCwgY291bnQsIGludGVyc2VjdHMsIG5lYXIsIGZhciApO1xuXG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBsZWZ0SW5kZXggPSBMRUZUX05PREUoIG5vZGVJbmRleDMyICk7XG5cdFx0XHRpZiAoIGludGVyc2VjdFJheSggbGVmdEluZGV4LCBmbG9hdDMyQXJyYXksIHJheSwgbmVhciwgZmFyICkgKSB7XG5cblx0XHRcdFx0X3JheWNhc3QoIGxlZnRJbmRleCwgYnZoLCBzaWRlLCByYXksIGludGVyc2VjdHMsIG5lYXIsIGZhciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHJpZ2h0SW5kZXggPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdGlmICggaW50ZXJzZWN0UmF5KCByaWdodEluZGV4LCBmbG9hdDMyQXJyYXksIHJheSwgbmVhciwgZmFyICkgKSB7XG5cblx0XHRcdFx0X3JheWNhc3QoIHJpZ2h0SW5kZXgsIGJ2aCwgc2lkZSwgcmF5LCBpbnRlcnNlY3RzLCBuZWFyLCBmYXIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcInJheWNhc3RGaXJzdC50ZW1wbGF0ZS5qc1wiLiAqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0Y29uc3QgX3h5ekZpZWxkcyA9IFsgJ3gnLCAneScsICd6JyBdO1xuXG5cdGZ1bmN0aW9uIHJheWNhc3RGaXJzdF9pbmRpcmVjdCggYnZoLCByb290LCBzaWRlLCByYXksIG5lYXIsIGZhciApIHtcblxuXHRcdEJ1ZmZlclN0YWNrLnNldEJ1ZmZlciggYnZoLl9yb290c1sgcm9vdCBdICk7XG5cdFx0Y29uc3QgcmVzdWx0ID0gX3JheWNhc3RGaXJzdCggMCwgYnZoLCBzaWRlLCByYXksIG5lYXIsIGZhciApO1xuXHRcdEJ1ZmZlclN0YWNrLmNsZWFyQnVmZmVyKCk7XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBfcmF5Y2FzdEZpcnN0KCBub2RlSW5kZXgzMiwgYnZoLCBzaWRlLCByYXksIG5lYXIsIGZhciApIHtcblxuXHRcdGNvbnN0IHsgZmxvYXQzMkFycmF5LCB1aW50MTZBcnJheSwgdWludDMyQXJyYXkgfSA9IEJ1ZmZlclN0YWNrO1xuXHRcdGxldCBub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMjtcblxuXHRcdGNvbnN0IGlzTGVhZiA9IElTX0xFQUYoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRjb25zdCBvZmZzZXQgPSBPRkZTRVQoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdFx0Y29uc3QgY291bnQgPSBDT1VOVCggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cblx0XHRcdHJldHVybiBpbnRlcnNlY3RDbG9zZXN0VHJpX2luZGlyZWN0KCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCwgbmVhciwgZmFyICk7XG5cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGNvbnNpZGVyIHRoZSBwb3NpdGlvbiBvZiB0aGUgc3BsaXQgcGxhbmUgd2l0aCByZXNwZWN0IHRvIHRoZSBvbmNvbWluZyByYXk7IHdoaWNoZXZlciBkaXJlY3Rpb25cblx0XHRcdC8vIHRoZSByYXkgaXMgY29taW5nIGZyb20sIGxvb2sgZm9yIGFuIGludGVyc2VjdGlvbiBhbW9uZyB0aGF0IHNpZGUgb2YgdGhlIHRyZWUgZmlyc3Rcblx0XHRcdGNvbnN0IHNwbGl0QXhpcyA9IFNQTElUX0FYSVMoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdFx0Y29uc3QgeHl6QXhpcyA9IF94eXpGaWVsZHNbIHNwbGl0QXhpcyBdO1xuXHRcdFx0Y29uc3QgcmF5RGlyID0gcmF5LmRpcmVjdGlvblsgeHl6QXhpcyBdO1xuXHRcdFx0Y29uc3QgbGVmdFRvUmlnaHQgPSByYXlEaXIgPj0gMDtcblxuXHRcdFx0Ly8gYzEgaXMgdGhlIGNoaWxkIHRvIGNoZWNrIGZpcnN0XG5cdFx0XHRsZXQgYzEsIGMyO1xuXHRcdFx0aWYgKCBsZWZ0VG9SaWdodCApIHtcblxuXHRcdFx0XHRjMSA9IExFRlRfTk9ERSggbm9kZUluZGV4MzIgKTtcblx0XHRcdFx0YzIgPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjMSA9IFJJR0hUX05PREUoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdFx0XHRjMiA9IExFRlRfTk9ERSggbm9kZUluZGV4MzIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBjMUludGVyc2VjdGlvbiA9IGludGVyc2VjdFJheSggYzEsIGZsb2F0MzJBcnJheSwgcmF5LCBuZWFyLCBmYXIgKTtcblx0XHRcdGNvbnN0IGMxUmVzdWx0ID0gYzFJbnRlcnNlY3Rpb24gPyBfcmF5Y2FzdEZpcnN0KCBjMSwgYnZoLCBzaWRlLCByYXksIG5lYXIsIGZhciApIDogbnVsbDtcblxuXHRcdFx0Ly8gaWYgd2UgZ290IGFuIGludGVyc2VjdGlvbiBpbiB0aGUgZmlyc3Qgbm9kZSBhbmQgaXQncyBjbG9zZXIgdGhhbiB0aGUgc2Vjb25kIG5vZGUncyBib3VuZGluZ1xuXHRcdFx0Ly8gYm94LCB3ZSBkb24ndCBuZWVkIHRvIGNvbnNpZGVyIHRoZSBzZWNvbmQgbm9kZSBiZWNhdXNlIGl0IGNvdWxkbid0IHBvc3NpYmx5IGJlIGEgYmV0dGVyIHJlc3VsdFxuXHRcdFx0aWYgKCBjMVJlc3VsdCApIHtcblxuXHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSBzZWNvbmQgYm91bmRzXG5cdFx0XHRcdC8vIFwicG9pbnRcIiBpcyBpbiB0aGUgbG9jYWwgZnJhbWUgb2YgdGhlIGJ2aFxuXHRcdFx0XHRjb25zdCBwb2ludCA9IGMxUmVzdWx0LnBvaW50WyB4eXpBeGlzIF07XG5cdFx0XHRcdGNvbnN0IGlzT3V0c2lkZSA9IGxlZnRUb1JpZ2h0ID9cblx0XHRcdFx0XHRwb2ludCA8PSBmbG9hdDMyQXJyYXlbIGMyICsgc3BsaXRBeGlzIF0gOiAvLyBtaW4gYm91bmRpbmcgZGF0YVxuXHRcdFx0XHRcdHBvaW50ID49IGZsb2F0MzJBcnJheVsgYzIgKyBzcGxpdEF4aXMgKyAzIF07IC8vIG1heCBib3VuZGluZyBkYXRhXG5cblx0XHRcdFx0aWYgKCBpc091dHNpZGUgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gYzFSZXN1bHQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGVpdGhlciB0aGVyZSB3YXMgbm8gaW50ZXJzZWN0aW9uIGluIHRoZSBmaXJzdCBub2RlLCBvciB0aGVyZSBjb3VsZCBzdGlsbCBiZSBhIGNsb3NlclxuXHRcdFx0Ly8gaW50ZXJzZWN0aW9uIGluIHRoZSBzZWNvbmQsIHNvIGNoZWNrIHRoZSBzZWNvbmQgbm9kZSBhbmQgdGhlbiB0YWtlIHRoZSBiZXR0ZXIgb2YgdGhlIHR3b1xuXHRcdFx0Y29uc3QgYzJJbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RSYXkoIGMyLCBmbG9hdDMyQXJyYXksIHJheSwgbmVhciwgZmFyICk7XG5cdFx0XHRjb25zdCBjMlJlc3VsdCA9IGMySW50ZXJzZWN0aW9uID8gX3JheWNhc3RGaXJzdCggYzIsIGJ2aCwgc2lkZSwgcmF5LCBuZWFyLCBmYXIgKSA6IG51bGw7XG5cblx0XHRcdGlmICggYzFSZXN1bHQgJiYgYzJSZXN1bHQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGMxUmVzdWx0LmRpc3RhbmNlIDw9IGMyUmVzdWx0LmRpc3RhbmNlID8gYzFSZXN1bHQgOiBjMlJlc3VsdDtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gYzFSZXN1bHQgfHwgYzJSZXN1bHQgfHwgbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcImludGVyc2VjdHNHZW9tZXRyeS50ZW1wbGF0ZS5qc1wiLiAqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuXG5cdGNvbnN0IGJvdW5kaW5nQm94JDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLkJveDMoKTtcblx0Y29uc3QgdHJpYW5nbGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IEV4dGVuZGVkVHJpYW5nbGUoKTtcblx0Y29uc3QgdHJpYW5nbGUyID0gLyogQF9fUFVSRV9fICovIG5ldyBFeHRlbmRlZFRyaWFuZ2xlKCk7XG5cdGNvbnN0IGludmVydGVkTWF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0Y29uc3Qgb2JiJDIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE9yaWVudGVkQm94KCk7XG5cdGNvbnN0IG9iYjIkMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgT3JpZW50ZWRCb3goKTtcblxuXHRmdW5jdGlvbiBpbnRlcnNlY3RzR2VvbWV0cnlfaW5kaXJlY3QoIGJ2aCwgcm9vdCwgb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCApIHtcblxuXHRcdEJ1ZmZlclN0YWNrLnNldEJ1ZmZlciggYnZoLl9yb290c1sgcm9vdCBdICk7XG5cdFx0Y29uc3QgcmVzdWx0ID0gX2ludGVyc2VjdHNHZW9tZXRyeSggMCwgYnZoLCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0QnVmZmVyU3RhY2suY2xlYXJCdWZmZXIoKTtcblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIF9pbnRlcnNlY3RzR2VvbWV0cnkoIG5vZGVJbmRleDMyLCBidmgsIG90aGVyR2VvbWV0cnksIGdlb21ldHJ5VG9CdmgsIGNhY2hlZE9iYiA9IG51bGwgKSB7XG5cblx0XHRjb25zdCB7IGZsb2F0MzJBcnJheSwgdWludDE2QXJyYXksIHVpbnQzMkFycmF5IH0gPSBCdWZmZXJTdGFjaztcblx0XHRsZXQgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cblx0XHRpZiAoIGNhY2hlZE9iYiA9PT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCAhIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3ggKSB7XG5cblx0XHRcdFx0b3RoZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvYmIkMi5zZXQoIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3gubWluLCBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94Lm1heCwgZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0Y2FjaGVkT2JiID0gb2JiJDI7XG5cblx0XHR9XG5cblx0XHRjb25zdCBpc0xlYWYgPSBJU19MRUFGKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0Y29uc3QgdGhpc0dlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRcdFx0Y29uc3QgdGhpc0luZGV4ID0gdGhpc0dlb21ldHJ5LmluZGV4O1xuXHRcdFx0Y29uc3QgdGhpc1BvcyA9IHRoaXNHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0XHRjb25zdCBpbmRleCA9IG90aGVyR2VvbWV0cnkuaW5kZXg7XG5cdFx0XHRjb25zdCBwb3MgPSBvdGhlckdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRcdGNvbnN0IG9mZnNldCA9IE9GRlNFVCggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0XHRjb25zdCBjb3VudCA9IENPVU5UKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblxuXHRcdFx0Ly8gZ2V0IHRoZSBpbnZlcnNlIG9mIHRoZSBnZW9tZXRyeSBtYXRyaXggc28gd2UgY2FuIHRyYW5zZm9ybSBvdXIgdHJpYW5nbGVzIGludG8gdGhlXG5cdFx0XHQvLyBnZW9tZXRyeSBzcGFjZSB3ZSdyZSB0cnlpbmcgdG8gdGVzdC4gV2UgYXNzdW1lIHRoZXJlIGFyZSBmZXdlciB0cmlhbmdsZXMgYmVpbmcgY2hlY2tlZFxuXHRcdFx0Ly8gaGVyZS5cblx0XHRcdGludmVydGVkTWF0LmNvcHkoIGdlb21ldHJ5VG9CdmggKS5pbnZlcnQoKTtcblxuXHRcdFx0aWYgKCBvdGhlckdlb21ldHJ5LmJvdW5kc1RyZWUgKSB7XG5cblx0XHRcdFx0Ly8gaWYgdGhlcmUncyBhIGJvdW5kcyB0cmVlXG5cdFx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIG5vZGVJbmRleDMyICksIGZsb2F0MzJBcnJheSwgb2JiMiQxICk7XG5cdFx0XHRcdG9iYjIkMS5tYXRyaXguY29weSggaW52ZXJ0ZWRNYXQgKTtcblx0XHRcdFx0b2JiMiQxLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBUT0RPOiB1c2UgYSB0cmlhbmdsZSBpdGVyYXRpb24gZnVuY3Rpb24gaGVyZVxuXHRcdFx0XHRjb25zdCByZXMgPSBvdGhlckdlb21ldHJ5LmJvdW5kc1RyZWUuc2hhcGVjYXN0KCB7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzOiBib3ggPT4gb2JiMiQxLmludGVyc2VjdHNCb3goIGJveCApLFxuXG5cdFx0XHRcdFx0aW50ZXJzZWN0c1RyaWFuZ2xlOiB0cmkgPT4ge1xuXG5cdFx0XHRcdFx0XHR0cmkuYS5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdHRyaS5iLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0dHJpLmMuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHR0cmkubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgbCA9IGNvdW50ICsgb2Zmc2V0OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyB0aGlzIHRyaWFuZ2xlIG5lZWRzIHRvIGJlIHRyYW5zZm9ybWVkIGludG8gdGhlIGN1cnJlbnQgQlZIIGNvb3JkaW5hdGUgZnJhbWVcblx0XHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgMyAqIGJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaSApLCB0aGlzSW5kZXgsIHRoaXNQb3MgKTtcblx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0aWYgKCB0cmkuaW50ZXJzZWN0c1RyaWFuZ2xlKCB0cmlhbmdsZTIgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0cmV0dXJuIHJlcztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBpZiB3ZSdyZSBqdXN0IGRlYWxpbmcgd2l0aCByYXcgZ2VvbWV0cnlcblx0XHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGwgPSBjb3VudCArIG9mZnNldDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHQvLyB0aGlzIHRyaWFuZ2xlIG5lZWRzIHRvIGJlIHRyYW5zZm9ybWVkIGludG8gdGhlIGN1cnJlbnQgQlZIIGNvb3JkaW5hdGUgZnJhbWVcblx0XHRcdFx0XHRjb25zdCB0aSA9IGJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaSApO1xuXHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZSwgMyAqIHRpLCB0aGlzSW5kZXgsIHRoaXNQb3MgKTtcblxuXG5cdFx0XHRcdFx0dHJpYW5nbGUuYS5hcHBseU1hdHJpeDQoIGludmVydGVkTWF0ICk7XG5cdFx0XHRcdFx0dHJpYW5nbGUuYi5hcHBseU1hdHJpeDQoIGludmVydGVkTWF0ICk7XG5cdFx0XHRcdFx0dHJpYW5nbGUuYy5hcHBseU1hdHJpeDQoIGludmVydGVkTWF0ICk7XG5cdFx0XHRcdFx0dHJpYW5nbGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkyID0gMCwgbDIgPSBpbmRleC5jb3VudDsgaTIgPCBsMjsgaTIgKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgaTIsIGluZGV4LCBwb3MgKTtcblx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdGlmICggdHJpYW5nbGUuaW50ZXJzZWN0c1RyaWFuZ2xlKCB0cmlhbmdsZTIgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBsZWZ0ID0gbm9kZUluZGV4MzIgKyA4O1xuXHRcdFx0Y29uc3QgcmlnaHQgPSB1aW50MzJBcnJheVsgbm9kZUluZGV4MzIgKyA2IF07XG5cblx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGxlZnQgKSwgZmxvYXQzMkFycmF5LCBib3VuZGluZ0JveCQxICk7XG5cdFx0XHRjb25zdCBsZWZ0SW50ZXJzZWN0aW9uID1cblx0XHRcdFx0Y2FjaGVkT2JiLmludGVyc2VjdHNCb3goIGJvdW5kaW5nQm94JDEgKSAmJlxuXHRcdFx0XHRfaW50ZXJzZWN0c0dlb21ldHJ5KCBsZWZ0LCBidmgsIG90aGVyR2VvbWV0cnksIGdlb21ldHJ5VG9CdmgsIGNhY2hlZE9iYiApO1xuXG5cdFx0XHRpZiAoIGxlZnRJbnRlcnNlY3Rpb24gKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggcmlnaHQgKSwgZmxvYXQzMkFycmF5LCBib3VuZGluZ0JveCQxICk7XG5cdFx0XHRjb25zdCByaWdodEludGVyc2VjdGlvbiA9XG5cdFx0XHRcdGNhY2hlZE9iYi5pbnRlcnNlY3RzQm94KCBib3VuZGluZ0JveCQxICkgJiZcblx0XHRcdFx0X2ludGVyc2VjdHNHZW9tZXRyeSggcmlnaHQsIGJ2aCwgb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCwgY2FjaGVkT2JiICk7XG5cblx0XHRcdGlmICggcmlnaHRJbnRlcnNlY3Rpb24gKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJjbG9zZXN0UG9pbnRUb0dlb21ldHJ5LnRlbXBsYXRlLmpzXCIuICovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0Y29uc3QgdGVtcE1hdHJpeCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRjb25zdCBvYmIkMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgT3JpZW50ZWRCb3goKTtcblx0Y29uc3Qgb2JiMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgT3JpZW50ZWRCb3goKTtcblx0Y29uc3QgdGVtcDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgdGVtcDIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgdGVtcDMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgdGVtcDQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRmdW5jdGlvbiBjbG9zZXN0UG9pbnRUb0dlb21ldHJ5X2luZGlyZWN0KFxuXHRcdGJ2aCxcblx0XHRvdGhlckdlb21ldHJ5LFxuXHRcdGdlb21ldHJ5VG9CdmgsXG5cdFx0dGFyZ2V0MSA9IHsgfSxcblx0XHR0YXJnZXQyID0geyB9LFxuXHRcdG1pblRocmVzaG9sZCA9IDAsXG5cdFx0bWF4VGhyZXNob2xkID0gSW5maW5pdHksXG5cdCkge1xuXG5cdFx0aWYgKCAhIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3ggKSB7XG5cblx0XHRcdG90aGVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHR9XG5cblx0XHRvYmIkMS5zZXQoIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3gubWluLCBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94Lm1heCwgZ2VvbWV0cnlUb0J2aCApO1xuXHRcdG9iYiQxLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdGNvbnN0IGdlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRcdGNvbnN0IHBvcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0Y29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCBvdGhlclBvcyA9IG90aGVyR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRjb25zdCBvdGhlckluZGV4ID0gb3RoZXJHZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCB0cmlhbmdsZSA9IEV4dGVuZGVkVHJpYW5nbGVQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdGNvbnN0IHRyaWFuZ2xlMiA9IEV4dGVuZGVkVHJpYW5nbGVQb29sLmdldFByaW1pdGl2ZSgpO1xuXG5cdFx0bGV0IHRlbXBUYXJnZXQxID0gdGVtcDE7XG5cdFx0bGV0IHRlbXBUYXJnZXREZXN0MSA9IHRlbXAyO1xuXHRcdGxldCB0ZW1wVGFyZ2V0MiA9IG51bGw7XG5cdFx0bGV0IHRlbXBUYXJnZXREZXN0MiA9IG51bGw7XG5cblx0XHRpZiAoIHRhcmdldDIgKSB7XG5cblx0XHRcdHRlbXBUYXJnZXQyID0gdGVtcDM7XG5cdFx0XHR0ZW1wVGFyZ2V0RGVzdDIgPSB0ZW1wNDtcblxuXHRcdH1cblxuXHRcdGxldCBjbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcblx0XHRsZXQgY2xvc2VzdERpc3RhbmNlVHJpSW5kZXggPSBudWxsO1xuXHRcdGxldCBjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4ID0gbnVsbDtcblx0XHR0ZW1wTWF0cml4LmNvcHkoIGdlb21ldHJ5VG9CdmggKS5pbnZlcnQoKTtcblx0XHRvYmIyLm1hdHJpeC5jb3B5KCB0ZW1wTWF0cml4ICk7XG5cdFx0YnZoLnNoYXBlY2FzdChcblx0XHRcdHtcblxuXHRcdFx0XHRib3VuZHNUcmF2ZXJzZU9yZGVyOiBib3ggPT4ge1xuXG5cdFx0XHRcdFx0cmV0dXJuIG9iYiQxLmRpc3RhbmNlVG9Cb3goIGJveCApO1xuXG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0aW50ZXJzZWN0c0JvdW5kczogKCBib3gsIGlzTGVhZiwgc2NvcmUgKSA9PiB7XG5cblx0XHRcdFx0XHRpZiAoIHNjb3JlIDwgY2xvc2VzdERpc3RhbmNlICYmIHNjb3JlIDwgbWF4VGhyZXNob2xkICkge1xuXG5cdFx0XHRcdFx0XHQvLyBpZiB3ZSBrbm93IHRoZSB0cmlhbmdsZXMgb2YgdGhpcyBib3VuZHMgd2lsbCBiZSBpbnRlcnNlY3RlZCBuZXh0IHRoZW5cblx0XHRcdFx0XHRcdC8vIHNhdmUgdGhlIGJvdW5kcyB0byB1c2UgZHVyaW5nIHRyaWFuZ2xlIGNoZWNrcy5cblx0XHRcdFx0XHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRcdFx0XHRcdG9iYjIubWluLmNvcHkoIGJveC5taW4gKTtcblx0XHRcdFx0XHRcdFx0b2JiMi5tYXguY29weSggYm94Lm1heCApO1xuXHRcdFx0XHRcdFx0XHRvYmIyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGludGVyc2VjdHNSYW5nZTogKCBvZmZzZXQsIGNvdW50ICkgPT4ge1xuXG5cdFx0XHRcdFx0aWYgKCBvdGhlckdlb21ldHJ5LmJvdW5kc1RyZWUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGlmIHRoZSBvdGhlciBnZW9tZXRyeSBoYXMgYSBidmggdGhlbiB1c2UgdGhlIGFjY2VsZXJhdGVkIHBhdGggd2hlcmUgd2UgdXNlIHNoYXBlY2FzdCB0byBmaW5kXG5cdFx0XHRcdFx0XHQvLyB0aGUgY2xvc2VzdCBib3VuZHMgaW4gdGhlIG90aGVyIGdlb21ldHJ5IHRvIGNoZWNrLlxuXHRcdFx0XHRcdFx0Y29uc3Qgb3RoZXJCdmggPSBvdGhlckdlb21ldHJ5LmJvdW5kc1RyZWU7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb3RoZXJCdmguc2hhcGVjYXN0KCB7XG5cdFx0XHRcdFx0XHRcdGJvdW5kc1RyYXZlcnNlT3JkZXI6IGJveCA9PiB7XG5cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gb2JiMi5kaXN0YW5jZVRvQm94KCBib3ggKTtcblxuXHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdGludGVyc2VjdHNCb3VuZHM6ICggYm94LCBpc0xlYWYsIHNjb3JlICkgPT4ge1xuXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHNjb3JlIDwgY2xvc2VzdERpc3RhbmNlICYmIHNjb3JlIDwgbWF4VGhyZXNob2xkO1xuXG5cdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlOiAoIG90aGVyT2Zmc2V0LCBvdGhlckNvdW50ICkgPT4ge1xuXG5cdFx0XHRcdFx0XHRcdFx0Zm9yICggbGV0IGkyID0gb3RoZXJPZmZzZXQsIGwyID0gb3RoZXJPZmZzZXQgKyBvdGhlckNvdW50OyBpMiA8IGwyOyBpMiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgdGkyID0gb3RoZXJCdmgucmVzb2x2ZVRyaWFuZ2xlSW5kZXgoIGkyICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUyLCAzICogdGkyLCBvdGhlckluZGV4LCBvdGhlclBvcyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIuYS5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5iLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLmMuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgbCA9IG9mZnNldCArIGNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zdCB0aSA9IGJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUsIDMgKiB0aSwgaW5kZXgsIHBvcyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyaWFuZ2xlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBkaXN0ID0gdHJpYW5nbGUuZGlzdGFuY2VUb1RyaWFuZ2xlKCB0cmlhbmdsZTIsIHRlbXBUYXJnZXQxLCB0ZW1wVGFyZ2V0MiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCBjbG9zZXN0RGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVGFyZ2V0RGVzdDEuY29weSggdGVtcFRhcmdldDEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdGVtcFRhcmdldERlc3QyICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVGFyZ2V0RGVzdDIuY29weSggdGVtcFRhcmdldDIgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZSA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlVHJpSW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZU90aGVyVHJpSW5kZXggPSBpMjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gc3RvcCB0cmF2ZXJzYWwgaWYgd2UgZmluZCBhIHBvaW50IHRoYXQncyB1bmRlciB0aGUgZ2l2ZW4gdGhyZXNob2xkXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGlzdCA8IG1pblRocmVzaG9sZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBubyBib3VuZHMgdHJlZSB0aGVuIHdlJ2xsIGp1c3QgY2hlY2sgZXZlcnkgdHJpYW5nbGUuXG5cdFx0XHRcdFx0XHRjb25zdCB0cmlDb3VudCA9IGdldFRyaUNvdW50KCBvdGhlckdlb21ldHJ5ICk7XG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaTIgPSAwLCBsMiA9IHRyaUNvdW50OyBpMiA8IGwyOyBpMiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUyLCAzICogaTIsIG90aGVySW5kZXgsIG90aGVyUG9zICk7XG5cdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5hLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIuYi5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdFx0dHJpYW5nbGUyLmMuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGwgPSBvZmZzZXQgKyBjb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zdCB0aSA9IGJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaSApO1xuXHRcdFx0XHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZSwgMyAqIHRpLCBpbmRleCwgcG9zICk7XG5cblx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zdCBkaXN0ID0gdHJpYW5nbGUuZGlzdGFuY2VUb1RyaWFuZ2xlKCB0cmlhbmdsZTIsIHRlbXBUYXJnZXQxLCB0ZW1wVGFyZ2V0MiApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRhcmdldERlc3QxLmNvcHkoIHRlbXBUYXJnZXQxICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggdGVtcFRhcmdldERlc3QyICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRlbXBUYXJnZXREZXN0Mi5jb3B5KCB0ZW1wVGFyZ2V0MiApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZSA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VUcmlJbmRleCA9IGk7XG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4ID0gaTI7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBzdG9wIHRyYXZlcnNhbCBpZiB3ZSBmaW5kIGEgcG9pbnQgdGhhdCdzIHVuZGVyIHRoZSBnaXZlbiB0aHJlc2hvbGRcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCBtaW5UaHJlc2hvbGQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0sXG5cblx0XHRcdH1cblxuXHRcdCk7XG5cblx0XHRFeHRlbmRlZFRyaWFuZ2xlUG9vbC5yZWxlYXNlUHJpbWl0aXZlKCB0cmlhbmdsZSApO1xuXHRcdEV4dGVuZGVkVHJpYW5nbGVQb29sLnJlbGVhc2VQcmltaXRpdmUoIHRyaWFuZ2xlMiApO1xuXG5cdFx0aWYgKCBjbG9zZXN0RGlzdGFuY2UgPT09IEluZmluaXR5ICkge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdGlmICggISB0YXJnZXQxLnBvaW50ICkge1xuXG5cdFx0XHR0YXJnZXQxLnBvaW50ID0gdGVtcFRhcmdldERlc3QxLmNsb25lKCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0YXJnZXQxLnBvaW50LmNvcHkoIHRlbXBUYXJnZXREZXN0MSApO1xuXG5cdFx0fVxuXG5cdFx0dGFyZ2V0MS5kaXN0YW5jZSA9IGNsb3Nlc3REaXN0YW5jZSxcblx0XHR0YXJnZXQxLmZhY2VJbmRleCA9IGNsb3Nlc3REaXN0YW5jZVRyaUluZGV4O1xuXG5cdFx0aWYgKCB0YXJnZXQyICkge1xuXG5cdFx0XHRpZiAoICEgdGFyZ2V0Mi5wb2ludCApIHRhcmdldDIucG9pbnQgPSB0ZW1wVGFyZ2V0RGVzdDIuY2xvbmUoKTtcblx0XHRcdGVsc2UgdGFyZ2V0Mi5wb2ludC5jb3B5KCB0ZW1wVGFyZ2V0RGVzdDIgKTtcblx0XHRcdHRhcmdldDIucG9pbnQuYXBwbHlNYXRyaXg0KCB0ZW1wTWF0cml4ICk7XG5cdFx0XHR0ZW1wVGFyZ2V0RGVzdDEuYXBwbHlNYXRyaXg0KCB0ZW1wTWF0cml4ICk7XG5cdFx0XHR0YXJnZXQyLmRpc3RhbmNlID0gdGVtcFRhcmdldERlc3QxLnN1YiggdGFyZ2V0Mi5wb2ludCApLmxlbmd0aCgpO1xuXHRcdFx0dGFyZ2V0Mi5mYWNlSW5kZXggPSBjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDE7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXJTdXBwb3J0ZWQoKSB7XG5cblx0XHRyZXR1cm4gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJztcblxuXHR9XG5cblx0ZnVuY3Rpb24gY29udmVydFRvQnVmZmVyVHlwZSggYXJyYXksIEJ1ZmZlckNvbnN0cnVjdG9yICkge1xuXG5cdFx0aWYgKCBhcnJheSA9PT0gbnVsbCApIHtcblxuXHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0fSBlbHNlIGlmICggYXJyYXkuYnVmZmVyICkge1xuXG5cdFx0XHRjb25zdCBidWZmZXIgPSBhcnJheS5idWZmZXI7XG5cdFx0XHRpZiAoIGJ1ZmZlci5jb25zdHJ1Y3RvciA9PT0gQnVmZmVyQ29uc3RydWN0b3IgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IEFycmF5Q29uc3RydWN0b3IgPSBhcnJheS5jb25zdHJ1Y3Rvcjtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheUNvbnN0cnVjdG9yKCBuZXcgQnVmZmVyQ29uc3RydWN0b3IoIGJ1ZmZlci5ieXRlTGVuZ3RoICkgKTtcblx0XHRcdHJlc3VsdC5zZXQoIGFycmF5ICk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCBhcnJheS5jb25zdHJ1Y3RvciA9PT0gQnVmZmVyQ29uc3RydWN0b3IgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGFycmF5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHJlc3VsdCA9IG5ldyBCdWZmZXJDb25zdHJ1Y3RvciggYXJyYXkuYnl0ZUxlbmd0aCApO1xuXHRcdFx0bmV3IFVpbnQ4QXJyYXkoIHJlc3VsdCApLnNldCggbmV3IFVpbnQ4QXJyYXkoIGFycmF5ICkgKTtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IF9idWZmZXJTdGFjazEgPSBuZXcgQnVmZmVyU3RhY2suY29uc3RydWN0b3IoKTtcblx0Y29uc3QgX2J1ZmZlclN0YWNrMiA9IG5ldyBCdWZmZXJTdGFjay5jb25zdHJ1Y3RvcigpO1xuXHRjb25zdCBfYm94UG9vbCA9IG5ldyBQcmltaXRpdmVQb29sKCAoKSA9PiBuZXcgVEhSRUUuQm94MygpICk7XG5cdGNvbnN0IF9sZWZ0Qm94MSA9IG5ldyBUSFJFRS5Cb3gzKCk7XG5cdGNvbnN0IF9yaWdodEJveDEgPSBuZXcgVEhSRUUuQm94MygpO1xuXG5cdGNvbnN0IF9sZWZ0Qm94MiA9IG5ldyBUSFJFRS5Cb3gzKCk7XG5cdGNvbnN0IF9yaWdodEJveDIgPSBuZXcgVEhSRUUuQm94MygpO1xuXG5cdGxldCBfYWN0aXZlID0gZmFsc2U7XG5cblx0ZnVuY3Rpb24gYnZoY2FzdCggYnZoLCBvdGhlckJ2aCwgbWF0cml4VG9Mb2NhbCwgaW50ZXJzZWN0c1JhbmdlcyApIHtcblxuXHRcdGlmICggX2FjdGl2ZSApIHtcblxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnTWVzaEJWSDogUmVjdXJzaXZlIGNhbGxzIHRvIGJ2aGNhc3Qgbm90IHN1cHBvcnRlZC4nICk7XG5cblx0XHR9XG5cblx0XHRfYWN0aXZlID0gdHJ1ZTtcblxuXHRcdGNvbnN0IHJvb3RzID0gYnZoLl9yb290cztcblx0XHRjb25zdCBvdGhlclJvb3RzID0gb3RoZXJCdmguX3Jvb3RzO1xuXHRcdGxldCByZXN1bHQ7XG5cdFx0bGV0IG9mZnNldDEgPSAwO1xuXHRcdGxldCBvZmZzZXQyID0gMDtcblx0XHRjb25zdCBpbnZNYXQgPSBuZXcgVEhSRUUuTWF0cml4NCgpLmNvcHkoIG1hdHJpeFRvTG9jYWwgKS5pbnZlcnQoKTtcblxuXHRcdC8vIGl0ZXJhdGUgb3ZlciB0aGUgZmlyc3Qgc2V0IG9mIHJvb3RzXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHJvb3RzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRfYnVmZmVyU3RhY2sxLnNldEJ1ZmZlciggcm9vdHNbIGkgXSApO1xuXHRcdFx0b2Zmc2V0MiA9IDA7XG5cblx0XHRcdC8vIHByZXAgdGhlIGluaXRpYWwgcm9vdCBib3hcblx0XHRcdGNvbnN0IGxvY2FsQm94ID0gX2JveFBvb2wuZ2V0UHJpbWl0aXZlKCk7XG5cdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCAwICksIF9idWZmZXJTdGFjazEuZmxvYXQzMkFycmF5LCBsb2NhbEJveCApO1xuXHRcdFx0bG9jYWxCb3guYXBwbHlNYXRyaXg0KCBpbnZNYXQgKTtcblxuXHRcdFx0Ly8gaXRlcmF0ZSBvdmVyIHRoZSBzZWNvbmQgc2V0IG9mIHJvb3RzXG5cdFx0XHRmb3IgKCBsZXQgaiA9IDAsIGpsID0gb3RoZXJSb290cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRfYnVmZmVyU3RhY2syLnNldEJ1ZmZlciggb3RoZXJSb290c1sgaiBdICk7XG5cblx0XHRcdFx0cmVzdWx0ID0gX3RyYXZlcnNlKFxuXHRcdFx0XHRcdDAsIDAsIG1hdHJpeFRvTG9jYWwsIGludk1hdCwgaW50ZXJzZWN0c1Jhbmdlcyxcblx0XHRcdFx0XHRvZmZzZXQxLCBvZmZzZXQyLCAwLCAwLFxuXHRcdFx0XHRcdGxvY2FsQm94LFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdF9idWZmZXJTdGFjazIuY2xlYXJCdWZmZXIoKTtcblx0XHRcdFx0b2Zmc2V0MiArPSBvdGhlclJvb3RzWyBqIF0ubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlbGVhc2Ugc3RhY2sgaW5mb1xuXHRcdFx0X2JveFBvb2wucmVsZWFzZVByaW1pdGl2ZSggbG9jYWxCb3ggKTtcblx0XHRcdF9idWZmZXJTdGFjazEuY2xlYXJCdWZmZXIoKTtcblx0XHRcdG9mZnNldDEgKz0gcm9vdHNbIGkgXS5sZW5ndGg7XG5cblx0XHRcdGlmICggcmVzdWx0ICkge1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRfYWN0aXZlID0gZmFsc2U7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gX3RyYXZlcnNlKFxuXHRcdG5vZGUxSW5kZXgzMixcblx0XHRub2RlMkluZGV4MzIsXG5cdFx0bWF0cml4MnRvMSxcblx0XHRtYXRyaXgxdG8yLFxuXHRcdGludGVyc2VjdHNSYW5nZXNGdW5jLFxuXG5cdFx0Ly8gb2Zmc2V0cyBmb3IgaWRzXG5cdFx0bm9kZTFJbmRleEJ5dGVPZmZzZXQgPSAwLFxuXHRcdG5vZGUySW5kZXhCeXRlT2Zmc2V0ID0gMCxcblxuXHRcdC8vIHRyZWUgZGVwdGhcblx0XHRkZXB0aDEgPSAwLFxuXHRcdGRlcHRoMiA9IDAsXG5cblx0XHRjdXJyQm94ID0gbnVsbCxcblx0XHRyZXZlcnNlZCA9IGZhbHNlLFxuXG5cdCkge1xuXG5cdFx0Ly8gZ2V0IHRoZSBidWZmZXIgc3RhY2tzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBpbmRpY2VzXG5cdFx0bGV0IGJ1ZmZlclN0YWNrMSwgYnVmZmVyU3RhY2syO1xuXHRcdGlmICggcmV2ZXJzZWQgKSB7XG5cblx0XHRcdGJ1ZmZlclN0YWNrMSA9IF9idWZmZXJTdGFjazI7XG5cdFx0XHRidWZmZXJTdGFjazIgPSBfYnVmZmVyU3RhY2sxO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0YnVmZmVyU3RhY2sxID0gX2J1ZmZlclN0YWNrMTtcblx0XHRcdGJ1ZmZlclN0YWNrMiA9IF9idWZmZXJTdGFjazI7XG5cblx0XHR9XG5cblx0XHQvLyBnZXQgdGhlIGxvY2FsIGluc3RhbmNlcyBvZiB0aGUgdHlwZWQgYnVmZmVyc1xuXHRcdGNvbnN0XG5cdFx0XHRmbG9hdDMyQXJyYXkxID0gYnVmZmVyU3RhY2sxLmZsb2F0MzJBcnJheSxcblx0XHRcdHVpbnQzMkFycmF5MSA9IGJ1ZmZlclN0YWNrMS51aW50MzJBcnJheSxcblx0XHRcdHVpbnQxNkFycmF5MSA9IGJ1ZmZlclN0YWNrMS51aW50MTZBcnJheSxcblx0XHRcdGZsb2F0MzJBcnJheTIgPSBidWZmZXJTdGFjazIuZmxvYXQzMkFycmF5LFxuXHRcdFx0dWludDMyQXJyYXkyID0gYnVmZmVyU3RhY2syLnVpbnQzMkFycmF5LFxuXHRcdFx0dWludDE2QXJyYXkyID0gYnVmZmVyU3RhY2syLnVpbnQxNkFycmF5O1xuXG5cdFx0Y29uc3Qgbm9kZTFJbmRleDE2ID0gbm9kZTFJbmRleDMyICogMjtcblx0XHRjb25zdCBub2RlMkluZGV4MTYgPSBub2RlMkluZGV4MzIgKiAyO1xuXHRcdGNvbnN0IGlzTGVhZjEgPSBJU19MRUFGKCBub2RlMUluZGV4MTYsIHVpbnQxNkFycmF5MSApO1xuXHRcdGNvbnN0IGlzTGVhZjIgPSBJU19MRUFGKCBub2RlMkluZGV4MTYsIHVpbnQxNkFycmF5MiApO1xuXHRcdGxldCByZXN1bHQgPSBmYWxzZTtcblx0XHRpZiAoIGlzTGVhZjIgJiYgaXNMZWFmMSApIHtcblxuXHRcdFx0Ly8gaWYgYm90aCBib3VuZHMgYXJlIGxlYWYgbm9kZXMgdGhlbiBmaXJlIHRoZSBjYWxsYmFjayBpZiB0aGUgYm94ZXMgaW50ZXJzZWN0XG5cdFx0XHRpZiAoIHJldmVyc2VkICkge1xuXG5cdFx0XHRcdHJlc3VsdCA9IGludGVyc2VjdHNSYW5nZXNGdW5jKFxuXHRcdFx0XHRcdE9GRlNFVCggbm9kZTJJbmRleDMyLCB1aW50MzJBcnJheTIgKSwgQ09VTlQoIG5vZGUySW5kZXgzMiAqIDIsIHVpbnQxNkFycmF5MiApLFxuXHRcdFx0XHRcdE9GRlNFVCggbm9kZTFJbmRleDMyLCB1aW50MzJBcnJheTEgKSwgQ09VTlQoIG5vZGUxSW5kZXgzMiAqIDIsIHVpbnQxNkFycmF5MSApLFxuXHRcdFx0XHRcdGRlcHRoMiwgbm9kZTJJbmRleEJ5dGVPZmZzZXQgKyBub2RlMkluZGV4MzIsXG5cdFx0XHRcdFx0ZGVwdGgxLCBub2RlMUluZGV4Qnl0ZU9mZnNldCArIG5vZGUxSW5kZXgzMixcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZXN1bHQgPSBpbnRlcnNlY3RzUmFuZ2VzRnVuYyhcblx0XHRcdFx0XHRPRkZTRVQoIG5vZGUxSW5kZXgzMiwgdWludDMyQXJyYXkxICksIENPVU5UKCBub2RlMUluZGV4MzIgKiAyLCB1aW50MTZBcnJheTEgKSxcblx0XHRcdFx0XHRPRkZTRVQoIG5vZGUySW5kZXgzMiwgdWludDMyQXJyYXkyICksIENPVU5UKCBub2RlMkluZGV4MzIgKiAyLCB1aW50MTZBcnJheTIgKSxcblx0XHRcdFx0XHRkZXB0aDEsIG5vZGUxSW5kZXhCeXRlT2Zmc2V0ICsgbm9kZTFJbmRleDMyLFxuXHRcdFx0XHRcdGRlcHRoMiwgbm9kZTJJbmRleEJ5dGVPZmZzZXQgKyBub2RlMkluZGV4MzIsXG5cdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIGlzTGVhZjIgKSB7XG5cblx0XHRcdC8vIFNXQVBcblx0XHRcdC8vIElmIHdlJ3ZlIHRyYXZlcnNlZCB0byB0aGUgbGVhZiBub2RlIG9uIHRoZSBvdGhlciBidmggdGhlbiB3ZSBuZWVkIHRvIHN3YXAgb3ZlclxuXHRcdFx0Ly8gdG8gdHJhdmVyc2UgZG93biB0aGUgZmlyc3Qgb25lXG5cblx0XHRcdC8vIGdldCB0aGUgbmV3IGJveCB0byB1c2Vcblx0XHRcdGNvbnN0IG5ld0JveCA9IF9ib3hQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggbm9kZTJJbmRleDMyICksIGZsb2F0MzJBcnJheTIsIG5ld0JveCApO1xuXHRcdFx0bmV3Qm94LmFwcGx5TWF0cml4NCggbWF0cml4MnRvMSApO1xuXG5cdFx0XHQvLyBnZXQgdGhlIGNoaWxkIGJvdW5kcyB0byBjaGVjayBiZWZvcmUgdHJhdmVyc2FsXG5cdFx0XHRjb25zdCBjbDEgPSBMRUZUX05PREUoIG5vZGUxSW5kZXgzMiApO1xuXHRcdFx0Y29uc3QgY3IxID0gUklHSFRfTk9ERSggbm9kZTFJbmRleDMyLCB1aW50MzJBcnJheTEgKTtcblx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGNsMSApLCBmbG9hdDMyQXJyYXkxLCBfbGVmdEJveDEgKTtcblx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGNyMSApLCBmbG9hdDMyQXJyYXkxLCBfcmlnaHRCb3gxICk7XG5cblx0XHRcdC8vIHByZWNvbXB1dGUgdGhlIGludGVyc2VjdGlvbnMgb3RoZXJ3aXNlIHRoZSBnbG9iYWwgYm94ZXMgd2lsbCBiZSBtb2RpZmllZCBkdXJpbmcgdHJhdmVyc2FsXG5cdFx0XHRjb25zdCBpbnRlcnNlY3RDbDEgPSBuZXdCb3guaW50ZXJzZWN0c0JveCggX2xlZnRCb3gxICk7XG5cdFx0XHRjb25zdCBpbnRlcnNlY3RDcjEgPSBuZXdCb3guaW50ZXJzZWN0c0JveCggX3JpZ2h0Qm94MSApO1xuXHRcdFx0cmVzdWx0ID0gKFxuXHRcdFx0XHRpbnRlcnNlY3RDbDEgJiYgX3RyYXZlcnNlKFxuXHRcdFx0XHRcdG5vZGUySW5kZXgzMiwgY2wxLCBtYXRyaXgxdG8yLCBtYXRyaXgydG8xLCBpbnRlcnNlY3RzUmFuZ2VzRnVuYyxcblx0XHRcdFx0XHRub2RlMkluZGV4Qnl0ZU9mZnNldCwgbm9kZTFJbmRleEJ5dGVPZmZzZXQsIGRlcHRoMiwgZGVwdGgxICsgMSxcblx0XHRcdFx0XHRuZXdCb3gsICEgcmV2ZXJzZWQsXG5cdFx0XHRcdClcblx0XHRcdCkgfHwgKFxuXHRcdFx0XHRpbnRlcnNlY3RDcjEgJiYgX3RyYXZlcnNlKFxuXHRcdFx0XHRcdG5vZGUySW5kZXgzMiwgY3IxLCBtYXRyaXgxdG8yLCBtYXRyaXgydG8xLCBpbnRlcnNlY3RzUmFuZ2VzRnVuYyxcblx0XHRcdFx0XHRub2RlMkluZGV4Qnl0ZU9mZnNldCwgbm9kZTFJbmRleEJ5dGVPZmZzZXQsIGRlcHRoMiwgZGVwdGgxICsgMSxcblx0XHRcdFx0XHRuZXdCb3gsICEgcmV2ZXJzZWQsXG5cdFx0XHRcdClcblx0XHRcdCk7XG5cblx0XHRcdF9ib3hQb29sLnJlbGVhc2VQcmltaXRpdmUoIG5ld0JveCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gaWYgbmVpdGhlciBhcmUgbGVhdmVzIHRoZW4gd2Ugc2hvdWxkIHN3YXAgaWYgb25lIG9mIHRoZSBjaGlsZHJlbiBkb2VzIG5vdFxuXHRcdFx0Ly8gaW50ZXJzZWN0IHdpdGggdGhlIGN1cnJlbnQgYm91bmRzXG5cblx0XHRcdC8vIGdldCB0aGUgY2hpbGQgYm91bmRzIHRvIGNoZWNrXG5cdFx0XHRjb25zdCBjbDIgPSBMRUZUX05PREUoIG5vZGUySW5kZXgzMiApO1xuXHRcdFx0Y29uc3QgY3IyID0gUklHSFRfTk9ERSggbm9kZTJJbmRleDMyLCB1aW50MzJBcnJheTIgKTtcblx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGNsMiApLCBmbG9hdDMyQXJyYXkyLCBfbGVmdEJveDIgKTtcblx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGNyMiApLCBmbG9hdDMyQXJyYXkyLCBfcmlnaHRCb3gyICk7XG5cblx0XHRcdGNvbnN0IGxlZnRJbnRlcnNlY3RzID0gY3VyckJveC5pbnRlcnNlY3RzQm94KCBfbGVmdEJveDIgKTtcblx0XHRcdGNvbnN0IHJpZ2h0SW50ZXJzZWN0cyA9IGN1cnJCb3guaW50ZXJzZWN0c0JveCggX3JpZ2h0Qm94MiApO1xuXHRcdFx0aWYgKCBsZWZ0SW50ZXJzZWN0cyAmJiByaWdodEludGVyc2VjdHMgKSB7XG5cblx0XHRcdFx0Ly8gY29udGludWUgdG8gdHJhdmVyc2UgYm90aCBjaGlsZHJlbiBpZiB0aGV5IGJvdGggaW50ZXJzZWN0XG5cdFx0XHRcdHJlc3VsdCA9IF90cmF2ZXJzZShcblx0XHRcdFx0XHRub2RlMUluZGV4MzIsIGNsMiwgbWF0cml4MnRvMSwgbWF0cml4MXRvMiwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0bm9kZTFJbmRleEJ5dGVPZmZzZXQsIG5vZGUySW5kZXhCeXRlT2Zmc2V0LCBkZXB0aDEsIGRlcHRoMiArIDEsXG5cdFx0XHRcdFx0Y3VyckJveCwgcmV2ZXJzZWQsXG5cdFx0XHRcdCkgfHwgX3RyYXZlcnNlKFxuXHRcdFx0XHRcdG5vZGUxSW5kZXgzMiwgY3IyLCBtYXRyaXgydG8xLCBtYXRyaXgxdG8yLCBpbnRlcnNlY3RzUmFuZ2VzRnVuYyxcblx0XHRcdFx0XHRub2RlMUluZGV4Qnl0ZU9mZnNldCwgbm9kZTJJbmRleEJ5dGVPZmZzZXQsIGRlcHRoMSwgZGVwdGgyICsgMSxcblx0XHRcdFx0XHRjdXJyQm94LCByZXZlcnNlZCxcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIGlmICggbGVmdEludGVyc2VjdHMgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0xlYWYxICkge1xuXG5cdFx0XHRcdFx0Ly8gaWYgdGhlIGN1cnJlbnQgYm94IGlzIGEgbGVhZiB0aGVuIGp1c3QgY29udGludWVcblx0XHRcdFx0XHRyZXN1bHQgPSBfdHJhdmVyc2UoXG5cdFx0XHRcdFx0XHRub2RlMUluZGV4MzIsIGNsMiwgbWF0cml4MnRvMSwgbWF0cml4MXRvMiwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0XHRub2RlMUluZGV4Qnl0ZU9mZnNldCwgbm9kZTJJbmRleEJ5dGVPZmZzZXQsIGRlcHRoMSwgZGVwdGgyICsgMSxcblx0XHRcdFx0XHRcdGN1cnJCb3gsIHJldmVyc2VkLFxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIFNXQVBcblx0XHRcdFx0XHQvLyBpZiBvbmx5IG9uZSBib3ggaW50ZXJzZWN0cyB0aGVuIHdlIGhhdmUgdG8gc3dhcCB0byB0aGUgb3RoZXIgYnZoIHRvIGNvbnRpbnVlXG5cdFx0XHRcdFx0Y29uc3QgbmV3Qm94ID0gX2JveFBvb2wuZ2V0UHJpbWl0aXZlKCk7XG5cdFx0XHRcdFx0bmV3Qm94LmNvcHkoIF9sZWZ0Qm94MiApLmFwcGx5TWF0cml4NCggbWF0cml4MnRvMSApO1xuXG5cdFx0XHRcdFx0Y29uc3QgY2wxID0gTEVGVF9OT0RFKCBub2RlMUluZGV4MzIgKTtcblx0XHRcdFx0XHRjb25zdCBjcjEgPSBSSUdIVF9OT0RFKCBub2RlMUluZGV4MzIsIHVpbnQzMkFycmF5MSApO1xuXHRcdFx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGNsMSApLCBmbG9hdDMyQXJyYXkxLCBfbGVmdEJveDEgKTtcblx0XHRcdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjcjEgKSwgZmxvYXQzMkFycmF5MSwgX3JpZ2h0Qm94MSApO1xuXG5cdFx0XHRcdFx0Ly8gcHJlY29tcHV0ZSB0aGUgaW50ZXJzZWN0aW9ucyBvdGhlcndpc2UgdGhlIGdsb2JhbCBib3hlcyB3aWxsIGJlIG1vZGlmaWVkIGR1cmluZyB0cmF2ZXJzYWxcblx0XHRcdFx0XHRjb25zdCBpbnRlcnNlY3RDbDEgPSBuZXdCb3guaW50ZXJzZWN0c0JveCggX2xlZnRCb3gxICk7XG5cdFx0XHRcdFx0Y29uc3QgaW50ZXJzZWN0Q3IxID0gbmV3Qm94LmludGVyc2VjdHNCb3goIF9yaWdodEJveDEgKTtcblx0XHRcdFx0XHRyZXN1bHQgPSAoXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RDbDEgJiYgX3RyYXZlcnNlKFxuXHRcdFx0XHRcdFx0XHRjbDIsIGNsMSwgbWF0cml4MXRvMiwgbWF0cml4MnRvMSwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0XHRcdG5vZGUySW5kZXhCeXRlT2Zmc2V0LCBub2RlMUluZGV4Qnl0ZU9mZnNldCwgZGVwdGgyLCBkZXB0aDEgKyAxLFxuXHRcdFx0XHRcdFx0XHRuZXdCb3gsICEgcmV2ZXJzZWQsXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KSB8fCAoXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RDcjEgJiYgX3RyYXZlcnNlKFxuXHRcdFx0XHRcdFx0XHRjbDIsIGNyMSwgbWF0cml4MXRvMiwgbWF0cml4MnRvMSwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0XHRcdG5vZGUySW5kZXhCeXRlT2Zmc2V0LCBub2RlMUluZGV4Qnl0ZU9mZnNldCwgZGVwdGgyLCBkZXB0aDEgKyAxLFxuXHRcdFx0XHRcdFx0XHRuZXdCb3gsICEgcmV2ZXJzZWQsXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdF9ib3hQb29sLnJlbGVhc2VQcmltaXRpdmUoIG5ld0JveCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIGlmICggcmlnaHRJbnRlcnNlY3RzICkge1xuXG5cdFx0XHRcdGlmICggaXNMZWFmMSApIHtcblxuXHRcdFx0XHRcdC8vIGlmIHRoZSBjdXJyZW50IGJveCBpcyBhIGxlYWYgdGhlbiBqdXN0IGNvbnRpbnVlXG5cdFx0XHRcdFx0cmVzdWx0ID0gX3RyYXZlcnNlKFxuXHRcdFx0XHRcdFx0bm9kZTFJbmRleDMyLCBjcjIsIG1hdHJpeDJ0bzEsIG1hdHJpeDF0bzIsIGludGVyc2VjdHNSYW5nZXNGdW5jLFxuXHRcdFx0XHRcdFx0bm9kZTFJbmRleEJ5dGVPZmZzZXQsIG5vZGUySW5kZXhCeXRlT2Zmc2V0LCBkZXB0aDEsIGRlcHRoMiArIDEsXG5cdFx0XHRcdFx0XHRjdXJyQm94LCByZXZlcnNlZCxcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBTV0FQXG5cdFx0XHRcdFx0Ly8gaWYgb25seSBvbmUgYm94IGludGVyc2VjdHMgdGhlbiB3ZSBoYXZlIHRvIHN3YXAgdG8gdGhlIG90aGVyIGJ2aCB0byBjb250aW51ZVxuXHRcdFx0XHRcdGNvbnN0IG5ld0JveCA9IF9ib3hQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdFx0XHRcdG5ld0JveC5jb3B5KCBfcmlnaHRCb3gyICkuYXBwbHlNYXRyaXg0KCBtYXRyaXgydG8xICk7XG5cblx0XHRcdFx0XHRjb25zdCBjbDEgPSBMRUZUX05PREUoIG5vZGUxSW5kZXgzMiApO1xuXHRcdFx0XHRcdGNvbnN0IGNyMSA9IFJJR0hUX05PREUoIG5vZGUxSW5kZXgzMiwgdWludDMyQXJyYXkxICk7XG5cdFx0XHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggY2wxICksIGZsb2F0MzJBcnJheTEsIF9sZWZ0Qm94MSApO1xuXHRcdFx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGNyMSApLCBmbG9hdDMyQXJyYXkxLCBfcmlnaHRCb3gxICk7XG5cblx0XHRcdFx0XHQvLyBwcmVjb21wdXRlIHRoZSBpbnRlcnNlY3Rpb25zIG90aGVyd2lzZSB0aGUgZ2xvYmFsIGJveGVzIHdpbGwgYmUgbW9kaWZpZWQgZHVyaW5nIHRyYXZlcnNhbFxuXHRcdFx0XHRcdGNvbnN0IGludGVyc2VjdENsMSA9IG5ld0JveC5pbnRlcnNlY3RzQm94KCBfbGVmdEJveDEgKTtcblx0XHRcdFx0XHRjb25zdCBpbnRlcnNlY3RDcjEgPSBuZXdCb3guaW50ZXJzZWN0c0JveCggX3JpZ2h0Qm94MSApO1xuXHRcdFx0XHRcdHJlc3VsdCA9IChcblx0XHRcdFx0XHRcdGludGVyc2VjdENsMSAmJiBfdHJhdmVyc2UoXG5cdFx0XHRcdFx0XHRcdGNyMiwgY2wxLCBtYXRyaXgxdG8yLCBtYXRyaXgydG8xLCBpbnRlcnNlY3RzUmFuZ2VzRnVuYyxcblx0XHRcdFx0XHRcdFx0bm9kZTJJbmRleEJ5dGVPZmZzZXQsIG5vZGUxSW5kZXhCeXRlT2Zmc2V0LCBkZXB0aDIsIGRlcHRoMSArIDEsXG5cdFx0XHRcdFx0XHRcdG5ld0JveCwgISByZXZlcnNlZCxcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpIHx8IChcblx0XHRcdFx0XHRcdGludGVyc2VjdENyMSAmJiBfdHJhdmVyc2UoXG5cdFx0XHRcdFx0XHRcdGNyMiwgY3IxLCBtYXRyaXgxdG8yLCBtYXRyaXgydG8xLCBpbnRlcnNlY3RzUmFuZ2VzRnVuYyxcblx0XHRcdFx0XHRcdFx0bm9kZTJJbmRleEJ5dGVPZmZzZXQsIG5vZGUxSW5kZXhCeXRlT2Zmc2V0LCBkZXB0aDIsIGRlcHRoMSArIDEsXG5cdFx0XHRcdFx0XHRcdG5ld0JveCwgISByZXZlcnNlZCxcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0X2JveFBvb2wucmVsZWFzZVByaW1pdGl2ZSggbmV3Qm94ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxuXHRjb25zdCBvYmIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE9yaWVudGVkQm94KCk7XG5cdGNvbnN0IHRlbXBCb3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLkJveDMoKTtcblx0Y29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuXHRcdHN0cmF0ZWd5OiBDRU5URVIsXG5cdFx0bWF4RGVwdGg6IDQwLFxuXHRcdG1heExlYWZUcmlzOiAxMCxcblx0XHR1c2VTaGFyZWRBcnJheUJ1ZmZlcjogZmFsc2UsXG5cdFx0c2V0Qm91bmRpbmdCb3g6IHRydWUsXG5cdFx0b25Qcm9ncmVzczogbnVsbCxcblx0XHRpbmRpcmVjdDogZmFsc2UsXG5cdFx0dmVyYm9zZTogdHJ1ZSxcblx0XHRyYW5nZTogbnVsbFxuXHR9O1xuXG5cdGNsYXNzIE1lc2hCVkgge1xuXG5cdFx0c3RhdGljIHNlcmlhbGl6ZSggYnZoLCBvcHRpb25zID0ge30gKSB7XG5cblx0XHRcdG9wdGlvbnMgPSB7XG5cdFx0XHRcdGNsb25lQnVmZmVyczogdHJ1ZSxcblx0XHRcdFx0Li4ub3B0aW9ucyxcblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRcdFx0Y29uc3Qgcm9vdERhdGEgPSBidmguX3Jvb3RzO1xuXHRcdFx0Y29uc3QgaW5kaXJlY3RCdWZmZXIgPSBidmguX2luZGlyZWN0QnVmZmVyO1xuXHRcdFx0Y29uc3QgaW5kZXhBdHRyaWJ1dGUgPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuXHRcdFx0bGV0IHJlc3VsdDtcblx0XHRcdGlmICggb3B0aW9ucy5jbG9uZUJ1ZmZlcnMgKSB7XG5cblx0XHRcdFx0cmVzdWx0ID0ge1xuXHRcdFx0XHRcdHJvb3RzOiByb290RGF0YS5tYXAoIHJvb3QgPT4gcm9vdC5zbGljZSgpICksXG5cdFx0XHRcdFx0aW5kZXg6IGluZGV4QXR0cmlidXRlID8gaW5kZXhBdHRyaWJ1dGUuYXJyYXkuc2xpY2UoKSA6IG51bGwsXG5cdFx0XHRcdFx0aW5kaXJlY3RCdWZmZXI6IGluZGlyZWN0QnVmZmVyID8gaW5kaXJlY3RCdWZmZXIuc2xpY2UoKSA6IG51bGwsXG5cdFx0XHRcdH07XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmVzdWx0ID0ge1xuXHRcdFx0XHRcdHJvb3RzOiByb290RGF0YSxcblx0XHRcdFx0XHRpbmRleDogaW5kZXhBdHRyaWJ1dGUgPyBpbmRleEF0dHJpYnV0ZS5hcnJheSA6IG51bGwsXG5cdFx0XHRcdFx0aW5kaXJlY3RCdWZmZXI6IGluZGlyZWN0QnVmZmVyLFxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9XG5cblx0XHRzdGF0aWMgZGVzZXJpYWxpemUoIGRhdGEsIGdlb21ldHJ5LCBvcHRpb25zID0ge30gKSB7XG5cblx0XHRcdG9wdGlvbnMgPSB7XG5cdFx0XHRcdHNldEluZGV4OiB0cnVlLFxuXHRcdFx0XHRpbmRpcmVjdDogQm9vbGVhbiggZGF0YS5pbmRpcmVjdEJ1ZmZlciApLFxuXHRcdFx0XHQuLi5vcHRpb25zLFxuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3QgeyBpbmRleCwgcm9vdHMsIGluZGlyZWN0QnVmZmVyIH0gPSBkYXRhO1xuXHRcdFx0Y29uc3QgYnZoID0gbmV3IE1lc2hCVkgoIGdlb21ldHJ5LCB7IC4uLm9wdGlvbnMsIFsgU0tJUF9HRU5FUkFUSU9OIF06IHRydWUgfSApO1xuXHRcdFx0YnZoLl9yb290cyA9IHJvb3RzO1xuXHRcdFx0YnZoLl9pbmRpcmVjdEJ1ZmZlciA9IGluZGlyZWN0QnVmZmVyIHx8IG51bGw7XG5cblx0XHRcdGlmICggb3B0aW9ucy5zZXRJbmRleCApIHtcblxuXHRcdFx0XHRjb25zdCBpbmRleEF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG5cdFx0XHRcdGlmICggaW5kZXhBdHRyaWJ1dGUgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBuZXdJbmRleCA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGRhdGEuaW5kZXgsIDEsIGZhbHNlICk7XG5cdFx0XHRcdFx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ld0luZGV4ICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggaW5kZXhBdHRyaWJ1dGUuYXJyYXkgIT09IGluZGV4ICkge1xuXG5cdFx0XHRcdFx0aW5kZXhBdHRyaWJ1dGUuYXJyYXkuc2V0KCBpbmRleCApO1xuXHRcdFx0XHRcdGluZGV4QXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJ2aDtcblxuXHRcdH1cblxuXHRcdGdldCBpbmRpcmVjdCgpIHtcblxuXHRcdFx0cmV0dXJuICEgISB0aGlzLl9pbmRpcmVjdEJ1ZmZlcjtcblxuXHRcdH1cblxuXHRcdGNvbnN0cnVjdG9yKCBnZW9tZXRyeSwgb3B0aW9ucyA9IHt9ICkge1xuXG5cdFx0XHRpZiAoICEgZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdNZXNoQlZIOiBPbmx5IEJ1ZmZlckdlb21ldHJpZXMgYXJlIHN1cHBvcnRlZC4nICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGdlb21ldHJ5LmluZGV4ICYmIGdlb21ldHJ5LmluZGV4LmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnTWVzaEJWSDogSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhlIGluZGV4IGF0dHJpYnV0ZS4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZGVmYXVsdCBvcHRpb25zXG5cdFx0XHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbigge1xuXG5cdFx0XHRcdC4uLkRFRkFVTFRfT1BUSU9OUyxcblxuXHRcdFx0XHQvLyB1bmRvY3VtZW50ZWQgb3B0aW9uc1xuXG5cdFx0XHRcdC8vIFdoZXRoZXIgdG8gc2tpcCBnZW5lcmF0aW5nIHRoZSB0cmVlLiBVc2VkIGZvciBkZXNlcmlhbGl6YXRpb24uXG5cdFx0XHRcdFsgU0tJUF9HRU5FUkFUSU9OIF06IGZhbHNlLFxuXG5cdFx0XHR9LCBvcHRpb25zICk7XG5cblx0XHRcdGlmICggb3B0aW9ucy51c2VTaGFyZWRBcnJheUJ1ZmZlciAmJiAhIGlzU2hhcmVkQXJyYXlCdWZmZXJTdXBwb3J0ZWQoKSApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdNZXNoQlZIOiBTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYXZhaWxhYmxlLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZXRhaW4gcmVmZXJlbmNlcyB0byB0aGUgZ2VvbWV0cnkgc28gd2UgY2FuIHVzZSB0aGVtIGl0IHdpdGhvdXQgaGF2aW5nIHRvXG5cdFx0XHQvLyB0YWtlIGEgZ2VvbWV0cnkgcmVmZXJlbmNlIGluIGV2ZXJ5IGZ1bmN0aW9uLlxuXHRcdFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuXHRcdFx0dGhpcy5fcm9vdHMgPSBudWxsO1xuXHRcdFx0dGhpcy5faW5kaXJlY3RCdWZmZXIgPSBudWxsO1xuXHRcdFx0aWYgKCAhIG9wdGlvbnNbIFNLSVBfR0VORVJBVElPTiBdICkge1xuXG5cdFx0XHRcdGJ1aWxkUGFja2VkVHJlZSggdGhpcywgb3B0aW9ucyApO1xuXG5cdFx0XHRcdGlmICggISBnZW9tZXRyeS5ib3VuZGluZ0JveCAmJiBvcHRpb25zLnNldEJvdW5kaW5nQm94ICkge1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnkuYm91bmRpbmdCb3ggPSB0aGlzLmdldEJvdW5kaW5nQm94KCBuZXcgVEhSRUUuQm94MygpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMucmVzb2x2ZVRyaWFuZ2xlSW5kZXggPSBvcHRpb25zLmluZGlyZWN0ID8gaSA9PiB0aGlzLl9pbmRpcmVjdEJ1ZmZlclsgaSBdIDogaSA9PiBpO1xuXG5cdFx0fVxuXG5cdFx0cmVmaXQoIG5vZGVJbmRpY2VzID0gbnVsbCApIHtcblxuXHRcdFx0Y29uc3QgcmVmaXRGdW5jID0gdGhpcy5pbmRpcmVjdCA/IHJlZml0X2luZGlyZWN0IDogcmVmaXQ7XG5cdFx0XHRyZXR1cm4gcmVmaXRGdW5jKCB0aGlzLCBub2RlSW5kaWNlcyApO1xuXG5cdFx0fVxuXG5cdFx0dHJhdmVyc2UoIGNhbGxiYWNrLCByb290SW5kZXggPSAwICkge1xuXG5cdFx0XHRjb25zdCBidWZmZXIgPSB0aGlzLl9yb290c1sgcm9vdEluZGV4IF07XG5cdFx0XHRjb25zdCB1aW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSggYnVmZmVyICk7XG5cdFx0XHRjb25zdCB1aW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheSggYnVmZmVyICk7XG5cdFx0XHRfdHJhdmVyc2UoIDAgKTtcblxuXHRcdFx0ZnVuY3Rpb24gX3RyYXZlcnNlKCBub2RlMzJJbmRleCwgZGVwdGggPSAwICkge1xuXG5cdFx0XHRcdGNvbnN0IG5vZGUxNkluZGV4ID0gbm9kZTMySW5kZXggKiAyO1xuXHRcdFx0XHRjb25zdCBpc0xlYWYgPSB1aW50MTZBcnJheVsgbm9kZTE2SW5kZXggKyAxNSBdID09PSBJU19MRUFGTk9ERV9GTEFHO1xuXHRcdFx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0XHRcdGNvbnN0IG9mZnNldCA9IHVpbnQzMkFycmF5WyBub2RlMzJJbmRleCArIDYgXTtcblx0XHRcdFx0XHRjb25zdCBjb3VudCA9IHVpbnQxNkFycmF5WyBub2RlMTZJbmRleCArIDE0IF07XG5cdFx0XHRcdFx0Y2FsbGJhY2soIGRlcHRoLCBpc0xlYWYsIG5ldyBGbG9hdDMyQXJyYXkoIGJ1ZmZlciwgbm9kZTMySW5kZXggKiA0LCA2ICksIG9mZnNldCwgY291bnQgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gVE9ETzogdXNlIG5vZGUgZnVuY3Rpb25zIGhlcmVcblx0XHRcdFx0XHRjb25zdCBsZWZ0ID0gbm9kZTMySW5kZXggKyBCWVRFU19QRVJfTk9ERSAvIDQ7XG5cdFx0XHRcdFx0Y29uc3QgcmlnaHQgPSB1aW50MzJBcnJheVsgbm9kZTMySW5kZXggKyA2IF07XG5cdFx0XHRcdFx0Y29uc3Qgc3BsaXRBeGlzID0gdWludDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNyBdO1xuXHRcdFx0XHRcdGNvbnN0IHN0b3BUcmF2ZXJzYWwgPSBjYWxsYmFjayggZGVwdGgsIGlzTGVhZiwgbmV3IEZsb2F0MzJBcnJheSggYnVmZmVyLCBub2RlMzJJbmRleCAqIDQsIDYgKSwgc3BsaXRBeGlzICk7XG5cblx0XHRcdFx0XHRpZiAoICEgc3RvcFRyYXZlcnNhbCApIHtcblxuXHRcdFx0XHRcdFx0X3RyYXZlcnNlKCBsZWZ0LCBkZXB0aCArIDEgKTtcblx0XHRcdFx0XHRcdF90cmF2ZXJzZSggcmlnaHQsIGRlcHRoICsgMSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0LyogQ29yZSBDYXN0IEZ1bmN0aW9ucyAqL1xuXHRcdHJheWNhc3QoIHJheSwgbWF0ZXJpYWxPclNpZGUgPSBUSFJFRS5Gcm9udFNpZGUsIG5lYXIgPSAwLCBmYXIgPSBJbmZpbml0eSApIHtcblxuXHRcdFx0Y29uc3Qgcm9vdHMgPSB0aGlzLl9yb290cztcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRcdGNvbnN0IGludGVyc2VjdHMgPSBbXTtcblx0XHRcdGNvbnN0IGlzTWF0ZXJpYWwgPSBtYXRlcmlhbE9yU2lkZS5pc01hdGVyaWFsO1xuXHRcdFx0Y29uc3QgaXNBcnJheU1hdGVyaWFsID0gQXJyYXkuaXNBcnJheSggbWF0ZXJpYWxPclNpZGUgKTtcblxuXHRcdFx0Y29uc3QgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXHRcdFx0Y29uc3Qgc2lkZSA9IGlzTWF0ZXJpYWwgPyBtYXRlcmlhbE9yU2lkZS5zaWRlIDogbWF0ZXJpYWxPclNpZGU7XG5cdFx0XHRjb25zdCByYXljYXN0RnVuYyA9IHRoaXMuaW5kaXJlY3QgPyByYXljYXN0X2luZGlyZWN0IDogcmF5Y2FzdDtcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHJvb3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgbWF0ZXJpYWxTaWRlID0gaXNBcnJheU1hdGVyaWFsID8gbWF0ZXJpYWxPclNpZGVbIGdyb3Vwc1sgaSBdLm1hdGVyaWFsSW5kZXggXS5zaWRlIDogc2lkZTtcblx0XHRcdFx0Y29uc3Qgc3RhcnRDb3VudCA9IGludGVyc2VjdHMubGVuZ3RoO1xuXG5cdFx0XHRcdHJheWNhc3RGdW5jKCB0aGlzLCBpLCBtYXRlcmlhbFNpZGUsIHJheSwgaW50ZXJzZWN0cywgbmVhciwgZmFyICk7XG5cblx0XHRcdFx0aWYgKCBpc0FycmF5TWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBtYXRlcmlhbEluZGV4ID0gZ3JvdXBzWyBpIF0ubWF0ZXJpYWxJbmRleDtcblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IHN0YXJ0Q291bnQsIGpsID0gaW50ZXJzZWN0cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0c1sgaiBdLmZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xuXG5cdFx0fVxuXG5cdFx0cmF5Y2FzdEZpcnN0KCByYXksIG1hdGVyaWFsT3JTaWRlID0gVEhSRUUuRnJvbnRTaWRlLCBuZWFyID0gMCwgZmFyID0gSW5maW5pdHkgKSB7XG5cblx0XHRcdGNvbnN0IHJvb3RzID0gdGhpcy5fcm9vdHM7XG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0XHRjb25zdCBpc01hdGVyaWFsID0gbWF0ZXJpYWxPclNpZGUuaXNNYXRlcmlhbDtcblx0XHRcdGNvbnN0IGlzQXJyYXlNYXRlcmlhbCA9IEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsT3JTaWRlICk7XG5cblx0XHRcdGxldCBjbG9zZXN0UmVzdWx0ID0gbnVsbDtcblxuXHRcdFx0Y29uc3QgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXHRcdFx0Y29uc3Qgc2lkZSA9IGlzTWF0ZXJpYWwgPyBtYXRlcmlhbE9yU2lkZS5zaWRlIDogbWF0ZXJpYWxPclNpZGU7XG5cdFx0XHRjb25zdCByYXljYXN0Rmlyc3RGdW5jID0gdGhpcy5pbmRpcmVjdCA/IHJheWNhc3RGaXJzdF9pbmRpcmVjdCA6IHJheWNhc3RGaXJzdDtcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHJvb3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgbWF0ZXJpYWxTaWRlID0gaXNBcnJheU1hdGVyaWFsID8gbWF0ZXJpYWxPclNpZGVbIGdyb3Vwc1sgaSBdLm1hdGVyaWFsSW5kZXggXS5zaWRlIDogc2lkZTtcblx0XHRcdFx0Y29uc3QgcmVzdWx0ID0gcmF5Y2FzdEZpcnN0RnVuYyggdGhpcywgaSwgbWF0ZXJpYWxTaWRlLCByYXksIG5lYXIsIGZhciApO1xuXHRcdFx0XHRpZiAoIHJlc3VsdCAhPSBudWxsICYmICggY2xvc2VzdFJlc3VsdCA9PSBudWxsIHx8IHJlc3VsdC5kaXN0YW5jZSA8IGNsb3Nlc3RSZXN1bHQuZGlzdGFuY2UgKSApIHtcblxuXHRcdFx0XHRcdGNsb3Nlc3RSZXN1bHQgPSByZXN1bHQ7XG5cdFx0XHRcdFx0aWYgKCBpc0FycmF5TWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRcdHJlc3VsdC5mYWNlLm1hdGVyaWFsSW5kZXggPSBncm91cHNbIGkgXS5tYXRlcmlhbEluZGV4O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2xvc2VzdFJlc3VsdDtcblxuXHRcdH1cblxuXHRcdGludGVyc2VjdHNHZW9tZXRyeSggb3RoZXJHZW9tZXRyeSwgZ2VvbVRvTWVzaCApIHtcblxuXHRcdFx0bGV0IHJlc3VsdCA9IGZhbHNlO1xuXHRcdFx0Y29uc3Qgcm9vdHMgPSB0aGlzLl9yb290cztcblx0XHRcdGNvbnN0IGludGVyc2VjdHNHZW9tZXRyeUZ1bmMgPSB0aGlzLmluZGlyZWN0ID8gaW50ZXJzZWN0c0dlb21ldHJ5X2luZGlyZWN0IDogaW50ZXJzZWN0c0dlb21ldHJ5O1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gcm9vdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRyZXN1bHQgPSBpbnRlcnNlY3RzR2VvbWV0cnlGdW5jKCB0aGlzLCBpLCBvdGhlckdlb21ldHJ5LCBnZW9tVG9NZXNoICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgKSB7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdH1cblxuXHRcdHNoYXBlY2FzdCggY2FsbGJhY2tzICkge1xuXG5cdFx0XHRjb25zdCB0cmlhbmdsZSA9IEV4dGVuZGVkVHJpYW5nbGVQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdFx0Y29uc3QgaXRlcmF0ZUZ1bmMgPSB0aGlzLmluZGlyZWN0ID8gaXRlcmF0ZU92ZXJUcmlhbmdsZXNfaW5kaXJlY3QgOiBpdGVyYXRlT3ZlclRyaWFuZ2xlcztcblx0XHRcdGxldCB7XG5cdFx0XHRcdGJvdW5kc1RyYXZlcnNlT3JkZXIsXG5cdFx0XHRcdGludGVyc2VjdHNCb3VuZHMsXG5cdFx0XHRcdGludGVyc2VjdHNSYW5nZSxcblx0XHRcdFx0aW50ZXJzZWN0c1RyaWFuZ2xlLFxuXHRcdFx0fSA9IGNhbGxiYWNrcztcblxuXHRcdFx0Ly8gd3JhcCB0aGUgaW50ZXJzZWN0c1JhbmdlIGZ1bmN0aW9uXG5cdFx0XHRpZiAoIGludGVyc2VjdHNSYW5nZSAmJiBpbnRlcnNlY3RzVHJpYW5nbGUgKSB7XG5cblx0XHRcdFx0Y29uc3Qgb3JpZ2luYWxJbnRlcnNlY3RzUmFuZ2UgPSBpbnRlcnNlY3RzUmFuZ2U7XG5cdFx0XHRcdGludGVyc2VjdHNSYW5nZSA9ICggb2Zmc2V0LCBjb3VudCwgY29udGFpbmVkLCBkZXB0aCwgbm9kZUluZGV4ICkgPT4ge1xuXG5cdFx0XHRcdFx0aWYgKCAhIG9yaWdpbmFsSW50ZXJzZWN0c1JhbmdlKCBvZmZzZXQsIGNvdW50LCBjb250YWluZWQsIGRlcHRoLCBub2RlSW5kZXggKSApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGl0ZXJhdGVGdW5jKCBvZmZzZXQsIGNvdW50LCB0aGlzLCBpbnRlcnNlY3RzVHJpYW5nbGUsIGNvbnRhaW5lZCwgZGVwdGgsIHRyaWFuZ2xlICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCAhIGludGVyc2VjdHNSYW5nZSApIHtcblxuXHRcdFx0XHRpZiAoIGludGVyc2VjdHNUcmlhbmdsZSApIHtcblxuXHRcdFx0XHRcdGludGVyc2VjdHNSYW5nZSA9ICggb2Zmc2V0LCBjb3VudCwgY29udGFpbmVkLCBkZXB0aCApID0+IHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGl0ZXJhdGVGdW5jKCBvZmZzZXQsIGNvdW50LCB0aGlzLCBpbnRlcnNlY3RzVHJpYW5nbGUsIGNvbnRhaW5lZCwgZGVwdGgsIHRyaWFuZ2xlICk7XG5cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2UgPSAoIG9mZnNldCwgY291bnQsIGNvbnRhaW5lZCApID0+IHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGNvbnRhaW5lZDtcblxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHJ1biBzaGFwZWNhc3Rcblx0XHRcdGxldCByZXN1bHQgPSBmYWxzZTtcblx0XHRcdGxldCBieXRlT2Zmc2V0ID0gMDtcblx0XHRcdGNvbnN0IHJvb3RzID0gdGhpcy5fcm9vdHM7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSByb290cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHJvb3QgPSByb290c1sgaSBdO1xuXHRcdFx0XHRyZXN1bHQgPSBzaGFwZWNhc3QoIHRoaXMsIGksIGludGVyc2VjdHNCb3VuZHMsIGludGVyc2VjdHNSYW5nZSwgYm91bmRzVHJhdmVyc2VPcmRlciwgYnl0ZU9mZnNldCApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJ5dGVPZmZzZXQgKz0gcm9vdC5ieXRlTGVuZ3RoO1xuXG5cdFx0XHR9XG5cblx0XHRcdEV4dGVuZGVkVHJpYW5nbGVQb29sLnJlbGVhc2VQcmltaXRpdmUoIHRyaWFuZ2xlICk7XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9XG5cblx0XHRidmhjYXN0KCBvdGhlckJ2aCwgbWF0cml4VG9Mb2NhbCwgY2FsbGJhY2tzICkge1xuXG5cdFx0XHRsZXQge1xuXHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2VzLFxuXHRcdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGVzLFxuXHRcdFx0fSA9IGNhbGxiYWNrcztcblxuXHRcdFx0Y29uc3QgdHJpYW5nbGUxID0gRXh0ZW5kZWRUcmlhbmdsZVBvb2wuZ2V0UHJpbWl0aXZlKCk7XG5cdFx0XHRjb25zdCBpbmRleEF0dHIxID0gdGhpcy5nZW9tZXRyeS5pbmRleDtcblx0XHRcdGNvbnN0IHBvc2l0aW9uQXR0cjEgPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRjb25zdCBhc3NpZ25UcmlhbmdsZTEgPSB0aGlzLmluZGlyZWN0ID9cblx0XHRcdFx0aTEgPT4ge1xuXG5cblx0XHRcdFx0XHRjb25zdCB0aSA9IHRoaXMucmVzb2x2ZVRyaWFuZ2xlSW5kZXgoIGkxICk7XG5cdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMSwgdGkgKiAzLCBpbmRleEF0dHIxLCBwb3NpdGlvbkF0dHIxICk7XG5cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGkxID0+IHtcblxuXHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZTEsIGkxICogMywgaW5kZXhBdHRyMSwgcG9zaXRpb25BdHRyMSApO1xuXG5cdFx0XHRcdH07XG5cblx0XHRcdGNvbnN0IHRyaWFuZ2xlMiA9IEV4dGVuZGVkVHJpYW5nbGVQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdFx0Y29uc3QgaW5kZXhBdHRyMiA9IG90aGVyQnZoLmdlb21ldHJ5LmluZGV4O1xuXHRcdFx0Y29uc3QgcG9zaXRpb25BdHRyMiA9IG90aGVyQnZoLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdFx0XHRjb25zdCBhc3NpZ25UcmlhbmdsZTIgPSBvdGhlckJ2aC5pbmRpcmVjdCA/XG5cdFx0XHRcdGkyID0+IHtcblxuXHRcdFx0XHRcdGNvbnN0IHRpMiA9IG90aGVyQnZoLnJlc29sdmVUcmlhbmdsZUluZGV4KCBpMiApO1xuXHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZTIsIHRpMiAqIDMsIGluZGV4QXR0cjIsIHBvc2l0aW9uQXR0cjIgKTtcblxuXHRcdFx0XHR9IDpcblx0XHRcdFx0aTIgPT4ge1xuXG5cdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgaTIgKiAzLCBpbmRleEF0dHIyLCBwb3NpdGlvbkF0dHIyICk7XG5cblx0XHRcdFx0fTtcblxuXHRcdFx0Ly8gZ2VuZXJhdGUgdHJpYW5nbGUgY2FsbGJhY2sgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIGludGVyc2VjdHNUcmlhbmdsZXMgKSB7XG5cblx0XHRcdFx0Y29uc3QgaXRlcmF0ZU92ZXJEb3VibGVUcmlhbmdsZXMgPSAoIG9mZnNldDEsIGNvdW50MSwgb2Zmc2V0MiwgY291bnQyLCBkZXB0aDEsIGluZGV4MSwgZGVwdGgyLCBpbmRleDIgKSA9PiB7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaTIgPSBvZmZzZXQyLCBsMiA9IG9mZnNldDIgKyBjb3VudDI7IGkyIDwgbDI7IGkyICsrICkge1xuXG5cdFx0XHRcdFx0XHRhc3NpZ25UcmlhbmdsZTIoIGkyICk7XG5cblx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5hLmFwcGx5TWF0cml4NCggbWF0cml4VG9Mb2NhbCApO1xuXHRcdFx0XHRcdFx0dHJpYW5nbGUyLmIuYXBwbHlNYXRyaXg0KCBtYXRyaXhUb0xvY2FsICk7XG5cdFx0XHRcdFx0XHR0cmlhbmdsZTIuYy5hcHBseU1hdHJpeDQoIG1hdHJpeFRvTG9jYWwgKTtcblx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdGZvciAoIGxldCBpMSA9IG9mZnNldDEsIGwxID0gb2Zmc2V0MSArIGNvdW50MTsgaTEgPCBsMTsgaTEgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0YXNzaWduVHJpYW5nbGUxKCBpMSApO1xuXG5cdFx0XHRcdFx0XHRcdHRyaWFuZ2xlMS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3RzVHJpYW5nbGVzKCB0cmlhbmdsZTEsIHRyaWFuZ2xlMiwgaTEsIGkyLCBkZXB0aDEsIGluZGV4MSwgZGVwdGgyLCBpbmRleDIgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYgKCBpbnRlcnNlY3RzUmFuZ2VzICkge1xuXG5cdFx0XHRcdFx0Y29uc3Qgb3JpZ2luYWxJbnRlcnNlY3RzUmFuZ2VzID0gaW50ZXJzZWN0c1Jhbmdlcztcblx0XHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2VzID0gZnVuY3Rpb24gKCBvZmZzZXQxLCBjb3VudDEsIG9mZnNldDIsIGNvdW50MiwgZGVwdGgxLCBpbmRleDEsIGRlcHRoMiwgaW5kZXgyICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoICEgb3JpZ2luYWxJbnRlcnNlY3RzUmFuZ2VzKCBvZmZzZXQxLCBjb3VudDEsIG9mZnNldDIsIGNvdW50MiwgZGVwdGgxLCBpbmRleDEsIGRlcHRoMiwgaW5kZXgyICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIGl0ZXJhdGVPdmVyRG91YmxlVHJpYW5nbGVzKCBvZmZzZXQxLCBjb3VudDEsIG9mZnNldDIsIGNvdW50MiwgZGVwdGgxLCBpbmRleDEsIGRlcHRoMiwgaW5kZXgyICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2VzID0gaXRlcmF0ZU92ZXJEb3VibGVUcmlhbmdsZXM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidmhjYXN0KCB0aGlzLCBvdGhlckJ2aCwgbWF0cml4VG9Mb2NhbCwgaW50ZXJzZWN0c1JhbmdlcyApO1xuXG5cdFx0fVxuXG5cblx0XHQvKiBEZXJpdmVkIENhc3QgRnVuY3Rpb25zICovXG5cdFx0aW50ZXJzZWN0c0JveCggYm94LCBib3hUb01lc2ggKSB7XG5cblx0XHRcdG9iYi5zZXQoIGJveC5taW4sIGJveC5tYXgsIGJveFRvTWVzaCApO1xuXHRcdFx0b2JiLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuc2hhcGVjYXN0KFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aW50ZXJzZWN0c0JvdW5kczogYm94ID0+IG9iYi5pbnRlcnNlY3RzQm94KCBib3ggKSxcblx0XHRcdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGU6IHRyaSA9PiBvYmIuaW50ZXJzZWN0c1RyaWFuZ2xlKCB0cmkgKVxuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXG5cdFx0fVxuXG5cdFx0aW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zaGFwZWNhc3QoXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzOiBib3ggPT4gc3BoZXJlLmludGVyc2VjdHNCb3goIGJveCApLFxuXHRcdFx0XHRcdGludGVyc2VjdHNUcmlhbmdsZTogdHJpID0+IHRyaS5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKVxuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXG5cdFx0fVxuXG5cdFx0Y2xvc2VzdFBvaW50VG9HZW9tZXRyeSggb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCwgdGFyZ2V0MSA9IHsgfSwgdGFyZ2V0MiA9IHsgfSwgbWluVGhyZXNob2xkID0gMCwgbWF4VGhyZXNob2xkID0gSW5maW5pdHkgKSB7XG5cblx0XHRcdGNvbnN0IGNsb3Nlc3RQb2ludFRvR2VvbWV0cnlGdW5jID0gdGhpcy5pbmRpcmVjdCA/IGNsb3Nlc3RQb2ludFRvR2VvbWV0cnlfaW5kaXJlY3QgOiBjbG9zZXN0UG9pbnRUb0dlb21ldHJ5O1xuXHRcdFx0cmV0dXJuIGNsb3Nlc3RQb2ludFRvR2VvbWV0cnlGdW5jKFxuXHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRvdGhlckdlb21ldHJ5LFxuXHRcdFx0XHRnZW9tZXRyeVRvQnZoLFxuXHRcdFx0XHR0YXJnZXQxLFxuXHRcdFx0XHR0YXJnZXQyLFxuXHRcdFx0XHRtaW5UaHJlc2hvbGQsXG5cdFx0XHRcdG1heFRocmVzaG9sZCxcblx0XHRcdCk7XG5cblx0XHR9XG5cblx0XHRjbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCwgdGFyZ2V0ID0geyB9LCBtaW5UaHJlc2hvbGQgPSAwLCBtYXhUaHJlc2hvbGQgPSBJbmZpbml0eSApIHtcblxuXHRcdFx0cmV0dXJuIGNsb3Nlc3RQb2ludFRvUG9pbnQoXG5cdFx0XHRcdHRoaXMsXG5cdFx0XHRcdHBvaW50LFxuXHRcdFx0XHR0YXJnZXQsXG5cdFx0XHRcdG1pblRocmVzaG9sZCxcblx0XHRcdFx0bWF4VGhyZXNob2xkLFxuXHRcdFx0KTtcblxuXHRcdH1cblxuXHRcdGdldEJvdW5kaW5nQm94KCB0YXJnZXQgKSB7XG5cblx0XHRcdHRhcmdldC5tYWtlRW1wdHkoKTtcblxuXHRcdFx0Y29uc3Qgcm9vdHMgPSB0aGlzLl9yb290cztcblx0XHRcdHJvb3RzLmZvckVhY2goIGJ1ZmZlciA9PiB7XG5cblx0XHRcdFx0YXJyYXlUb0JveCggMCwgbmV3IEZsb2F0MzJBcnJheSggYnVmZmVyICksIHRlbXBCb3ggKTtcblx0XHRcdFx0dGFyZ2V0LnVuaW9uKCB0ZW1wQm94ICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuIHRhcmdldDtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgYm91bmRpbmdCb3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLkJveDMoKTtcblx0Y29uc3QgbWF0cml4ID0gLyogQF9fUFVSRV9fICovIG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0Y2xhc3MgTWVzaEJWSFJvb3RIZWxwZXIgZXh0ZW5kcyBUSFJFRS5PYmplY3QzRCB7XG5cblx0XHRnZXQgaXNNZXNoKCkge1xuXG5cdFx0XHRyZXR1cm4gISB0aGlzLmRpc3BsYXlFZGdlcztcblxuXHRcdH1cblxuXHRcdGdldCBpc0xpbmVTZWdtZW50cygpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZGlzcGxheUVkZ2VzO1xuXG5cdFx0fVxuXG5cdFx0Z2V0IGlzTGluZSgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZGlzcGxheUVkZ2VzO1xuXG5cdFx0fVxuXG5cdFx0Z2V0VmVydGV4UG9zaXRpb24oIC4uLmFyZ3MgKSB7XG5cblx0XHRcdC8vIGltcGxlbWVudCB0aGlzIGZ1bmN0aW9uIHNvIGl0IHdvcmtzIHdpdGggQm94My5zZXRGcm9tT2JqZWN0XG5cdFx0XHRyZXR1cm4gVEhSRUUuTWVzaC5wcm90b3R5cGUuZ2V0VmVydGV4UG9zaXRpb24uY2FsbCggdGhpcywgLi4uYXJncyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3RydWN0b3IoIGJ2aCwgbWF0ZXJpYWwsIGRlcHRoID0gMTAsIGdyb3VwID0gMCApIHtcblxuXHRcdFx0c3VwZXIoKTtcblxuXHRcdFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXHRcdFx0dGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuXHRcdFx0dGhpcy5uYW1lID0gJ01lc2hCVkhSb290SGVscGVyJztcblx0XHRcdHRoaXMuZGVwdGggPSBkZXB0aDtcblx0XHRcdHRoaXMuZGlzcGxheVBhcmVudHMgPSBmYWxzZTtcblx0XHRcdHRoaXMuYnZoID0gYnZoO1xuXHRcdFx0dGhpcy5kaXNwbGF5RWRnZXMgPSB0cnVlO1xuXHRcdFx0dGhpcy5fZ3JvdXAgPSBncm91cDtcblxuXHRcdH1cblxuXHRcdHJheWNhc3QoKSB7fVxuXG5cdFx0dXBkYXRlKCkge1xuXG5cdFx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0XHRjb25zdCBib3VuZHNUcmVlID0gdGhpcy5idmg7XG5cdFx0XHRjb25zdCBncm91cCA9IHRoaXMuX2dyb3VwO1xuXHRcdFx0Z2VvbWV0cnkuZGlzcG9zZSgpO1xuXHRcdFx0dGhpcy52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHRpZiAoIGJvdW5kc1RyZWUgKSB7XG5cblx0XHRcdFx0Ly8gY291bnQgdGhlIG51bWJlciBvZiBib3VuZHMgcmVxdWlyZWRcblx0XHRcdFx0Y29uc3QgdGFyZ2V0RGVwdGggPSB0aGlzLmRlcHRoIC0gMTtcblx0XHRcdFx0Y29uc3QgZGlzcGxheVBhcmVudHMgPSB0aGlzLmRpc3BsYXlQYXJlbnRzO1xuXHRcdFx0XHRsZXQgYm91bmRzQ291bnQgPSAwO1xuXHRcdFx0XHRib3VuZHNUcmVlLnRyYXZlcnNlKCAoIGRlcHRoLCBpc0xlYWYgKSA9PiB7XG5cblx0XHRcdFx0XHRpZiAoIGRlcHRoID49IHRhcmdldERlcHRoIHx8IGlzTGVhZiApIHtcblxuXHRcdFx0XHRcdFx0Ym91bmRzQ291bnQgKys7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGRpc3BsYXlQYXJlbnRzICkge1xuXG5cdFx0XHRcdFx0XHRib3VuZHNDb3VudCArKztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9LCBncm91cCApO1xuXG5cdFx0XHRcdC8vIGZpbGwgaW4gdGhlIHBvc2l0aW9uIGJ1ZmZlciB3aXRoIHRoZSBib3VuZHMgY29ybmVyc1xuXHRcdFx0XHRsZXQgcG9zSW5kZXggPSAwO1xuXHRcdFx0XHRjb25zdCBwb3NpdGlvbkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggOCAqIDMgKiBib3VuZHNDb3VudCApO1xuXHRcdFx0XHRib3VuZHNUcmVlLnRyYXZlcnNlKCAoIGRlcHRoLCBpc0xlYWYsIGJvdW5kaW5nRGF0YSApID0+IHtcblxuXHRcdFx0XHRcdGNvbnN0IHRlcm1pbmF0ZSA9IGRlcHRoID49IHRhcmdldERlcHRoIHx8IGlzTGVhZjtcblx0XHRcdFx0XHRpZiAoIHRlcm1pbmF0ZSB8fCBkaXNwbGF5UGFyZW50cyApIHtcblxuXHRcdFx0XHRcdFx0YXJyYXlUb0JveCggMCwgYm91bmRpbmdEYXRhLCBib3VuZGluZ0JveCApO1xuXG5cdFx0XHRcdFx0XHRjb25zdCB7IG1pbiwgbWF4IH0gPSBib3VuZGluZ0JveDtcblx0XHRcdFx0XHRcdGZvciAoIGxldCB4ID0gLSAxOyB4IDw9IDE7IHggKz0gMiApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCB4VmFsID0geCA8IDAgPyBtaW4ueCA6IG1heC54O1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgeSA9IC0gMTsgeSA8PSAxOyB5ICs9IDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zdCB5VmFsID0geSA8IDAgPyBtaW4ueSA6IG1heC55O1xuXHRcdFx0XHRcdFx0XHRcdGZvciAoIGxldCB6ID0gLSAxOyB6IDw9IDE7IHogKz0gMiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgelZhbCA9IHogPCAwID8gbWluLnogOiBtYXguejtcblx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uQXJyYXlbIHBvc0luZGV4ICsgMCBdID0geFZhbDtcblx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uQXJyYXlbIHBvc0luZGV4ICsgMSBdID0geVZhbDtcblx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uQXJyYXlbIHBvc0luZGV4ICsgMiBdID0gelZhbDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0cG9zSW5kZXggKz0gMztcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIHRlcm1pbmF0ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9LCBncm91cCApO1xuXG5cdFx0XHRcdGxldCBpbmRleEFycmF5O1xuXHRcdFx0XHRsZXQgaW5kaWNlcztcblx0XHRcdFx0aWYgKCB0aGlzLmRpc3BsYXlFZGdlcyApIHtcblxuXHRcdFx0XHRcdC8vIGZpbGwgaW4gdGhlIGluZGV4IGJ1ZmZlciB0byBwb2ludCB0byB0aGUgY29ybmVyIHBvaW50c1xuXHRcdFx0XHRcdGluZGljZXMgPSBuZXcgVWludDhBcnJheSggW1xuXHRcdFx0XHRcdFx0Ly8geCBheGlzXG5cdFx0XHRcdFx0XHQwLCA0LFxuXHRcdFx0XHRcdFx0MSwgNSxcblx0XHRcdFx0XHRcdDIsIDYsXG5cdFx0XHRcdFx0XHQzLCA3LFxuXG5cdFx0XHRcdFx0XHQvLyB5IGF4aXNcblx0XHRcdFx0XHRcdDAsIDIsXG5cdFx0XHRcdFx0XHQxLCAzLFxuXHRcdFx0XHRcdFx0NCwgNixcblx0XHRcdFx0XHRcdDUsIDcsXG5cblx0XHRcdFx0XHRcdC8vIHogYXhpc1xuXHRcdFx0XHRcdFx0MCwgMSxcblx0XHRcdFx0XHRcdDIsIDMsXG5cdFx0XHRcdFx0XHQ0LCA1LFxuXHRcdFx0XHRcdFx0NiwgNyxcblx0XHRcdFx0XHRdICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGluZGljZXMgPSBuZXcgVWludDhBcnJheSggW1xuXG5cdFx0XHRcdFx0XHQvLyBYLSwgWCtcblx0XHRcdFx0XHRcdDAsIDEsIDIsXG5cdFx0XHRcdFx0XHQyLCAxLCAzLFxuXG5cdFx0XHRcdFx0XHQ0LCA2LCA1LFxuXHRcdFx0XHRcdFx0NiwgNywgNSxcblxuXHRcdFx0XHRcdFx0Ly8gWS0sIFkrXG5cdFx0XHRcdFx0XHQxLCA0LCA1LFxuXHRcdFx0XHRcdFx0MCwgNCwgMSxcblxuXHRcdFx0XHRcdFx0MiwgMywgNixcblx0XHRcdFx0XHRcdDMsIDcsIDYsXG5cblx0XHRcdFx0XHRcdC8vIFotLCBaK1xuXHRcdFx0XHRcdFx0MCwgMiwgNCxcblx0XHRcdFx0XHRcdDIsIDYsIDQsXG5cblx0XHRcdFx0XHRcdDEsIDUsIDMsXG5cdFx0XHRcdFx0XHQzLCA1LCA3LFxuXG5cdFx0XHRcdFx0XSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHBvc2l0aW9uQXJyYXkubGVuZ3RoID4gNjU1MzUgKSB7XG5cblx0XHRcdFx0XHRpbmRleEFycmF5ID0gbmV3IFVpbnQzMkFycmF5KCBpbmRpY2VzLmxlbmd0aCAqIGJvdW5kc0NvdW50ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGluZGV4QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoIGluZGljZXMubGVuZ3RoICogYm91bmRzQ291bnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgaW5kZXhMZW5ndGggPSBpbmRpY2VzLmxlbmd0aDtcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgYm91bmRzQ291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBwb3NPZmZzZXQgPSBpICogODtcblx0XHRcdFx0XHRjb25zdCBpbmRleE9mZnNldCA9IGkgKiBpbmRleExlbmd0aDtcblx0XHRcdFx0XHRmb3IgKCBsZXQgaiA9IDA7IGogPCBpbmRleExlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0aW5kZXhBcnJheVsgaW5kZXhPZmZzZXQgKyBqIF0gPSBwb3NPZmZzZXQgKyBpbmRpY2VzWyBqIF07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHVwZGF0ZSB0aGUgZ2VvbWV0cnlcblx0XHRcdFx0Z2VvbWV0cnkuc2V0SW5kZXgoXG5cdFx0XHRcdFx0bmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggaW5kZXhBcnJheSwgMSwgZmFsc2UgKSxcblx0XHRcdFx0KTtcblx0XHRcdFx0Z2VvbWV0cnkuc2V0QXR0cmlidXRlKFxuXHRcdFx0XHRcdCdwb3NpdGlvbicsXG5cdFx0XHRcdFx0bmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25BcnJheSwgMywgZmFsc2UgKSxcblx0XHRcdFx0KTtcblx0XHRcdFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBNZXNoQlZISGVscGVyIGV4dGVuZHMgVEhSRUUuR3JvdXAge1xuXG5cdFx0Z2V0IGNvbG9yKCkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5lZGdlTWF0ZXJpYWwuY29sb3I7XG5cblx0XHR9XG5cblx0XHRnZXQgb3BhY2l0eSgpIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZWRnZU1hdGVyaWFsLm9wYWNpdHk7XG5cblx0XHR9XG5cblx0XHRzZXQgb3BhY2l0eSggdiApIHtcblxuXHRcdFx0dGhpcy5lZGdlTWF0ZXJpYWwub3BhY2l0eSA9IHY7XG5cdFx0XHR0aGlzLm1lc2hNYXRlcmlhbC5vcGFjaXR5ID0gdjtcblxuXHRcdH1cblxuXHRcdGNvbnN0cnVjdG9yKCBtZXNoID0gbnVsbCwgYnZoID0gbnVsbCwgZGVwdGggPSAxMCApIHtcblxuXHRcdFx0Ly8gaGFuZGxlIGJ2aCwgZGVwdGggc2lnbmF0dXJlXG5cdFx0XHRpZiAoIG1lc2ggaW5zdGFuY2VvZiBNZXNoQlZIICkge1xuXG5cdFx0XHRcdGRlcHRoID0gYnZoIHx8IDEwO1xuXHRcdFx0XHRidmggPSBtZXNoO1xuXHRcdFx0XHRtZXNoID0gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBoYW5kbGUgbWVzaCwgZGVwdGggc2lnbmF0dXJlXG5cdFx0XHRpZiAoIHR5cGVvZiBidmggPT09ICdudW1iZXInICkge1xuXG5cdFx0XHRcdGRlcHRoID0gYnZoO1xuXHRcdFx0XHRidmggPSBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdHN1cGVyKCk7XG5cblx0XHRcdHRoaXMubmFtZSA9ICdNZXNoQlZISGVscGVyJztcblx0XHRcdHRoaXMuZGVwdGggPSBkZXB0aDtcblx0XHRcdHRoaXMubWVzaCA9IG1lc2g7XG5cdFx0XHR0aGlzLmJ2aCA9IGJ2aDtcblx0XHRcdHRoaXMuZGlzcGxheVBhcmVudHMgPSBmYWxzZTtcblx0XHRcdHRoaXMuZGlzcGxheUVkZ2VzID0gdHJ1ZTtcblx0XHRcdHRoaXMub2JqZWN0SW5kZXggPSAwO1xuXHRcdFx0dGhpcy5fcm9vdHMgPSBbXTtcblxuXHRcdFx0Y29uc3QgZWRnZU1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7XG5cdFx0XHRcdGNvbG9yOiAweDAwRkY4OCxcblx0XHRcdFx0dHJhbnNwYXJlbnQ6IHRydWUsXG5cdFx0XHRcdG9wYWNpdHk6IDAuMyxcblx0XHRcdFx0ZGVwdGhXcml0ZTogZmFsc2UsXG5cdFx0XHR9ICk7XG5cblx0XHRcdGNvbnN0IG1lc2hNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCgge1xuXHRcdFx0XHRjb2xvcjogMHgwMEZGODgsXG5cdFx0XHRcdHRyYW5zcGFyZW50OiB0cnVlLFxuXHRcdFx0XHRvcGFjaXR5OiAwLjMsXG5cdFx0XHRcdGRlcHRoV3JpdGU6IGZhbHNlLFxuXHRcdFx0fSApO1xuXG5cdFx0XHRtZXNoTWF0ZXJpYWwuY29sb3IgPSBlZGdlTWF0ZXJpYWwuY29sb3I7XG5cblx0XHRcdHRoaXMuZWRnZU1hdGVyaWFsID0gZWRnZU1hdGVyaWFsO1xuXHRcdFx0dGhpcy5tZXNoTWF0ZXJpYWwgPSBtZXNoTWF0ZXJpYWw7XG5cblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHR9XG5cblx0XHR1cGRhdGUoKSB7XG5cblx0XHRcdGNvbnN0IG1lc2ggPSB0aGlzLm1lc2g7XG5cdFx0XHRsZXQgYnZoID0gdGhpcy5idmggfHwgbWVzaC5nZW9tZXRyeS5ib3VuZHNUcmVlIHx8IG51bGw7XG5cdFx0XHRpZiAoIG1lc2guaXNCYXRjaGVkTWVzaCAmJiBtZXNoLmJvdW5kc1RyZWVzICYmICEgYnZoICkge1xuXG5cdFx0XHRcdC8vIGdldCB0aGUgYnZoIGZyb20gYSBiYXRjaGVkTWVzaCBpZiBub3QgcHJvdmlkZWRcblx0XHRcdFx0Ly8gVE9ETzogd2Ugc2hvdWxkIGhhdmUgYW4gb2ZmaWNpYWwgd2F5IHRvIGdldCB0aGUgZ2VvbWV0cnkgaW5kZXggY2xlYW5seVxuXHRcdFx0XHRjb25zdCBkcmF3SW5mbyA9IG1lc2guX2RyYXdJbmZvWyB0aGlzLm9iamVjdEluZGV4IF07XG5cdFx0XHRcdGlmICggZHJhd0luZm8gKSB7XG5cblx0XHRcdFx0XHRidmggPSBtZXNoLmJvdW5kc1RyZWVzWyBkcmF3SW5mby5nZW9tZXRyeUluZGV4IF0gfHwgYnZoO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0b3RhbFJvb3RzID0gYnZoID8gYnZoLl9yb290cy5sZW5ndGggOiAwO1xuXHRcdFx0d2hpbGUgKCB0aGlzLl9yb290cy5sZW5ndGggPiB0b3RhbFJvb3RzICkge1xuXG5cdFx0XHRcdGNvbnN0IHJvb3QgPSB0aGlzLl9yb290cy5wb3AoKTtcblx0XHRcdFx0cm9vdC5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdFx0XHRcdHRoaXMucmVtb3ZlKCByb290ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgdG90YWxSb290czsgaSArKyApIHtcblxuXHRcdFx0XHRjb25zdCB7IGRlcHRoLCBlZGdlTWF0ZXJpYWwsIG1lc2hNYXRlcmlhbCwgZGlzcGxheVBhcmVudHMsIGRpc3BsYXlFZGdlcyB9ID0gdGhpcztcblxuXHRcdFx0XHRpZiAoIGkgPj0gdGhpcy5fcm9vdHMubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Y29uc3Qgcm9vdCA9IG5ldyBNZXNoQlZIUm9vdEhlbHBlciggYnZoLCBlZGdlTWF0ZXJpYWwsIGRlcHRoLCBpICk7XG5cdFx0XHRcdFx0dGhpcy5hZGQoIHJvb3QgKTtcblx0XHRcdFx0XHR0aGlzLl9yb290cy5wdXNoKCByb290ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHJvb3QgPSB0aGlzLl9yb290c1sgaSBdO1xuXHRcdFx0XHRyb290LmJ2aCA9IGJ2aDtcblx0XHRcdFx0cm9vdC5kZXB0aCA9IGRlcHRoO1xuXHRcdFx0XHRyb290LmRpc3BsYXlQYXJlbnRzID0gZGlzcGxheVBhcmVudHM7XG5cdFx0XHRcdHJvb3QuZGlzcGxheUVkZ2VzID0gZGlzcGxheUVkZ2VzO1xuXHRcdFx0XHRyb290Lm1hdGVyaWFsID0gZGlzcGxheUVkZ2VzID8gZWRnZU1hdGVyaWFsIDogbWVzaE1hdGVyaWFsO1xuXHRcdFx0XHRyb290LnVwZGF0ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR1cGRhdGVNYXRyaXhXb3JsZCggLi4uYXJncyApIHtcblxuXHRcdFx0Y29uc3QgbWVzaCA9IHRoaXMubWVzaDtcblx0XHRcdGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG5cdFx0XHRpZiAoIG1lc2ggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0bWVzaC51cGRhdGVXb3JsZE1hdHJpeCggdHJ1ZSwgZmFsc2UgKTtcblxuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdHRoaXMubWF0cml4XG5cdFx0XHRcdFx0XHQuY29weSggcGFyZW50Lm1hdHJpeFdvcmxkIClcblx0XHRcdFx0XHRcdC5pbnZlcnQoKVxuXHRcdFx0XHRcdFx0Lm11bHRpcGx5KCBtZXNoLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRoaXMubWF0cml4XG5cdFx0XHRcdFx0XHQuY29weSggbWVzaC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBoYW5kbGUgYmF0Y2hlZCBhbmQgaW5zdGFuY2VkIG1lc2ggYnZoc1xuXHRcdFx0XHRpZiAoIG1lc2guaXNJbnN0YW5jZWRNZXNoIHx8IG1lc2guaXNCYXRjaGVkTWVzaCApIHtcblxuXHRcdFx0XHRcdG1lc2guZ2V0TWF0cml4QXQoIHRoaXMub2JqZWN0SW5kZXgsIG1hdHJpeCApO1xuXHRcdFx0XHRcdHRoaXMubWF0cml4Lm11bHRpcGx5KCBtYXRyaXggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5tYXRyaXguZGVjb21wb3NlKFxuXHRcdFx0XHRcdHRoaXMucG9zaXRpb24sXG5cdFx0XHRcdFx0dGhpcy5xdWF0ZXJuaW9uLFxuXHRcdFx0XHRcdHRoaXMuc2NhbGUsXG5cdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdFx0c3VwZXIudXBkYXRlTWF0cml4V29ybGQoIC4uLmFyZ3MgKTtcblxuXHRcdH1cblxuXHRcdGNvcHkoIHNvdXJjZSApIHtcblxuXHRcdFx0dGhpcy5kZXB0aCA9IHNvdXJjZS5kZXB0aDtcblx0XHRcdHRoaXMubWVzaCA9IHNvdXJjZS5tZXNoO1xuXHRcdFx0dGhpcy5idmggPSBzb3VyY2UuYnZoO1xuXHRcdFx0dGhpcy5vcGFjaXR5ID0gc291cmNlLm9wYWNpdHk7XG5cdFx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG5cdFx0fVxuXG5cdFx0Y2xvbmUoKSB7XG5cblx0XHRcdHJldHVybiBuZXcgTWVzaEJWSEhlbHBlciggdGhpcy5tZXNoLCB0aGlzLmJ2aCwgdGhpcy5kZXB0aCApO1xuXG5cdFx0fVxuXG5cdFx0ZGlzcG9zZSgpIHtcblxuXHRcdFx0dGhpcy5lZGdlTWF0ZXJpYWwuZGlzcG9zZSgpO1xuXHRcdFx0dGhpcy5tZXNoTWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdFx0XHRjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNoaWxkcmVuWyBpIF0uZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIE1lc2hCVkhWaXN1YWxpemVyIGV4dGVuZHMgTWVzaEJWSEhlbHBlciB7XG5cblx0XHRjb25zdHJ1Y3RvciggLi4uYXJncyApIHtcblxuXHRcdFx0c3VwZXIoIC4uLmFyZ3MgKTtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnTWVzaEJWSFZpc3VhbGl6ZXI6IE1lc2hCVkhWaXN1YWxpemVyIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBNZXNoQlZISGVscGVyLCBpbnN0ZWFkLicgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y29uc3QgX2JveDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLkJveDMoKTtcblx0Y29uc3QgX2JveDIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLkJveDMoKTtcblx0Y29uc3QgX3ZlYyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyNDgzMDIvaG93LXRvLWdldC10aGUtc2l6ZS1vZi1hLWphdmFzY3JpcHQtb2JqZWN0XG5cdGZ1bmN0aW9uIGdldFByaW1pdGl2ZVNpemUoIGVsICkge1xuXG5cdFx0c3dpdGNoICggdHlwZW9mIGVsICkge1xuXG5cdFx0XHRjYXNlICdudW1iZXInOlxuXHRcdFx0XHRyZXR1cm4gODtcblx0XHRcdGNhc2UgJ3N0cmluZyc6XG5cdFx0XHRcdHJldHVybiBlbC5sZW5ndGggKiAyO1xuXHRcdFx0Y2FzZSAnYm9vbGVhbic6XG5cdFx0XHRcdHJldHVybiA0O1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIDA7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGlzVHlwZWRBcnJheSggYXJyICkge1xuXG5cdFx0Y29uc3QgcmVnZXggPSAvKFVpbnR8SW50fEZsb2F0KSg4fDE2fDMyKUFycmF5Lztcblx0XHRyZXR1cm4gcmVnZXgudGVzdCggYXJyLmNvbnN0cnVjdG9yLm5hbWUgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Um9vdEV4dHJlbWVzKCBidmgsIGdyb3VwICkge1xuXG5cdFx0Y29uc3QgcmVzdWx0ID0ge1xuXHRcdFx0bm9kZUNvdW50OiAwLFxuXHRcdFx0bGVhZk5vZGVDb3VudDogMCxcblxuXHRcdFx0ZGVwdGg6IHtcblx0XHRcdFx0bWluOiBJbmZpbml0eSwgbWF4OiAtIEluZmluaXR5XG5cdFx0XHR9LFxuXHRcdFx0dHJpczoge1xuXHRcdFx0XHRtaW46IEluZmluaXR5LCBtYXg6IC0gSW5maW5pdHlcblx0XHRcdH0sXG5cdFx0XHRzcGxpdHM6IFsgMCwgMCwgMCBdLFxuXHRcdFx0c3VyZmFjZUFyZWFTY29yZTogMCxcblx0XHR9O1xuXG5cdFx0YnZoLnRyYXZlcnNlKCAoIGRlcHRoLCBpc0xlYWYsIGJvdW5kaW5nRGF0YSwgb2Zmc2V0T3JTcGxpdCwgY291bnQgKSA9PiB7XG5cblx0XHRcdGNvbnN0IGwwID0gYm91bmRpbmdEYXRhWyAwICsgMyBdIC0gYm91bmRpbmdEYXRhWyAwIF07XG5cdFx0XHRjb25zdCBsMSA9IGJvdW5kaW5nRGF0YVsgMSArIDMgXSAtIGJvdW5kaW5nRGF0YVsgMSBdO1xuXHRcdFx0Y29uc3QgbDIgPSBib3VuZGluZ0RhdGFbIDIgKyAzIF0gLSBib3VuZGluZ0RhdGFbIDIgXTtcblxuXHRcdFx0Y29uc3Qgc3VyZmFjZUFyZWEgPSAyICogKCBsMCAqIGwxICsgbDEgKiBsMiArIGwyICogbDAgKTtcblxuXHRcdFx0cmVzdWx0Lm5vZGVDb3VudCArKztcblx0XHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRcdHJlc3VsdC5sZWFmTm9kZUNvdW50ICsrO1xuXG5cdFx0XHRcdHJlc3VsdC5kZXB0aC5taW4gPSBNYXRoLm1pbiggZGVwdGgsIHJlc3VsdC5kZXB0aC5taW4gKTtcblx0XHRcdFx0cmVzdWx0LmRlcHRoLm1heCA9IE1hdGgubWF4KCBkZXB0aCwgcmVzdWx0LmRlcHRoLm1heCApO1xuXG5cdFx0XHRcdHJlc3VsdC50cmlzLm1pbiA9IE1hdGgubWluKCBjb3VudCwgcmVzdWx0LnRyaXMubWluICk7XG5cdFx0XHRcdHJlc3VsdC50cmlzLm1heCA9IE1hdGgubWF4KCBjb3VudCwgcmVzdWx0LnRyaXMubWF4ICk7XG5cblx0XHRcdFx0cmVzdWx0LnN1cmZhY2VBcmVhU2NvcmUgKz0gc3VyZmFjZUFyZWEgKiBUUklBTkdMRV9JTlRFUlNFQ1RfQ09TVCAqIGNvdW50O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJlc3VsdC5zcGxpdHNbIG9mZnNldE9yU3BsaXQgXSArKztcblxuXHRcdFx0XHRyZXN1bHQuc3VyZmFjZUFyZWFTY29yZSArPSBzdXJmYWNlQXJlYSAqIFRSQVZFUlNBTF9DT1NUO1xuXG5cdFx0XHR9XG5cblx0XHR9LCBncm91cCApO1xuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIG5vIGxlYWYgbm9kZXMgYmVjYXVzZSB0aGUgdHJlZSBoYXNuJ3QgZmluaXNoZWQgZ2VuZXJhdGluZyB5ZXQuXG5cdFx0aWYgKCByZXN1bHQudHJpcy5taW4gPT09IEluZmluaXR5ICkge1xuXG5cdFx0XHRyZXN1bHQudHJpcy5taW4gPSAwO1xuXHRcdFx0cmVzdWx0LnRyaXMubWF4ID0gMDtcblxuXHRcdH1cblxuXHRcdGlmICggcmVzdWx0LmRlcHRoLm1pbiA9PT0gSW5maW5pdHkgKSB7XG5cblx0XHRcdHJlc3VsdC5kZXB0aC5taW4gPSAwO1xuXHRcdFx0cmVzdWx0LmRlcHRoLm1heCA9IDA7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRCVkhFeHRyZW1lcyggYnZoICkge1xuXG5cdFx0cmV0dXJuIGJ2aC5fcm9vdHMubWFwKCAoIHJvb3QsIGkgKSA9PiBnZXRSb290RXh0cmVtZXMoIGJ2aCwgaSApICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGVzdGltYXRlTWVtb3J5SW5CeXRlcyggb2JqICkge1xuXG5cdFx0Y29uc3QgdHJhdmVyc2VkID0gbmV3IFNldCgpO1xuXHRcdGNvbnN0IHN0YWNrID0gWyBvYmogXTtcblx0XHRsZXQgYnl0ZXMgPSAwO1xuXG5cdFx0d2hpbGUgKCBzdGFjay5sZW5ndGggKSB7XG5cblx0XHRcdGNvbnN0IGN1cnIgPSBzdGFjay5wb3AoKTtcblx0XHRcdGlmICggdHJhdmVyc2VkLmhhcyggY3VyciApICkge1xuXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRyYXZlcnNlZC5hZGQoIGN1cnIgKTtcblxuXHRcdFx0Zm9yICggbGV0IGtleSBpbiBjdXJyICkge1xuXG5cdFx0XHRcdGlmICggISBPYmplY3QuaGFzT3duKCBjdXJyLCBrZXkgKSApIHtcblxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRieXRlcyArPSBnZXRQcmltaXRpdmVTaXplKCBrZXkgKTtcblxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IGN1cnJbIGtleSBdO1xuXHRcdFx0XHRpZiAoIHZhbHVlICYmICggdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgKSApIHtcblxuXHRcdFx0XHRcdGlmICggaXNUeXBlZEFycmF5KCB2YWx1ZSApICkge1xuXG5cdFx0XHRcdFx0XHRieXRlcyArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggaXNTaGFyZWRBcnJheUJ1ZmZlclN1cHBvcnRlZCgpICYmIHZhbHVlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIgKSB7XG5cblx0XHRcdFx0XHRcdGJ5dGVzICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICkge1xuXG5cdFx0XHRcdFx0XHRieXRlcyArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0c3RhY2sucHVzaCggdmFsdWUgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ynl0ZXMgKz0gZ2V0UHJpbWl0aXZlU2l6ZSggdmFsdWUgKTtcblxuXHRcdFx0XHR9XG5cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJ5dGVzO1xuXG5cdH1cblxuXHRmdW5jdGlvbiB2YWxpZGF0ZUJvdW5kcyggYnZoICkge1xuXG5cdFx0Y29uc3QgZ2VvbWV0cnkgPSBidmguZ2VvbWV0cnk7XG5cdFx0Y29uc3QgZGVwdGhTdGFjayA9IFtdO1xuXHRcdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0Y29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblx0XHRsZXQgcGFzc2VzID0gdHJ1ZTtcblxuXHRcdGJ2aC50cmF2ZXJzZSggKCBkZXB0aCwgaXNMZWFmLCBib3VuZGluZ0RhdGEsIG9mZnNldCwgY291bnQgKSA9PiB7XG5cblx0XHRcdGNvbnN0IGluZm8gPSB7XG5cdFx0XHRcdGRlcHRoLFxuXHRcdFx0XHRpc0xlYWYsXG5cdFx0XHRcdGJvdW5kaW5nRGF0YSxcblx0XHRcdFx0b2Zmc2V0LFxuXHRcdFx0XHRjb3VudCxcblx0XHRcdH07XG5cdFx0XHRkZXB0aFN0YWNrWyBkZXB0aCBdID0gaW5mbztcblxuXHRcdFx0YXJyYXlUb0JveCggMCwgYm91bmRpbmdEYXRhLCBfYm94MSApO1xuXHRcdFx0Y29uc3QgcGFyZW50ID0gZGVwdGhTdGFja1sgZGVwdGggLSAxIF07XG5cblx0XHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRcdC8vIGNoZWNrIHRyaWFuZ2xlc1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgbCA9IG9mZnNldCArIGNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHRyaUluZGV4ID0gYnZoLnJlc29sdmVUcmlhbmdsZUluZGV4KCBpICk7XG5cdFx0XHRcdFx0bGV0IGkwID0gMyAqIHRyaUluZGV4O1xuXHRcdFx0XHRcdGxldCBpMSA9IDMgKiB0cmlJbmRleCArIDE7XG5cdFx0XHRcdFx0bGV0IGkyID0gMyAqIHRyaUluZGV4ICsgMjtcblxuXHRcdFx0XHRcdGlmICggaW5kZXggKSB7XG5cblx0XHRcdFx0XHRcdGkwID0gaW5kZXguZ2V0WCggaTAgKTtcblx0XHRcdFx0XHRcdGkxID0gaW5kZXguZ2V0WCggaTEgKTtcblx0XHRcdFx0XHRcdGkyID0gaW5kZXguZ2V0WCggaTIgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxldCBpc0NvbnRhaW5lZDtcblxuXHRcdFx0XHRcdF92ZWMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGkwICk7XG5cdFx0XHRcdFx0aXNDb250YWluZWQgPSBfYm94MS5jb250YWluc1BvaW50KCBfdmVjICk7XG5cblx0XHRcdFx0XHRfdmVjLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpMSApO1xuXHRcdFx0XHRcdGlzQ29udGFpbmVkID0gaXNDb250YWluZWQgJiYgX2JveDEuY29udGFpbnNQb2ludCggX3ZlYyApO1xuXG5cdFx0XHRcdFx0X3ZlYy5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaTIgKTtcblx0XHRcdFx0XHRpc0NvbnRhaW5lZCA9IGlzQ29udGFpbmVkICYmIF9ib3gxLmNvbnRhaW5zUG9pbnQoIF92ZWMgKTtcblxuXHRcdFx0XHRcdGNvbnNvbGUuYXNzZXJ0KCBpc0NvbnRhaW5lZCwgJ0xlYWYgYm91bmRzIGRvZXMgbm90IGZ1bGx5IGNvbnRhaW4gdHJpYW5nbGUuJyApO1xuXHRcdFx0XHRcdHBhc3NlcyA9IHBhc3NlcyAmJiBpc0NvbnRhaW5lZDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gY2hlY2sgaWYgbXkgYm91bmRzIGZpdCBpbiBteSBwYXJlbnRzXG5cdFx0XHRcdGFycmF5VG9Cb3goIDAsIGJvdW5kaW5nRGF0YSwgX2JveDIgKTtcblxuXHRcdFx0XHRjb25zdCBpc0NvbnRhaW5lZCA9IF9ib3gyLmNvbnRhaW5zQm94KCBfYm94MSApO1xuXHRcdFx0XHRjb25zb2xlLmFzc2VydCggaXNDb250YWluZWQsICdQYXJlbnQgYm91bmRzIGRvZXMgbm90IGZ1bGx5IGNvbnRhaW4gY2hpbGQuJyApO1xuXHRcdFx0XHRwYXNzZXMgPSBwYXNzZXMgJiYgaXNDb250YWluZWQ7XG5cblx0XHRcdH1cblxuXHRcdH0gKTtcblxuXHRcdHJldHVybiBwYXNzZXM7XG5cblx0fVxuXG5cdC8vIFJldHVybnMgYSBzaW1wbGUsIGh1bWFuIHJlYWRhYmxlIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIEJWSC5cblx0ZnVuY3Rpb24gZ2V0SlNPTlN0cnVjdHVyZSggYnZoICkge1xuXG5cdFx0Y29uc3QgZGVwdGhTdGFjayA9IFtdO1xuXG5cdFx0YnZoLnRyYXZlcnNlKCAoIGRlcHRoLCBpc0xlYWYsIGJvdW5kaW5nRGF0YSwgb2Zmc2V0LCBjb3VudCApID0+IHtcblxuXHRcdFx0Y29uc3QgaW5mbyA9IHtcblx0XHRcdFx0Ym91bmRzOiBhcnJheVRvQm94KCAwLCBib3VuZGluZ0RhdGEsIG5ldyBUSFJFRS5Cb3gzKCkgKSxcblx0XHRcdH07XG5cblx0XHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRcdGluZm8uY291bnQgPSBjb3VudDtcblx0XHRcdFx0aW5mby5vZmZzZXQgPSBvZmZzZXQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aW5mby5sZWZ0ID0gbnVsbDtcblx0XHRcdFx0aW5mby5yaWdodCA9IG51bGw7XG5cblx0XHRcdH1cblxuXHRcdFx0ZGVwdGhTdGFja1sgZGVwdGggXSA9IGluZm87XG5cblx0XHRcdC8vIHRyYXZlcnNhbCBoaXRzIHRoZSBsZWZ0IHRoZW4gcmlnaHQgbm9kZVxuXHRcdFx0Y29uc3QgcGFyZW50ID0gZGVwdGhTdGFja1sgZGVwdGggLSAxIF07XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5sZWZ0ID09PSBudWxsICkge1xuXG5cdFx0XHRcdFx0cGFyZW50LmxlZnQgPSBpbmZvO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRwYXJlbnQucmlnaHQgPSBpbmZvO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSApO1xuXG5cdFx0cmV0dXJuIGRlcHRoU3RhY2tbIDAgXTtcblxuXHR9XG5cblx0Ly8gY29udmVydHMgdGhlIGdpdmVuIEJWSCByYXljYXN0IGludGVyc2VjdGlvbiB0byBhbGlnbiB3aXRoIHRoZSB0aHJlZS5qcyByYXljYXN0XG5cdC8vIHN0cnVjdHVyZSAoaW5jbHVkZSBvYmplY3QsIHdvcmxkIHNwYWNlIGRpc3RhbmNlIGFuZCBwb2ludCkuXG5cdGZ1bmN0aW9uIGNvbnZlcnRSYXljYXN0SW50ZXJzZWN0KCBoaXQsIG9iamVjdCwgcmF5Y2FzdGVyICkge1xuXG5cdFx0aWYgKCBoaXQgPT09IG51bGwgKSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdFx0aGl0LnBvaW50LmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cdFx0aGl0LmRpc3RhbmNlID0gaGl0LnBvaW50LmRpc3RhbmNlVG8oIHJheWNhc3Rlci5yYXkub3JpZ2luICk7XG5cdFx0aGl0Lm9iamVjdCA9IG9iamVjdDtcblxuXHRcdHJldHVybiBoaXQ7XG5cblx0fVxuXG5cdGNvbnN0IEJhdGNoZWRNZXNoID0gVEhSRUVfX25hbWVzcGFjZS5CYXRjaGVkTWVzaCB8fCBudWxsOyAvLyB0aGlzIGlzIG5lY2Vzc2FyeSB0byBub3QgYnJlYWsgdGhyZWUuanMgcjE1Ny1cblx0Y29uc3QgSVNfUkVWSVNJT05fMTY2ID0gcGFyc2VJbnQoIFRIUkVFLlJFVklTSU9OICkgPj0gMTY2O1xuXHRjb25zdCByYXkgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlJheSgpO1xuXHRjb25zdCBkaXJlY3Rpb24gPSAvKiBAX19QVVJFX18gKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgdG1wSW52ZXJzZU1hdHJpeCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRjb25zdCBvcmlnTWVzaFJheWNhc3RGdW5jID0gVEhSRUUuTWVzaC5wcm90b3R5cGUucmF5Y2FzdDtcblx0Y29uc3Qgb3JpZ0JhdGNoZWRSYXljYXN0RnVuYyA9IEJhdGNoZWRNZXNoICE9PSBudWxsID8gQmF0Y2hlZE1lc2gucHJvdG90eXBlLnJheWNhc3QgOiBudWxsO1xuXHRjb25zdCBfd29ybGRTY2FsZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRjb25zdCBfbWVzaCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVEhSRUUuTWVzaCgpO1xuXHRjb25zdCBfYmF0Y2hJbnRlcnNlY3RzID0gW107XG5cblx0ZnVuY3Rpb24gYWNjZWxlcmF0ZWRSYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHRpZiAoIHRoaXMuaXNCYXRjaGVkTWVzaCApIHtcblxuXHRcdFx0YWNjZWxlcmF0ZWRCYXRjaGVkTWVzaFJheWNhc3QuY2FsbCggdGhpcywgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRhY2NlbGVyYXRlZE1lc2hSYXljYXN0LmNhbGwoIHRoaXMsIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBhY2NlbGVyYXRlZEJhdGNoZWRNZXNoUmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0aWYgKCB0aGlzLmJvdW5kc1RyZWVzICkge1xuXG5cdFx0XHRjb25zdCBib3VuZHNUcmVlcyA9IHRoaXMuYm91bmRzVHJlZXM7XG5cdFx0XHRjb25zdCBkcmF3SW5mbyA9IHRoaXMuX2RyYXdJbmZvO1xuXHRcdFx0Y29uc3QgZHJhd1JhbmdlcyA9IHRoaXMuX2RyYXdSYW5nZXM7XG5cdFx0XHRjb25zdCBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG5cblx0XHRcdF9tZXNoLm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcblx0XHRcdF9tZXNoLmdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHRcdFx0Y29uc3Qgb2xkQm91bmRzVHJlZSA9IF9tZXNoLmdlb21ldHJ5LmJvdW5kc1RyZWU7XG5cdFx0XHRjb25zdCBvbGREcmF3UmFuZ2UgPSBfbWVzaC5nZW9tZXRyeS5kcmF3UmFuZ2U7XG5cblx0XHRcdGlmICggX21lc2guZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0X21lc2guZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gVE9ETzogcHJvdmlkZSBuZXcgbWV0aG9kIHRvIGdldCBpbnN0YW5jZXMgY291bnQgaW5zdGVhZCBvZiAnZHJhd0luZm8ubGVuZ3RoJ1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gZHJhd0luZm8ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoICEgdGhpcy5nZXRWaXNpYmxlQXQoIGkgKSApIHtcblxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUT0RPOiB1c2UgZ2V0R2VvbWV0cnlJbmRleFxuXHRcdFx0XHRjb25zdCBnZW9tZXRyeUlkID0gZHJhd0luZm9bIGkgXS5nZW9tZXRyeUluZGV4O1xuXG5cdFx0XHRcdF9tZXNoLmdlb21ldHJ5LmJvdW5kc1RyZWUgPSBib3VuZHNUcmVlc1sgZ2VvbWV0cnlJZCBdO1xuXG5cdFx0XHRcdHRoaXMuZ2V0TWF0cml4QXQoIGksIF9tZXNoLm1hdHJpeFdvcmxkICkucHJlbXVsdGlwbHkoIG1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0aWYgKCAhIF9tZXNoLmdlb21ldHJ5LmJvdW5kc1RyZWUgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmdldEJvdW5kaW5nQm94QXQoIGdlb21ldHJ5SWQsIF9tZXNoLmdlb21ldHJ5LmJvdW5kaW5nQm94ICk7XG5cdFx0XHRcdFx0dGhpcy5nZXRCb3VuZGluZ1NwaGVyZUF0KCBnZW9tZXRyeUlkLCBfbWVzaC5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xuXG5cdFx0XHRcdFx0Y29uc3QgZHJhd1JhbmdlID0gZHJhd1Jhbmdlc1sgZ2VvbWV0cnlJZCBdO1xuXHRcdFx0XHRcdF9tZXNoLmdlb21ldHJ5LnNldERyYXdSYW5nZSggZHJhd1JhbmdlLnN0YXJ0LCBkcmF3UmFuZ2UuY291bnQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X21lc2gucmF5Y2FzdCggcmF5Y2FzdGVyLCBfYmF0Y2hJbnRlcnNlY3RzICk7XG5cblx0XHRcdFx0Zm9yICggbGV0IGogPSAwLCBsID0gX2JhdGNoSW50ZXJzZWN0cy5sZW5ndGg7IGogPCBsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgaW50ZXJzZWN0ID0gX2JhdGNoSW50ZXJzZWN0c1sgaiBdO1xuXHRcdFx0XHRcdGludGVyc2VjdC5vYmplY3QgPSB0aGlzO1xuXHRcdFx0XHRcdGludGVyc2VjdC5iYXRjaElkID0gaTtcblx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfYmF0Y2hJbnRlcnNlY3RzLmxlbmd0aCA9IDA7XG5cblx0XHRcdH1cblxuXHRcdFx0X21lc2guZ2VvbWV0cnkuYm91bmRzVHJlZSA9IG9sZEJvdW5kc1RyZWU7XG5cdFx0XHRfbWVzaC5nZW9tZXRyeS5kcmF3UmFuZ2UgPSBvbGREcmF3UmFuZ2U7XG5cdFx0XHRfbWVzaC5tYXRlcmlhbCA9IG51bGw7XG5cdFx0XHRfbWVzaC5nZW9tZXRyeSA9IG51bGw7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRvcmlnQmF0Y2hlZFJheWNhc3RGdW5jLmNhbGwoIHRoaXMsIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBhY2NlbGVyYXRlZE1lc2hSYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHRpZiAoIHRoaXMuZ2VvbWV0cnkuYm91bmRzVHJlZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLm1hdGVyaWFsID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRcdHRtcEludmVyc2VNYXRyaXguY29weSggdGhpcy5tYXRyaXhXb3JsZCApLmludmVydCgpO1xuXHRcdFx0cmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIHRtcEludmVyc2VNYXRyaXggKTtcblxuXHRcdFx0X3dvcmxkU2NhbGUuc2V0RnJvbU1hdHJpeFNjYWxlKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cdFx0XHRkaXJlY3Rpb24uY29weSggcmF5LmRpcmVjdGlvbiApLm11bHRpcGx5KCBfd29ybGRTY2FsZSApO1xuXG5cdFx0XHRjb25zdCBzY2FsZUZhY3RvciA9IGRpcmVjdGlvbi5sZW5ndGgoKTtcblx0XHRcdGNvbnN0IG5lYXIgPSByYXljYXN0ZXIubmVhciAvIHNjYWxlRmFjdG9yO1xuXHRcdFx0Y29uc3QgZmFyID0gcmF5Y2FzdGVyLmZhciAvIHNjYWxlRmFjdG9yO1xuXG5cdFx0XHRjb25zdCBidmggPSB0aGlzLmdlb21ldHJ5LmJvdW5kc1RyZWU7XG5cdFx0XHRpZiAoIHJheWNhc3Rlci5maXJzdEhpdE9ubHkgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0Y29uc3QgaGl0ID0gY29udmVydFJheWNhc3RJbnRlcnNlY3QoIGJ2aC5yYXljYXN0Rmlyc3QoIHJheSwgdGhpcy5tYXRlcmlhbCwgbmVhciwgZmFyICksIHRoaXMsIHJheWNhc3RlciApO1xuXHRcdFx0XHRpZiAoIGhpdCApIHtcblxuXHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaGl0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnN0IGhpdHMgPSBidmgucmF5Y2FzdCggcmF5LCB0aGlzLm1hdGVyaWFsLCBuZWFyLCBmYXIgKTtcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaGl0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgaGl0ID0gY29udmVydFJheWNhc3RJbnRlcnNlY3QoIGhpdHNbIGkgXSwgdGhpcywgcmF5Y2FzdGVyICk7XG5cdFx0XHRcdFx0aWYgKCBoaXQgKSB7XG5cblx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaGl0ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRvcmlnTWVzaFJheWNhc3RGdW5jLmNhbGwoIHRoaXMsIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBjb21wdXRlQm91bmRzVHJlZSggb3B0aW9ucyA9IHt9ICkge1xuXG5cdFx0dGhpcy5ib3VuZHNUcmVlID0gbmV3IE1lc2hCVkgoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHRyZXR1cm4gdGhpcy5ib3VuZHNUcmVlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBkaXNwb3NlQm91bmRzVHJlZSgpIHtcblxuXHRcdHRoaXMuYm91bmRzVHJlZSA9IG51bGw7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbXB1dGVCYXRjaGVkQm91bmRzVHJlZSggaW5kZXggPSAtIDEsIG9wdGlvbnMgPSB7fSApIHtcblxuXHRcdGlmICggISBJU19SRVZJU0lPTl8xNjYgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0JhdGNoZWRNZXNoOiBUaHJlZSByMTY2KyBpcyByZXF1aXJlZCB0byBjb21wdXRlIGJvdW5kcyB0cmVlcy4nICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMuaW5kaXJlY3QgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1wiSW5kaXJlY3RcIiBpcyBzZXQgdG8gZmFsc2UgYmVjYXVzZSBpdCBpcyBub3Qgc3VwcG9ydGVkIGZvciBCYXRjaGVkTWVzaC4nICk7XG5cblx0XHR9XG5cblx0XHRvcHRpb25zID0ge1xuXHRcdFx0Li4ub3B0aW9ucyxcblx0XHRcdGluZGlyZWN0OiBmYWxzZSxcblx0XHRcdHJhbmdlOiBudWxsXG5cdFx0fTtcblxuXHRcdGNvbnN0IGRyYXdSYW5nZXMgPSB0aGlzLl9kcmF3UmFuZ2VzO1xuXHRcdGNvbnN0IGdlb21ldHJ5Q291bnQgPSB0aGlzLl9nZW9tZXRyeUNvdW50O1xuXHRcdGlmICggISB0aGlzLmJvdW5kc1RyZWVzICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kc1RyZWVzID0gbmV3IEFycmF5KCBnZW9tZXRyeUNvdW50ICkuZmlsbCggbnVsbCApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgYm91bmRzVHJlZXMgPSB0aGlzLmJvdW5kc1RyZWVzO1xuXHRcdHdoaWxlICggYm91bmRzVHJlZXMubGVuZ3RoIDwgZ2VvbWV0cnlDb3VudCApIHtcblxuXHRcdFx0Ym91bmRzVHJlZXMucHVzaCggbnVsbCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IGdlb21ldHJ5Q291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5yYW5nZSA9IGRyYXdSYW5nZXNbIGkgXTtcblx0XHRcdFx0Ym91bmRzVHJlZXNbIGkgXSA9IG5ldyBNZXNoQlZIKCB0aGlzLmdlb21ldHJ5LCBvcHRpb25zICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJvdW5kc1RyZWVzO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKCBpbmRleCA8IGRyYXdSYW5nZXMubGVuZ3RoICkge1xuXG5cdFx0XHRcdG9wdGlvbnMucmFuZ2UgPSBkcmF3UmFuZ2VzWyBpbmRleCBdO1xuXHRcdFx0XHRib3VuZHNUcmVlc1sgaW5kZXggXSA9IG5ldyBNZXNoQlZIKCB0aGlzLmdlb21ldHJ5LCBvcHRpb25zICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGJvdW5kc1RyZWVzWyBpbmRleCBdIHx8IG51bGw7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGRpc3Bvc2VCYXRjaGVkQm91bmRzVHJlZSggaW5kZXggPSAtIDEgKSB7XG5cblx0XHRpZiAoIGluZGV4IDwgMCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZHNUcmVlcy5maWxsKCBudWxsICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIGluZGV4IDwgdGhpcy5ib3VuZHNUcmVlLmxlbmd0aCApIHtcblxuXHRcdFx0XHR0aGlzLmJvdW5kc1RyZWVzWyBpbmRleCBdID0gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBjb3VudFRvU3RyaW5nRm9ybWF0KCBjb3VudCApIHtcblxuXHRcdHN3aXRjaCAoIGNvdW50ICkge1xuXG5cdFx0XHRjYXNlIDE6IHJldHVybiAnUic7XG5cdFx0XHRjYXNlIDI6IHJldHVybiAnUkcnO1xuXHRcdFx0Y2FzZSAzOiByZXR1cm4gJ1JHQkEnO1xuXHRcdFx0Y2FzZSA0OiByZXR1cm4gJ1JHQkEnO1xuXG5cdFx0fVxuXG5cdFx0dGhyb3cgbmV3IEVycm9yKCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNvdW50VG9Gb3JtYXQoIGNvdW50ICkge1xuXG5cdFx0c3dpdGNoICggY291bnQgKSB7XG5cblx0XHRcdGNhc2UgMTogcmV0dXJuIFRIUkVFLlJlZEZvcm1hdDtcblx0XHRcdGNhc2UgMjogcmV0dXJuIFRIUkVFLlJHRm9ybWF0O1xuXHRcdFx0Y2FzZSAzOiByZXR1cm4gVEhSRUUuUkdCQUZvcm1hdDtcblx0XHRcdGNhc2UgNDogcmV0dXJuIFRIUkVFLlJHQkFGb3JtYXQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNvdW50VG9JbnRGb3JtYXQoIGNvdW50ICkge1xuXG5cdFx0c3dpdGNoICggY291bnQgKSB7XG5cblx0XHRcdGNhc2UgMTogcmV0dXJuIFRIUkVFLlJlZEludGVnZXJGb3JtYXQ7XG5cdFx0XHRjYXNlIDI6IHJldHVybiBUSFJFRS5SR0ludGVnZXJGb3JtYXQ7XG5cdFx0XHRjYXNlIDM6IHJldHVybiBUSFJFRS5SR0JBSW50ZWdlckZvcm1hdDtcblx0XHRcdGNhc2UgNDogcmV0dXJuIFRIUkVFLlJHQkFJbnRlZ2VyRm9ybWF0O1xuXG5cdFx0fVxuXG5cdH1cblxuXHRjbGFzcyBWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlIGV4dGVuZHMgVEhSRUUuRGF0YVRleHR1cmUge1xuXG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLm1pbkZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG5cdFx0XHR0aGlzLm1hZ0ZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG5cdFx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5vdmVycmlkZUl0ZW1TaXplID0gbnVsbDtcblx0XHRcdHRoaXMuX2ZvcmNlZFR5cGUgPSBudWxsO1xuXG5cdFx0fVxuXG5cdFx0dXBkYXRlRnJvbSggYXR0ciApIHtcblxuXHRcdFx0Y29uc3Qgb3ZlcnJpZGVJdGVtU2l6ZSA9IHRoaXMub3ZlcnJpZGVJdGVtU2l6ZTtcblx0XHRcdGNvbnN0IG9yaWdpbmFsSXRlbVNpemUgPSBhdHRyLml0ZW1TaXplO1xuXHRcdFx0Y29uc3Qgb3JpZ2luYWxDb3VudCA9IGF0dHIuY291bnQ7XG5cdFx0XHRpZiAoIG92ZXJyaWRlSXRlbVNpemUgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0aWYgKCAoIG9yaWdpbmFsSXRlbVNpemUgKiBvcmlnaW5hbENvdW50ICkgJSBvdmVycmlkZUl0ZW1TaXplICE9PSAwLjAgKSB7XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlOiBvdmVycmlkZUl0ZW1TaXplIG11c3QgZGl2aWRlIGV2ZW5seSBpbnRvIGJ1ZmZlciBsZW5ndGguJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhdHRyLml0ZW1TaXplID0gb3ZlcnJpZGVJdGVtU2l6ZTtcblx0XHRcdFx0YXR0ci5jb3VudCA9IG9yaWdpbmFsQ291bnQgKiBvcmlnaW5hbEl0ZW1TaXplIC8gb3ZlcnJpZGVJdGVtU2l6ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBpdGVtU2l6ZSA9IGF0dHIuaXRlbVNpemU7XG5cdFx0XHRjb25zdCBjb3VudCA9IGF0dHIuY291bnQ7XG5cdFx0XHRjb25zdCBub3JtYWxpemVkID0gYXR0ci5ub3JtYWxpemVkO1xuXHRcdFx0Y29uc3Qgb3JpZ2luYWxCdWZmZXJDb25zID0gYXR0ci5hcnJheS5jb25zdHJ1Y3Rvcjtcblx0XHRcdGNvbnN0IGJ5dGVDb3VudCA9IG9yaWdpbmFsQnVmZmVyQ29ucy5CWVRFU19QRVJfRUxFTUVOVDtcblx0XHRcdGxldCB0YXJnZXRUeXBlID0gdGhpcy5fZm9yY2VkVHlwZTtcblx0XHRcdGxldCBmaW5hbFN0cmlkZSA9IGl0ZW1TaXplO1xuXG5cdFx0XHQvLyBkZXJpdmUgdGhlIHR5cGUgb2YgdGV4dHVyZSB0aGlzIHNob3VsZCBiZSBpbiB0aGUgc2hhZGVyXG5cdFx0XHRpZiAoIHRhcmdldFR5cGUgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0c3dpdGNoICggb3JpZ2luYWxCdWZmZXJDb25zICkge1xuXG5cdFx0XHRcdFx0Y2FzZSBGbG9hdDMyQXJyYXk6XG5cdFx0XHRcdFx0XHR0YXJnZXRUeXBlID0gVEhSRUUuRmxvYXRUeXBlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFVpbnQ4QXJyYXk6XG5cdFx0XHRcdFx0Y2FzZSBVaW50MTZBcnJheTpcblx0XHRcdFx0XHRjYXNlIFVpbnQzMkFycmF5OlxuXHRcdFx0XHRcdFx0dGFyZ2V0VHlwZSA9IFRIUkVFLlVuc2lnbmVkSW50VHlwZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBJbnQ4QXJyYXk6XG5cdFx0XHRcdFx0Y2FzZSBJbnQxNkFycmF5OlxuXHRcdFx0XHRcdGNhc2UgSW50MzJBcnJheTpcblx0XHRcdFx0XHRcdHRhcmdldFR5cGUgPSBUSFJFRS5JbnRUeXBlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGdldCB0aGUgdGFyZ2V0IGZvcm1hdCB0byBzdG9yZSB0aGUgdGV4dHVyZSBhc1xuXHRcdFx0bGV0IHR5cGUsIGZvcm1hdCwgbm9ybWFsaXplVmFsdWUsIHRhcmdldEJ1ZmZlckNvbnM7XG5cdFx0XHRsZXQgaW50ZXJuYWxGb3JtYXQgPSBjb3VudFRvU3RyaW5nRm9ybWF0KCBpdGVtU2l6ZSApO1xuXHRcdFx0c3dpdGNoICggdGFyZ2V0VHlwZSApIHtcblxuXHRcdFx0XHRjYXNlIFRIUkVFLkZsb2F0VHlwZTpcblx0XHRcdFx0XHRub3JtYWxpemVWYWx1ZSA9IDEuMDtcblx0XHRcdFx0XHRmb3JtYXQgPSBjb3VudFRvRm9ybWF0KCBpdGVtU2l6ZSApO1xuXG5cdFx0XHRcdFx0aWYgKCBub3JtYWxpemVkICYmIGJ5dGVDb3VudCA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IG9yaWdpbmFsQnVmZmVyQ29ucztcblx0XHRcdFx0XHRcdGludGVybmFsRm9ybWF0ICs9ICc4JztcblxuXHRcdFx0XHRcdFx0aWYgKCBvcmlnaW5hbEJ1ZmZlckNvbnMgPT09IFVpbnQ4QXJyYXkgKSB7XG5cblx0XHRcdFx0XHRcdFx0dHlwZSA9IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGU7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0dHlwZSA9IFRIUkVFLkJ5dGVUeXBlO1xuXHRcdFx0XHRcdFx0XHRpbnRlcm5hbEZvcm1hdCArPSAnX1NOT1JNJztcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IEZsb2F0MzJBcnJheTtcblx0XHRcdFx0XHRcdGludGVybmFsRm9ybWF0ICs9ICczMkYnO1xuXHRcdFx0XHRcdFx0dHlwZSA9IFRIUkVFLkZsb2F0VHlwZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgVEhSRUUuSW50VHlwZTpcblx0XHRcdFx0XHRpbnRlcm5hbEZvcm1hdCArPSBieXRlQ291bnQgKiA4ICsgJ0knO1xuXHRcdFx0XHRcdG5vcm1hbGl6ZVZhbHVlID0gbm9ybWFsaXplZCA/IE1hdGgucG93KCAyLCBvcmlnaW5hbEJ1ZmZlckNvbnMuQllURVNfUEVSX0VMRU1FTlQgKiA4IC0gMSApIDogMS4wO1xuXHRcdFx0XHRcdGZvcm1hdCA9IGNvdW50VG9JbnRGb3JtYXQoIGl0ZW1TaXplICk7XG5cblx0XHRcdFx0XHRpZiAoIGJ5dGVDb3VudCA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IEludDhBcnJheTtcblx0XHRcdFx0XHRcdHR5cGUgPSBUSFJFRS5CeXRlVHlwZTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGJ5dGVDb3VudCA9PT0gMiApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IEludDE2QXJyYXk7XG5cdFx0XHRcdFx0XHR0eXBlID0gVEhSRUUuU2hvcnRUeXBlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IEludDMyQXJyYXk7XG5cdFx0XHRcdFx0XHR0eXBlID0gVEhSRUUuSW50VHlwZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgVEhSRUUuVW5zaWduZWRJbnRUeXBlOlxuXHRcdFx0XHRcdGludGVybmFsRm9ybWF0ICs9IGJ5dGVDb3VudCAqIDggKyAnVUknO1xuXHRcdFx0XHRcdG5vcm1hbGl6ZVZhbHVlID0gbm9ybWFsaXplZCA/IE1hdGgucG93KCAyLCBvcmlnaW5hbEJ1ZmZlckNvbnMuQllURVNfUEVSX0VMRU1FTlQgKiA4IC0gMSApIDogMS4wO1xuXHRcdFx0XHRcdGZvcm1hdCA9IGNvdW50VG9JbnRGb3JtYXQoIGl0ZW1TaXplICk7XG5cblx0XHRcdFx0XHRpZiAoIGJ5dGVDb3VudCA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IFVpbnQ4QXJyYXk7XG5cdFx0XHRcdFx0XHR0eXBlID0gVEhSRUUuVW5zaWduZWRCeXRlVHlwZTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGJ5dGVDb3VudCA9PT0gMiApIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IFVpbnQxNkFycmF5O1xuXHRcdFx0XHRcdFx0dHlwZSA9IFRIUkVFLlVuc2lnbmVkU2hvcnRUeXBlO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dGFyZ2V0QnVmZmVyQ29ucyA9IFVpbnQzMkFycmF5O1xuXHRcdFx0XHRcdFx0dHlwZSA9IFRIUkVFLlVuc2lnbmVkSW50VHlwZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHRoZXJlIHdpbGwgYmUgYSBtaXNtYXRjaCBiZXR3ZWVuIGZvcm1hdCBsZW5ndGggYW5kIGZpbmFsIGxlbmd0aCBiZWNhdXNlXG5cdFx0XHQvLyBSR0JGb3JtYXQgYW5kIFJHQkludGVnZXJGb3JtYXQgd2FzIHJlbW92ZWRcblx0XHRcdGlmICggZmluYWxTdHJpZGUgPT09IDMgJiYgKCBmb3JtYXQgPT09IFRIUkVFLlJHQkFGb3JtYXQgfHwgZm9ybWF0ID09PSBUSFJFRS5SR0JBSW50ZWdlckZvcm1hdCApICkge1xuXG5cdFx0XHRcdGZpbmFsU3RyaWRlID0gNDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjb3B5IHRoZSBkYXRhIG92ZXIgdG8gdGhlIG5ldyB0ZXh0dXJlIGFycmF5XG5cdFx0XHRjb25zdCBkaW1lbnNpb24gPSBNYXRoLmNlaWwoIE1hdGguc3FydCggY291bnQgKSApIHx8IDE7XG5cdFx0XHRjb25zdCBsZW5ndGggPSBmaW5hbFN0cmlkZSAqIGRpbWVuc2lvbiAqIGRpbWVuc2lvbjtcblx0XHRcdGNvbnN0IGRhdGFBcnJheSA9IG5ldyB0YXJnZXRCdWZmZXJDb25zKCBsZW5ndGggKTtcblxuXHRcdFx0Ly8gdGVtcG9yYXJpbHkgc2V0IHRoZSBub3JtYWxpemVkIHN0YXRlIHRvIGZhbHNlIHNpbmNlIHdlIGhhdmUgY3VzdG9tIG5vcm1hbGl6YXRpb24gbG9naWNcblx0XHRcdGNvbnN0IG9yaWdpbmFsTm9ybWFsaXplZCA9IGF0dHIubm9ybWFsaXplZDtcblx0XHRcdGF0dHIubm9ybWFsaXplZCA9IGZhbHNlO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaWkgPSBmaW5hbFN0cmlkZSAqIGk7XG5cdFx0XHRcdGRhdGFBcnJheVsgaWkgXSA9IGF0dHIuZ2V0WCggaSApIC8gbm9ybWFsaXplVmFsdWU7XG5cblx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSAyICkge1xuXG5cdFx0XHRcdFx0ZGF0YUFycmF5WyBpaSArIDEgXSA9IGF0dHIuZ2V0WSggaSApIC8gbm9ybWFsaXplVmFsdWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaXRlbVNpemUgPj0gMyApIHtcblxuXHRcdFx0XHRcdGRhdGFBcnJheVsgaWkgKyAyIF0gPSBhdHRyLmdldFooIGkgKSAvIG5vcm1hbGl6ZVZhbHVlO1xuXG5cdFx0XHRcdFx0aWYgKCBmaW5hbFN0cmlkZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0ZGF0YUFycmF5WyBpaSArIDMgXSA9IDEuMDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSA0ICkge1xuXG5cdFx0XHRcdFx0ZGF0YUFycmF5WyBpaSArIDMgXSA9IGF0dHIuZ2V0VyggaSApIC8gbm9ybWFsaXplVmFsdWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGF0dHIubm9ybWFsaXplZCA9IG9yaWdpbmFsTm9ybWFsaXplZDtcblxuXHRcdFx0dGhpcy5pbnRlcm5hbEZvcm1hdCA9IGludGVybmFsRm9ybWF0O1xuXHRcdFx0dGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdFx0dGhpcy5pbWFnZS53aWR0aCA9IGRpbWVuc2lvbjtcblx0XHRcdHRoaXMuaW1hZ2UuaGVpZ2h0ID0gZGltZW5zaW9uO1xuXHRcdFx0dGhpcy5pbWFnZS5kYXRhID0gZGF0YUFycmF5O1xuXHRcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR0aGlzLmRpc3Bvc2UoKTtcblxuXHRcdFx0YXR0ci5pdGVtU2l6ZSA9IG9yaWdpbmFsSXRlbVNpemU7XG5cdFx0XHRhdHRyLmNvdW50ID0gb3JpZ2luYWxDb3VudDtcblxuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgVUludFZlcnRleEF0dHJpYnV0ZVRleHR1cmUgZXh0ZW5kcyBWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlIHtcblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy5fZm9yY2VkVHlwZSA9IFRIUkVFLlVuc2lnbmVkSW50VHlwZTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgSW50VmVydGV4QXR0cmlidXRlVGV4dHVyZSBleHRlbmRzIFZlcnRleEF0dHJpYnV0ZVRleHR1cmUge1xuXG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLl9mb3JjZWRUeXBlID0gVEhSRUUuSW50VHlwZTtcblxuXHRcdH1cblxuXG5cdH1cblxuXHRjbGFzcyBGbG9hdFZlcnRleEF0dHJpYnV0ZVRleHR1cmUgZXh0ZW5kcyBWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlIHtcblxuXHRcdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0XHRzdXBlcigpO1xuXHRcdFx0dGhpcy5fZm9yY2VkVHlwZSA9IFRIUkVFLkZsb2F0VHlwZTtcblxuXHRcdH1cblxuXHR9XG5cblx0Y2xhc3MgTWVzaEJWSFVuaWZvcm1TdHJ1Y3Qge1xuXG5cdFx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHRcdHRoaXMuaW5kZXggPSBuZXcgVUludFZlcnRleEF0dHJpYnV0ZVRleHR1cmUoKTtcblx0XHRcdHRoaXMucG9zaXRpb24gPSBuZXcgRmxvYXRWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlKCk7XG5cdFx0XHR0aGlzLmJ2aEJvdW5kcyA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSgpO1xuXHRcdFx0dGhpcy5idmhDb250ZW50cyA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSgpO1xuXHRcdFx0dGhpcy5fY2FjaGVkSW5kZXhBdHRyID0gbnVsbDtcblxuXHRcdFx0dGhpcy5pbmRleC5vdmVycmlkZUl0ZW1TaXplID0gMztcblxuXHRcdH1cblxuXHRcdHVwZGF0ZUZyb20oIGJ2aCApIHtcblxuXHRcdFx0Y29uc3QgeyBnZW9tZXRyeSB9ID0gYnZoO1xuXHRcdFx0YnZoVG9UZXh0dXJlcyggYnZoLCB0aGlzLmJ2aEJvdW5kcywgdGhpcy5idmhDb250ZW50cyApO1xuXG5cdFx0XHR0aGlzLnBvc2l0aW9uLnVwZGF0ZUZyb20oIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24gKTtcblxuXHRcdFx0Ly8gZGVyZWZlcmVuY2UgYSBuZXcgaW5kZXggYXR0cmlidXRlIGlmIHdlJ3JlIHVzaW5nIGluZGlyZWN0IHN0b3JhZ2Vcblx0XHRcdGlmICggYnZoLmluZGlyZWN0ICkge1xuXG5cdFx0XHRcdGNvbnN0IGluZGlyZWN0QnVmZmVyID0gYnZoLl9pbmRpcmVjdEJ1ZmZlcjtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4QXR0ciA9PT0gbnVsbCB8fFxuXHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4QXR0ci5jb3VudCAhPT0gaW5kaXJlY3RCdWZmZXIubGVuZ3RoXG5cdFx0XHRcdCkge1xuXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5pbmRleCApIHtcblxuXHRcdFx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXhBdHRyID0gZ2VvbWV0cnkuaW5kZXguY2xvbmUoKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGFycmF5ID0gZ2V0SW5kZXhBcnJheSggZ2V0VmVydGV4Q291bnQoIGdlb21ldHJ5ICkgKTtcblx0XHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4QXR0ciA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCAxLCBmYWxzZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZXJlZmVyZW5jZUluZGV4KCBnZW9tZXRyeSwgaW5kaXJlY3RCdWZmZXIsIHRoaXMuX2NhY2hlZEluZGV4QXR0ciApO1xuXHRcdFx0XHR0aGlzLmluZGV4LnVwZGF0ZUZyb20oIHRoaXMuX2NhY2hlZEluZGV4QXR0ciApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuaW5kZXgudXBkYXRlRnJvbSggZ2VvbWV0cnkuaW5kZXggKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZGlzcG9zZSgpIHtcblxuXHRcdFx0Y29uc3QgeyBpbmRleCwgcG9zaXRpb24sIGJ2aEJvdW5kcywgYnZoQ29udGVudHMgfSA9IHRoaXM7XG5cblx0XHRcdGlmICggaW5kZXggKSBpbmRleC5kaXNwb3NlKCk7XG5cdFx0XHRpZiAoIHBvc2l0aW9uICkgcG9zaXRpb24uZGlzcG9zZSgpO1xuXHRcdFx0aWYgKCBidmhCb3VuZHMgKSBidmhCb3VuZHMuZGlzcG9zZSgpO1xuXHRcdFx0aWYgKCBidmhDb250ZW50cyApIGJ2aENvbnRlbnRzLmRpc3Bvc2UoKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gZGVyZWZlcmVuY2VJbmRleCggZ2VvbWV0cnksIGluZGlyZWN0QnVmZmVyLCB0YXJnZXQgKSB7XG5cblx0XHRjb25zdCB1bnBhY2tlZCA9IHRhcmdldC5hcnJheTtcblx0XHRjb25zdCBpbmRleEFycmF5ID0gZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS5pbmRleC5hcnJheSA6IG51bGw7XG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gaW5kaXJlY3RCdWZmZXIubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgaTMgPSAzICogaTtcblx0XHRcdGNvbnN0IHYzID0gMyAqIGluZGlyZWN0QnVmZmVyWyBpIF07XG5cdFx0XHRmb3IgKCBsZXQgYyA9IDA7IGMgPCAzOyBjICsrICkge1xuXG5cdFx0XHRcdHVucGFja2VkWyBpMyArIGMgXSA9IGluZGV4QXJyYXkgPyBpbmRleEFycmF5WyB2MyArIGMgXSA6IHYzICsgYztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBidmhUb1RleHR1cmVzKCBidmgsIGJvdW5kc1RleHR1cmUsIGNvbnRlbnRzVGV4dHVyZSApIHtcblxuXHRcdGNvbnN0IHJvb3RzID0gYnZoLl9yb290cztcblxuXHRcdGlmICggcm9vdHMubGVuZ3RoICE9PSAxICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdNZXNoQlZIVW5pZm9ybVN0cnVjdDogTXVsdGktcm9vdCBCVkhzIG5vdCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgcm9vdCA9IHJvb3RzWyAwIF07XG5cdFx0Y29uc3QgdWludDE2QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoIHJvb3QgKTtcblx0XHRjb25zdCB1aW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSggcm9vdCApO1xuXHRcdGNvbnN0IGZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIHJvb3QgKTtcblxuXHRcdC8vIEJvdGggYm91bmRzIG5lZWQgdHdvIGVsZW1lbnRzIHBlciBub2RlIHNvIGNvbXB1dGUgdGhlIGhlaWdodCBzbyBpdCdzIHR3aWNlIGFzIGxvbmcgYXNcblx0XHQvLyB0aGUgd2lkdGggc28gd2UgY2FuIGV4cGFuZCB0aGUgcm93IGJ5IHR3byBhbmQgc3RpbGwgaGF2ZSBhIHNxdWFyZSB0ZXh0dXJlXG5cdFx0Y29uc3Qgbm9kZUNvdW50ID0gcm9vdC5ieXRlTGVuZ3RoIC8gQllURVNfUEVSX05PREU7XG5cdFx0Y29uc3QgYm91bmRzRGltZW5zaW9uID0gMiAqIE1hdGguY2VpbCggTWF0aC5zcXJ0KCBub2RlQ291bnQgLyAyICkgKTtcblx0XHRjb25zdCBib3VuZHNBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDQgKiBib3VuZHNEaW1lbnNpb24gKiBib3VuZHNEaW1lbnNpb24gKTtcblxuXHRcdGNvbnN0IGNvbnRlbnRzRGltZW5zaW9uID0gTWF0aC5jZWlsKCBNYXRoLnNxcnQoIG5vZGVDb3VudCApICk7XG5cdFx0Y29uc3QgY29udGVudHNBcnJheSA9IG5ldyBVaW50MzJBcnJheSggMiAqIGNvbnRlbnRzRGltZW5zaW9uICogY29udGVudHNEaW1lbnNpb24gKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG5vZGVDb3VudDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3Qgbm9kZUluZGV4MzIgPSBpICogQllURVNfUEVSX05PREUgLyA0O1xuXHRcdFx0Y29uc3Qgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cdFx0XHRjb25zdCBib3VuZHNJbmRleCA9IEJPVU5ESU5HX0RBVEFfSU5ERVgoIG5vZGVJbmRleDMyICk7XG5cdFx0XHRmb3IgKCBsZXQgYiA9IDA7IGIgPCAzOyBiICsrICkge1xuXG5cdFx0XHRcdGJvdW5kc0FycmF5WyA4ICogaSArIDAgKyBiIF0gPSBmbG9hdDMyQXJyYXlbIGJvdW5kc0luZGV4ICsgMCArIGIgXTtcblx0XHRcdFx0Ym91bmRzQXJyYXlbIDggKiBpICsgNCArIGIgXSA9IGZsb2F0MzJBcnJheVsgYm91bmRzSW5kZXggKyAzICsgYiBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggSVNfTEVBRiggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICkgKSB7XG5cblx0XHRcdFx0Y29uc3QgY291bnQgPSBDT1VOVCggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cdFx0XHRcdGNvbnN0IG9mZnNldCA9IE9GRlNFVCggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cblx0XHRcdFx0Y29uc3QgbWVyZ2VkTGVhZkNvdW50ID0gMHhmZmZmMDAwMCB8IGNvdW50O1xuXHRcdFx0XHRjb250ZW50c0FycmF5WyBpICogMiArIDAgXSA9IG1lcmdlZExlYWZDb3VudDtcblx0XHRcdFx0Y29udGVudHNBcnJheVsgaSAqIDIgKyAxIF0gPSBvZmZzZXQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc3QgcmlnaHRJbmRleCA9IDQgKiBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKSAvIEJZVEVTX1BFUl9OT0RFO1xuXHRcdFx0XHRjb25zdCBzcGxpdEF4aXMgPSBTUExJVF9BWElTKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblxuXHRcdFx0XHRjb250ZW50c0FycmF5WyBpICogMiArIDAgXSA9IHNwbGl0QXhpcztcblx0XHRcdFx0Y29udGVudHNBcnJheVsgaSAqIDIgKyAxIF0gPSByaWdodEluZGV4O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRib3VuZHNUZXh0dXJlLmltYWdlLmRhdGEgPSBib3VuZHNBcnJheTtcblx0XHRib3VuZHNUZXh0dXJlLmltYWdlLndpZHRoID0gYm91bmRzRGltZW5zaW9uO1xuXHRcdGJvdW5kc1RleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gYm91bmRzRGltZW5zaW9uO1xuXHRcdGJvdW5kc1RleHR1cmUuZm9ybWF0ID0gVEhSRUUuUkdCQUZvcm1hdDtcblx0XHRib3VuZHNUZXh0dXJlLnR5cGUgPSBUSFJFRS5GbG9hdFR5cGU7XG5cdFx0Ym91bmRzVGV4dHVyZS5pbnRlcm5hbEZvcm1hdCA9ICdSR0JBMzJGJztcblx0XHRib3VuZHNUZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG5cdFx0Ym91bmRzVGV4dHVyZS5tYWdGaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuXHRcdGJvdW5kc1RleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cdFx0Ym91bmRzVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0Ym91bmRzVGV4dHVyZS5kaXNwb3NlKCk7XG5cblx0XHRjb250ZW50c1RleHR1cmUuaW1hZ2UuZGF0YSA9IGNvbnRlbnRzQXJyYXk7XG5cdFx0Y29udGVudHNUZXh0dXJlLmltYWdlLndpZHRoID0gY29udGVudHNEaW1lbnNpb247XG5cdFx0Y29udGVudHNUZXh0dXJlLmltYWdlLmhlaWdodCA9IGNvbnRlbnRzRGltZW5zaW9uO1xuXHRcdGNvbnRlbnRzVGV4dHVyZS5mb3JtYXQgPSBUSFJFRS5SR0ludGVnZXJGb3JtYXQ7XG5cdFx0Y29udGVudHNUZXh0dXJlLnR5cGUgPSBUSFJFRS5VbnNpZ25lZEludFR5cGU7XG5cdFx0Y29udGVudHNUZXh0dXJlLmludGVybmFsRm9ybWF0ID0gJ1JHMzJVSSc7XG5cdFx0Y29udGVudHNUZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG5cdFx0Y29udGVudHNUZXh0dXJlLm1hZ0ZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG5cdFx0Y29udGVudHNUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXHRcdGNvbnRlbnRzVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0Y29udGVudHNUZXh0dXJlLmRpc3Bvc2UoKTtcblxuXHR9XG5cblx0Y29uc3QgX3Bvc2l0aW9uVmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRjb25zdCBfbm9ybWFsVmVjdG9yID0gLypAX19QVVJFX18qLyBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRjb25zdCBfdGFuZ2VudFZlY3RvciA9IC8qQF9fUFVSRV9fKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgX3RhbmdlbnRWZWN0b3I0ID0gLypAX19QVVJFX18qLyBuZXcgVEhSRUUuVmVjdG9yNCgpO1xuXG5cdGNvbnN0IF9tb3JwaFZlY3RvciA9IC8qQF9fUFVSRV9fKi8gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0Y29uc3QgX3RlbXAgPSAvKkBfX1BVUkVfXyovIG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0Y29uc3QgX3NraW5JbmRleCA9IC8qQF9fUFVSRV9fKi8gbmV3IFRIUkVFLlZlY3RvcjQoKTtcblx0Y29uc3QgX3NraW5XZWlnaHQgPSAvKkBfX1BVUkVfXyovIG5ldyBUSFJFRS5WZWN0b3I0KCk7XG5cdGNvbnN0IF9tYXRyaXggPSAvKkBfX1BVUkVfXyovIG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cdGNvbnN0IF9ib25lTWF0cml4ID0gLypAX19QVVJFX18qLyBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdC8vIENvbmZpcm1zIHRoYXQgdGhlIHR3byBwcm92aWRlZCBhdHRyaWJ1dGVzIGFyZSBjb21wYXRpYmxlXG5cdGZ1bmN0aW9uIHZhbGlkYXRlQXR0cmlidXRlcyggYXR0cjEsIGF0dHIyICkge1xuXG5cdFx0aWYgKCAhIGF0dHIxICYmICEgYXR0cjIgKSB7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHNhbWVDb3VudCA9IGF0dHIxLmNvdW50ID09PSBhdHRyMi5jb3VudDtcblx0XHRjb25zdCBzYW1lTm9ybWFsaXplZCA9IGF0dHIxLm5vcm1hbGl6ZWQgPT09IGF0dHIyLm5vcm1hbGl6ZWQ7XG5cdFx0Y29uc3Qgc2FtZVR5cGUgPSBhdHRyMS5hcnJheS5jb25zdHJ1Y3RvciA9PT0gYXR0cjIuYXJyYXkuY29uc3RydWN0b3I7XG5cdFx0Y29uc3Qgc2FtZUl0ZW1TaXplID0gYXR0cjEuaXRlbVNpemUgPT09IGF0dHIyLml0ZW1TaXplO1xuXG5cdFx0aWYgKCAhIHNhbWVDb3VudCB8fCAhIHNhbWVOb3JtYWxpemVkIHx8ICEgc2FtZVR5cGUgfHwgISBzYW1lSXRlbVNpemUgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvcigpO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBDbG9uZXMgdGhlIGdpdmVuIGF0dHJpYnV0ZSB3aXRoIGEgbmV3IGNvbXBhdGlibGUgYnVmZmVyIGF0dHJpYnV0ZSBidXQgbm8gZGF0YVxuXHRmdW5jdGlvbiBjcmVhdGVBdHRyaWJ1dGVDbG9uZSggYXR0ciwgY291bnRPdmVycmlkZSA9IG51bGwgKSB7XG5cblx0XHRjb25zdCBjb25zID0gYXR0ci5hcnJheS5jb25zdHJ1Y3Rvcjtcblx0XHRjb25zdCBub3JtYWxpemVkID0gYXR0ci5ub3JtYWxpemVkO1xuXHRcdGNvbnN0IGl0ZW1TaXplID0gYXR0ci5pdGVtU2l6ZTtcblx0XHRjb25zdCBjb3VudCA9IGNvdW50T3ZlcnJpZGUgPT09IG51bGwgPyBhdHRyLmNvdW50IDogY291bnRPdmVycmlkZTtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgY29ucyggaXRlbVNpemUgKiBjb3VudCApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xuXG5cdH1cblxuXHQvLyB0YXJnZXQgb2Zmc2V0IGlzIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRhcmdldCBidWZmZXIgc3RyaWRlIHRvIHNraXAgYmVmb3JlIGNvcHlpbmcgdGhlXG5cdC8vIGF0dHJpYnV0ZXMgY29udGVudHMgaW4gdG8uXG5cdGZ1bmN0aW9uIGNvcHlBdHRyaWJ1dGVDb250ZW50cyggYXR0ciwgdGFyZ2V0LCB0YXJnZXRPZmZzZXQgPSAwICkge1xuXG5cdFx0aWYgKCBhdHRyLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdGNvbnN0IGl0ZW1TaXplID0gYXR0ci5pdGVtU2l6ZTtcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGF0dHIuY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IGlvID0gaSArIHRhcmdldE9mZnNldDtcblx0XHRcdFx0dGFyZ2V0LnNldFgoIGlvLCBhdHRyLmdldFgoIGkgKSApO1xuXHRcdFx0XHRpZiAoIGl0ZW1TaXplID49IDIgKSB0YXJnZXQuc2V0WSggaW8sIGF0dHIuZ2V0WSggaSApICk7XG5cdFx0XHRcdGlmICggaXRlbVNpemUgPj0gMyApIHRhcmdldC5zZXRaKCBpbywgYXR0ci5nZXRaKCBpICkgKTtcblx0XHRcdFx0aWYgKCBpdGVtU2l6ZSA+PSA0ICkgdGFyZ2V0LnNldFcoIGlvLCBhdHRyLmdldFcoIGkgKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBhcnJheSA9IHRhcmdldC5hcnJheTtcblx0XHRcdGNvbnN0IGNvbnMgPSBhcnJheS5jb25zdHJ1Y3Rvcjtcblx0XHRcdGNvbnN0IGJ5dGVPZmZzZXQgPSBhcnJheS5CWVRFU19QRVJfRUxFTUVOVCAqIGF0dHIuaXRlbVNpemUgKiB0YXJnZXRPZmZzZXQ7XG5cdFx0XHRjb25zdCB0ZW1wID0gbmV3IGNvbnMoIGFycmF5LmJ1ZmZlciwgYnl0ZU9mZnNldCwgYXR0ci5hcnJheS5sZW5ndGggKTtcblx0XHRcdHRlbXAuc2V0KCBhdHRyLmFycmF5ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIEFkZHMgdGhlIFwibWF0cml4XCIgbXVsdGlwbGllZCBieSBcInNjYWxlXCIgdG8gXCJ0YXJnZXRcIlxuXHRmdW5jdGlvbiBhZGRTY2FsZWRNYXRyaXgoIHRhcmdldCwgbWF0cml4LCBzY2FsZSApIHtcblxuXHRcdGNvbnN0IHRhcmdldEFycmF5ID0gdGFyZ2V0LmVsZW1lbnRzO1xuXHRcdGNvbnN0IG1hdHJpeEFycmF5ID0gbWF0cml4LmVsZW1lbnRzO1xuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IG1hdHJpeEFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHRhcmdldEFycmF5WyBpIF0gKz0gbWF0cml4QXJyYXlbIGkgXSAqIHNjYWxlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBBIHZlcnNpb24gb2YgXCJTa2lubmVkTWVzaC5ib25lVHJhbnNmb3JtXCIgZm9yIG5vcm1hbHNcblx0ZnVuY3Rpb24gYm9uZU5vcm1hbFRyYW5zZm9ybSggbWVzaCwgaW5kZXgsIHRhcmdldCApIHtcblxuXHRcdGNvbnN0IHNrZWxldG9uID0gbWVzaC5za2VsZXRvbjtcblx0XHRjb25zdCBnZW9tZXRyeSA9IG1lc2guZ2VvbWV0cnk7XG5cdFx0Y29uc3QgYm9uZXMgPSBza2VsZXRvbi5ib25lcztcblx0XHRjb25zdCBib25lSW52ZXJzZXMgPSBza2VsZXRvbi5ib25lSW52ZXJzZXM7XG5cblx0XHRfc2tpbkluZGV4LmZyb21CdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LmF0dHJpYnV0ZXMuc2tpbkluZGV4LCBpbmRleCApO1xuXHRcdF9za2luV2VpZ2h0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LmF0dHJpYnV0ZXMuc2tpbldlaWdodCwgaW5kZXggKTtcblxuXHRcdF9tYXRyaXguZWxlbWVudHMuZmlsbCggMCApO1xuXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3Qgd2VpZ2h0ID0gX3NraW5XZWlnaHQuZ2V0Q29tcG9uZW50KCBpICk7XG5cblx0XHRcdGlmICggd2VpZ2h0ICE9PSAwICkge1xuXG5cdFx0XHRcdGNvbnN0IGJvbmVJbmRleCA9IF9za2luSW5kZXguZ2V0Q29tcG9uZW50KCBpICk7XG5cdFx0XHRcdF9ib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGJvbmVzWyBib25lSW5kZXggXS5tYXRyaXhXb3JsZCwgYm9uZUludmVyc2VzWyBib25lSW5kZXggXSApO1xuXG5cdFx0XHRcdGFkZFNjYWxlZE1hdHJpeCggX21hdHJpeCwgX2JvbmVNYXRyaXgsIHdlaWdodCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRfbWF0cml4Lm11bHRpcGx5KCBtZXNoLmJpbmRNYXRyaXggKS5wcmVtdWx0aXBseSggbWVzaC5iaW5kTWF0cml4SW52ZXJzZSApO1xuXHRcdHRhcmdldC50cmFuc2Zvcm1EaXJlY3Rpb24oIF9tYXRyaXggKTtcblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cblx0fVxuXG5cdC8vIEFwcGxpZXMgdGhlIG1vcnBoIHRhcmdldCBkYXRhIHRvIHRoZSB0YXJnZXQgdmVjdG9yXG5cdGZ1bmN0aW9uIGFwcGx5TW9ycGhUYXJnZXQoIG1vcnBoRGF0YSwgbW9ycGhJbmZsdWVuY2VzLCBtb3JwaFRhcmdldHNSZWxhdGl2ZSwgaSwgdGFyZ2V0ICkge1xuXG5cdFx0X21vcnBoVmVjdG9yLnNldCggMCwgMCwgMCApO1xuXHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBtb3JwaERhdGEubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdGNvbnN0IGluZmx1ZW5jZSA9IG1vcnBoSW5mbHVlbmNlc1sgaiBdO1xuXHRcdFx0Y29uc3QgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaERhdGFbIGogXTtcblxuXHRcdFx0aWYgKCBpbmZsdWVuY2UgPT09IDAgKSBjb250aW51ZTtcblxuXHRcdFx0X3RlbXAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhBdHRyaWJ1dGUsIGkgKTtcblxuXHRcdFx0aWYgKCBtb3JwaFRhcmdldHNSZWxhdGl2ZSApIHtcblxuXHRcdFx0XHRfbW9ycGhWZWN0b3IuYWRkU2NhbGVkVmVjdG9yKCBfdGVtcCwgaW5mbHVlbmNlICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0X21vcnBoVmVjdG9yLmFkZFNjYWxlZFZlY3RvciggX3RlbXAuc3ViKCB0YXJnZXQgKSwgaW5mbHVlbmNlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRhcmdldC5hZGQoIF9tb3JwaFZlY3RvciApO1xuXG5cdH1cblxuXHQvLyBNb2RpZmllZCB2ZXJzaW9uIG9mIEJ1ZmZlckdlb21ldHJ5VXRpbHMubWVyZ2VCdWZmZXJHZW9tZXRyaWVzIHRoYXQgaWdub3JlcyBtb3JwaCB0YXJnZXRzIGFuZCB1cGRhdGVzIGEgYXR0cmlidXRlcyBpbiBwbGFjZVxuXHRmdW5jdGlvbiBtZXJnZUJ1ZmZlckdlb21ldHJpZXMoIGdlb21ldHJpZXMsIG9wdGlvbnMgPSB7IHVzZUdyb3VwczogZmFsc2UsIHVwZGF0ZUluZGV4OiBmYWxzZSwgc2tpcEF0dHJpYnV0ZXM6IFtdIH0sIHRhcmdldEdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkgKSB7XG5cblx0XHRjb25zdCBpc0luZGV4ZWQgPSBnZW9tZXRyaWVzWyAwIF0uaW5kZXggIT09IG51bGw7XG5cdFx0Y29uc3QgeyB1c2VHcm91cHMgPSBmYWxzZSwgdXBkYXRlSW5kZXggPSBmYWxzZSwgc2tpcEF0dHJpYnV0ZXMgPSBbXSB9ID0gb3B0aW9ucztcblxuXHRcdGNvbnN0IGF0dHJpYnV0ZXNVc2VkID0gbmV3IFNldCggT2JqZWN0LmtleXMoIGdlb21ldHJpZXNbIDAgXS5hdHRyaWJ1dGVzICkgKTtcblx0XHRjb25zdCBhdHRyaWJ1dGVzID0ge307XG5cblx0XHRsZXQgb2Zmc2V0ID0gMDtcblxuXHRcdHRhcmdldEdlb21ldHJ5LmNsZWFyR3JvdXBzKCk7XG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gZ2VvbWV0cmllc1sgaSBdO1xuXHRcdFx0bGV0IGF0dHJpYnV0ZXNDb3VudCA9IDA7XG5cblx0XHRcdC8vIGVuc3VyZSB0aGF0IGFsbCBnZW9tZXRyaWVzIGFyZSBpbmRleGVkLCBvciBub25lXG5cdFx0XHRpZiAoIGlzSW5kZXhlZCAhPT0gKCBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCApICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1N0YXRpY0dlb21ldHJ5R2VuZXJhdG9yOiBBbGwgZ2VvbWV0cmllcyBtdXN0IGhhdmUgY29tcGF0aWJsZSBhdHRyaWJ1dGVzOyBtYWtlIHN1cmUgaW5kZXggYXR0cmlidXRlIGV4aXN0cyBhbW9uZyBhbGwgZ2VvbWV0cmllcywgb3IgaW4gbm9uZSBvZiB0aGVtLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBnYXRoZXIgYXR0cmlidXRlcywgZXhpdCBlYXJseSBpZiB0aGV5J3JlIGRpZmZlcmVudFxuXHRcdFx0Zm9yICggY29uc3QgbmFtZSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdGlmICggISBhdHRyaWJ1dGVzVXNlZC5oYXMoIG5hbWUgKSApIHtcblxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1N0YXRpY0dlb21ldHJ5R2VuZXJhdG9yOiBBbGwgZ2VvbWV0cmllcyBtdXN0IGhhdmUgY29tcGF0aWJsZSBhdHRyaWJ1dGVzOyBtYWtlIHN1cmUgXCInICsgbmFtZSArICdcIiBhdHRyaWJ1dGUgZXhpc3RzIGFtb25nIGFsbCBnZW9tZXRyaWVzLCBvciBpbiBub25lIG9mIHRoZW0uJyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0YXR0cmlidXRlc1sgbmFtZSBdID0gW107XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGF0dHJpYnV0ZXNbIG5hbWUgXS5wdXNoKCBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBuYW1lIF0gKTtcblx0XHRcdFx0YXR0cmlidXRlc0NvdW50ICsrO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGVuc3VyZSBnZW9tZXRyaWVzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGF0dHJpYnV0ZXNcblx0XHRcdGlmICggYXR0cmlidXRlc0NvdW50ICE9PSBhdHRyaWJ1dGVzVXNlZC5zaXplICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1N0YXRpY0dlb21ldHJ5R2VuZXJhdG9yOiBNYWtlIHN1cmUgYWxsIGdlb21ldHJpZXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgYXR0cmlidXRlcy4nICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB1c2VHcm91cHMgKSB7XG5cblx0XHRcdFx0bGV0IGNvdW50O1xuXHRcdFx0XHRpZiAoIGlzSW5kZXhlZCApIHtcblxuXHRcdFx0XHRcdGNvdW50ID0gZ2VvbWV0cnkuaW5kZXguY291bnQ7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y291bnQgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdTdGF0aWNHZW9tZXRyeUdlbmVyYXRvcjogVGhlIGdlb21ldHJ5IG11c3QgaGF2ZSBlaXRoZXIgYW4gaW5kZXggb3IgYSBwb3NpdGlvbiBhdHRyaWJ1dGUnICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRhcmdldEdlb21ldHJ5LmFkZEdyb3VwKCBvZmZzZXQsIGNvdW50LCBpICk7XG5cdFx0XHRcdG9mZnNldCArPSBjb3VudDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gbWVyZ2UgaW5kaWNlc1xuXHRcdGlmICggaXNJbmRleGVkICkge1xuXG5cdFx0XHRsZXQgZm9yY2VVcGRhdGVJbmRleCA9IGZhbHNlO1xuXHRcdFx0aWYgKCAhIHRhcmdldEdlb21ldHJ5LmluZGV4ICkge1xuXG5cdFx0XHRcdGxldCBpbmRleENvdW50ID0gMDtcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRpbmRleENvdW50ICs9IGdlb21ldHJpZXNbIGkgXS5pbmRleC5jb3VudDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0R2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50MzJBcnJheSggaW5kZXhDb3VudCApLCAxLCBmYWxzZSApICk7XG5cdFx0XHRcdGZvcmNlVXBkYXRlSW5kZXggPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdXBkYXRlSW5kZXggfHwgZm9yY2VVcGRhdGVJbmRleCApIHtcblxuXHRcdFx0XHRjb25zdCB0YXJnZXRJbmRleCA9IHRhcmdldEdlb21ldHJ5LmluZGV4O1xuXHRcdFx0XHRsZXQgdGFyZ2V0T2Zmc2V0ID0gMDtcblx0XHRcdFx0bGV0IGluZGV4T2Zmc2V0ID0gMDtcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBnZW9tZXRyeSA9IGdlb21ldHJpZXNbIGkgXTtcblx0XHRcdFx0XHRjb25zdCBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuXHRcdFx0XHRcdGlmICggc2tpcEF0dHJpYnV0ZXNbIGkgXSAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggbGV0IGogPSAwOyBqIDwgaW5kZXguY291bnQ7ICsrIGogKSB7XG5cblx0XHRcdFx0XHRcdFx0dGFyZ2V0SW5kZXguc2V0WCggdGFyZ2V0T2Zmc2V0LCBpbmRleC5nZXRYKCBqICkgKyBpbmRleE9mZnNldCApO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRPZmZzZXQgKys7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGluZGV4T2Zmc2V0ICs9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBtZXJnZSBhdHRyaWJ1dGVzXG5cdFx0Zm9yICggY29uc3QgbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRjb25zdCBhdHRyTGlzdCA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcblx0XHRcdGlmICggISAoIG5hbWUgaW4gdGFyZ2V0R2VvbWV0cnkuYXR0cmlidXRlcyApICkge1xuXG5cdFx0XHRcdGxldCBjb3VudCA9IDA7XG5cdFx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiBhdHRyTGlzdCApIHtcblxuXHRcdFx0XHRcdGNvdW50ICs9IGF0dHJMaXN0WyBrZXkgXS5jb3VudDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0R2VvbWV0cnkuc2V0QXR0cmlidXRlKCBuYW1lLCBjcmVhdGVBdHRyaWJ1dGVDbG9uZSggYXR0cmlidXRlc1sgbmFtZSBdWyAwIF0sIGNvdW50ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0YXJnZXRBdHRyaWJ1dGUgPSB0YXJnZXRHZW9tZXRyeS5hdHRyaWJ1dGVzWyBuYW1lIF07XG5cdFx0XHRsZXQgb2Zmc2V0ID0gMDtcblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGF0dHJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYXR0ciA9IGF0dHJMaXN0WyBpIF07XG5cdFx0XHRcdGlmICggc2tpcEF0dHJpYnV0ZXNbIGkgXSAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdGNvcHlBdHRyaWJ1dGVDb250ZW50cyggYXR0ciwgdGFyZ2V0QXR0cmlidXRlLCBvZmZzZXQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0b2Zmc2V0ICs9IGF0dHIuY291bnQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXRHZW9tZXRyeTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tUeXBlZEFycmF5RXF1YWxpdHkoIGEsIGIgKSB7XG5cblx0XHRpZiAoIGEgPT09IG51bGwgfHwgYiA9PT0gbnVsbCApIHtcblxuXHRcdFx0cmV0dXJuIGEgPT09IGI7XG5cblx0XHR9XG5cblx0XHRpZiAoIGEubGVuZ3RoICE9PSBiLmxlbmd0aCApIHtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRpZiAoIGFbIGkgXSAhPT0gYlsgaSBdICkge1xuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGludmVydEdlb21ldHJ5KCBnZW9tZXRyeSApIHtcblxuXHRcdGNvbnN0IHsgaW5kZXgsIGF0dHJpYnV0ZXMgfSA9IGdlb21ldHJ5O1xuXHRcdGlmICggaW5kZXggKSB7XG5cblx0XHRcdGZvciAoIGxldCBpID0gMCwgbCA9IGluZGV4LmNvdW50OyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdGNvbnN0IHYwID0gaW5kZXguZ2V0WCggaSApO1xuXHRcdFx0XHRjb25zdCB2MiA9IGluZGV4LmdldFgoIGkgKyAyICk7XG5cdFx0XHRcdGluZGV4LnNldFgoIGksIHYyICk7XG5cdFx0XHRcdGluZGV4LnNldFgoIGkgKyAyLCB2MCApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHRjb25zdCBhdHRyID0gYXR0cmlidXRlc1sga2V5IF07XG5cdFx0XHRcdGNvbnN0IGl0ZW1TaXplID0gYXR0ci5pdGVtU2l6ZTtcblx0XHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYXR0ci5jb3VudDsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IGl0ZW1TaXplOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHRjb25zdCB2MCA9IGF0dHIuZ2V0Q29tcG9uZW50KCBpLCBqICk7XG5cdFx0XHRcdFx0XHRjb25zdCB2MiA9IGF0dHIuZ2V0Q29tcG9uZW50KCBpICsgMiwgaiApO1xuXHRcdFx0XHRcdFx0YXR0ci5zZXRDb21wb25lbnQoIGksIGosIHYyICk7XG5cdFx0XHRcdFx0XHRhdHRyLnNldENvbXBvbmVudCggaSArIDIsIGosIHYwICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZ2VvbWV0cnk7XG5cblxuXHR9XG5cblx0Ly8gQ2hlY2tzIHdoZXRoZXIgdGhlIGdlb21ldHJ5IGNoYW5nZWQgYmV0d2VlbiB0aGlzIGFuZCBsYXN0IGV2YWx1YXRpb25cblx0Y2xhc3MgR2VvbWV0cnlEaWZmIHtcblxuXHRcdGNvbnN0cnVjdG9yKCBtZXNoICkge1xuXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblx0XHRcdHRoaXMuZ2VvbWV0cnlIYXNoID0gbnVsbDtcblx0XHRcdHRoaXMuYm9uZU1hdHJpY2VzID0gbnVsbDtcblx0XHRcdHRoaXMucHJpbWl0aXZlQ291bnQgPSAtIDE7XG5cdFx0XHR0aGlzLm1lc2ggPSBtZXNoO1xuXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0dXBkYXRlKCkge1xuXG5cdFx0XHRjb25zdCBtZXNoID0gdGhpcy5tZXNoO1xuXHRcdFx0Y29uc3QgZ2VvbWV0cnkgPSBtZXNoLmdlb21ldHJ5O1xuXHRcdFx0Y29uc3Qgc2tlbGV0b24gPSBtZXNoLnNrZWxldG9uO1xuXHRcdFx0Y29uc3QgcHJpbWl0aXZlQ291bnQgPSAoIGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnkuaW5kZXguY291bnQgOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50ICkgLyAzO1xuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCBtZXNoLm1hdHJpeFdvcmxkICk7XG5cdFx0XHR0aGlzLmdlb21ldHJ5SGFzaCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24udmVyc2lvbjtcblx0XHRcdHRoaXMucHJpbWl0aXZlQ291bnQgPSBwcmltaXRpdmVDb3VudDtcblxuXHRcdFx0aWYgKCBza2VsZXRvbiApIHtcblxuXHRcdFx0XHQvLyBlbnN1cmUgdGhlIGJvbmUgbWF0cml4IGFycmF5IGlzIHVwZGF0ZWQgdG8gdGhlIGFwcHJvcHJpYXRlIGxlbmd0aFxuXHRcdFx0XHRpZiAoICEgc2tlbGV0b24uYm9uZVRleHR1cmUgKSB7XG5cblx0XHRcdFx0XHRza2VsZXRvbi5jb21wdXRlQm9uZVRleHR1cmUoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2tlbGV0b24udXBkYXRlKCk7XG5cblx0XHRcdFx0Ly8gY29weSBkYXRhIGlmIHBvc3NpYmxlIG90aGVyd2lzZSBjbG9uZSBpdFxuXHRcdFx0XHRjb25zdCBib25lTWF0cmljZXMgPSBza2VsZXRvbi5ib25lTWF0cmljZXM7XG5cdFx0XHRcdGlmICggISB0aGlzLmJvbmVNYXRyaWNlcyB8fCB0aGlzLmJvbmVNYXRyaWNlcy5sZW5ndGggIT09IGJvbmVNYXRyaWNlcy5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IGJvbmVNYXRyaWNlcy5zbGljZSgpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aGlzLmJvbmVNYXRyaWNlcy5zZXQoIGJvbmVNYXRyaWNlcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG51bGw7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGRpZENoYW5nZSgpIHtcblxuXHRcdFx0Y29uc3QgbWVzaCA9IHRoaXMubWVzaDtcblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcblx0XHRcdGNvbnN0IHByaW1pdGl2ZUNvdW50ID0gKCBnZW9tZXRyeS5pbmRleCA/IGdlb21ldHJ5LmluZGV4LmNvdW50IDogZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudCApIC8gMztcblx0XHRcdGNvbnN0IGlkZW50aWNhbCA9XG5cdFx0XHRcdHRoaXMubWF0cml4V29ybGQuZXF1YWxzKCBtZXNoLm1hdHJpeFdvcmxkICkgJiZcblx0XHRcdFx0dGhpcy5nZW9tZXRyeUhhc2ggPT09IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24udmVyc2lvbiAmJlxuXHRcdFx0XHRjaGVja1R5cGVkQXJyYXlFcXVhbGl0eSggbWVzaC5za2VsZXRvbiAmJiBtZXNoLnNrZWxldG9uLmJvbmVNYXRyaWNlcyB8fCBudWxsLCB0aGlzLmJvbmVNYXRyaWNlcyApICYmXG5cdFx0XHRcdHRoaXMucHJpbWl0aXZlQ291bnQgPT09IHByaW1pdGl2ZUNvdW50O1xuXG5cdFx0XHRyZXR1cm4gISBpZGVudGljYWw7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNsYXNzIFN0YXRpY0dlb21ldHJ5R2VuZXJhdG9yIHtcblxuXHRcdGNvbnN0cnVjdG9yKCBtZXNoZXMgKSB7XG5cblx0XHRcdGlmICggISBBcnJheS5pc0FycmF5KCBtZXNoZXMgKSApIHtcblxuXHRcdFx0XHRtZXNoZXMgPSBbIG1lc2hlcyBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGZpbmFsTWVzaGVzID0gW107XG5cdFx0XHRtZXNoZXMuZm9yRWFjaCggb2JqZWN0ID0+IHtcblxuXHRcdFx0XHRvYmplY3QudHJhdmVyc2VWaXNpYmxlKCBjID0+IHtcblxuXHRcdFx0XHRcdGlmICggYy5pc01lc2ggKSB7XG5cblx0XHRcdFx0XHRcdGZpbmFsTWVzaGVzLnB1c2goIGMgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0dGhpcy5tZXNoZXMgPSBmaW5hbE1lc2hlcztcblx0XHRcdHRoaXMudXNlR3JvdXBzID0gdHJ1ZTtcblx0XHRcdHRoaXMuYXBwbHlXb3JsZFRyYW5zZm9ybXMgPSB0cnVlO1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzID0gWyAncG9zaXRpb24nLCAnbm9ybWFsJywgJ2NvbG9yJywgJ3RhbmdlbnQnLCAndXYnLCAndXYyJyBdO1xuXHRcdFx0dGhpcy5faW50ZXJtZWRpYXRlR2VvbWV0cnkgPSBuZXcgQXJyYXkoIGZpbmFsTWVzaGVzLmxlbmd0aCApLmZpbGwoKS5tYXAoICgpID0+IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpICk7XG5cdFx0XHR0aGlzLl9kaWZmTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuXHRcdH1cblxuXHRcdGdldE1hdGVyaWFscygpIHtcblxuXHRcdFx0Y29uc3QgbWF0ZXJpYWxzID0gW107XG5cdFx0XHR0aGlzLm1lc2hlcy5mb3JFYWNoKCBtZXNoID0+IHtcblxuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG1lc2gubWF0ZXJpYWwgKSApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFscy5wdXNoKCAuLi5tZXNoLm1hdGVyaWFsICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFscy5wdXNoKCBtZXNoLm1hdGVyaWFsICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWxzO1xuXG5cdFx0fVxuXG5cdFx0Z2VuZXJhdGUoIHRhcmdldEdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkgKSB7XG5cblx0XHRcdC8vIHRyYWNrIHdoaWNoIGF0dHJpYnV0ZXMgaGF2ZSBiZWVuIHVwZGF0ZWQgYW5kIHdoaWNoIHRvIHNraXAgdG8gYXZvaWQgdW5uZWNlc3NhcnkgYXR0cmlidXRlIGNvcGllc1xuXHRcdFx0bGV0IHNraXBBdHRyaWJ1dGVzID0gW107XG5cdFx0XHRjb25zdCB7IG1lc2hlcywgdXNlR3JvdXBzLCBfaW50ZXJtZWRpYXRlR2VvbWV0cnksIF9kaWZmTWFwIH0gPSB0aGlzO1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gbWVzaGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgbWVzaCA9IG1lc2hlc1sgaSBdO1xuXHRcdFx0XHRjb25zdCBnZW9tID0gX2ludGVybWVkaWF0ZUdlb21ldHJ5WyBpIF07XG5cdFx0XHRcdGNvbnN0IGRpZmYgPSBfZGlmZk1hcC5nZXQoIG1lc2ggKTtcblx0XHRcdFx0aWYgKCAhIGRpZmYgfHwgZGlmZi5kaWRDaGFuZ2UoIG1lc2ggKSApIHtcblxuXHRcdFx0XHRcdHRoaXMuX2NvbnZlcnRUb1N0YXRpY0dlb21ldHJ5KCBtZXNoLCBnZW9tICk7XG5cdFx0XHRcdFx0c2tpcEF0dHJpYnV0ZXMucHVzaCggZmFsc2UgKTtcblxuXHRcdFx0XHRcdGlmICggISBkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRfZGlmZk1hcC5zZXQoIG1lc2gsIG5ldyBHZW9tZXRyeURpZmYoIG1lc2ggKSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0ZGlmZi51cGRhdGUoKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0c2tpcEF0dHJpYnV0ZXMucHVzaCggdHJ1ZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIF9pbnRlcm1lZGlhdGVHZW9tZXRyeS5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0Ly8gaWYgdGhlcmUgYXJlIG5vIGdlb21ldHJpZXMgdGhlbiBqdXN0IGNyZWF0ZSBhIGZha2UgZW1wdHkgZ2VvbWV0cnkgdG8gcHJvdmlkZVxuXHRcdFx0XHR0YXJnZXRHZW9tZXRyeS5zZXRJbmRleCggbnVsbCApO1xuXG5cdFx0XHRcdC8vIHJlbW92ZSBhbGwgZ2VvbWV0cnlcblx0XHRcdFx0Y29uc3QgYXR0cnMgPSB0YXJnZXRHZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXHRcdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4gYXR0cnMgKSB7XG5cblx0XHRcdFx0XHR0YXJnZXRHZW9tZXRyeS5kZWxldGVBdHRyaWJ1dGUoIGtleSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjcmVhdGUgZHVtbXkgYXR0cmlidXRlc1xuXHRcdFx0XHRmb3IgKCBjb25zdCBrZXkgaW4gdGhpcy5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdFx0dGFyZ2V0R2VvbWV0cnkuc2V0QXR0cmlidXRlKCB0aGlzLmF0dHJpYnV0ZXNbIGtleSBdLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCAwICksIDQsIGZhbHNlICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCBfaW50ZXJtZWRpYXRlR2VvbWV0cnksIHsgdXNlR3JvdXBzLCBza2lwQXR0cmlidXRlcyB9LCB0YXJnZXRHZW9tZXRyeSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGNvbnN0IGtleSBpbiB0YXJnZXRHZW9tZXRyeS5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdHRhcmdldEdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0R2VvbWV0cnk7XG5cblx0XHR9XG5cblx0XHRfY29udmVydFRvU3RhdGljR2VvbWV0cnkoIG1lc2gsIHRhcmdldEdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkgKSB7XG5cblx0XHRcdGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5nZW9tZXRyeTtcblx0XHRcdGNvbnN0IGFwcGx5V29ybGRUcmFuc2Zvcm1zID0gdGhpcy5hcHBseVdvcmxkVHJhbnNmb3Jtcztcblx0XHRcdGNvbnN0IGluY2x1ZGVOb3JtYWwgPSB0aGlzLmF0dHJpYnV0ZXMuaW5jbHVkZXMoICdub3JtYWwnICk7XG5cdFx0XHRjb25zdCBpbmNsdWRlVGFuZ2VudCA9IHRoaXMuYXR0cmlidXRlcy5pbmNsdWRlcyggJ3RhbmdlbnQnICk7XG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRcdGNvbnN0IHRhcmdldEF0dHJpYnV0ZXMgPSB0YXJnZXRHZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG5cdFx0XHQvLyBpbml0aWFsaXplIHRoZSBhdHRyaWJ1dGVzIGlmIHRoZXkgZG9uJ3QgZXhpc3Rcblx0XHRcdGlmICggISB0YXJnZXRHZW9tZXRyeS5pbmRleCAmJiBnZW9tZXRyeS5pbmRleCApIHtcblxuXHRcdFx0XHR0YXJnZXRHZW9tZXRyeS5pbmRleCA9IGdlb21ldHJ5LmluZGV4LmNsb25lKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhIHRhcmdldEF0dHJpYnV0ZXMucG9zaXRpb24gKSB7XG5cblx0XHRcdFx0dGFyZ2V0R2VvbWV0cnkuc2V0QXR0cmlidXRlKCAncG9zaXRpb24nLCBjcmVhdGVBdHRyaWJ1dGVDbG9uZSggYXR0cmlidXRlcy5wb3NpdGlvbiApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpbmNsdWRlTm9ybWFsICYmICEgdGFyZ2V0QXR0cmlidXRlcy5ub3JtYWwgJiYgYXR0cmlidXRlcy5ub3JtYWwgKSB7XG5cblx0XHRcdFx0dGFyZ2V0R2VvbWV0cnkuc2V0QXR0cmlidXRlKCAnbm9ybWFsJywgY3JlYXRlQXR0cmlidXRlQ2xvbmUoIGF0dHJpYnV0ZXMubm9ybWFsICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGluY2x1ZGVUYW5nZW50ICYmICEgdGFyZ2V0QXR0cmlidXRlcy50YW5nZW50ICYmIGF0dHJpYnV0ZXMudGFuZ2VudCApIHtcblxuXHRcdFx0XHR0YXJnZXRHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoICd0YW5nZW50JywgY3JlYXRlQXR0cmlidXRlQ2xvbmUoIGF0dHJpYnV0ZXMudGFuZ2VudCApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZW5zdXJlIHRoZSBhdHRyaWJ1dGVzIGFyZSBjb25zaXN0ZW50XG5cdFx0XHR2YWxpZGF0ZUF0dHJpYnV0ZXMoIGdlb21ldHJ5LmluZGV4LCB0YXJnZXRHZW9tZXRyeS5pbmRleCApO1xuXHRcdFx0dmFsaWRhdGVBdHRyaWJ1dGVzKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCB0YXJnZXRBdHRyaWJ1dGVzLnBvc2l0aW9uICk7XG5cblx0XHRcdGlmICggaW5jbHVkZU5vcm1hbCApIHtcblxuXHRcdFx0XHR2YWxpZGF0ZUF0dHJpYnV0ZXMoIGF0dHJpYnV0ZXMubm9ybWFsLCB0YXJnZXRBdHRyaWJ1dGVzLm5vcm1hbCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaW5jbHVkZVRhbmdlbnQgKSB7XG5cblx0XHRcdFx0dmFsaWRhdGVBdHRyaWJ1dGVzKCBhdHRyaWJ1dGVzLnRhbmdlbnQsIHRhcmdldEF0dHJpYnV0ZXMudGFuZ2VudCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGdlbmVyYXRlIHRyYW5zZm9ybWVkIHZlcnRleCBhdHRyaWJ1dGUgZGF0YVxuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSBhdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0Y29uc3Qgbm9ybWFsID0gaW5jbHVkZU5vcm1hbCA/IGF0dHJpYnV0ZXMubm9ybWFsIDogbnVsbDtcblx0XHRcdGNvbnN0IHRhbmdlbnQgPSBpbmNsdWRlVGFuZ2VudCA/IGF0dHJpYnV0ZXMudGFuZ2VudCA6IG51bGw7XG5cdFx0XHRjb25zdCBtb3JwaFBvc2l0aW9uID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdFx0Y29uc3QgbW9ycGhOb3JtYWwgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsO1xuXHRcdFx0Y29uc3QgbW9ycGhUYW5nZW50ID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnRhbmdlbnQ7XG5cdFx0XHRjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuXHRcdFx0Y29uc3QgbW9ycGhJbmZsdWVuY2VzID0gbWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cdFx0XHRjb25zdCBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuXHRcdFx0bm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggbWVzaC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHQvLyBjb3B5IHRoZSBpbmRleFxuXHRcdFx0aWYgKCBnZW9tZXRyeS5pbmRleCApIHtcblxuXHRcdFx0XHR0YXJnZXRHZW9tZXRyeS5pbmRleC5hcnJheS5zZXQoIGdlb21ldHJ5LmluZGV4LmFycmF5ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY29weSBhbmQgYXBwbHkgb3RoZXIgYXR0cmlidXRlc1xuXHRcdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gYXR0cmlidXRlcy5wb3NpdGlvbi5jb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0X3Bvc2l0aW9uVmVjdG9yLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpICk7XG5cdFx0XHRcdGlmICggbm9ybWFsICkge1xuXG5cdFx0XHRcdFx0X25vcm1hbFZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWwsIGkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0YW5nZW50ICkge1xuXG5cdFx0XHRcdFx0X3RhbmdlbnRWZWN0b3I0LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHRhbmdlbnQsIGkgKTtcblx0XHRcdFx0XHRfdGFuZ2VudFZlY3Rvci5mcm9tQnVmZmVyQXR0cmlidXRlKCB0YW5nZW50LCBpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFwcGx5IG1vcnBoIHRhcmdldCB0cmFuc2Zvcm1cblx0XHRcdFx0aWYgKCBtb3JwaEluZmx1ZW5jZXMgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG1vcnBoUG9zaXRpb24gKSB7XG5cblx0XHRcdFx0XHRcdGFwcGx5TW9ycGhUYXJnZXQoIG1vcnBoUG9zaXRpb24sIG1vcnBoSW5mbHVlbmNlcywgbW9ycGhUYXJnZXRzUmVsYXRpdmUsIGksIF9wb3NpdGlvblZlY3RvciApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBtb3JwaE5vcm1hbCApIHtcblxuXHRcdFx0XHRcdFx0YXBwbHlNb3JwaFRhcmdldCggbW9ycGhOb3JtYWwsIG1vcnBoSW5mbHVlbmNlcywgbW9ycGhUYXJnZXRzUmVsYXRpdmUsIGksIF9ub3JtYWxWZWN0b3IgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggbW9ycGhUYW5nZW50ICkge1xuXG5cdFx0XHRcdFx0XHRhcHBseU1vcnBoVGFyZ2V0KCBtb3JwaFRhbmdlbnQsIG1vcnBoSW5mbHVlbmNlcywgbW9ycGhUYXJnZXRzUmVsYXRpdmUsIGksIF90YW5nZW50VmVjdG9yICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFwcGx5IGJvbmUgdHJhbnNmb3JtXG5cdFx0XHRcdGlmICggbWVzaC5pc1NraW5uZWRNZXNoICkge1xuXG5cdFx0XHRcdFx0bWVzaC5hcHBseUJvbmVUcmFuc2Zvcm0oIGksIF9wb3NpdGlvblZlY3RvciApO1xuXHRcdFx0XHRcdGlmICggbm9ybWFsICkge1xuXG5cdFx0XHRcdFx0XHRib25lTm9ybWFsVHJhbnNmb3JtKCBtZXNoLCBpLCBfbm9ybWFsVmVjdG9yICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHRhbmdlbnQgKSB7XG5cblx0XHRcdFx0XHRcdGJvbmVOb3JtYWxUcmFuc2Zvcm0oIG1lc2gsIGksIF90YW5nZW50VmVjdG9yICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHVwZGF0ZSB0aGUgdmVjdG9ycyBvZiB0aGUgYXR0cmlidXRlc1xuXHRcdFx0XHRpZiAoIGFwcGx5V29ybGRUcmFuc2Zvcm1zICkge1xuXG5cdFx0XHRcdFx0X3Bvc2l0aW9uVmVjdG9yLmFwcGx5TWF0cml4NCggbWVzaC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0YXJnZXRBdHRyaWJ1dGVzLnBvc2l0aW9uLnNldFhZWiggaSwgX3Bvc2l0aW9uVmVjdG9yLngsIF9wb3NpdGlvblZlY3Rvci55LCBfcG9zaXRpb25WZWN0b3IueiApO1xuXG5cdFx0XHRcdGlmICggbm9ybWFsICkge1xuXG5cdFx0XHRcdFx0aWYgKCBhcHBseVdvcmxkVHJhbnNmb3JtcyApIHtcblxuXHRcdFx0XHRcdFx0X25vcm1hbFZlY3Rvci5hcHBseU5vcm1hbE1hdHJpeCggbm9ybWFsTWF0cml4ICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0YXJnZXRBdHRyaWJ1dGVzLm5vcm1hbC5zZXRYWVooIGksIF9ub3JtYWxWZWN0b3IueCwgX25vcm1hbFZlY3Rvci55LCBfbm9ybWFsVmVjdG9yLnogKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0YW5nZW50ICkge1xuXG5cdFx0XHRcdFx0aWYgKCBhcHBseVdvcmxkVHJhbnNmb3JtcyApIHtcblxuXHRcdFx0XHRcdFx0X3RhbmdlbnRWZWN0b3IudHJhbnNmb3JtRGlyZWN0aW9uKCBtZXNoLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0YXJnZXRBdHRyaWJ1dGVzLnRhbmdlbnQuc2V0WFlaVyggaSwgX3RhbmdlbnRWZWN0b3IueCwgX3RhbmdlbnRWZWN0b3IueSwgX3RhbmdlbnRWZWN0b3IueiwgX3RhbmdlbnRWZWN0b3I0LncgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gY29weSBvdGhlciBhdHRyaWJ1dGVzIG92ZXJcblx0XHRcdGZvciAoIGNvbnN0IGkgaW4gdGhpcy5hdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdGNvbnN0IGtleSA9IHRoaXMuYXR0cmlidXRlc1sgaSBdO1xuXHRcdFx0XHRpZiAoIGtleSA9PT0gJ3Bvc2l0aW9uJyB8fCBrZXkgPT09ICd0YW5nZW50JyB8fCBrZXkgPT09ICdub3JtYWwnIHx8ICEgKCBrZXkgaW4gYXR0cmlidXRlcyApICkge1xuXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggISB0YXJnZXRBdHRyaWJ1dGVzWyBrZXkgXSApIHtcblxuXHRcdFx0XHRcdHRhcmdldEdlb21ldHJ5LnNldEF0dHJpYnV0ZSgga2V5LCBjcmVhdGVBdHRyaWJ1dGVDbG9uZSggYXR0cmlidXRlc1sga2V5IF0gKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YWxpZGF0ZUF0dHJpYnV0ZXMoIGF0dHJpYnV0ZXNbIGtleSBdLCB0YXJnZXRBdHRyaWJ1dGVzWyBrZXkgXSApO1xuXHRcdFx0XHRjb3B5QXR0cmlidXRlQ29udGVudHMoIGF0dHJpYnV0ZXNbIGtleSBdLCB0YXJnZXRBdHRyaWJ1dGVzWyBrZXkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWVzaC5tYXRyaXhXb3JsZC5kZXRlcm1pbmFudCgpIDwgMCApIHtcblxuXHRcdFx0XHRpbnZlcnRHZW9tZXRyeSggdGFyZ2V0R2VvbWV0cnkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0R2VvbWV0cnk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGNvbnN0IGNvbW1vbl9mdW5jdGlvbnMgPSAvKiBnbHNsICovYFxuXG4vLyBBIHN0YWNrIG9mIHVpbnQzMiBpbmRpY2VzIGNhbiBjYW4gc3RvcmUgdGhlIGluZGljZXMgZm9yXG4vLyBhIHBlcmZlY3RseSBiYWxhbmNlZCB0cmVlIHdpdGggYSBkZXB0aCB1cCB0byAzMS4gTG93ZXIgc3RhY2tcbi8vIGRlcHRoIGdldHMgaGlnaGVyIHBlcmZvcm1hbmNlLlxuLy9cbi8vIEhvd2V2ZXIgbm90IGFsbCB0cmVlcyBhcmUgYmFsYW5jZWQuIEJlc3QgdmFsdWUgdG8gc2V0IHRoaXMgdG9cbi8vIGlzIHRoZSB0cmVlcyBtYXggZGVwdGguXG4jaWZuZGVmIEJWSF9TVEFDS19ERVBUSFxuI2RlZmluZSBCVkhfU1RBQ0tfREVQVEggNjBcbiNlbmRpZlxuXG4jaWZuZGVmIElORklOSVRZXG4jZGVmaW5lIElORklOSVRZIDFlMjBcbiNlbmRpZlxuXG4vLyBVdGlsaXRpZXNcbnV2ZWM0IHVUZXhlbEZldGNoMUQoIHVzYW1wbGVyMkQgdGV4LCB1aW50IGluZGV4ICkge1xuXG5cdHVpbnQgd2lkdGggPSB1aW50KCB0ZXh0dXJlU2l6ZSggdGV4LCAwICkueCApO1xuXHR1dmVjMiB1djtcblx0dXYueCA9IGluZGV4ICUgd2lkdGg7XG5cdHV2LnkgPSBpbmRleCAvIHdpZHRoO1xuXG5cdHJldHVybiB0ZXhlbEZldGNoKCB0ZXgsIGl2ZWMyKCB1diApLCAwICk7XG5cbn1cblxuaXZlYzQgaVRleGVsRmV0Y2gxRCggaXNhbXBsZXIyRCB0ZXgsIHVpbnQgaW5kZXggKSB7XG5cblx0dWludCB3aWR0aCA9IHVpbnQoIHRleHR1cmVTaXplKCB0ZXgsIDAgKS54ICk7XG5cdHV2ZWMyIHV2O1xuXHR1di54ID0gaW5kZXggJSB3aWR0aDtcblx0dXYueSA9IGluZGV4IC8gd2lkdGg7XG5cblx0cmV0dXJuIHRleGVsRmV0Y2goIHRleCwgaXZlYzIoIHV2ICksIDAgKTtcblxufVxuXG52ZWM0IHRleGVsRmV0Y2gxRCggc2FtcGxlcjJEIHRleCwgdWludCBpbmRleCApIHtcblxuXHR1aW50IHdpZHRoID0gdWludCggdGV4dHVyZVNpemUoIHRleCwgMCApLnggKTtcblx0dXZlYzIgdXY7XG5cdHV2LnggPSBpbmRleCAlIHdpZHRoO1xuXHR1di55ID0gaW5kZXggLyB3aWR0aDtcblxuXHRyZXR1cm4gdGV4ZWxGZXRjaCggdGV4LCBpdmVjMiggdXYgKSwgMCApO1xuXG59XG5cbnZlYzQgdGV4dHVyZVNhbXBsZUJhcnljb29yZCggc2FtcGxlcjJEIHRleCwgdmVjMyBiYXJ5Y29vcmQsIHV2ZWMzIGZhY2VJbmRpY2VzICkge1xuXG5cdHJldHVyblxuXHRcdGJhcnljb29yZC54ICogdGV4ZWxGZXRjaDFEKCB0ZXgsIGZhY2VJbmRpY2VzLnggKSArXG5cdFx0YmFyeWNvb3JkLnkgKiB0ZXhlbEZldGNoMUQoIHRleCwgZmFjZUluZGljZXMueSApICtcblx0XHRiYXJ5Y29vcmQueiAqIHRleGVsRmV0Y2gxRCggdGV4LCBmYWNlSW5kaWNlcy56ICk7XG5cbn1cblxudm9pZCBuZGNUb0NhbWVyYVJheShcblx0dmVjMiBjb29yZCwgbWF0NCBjYW1lcmFXb3JsZCwgbWF0NCBpbnZQcm9qZWN0aW9uTWF0cml4LFxuXHRvdXQgdmVjMyByYXlPcmlnaW4sIG91dCB2ZWMzIHJheURpcmVjdGlvblxuKSB7XG5cblx0Ly8gZ2V0IGNhbWVyYSBsb29rIGRpcmVjdGlvbiBhbmQgbmVhciBwbGFuZSBmb3IgY2FtZXJhIGNsaXBwaW5nXG5cdHZlYzQgbG9va0RpcmVjdGlvbiA9IGNhbWVyYVdvcmxkICogdmVjNCggMC4wLCAwLjAsIC0gMS4wLCAwLjAgKTtcblx0dmVjNCBuZWFyVmVjdG9yID0gaW52UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQoIDAuMCwgMC4wLCAtIDEuMCwgMS4wICk7XG5cdGZsb2F0IG5lYXIgPSBhYnMoIG5lYXJWZWN0b3IueiAvIG5lYXJWZWN0b3IudyApO1xuXG5cdC8vIGdldCB0aGUgY2FtZXJhIGRpcmVjdGlvbiBhbmQgcG9zaXRpb24gZnJvbSBjYW1lcmEgbWF0cmljZXNcblx0dmVjNCBvcmlnaW4gPSBjYW1lcmFXb3JsZCAqIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApO1xuXHR2ZWM0IGRpcmVjdGlvbiA9IGludlByb2plY3Rpb25NYXRyaXggKiB2ZWM0KCBjb29yZCwgMC41LCAxLjAgKTtcblx0ZGlyZWN0aW9uIC89IGRpcmVjdGlvbi53O1xuXHRkaXJlY3Rpb24gPSBjYW1lcmFXb3JsZCAqIGRpcmVjdGlvbiAtIG9yaWdpbjtcblxuXHQvLyBzbGlkZSB0aGUgb3JpZ2luIGFsb25nIHRoZSByYXkgdW50aWwgaXQgc2l0cyBhdCB0aGUgbmVhciBjbGlwIHBsYW5lIHBvc2l0aW9uXG5cdG9yaWdpbi54eXogKz0gZGlyZWN0aW9uLnh5eiAqIG5lYXIgLyBkb3QoIGRpcmVjdGlvbiwgbG9va0RpcmVjdGlvbiApO1xuXG5cdHJheU9yaWdpbiA9IG9yaWdpbi54eXo7XG5cdHJheURpcmVjdGlvbiA9IGRpcmVjdGlvbi54eXo7XG5cbn1cbmA7XG5cblx0Ly8gRGlzdGFuY2UgdG8gUG9pbnRcblx0Y29uc3QgYnZoX2Rpc3RhbmNlX2Z1bmN0aW9ucyA9IC8qIGdsc2wgKi9gXG5cbmZsb2F0IGRvdDIoIHZlYzMgdiApIHtcblxuXHRyZXR1cm4gZG90KCB2LCB2ICk7XG5cbn1cblxuLy8gaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3L3R0ZkdXbFxudmVjMyBjbG9zZXN0UG9pbnRUb1RyaWFuZ2xlKCB2ZWMzIHAsIHZlYzMgdjAsIHZlYzMgdjEsIHZlYzMgdjIsIG91dCB2ZWMzIGJhcnljb29yZCApIHtcblxuICAgIHZlYzMgdjEwID0gdjEgLSB2MDtcbiAgICB2ZWMzIHYyMSA9IHYyIC0gdjE7XG4gICAgdmVjMyB2MDIgPSB2MCAtIHYyO1xuXG5cdHZlYzMgcDAgPSBwIC0gdjA7XG5cdHZlYzMgcDEgPSBwIC0gdjE7XG5cdHZlYzMgcDIgPSBwIC0gdjI7XG5cbiAgICB2ZWMzIG5vciA9IGNyb3NzKCB2MTAsIHYwMiApO1xuXG4gICAgLy8gbWV0aG9kIDIsIGluIGJhcnljZW50cmljIHNwYWNlXG4gICAgdmVjMyAgcSA9IGNyb3NzKCBub3IsIHAwICk7XG4gICAgZmxvYXQgZCA9IDEuMCAvIGRvdDIoIG5vciApO1xuICAgIGZsb2F0IHUgPSBkICogZG90KCBxLCB2MDIgKTtcbiAgICBmbG9hdCB2ID0gZCAqIGRvdCggcSwgdjEwICk7XG4gICAgZmxvYXQgdyA9IDEuMCAtIHUgLSB2O1xuXG5cdGlmKCB1IDwgMC4wICkge1xuXG5cdFx0dyA9IGNsYW1wKCBkb3QoIHAyLCB2MDIgKSAvIGRvdDIoIHYwMiApLCAwLjAsIDEuMCApO1xuXHRcdHUgPSAwLjA7XG5cdFx0diA9IDEuMCAtIHc7XG5cblx0fSBlbHNlIGlmKCB2IDwgMC4wICkge1xuXG5cdFx0dSA9IGNsYW1wKCBkb3QoIHAwLCB2MTAgKSAvIGRvdDIoIHYxMCApLCAwLjAsIDEuMCApO1xuXHRcdHYgPSAwLjA7XG5cdFx0dyA9IDEuMCAtIHU7XG5cblx0fSBlbHNlIGlmKCB3IDwgMC4wICkge1xuXG5cdFx0diA9IGNsYW1wKCBkb3QoIHAxLCB2MjEgKSAvIGRvdDIoIHYyMSApLCAwLjAsIDEuMCApO1xuXHRcdHcgPSAwLjA7XG5cdFx0dSA9IDEuMC12O1xuXG5cdH1cblxuXHRiYXJ5Y29vcmQgPSB2ZWMzKCB1LCB2LCB3ICk7XG4gICAgcmV0dXJuIHUgKiB2MSArIHYgKiB2MiArIHcgKiB2MDtcblxufVxuXG5mbG9hdCBkaXN0YW5jZVRvVHJpYW5nbGVzKFxuXHQvLyBnZW9tZXRyeSBpbmZvIGFuZCB0cmlhbmdsZSByYW5nZVxuXHRzYW1wbGVyMkQgcG9zaXRpb25BdHRyLCB1c2FtcGxlcjJEIGluZGV4QXR0ciwgdWludCBvZmZzZXQsIHVpbnQgY291bnQsXG5cblx0Ly8gcG9pbnQgYW5kIGN1dCBvZmYgcmFuZ2Vcblx0dmVjMyBwb2ludCwgZmxvYXQgY2xvc2VzdERpc3RhbmNlU3F1YXJlZCxcblxuXHQvLyBvdXRwdXRzXG5cdGlub3V0IHV2ZWM0IGZhY2VJbmRpY2VzLCBpbm91dCB2ZWMzIGZhY2VOb3JtYWwsIGlub3V0IHZlYzMgYmFyeWNvb3JkLCBpbm91dCBmbG9hdCBzaWRlLCBpbm91dCB2ZWMzIG91dFBvaW50XG4pIHtcblxuXHRib29sIGZvdW5kID0gZmFsc2U7XG5cdHZlYzMgbG9jYWxCYXJ5Y29vcmQ7XG5cdGZvciAoIHVpbnQgaSA9IG9mZnNldCwgbCA9IG9mZnNldCArIGNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdHV2ZWMzIGluZGljZXMgPSB1VGV4ZWxGZXRjaDFEKCBpbmRleEF0dHIsIGkgKS54eXo7XG5cdFx0dmVjMyBhID0gdGV4ZWxGZXRjaDFEKCBwb3NpdGlvbkF0dHIsIGluZGljZXMueCApLnJnYjtcblx0XHR2ZWMzIGIgPSB0ZXhlbEZldGNoMUQoIHBvc2l0aW9uQXR0ciwgaW5kaWNlcy55ICkucmdiO1xuXHRcdHZlYzMgYyA9IHRleGVsRmV0Y2gxRCggcG9zaXRpb25BdHRyLCBpbmRpY2VzLnogKS5yZ2I7XG5cblx0XHQvLyBnZXQgdGhlIGNsb3Nlc3QgcG9pbnQgYW5kIGJhcnljb29yZFxuXHRcdHZlYzMgY2xvc2VzdFBvaW50ID0gY2xvc2VzdFBvaW50VG9UcmlhbmdsZSggcG9pbnQsIGEsIGIsIGMsIGxvY2FsQmFyeWNvb3JkICk7XG5cdFx0dmVjMyBkZWx0YSA9IHBvaW50IC0gY2xvc2VzdFBvaW50O1xuXHRcdGZsb2F0IHNxRGlzdCA9IGRvdDIoIGRlbHRhICk7XG5cdFx0aWYgKCBzcURpc3QgPCBjbG9zZXN0RGlzdGFuY2VTcXVhcmVkICkge1xuXG5cdFx0XHQvLyBzZXQgdGhlIG91dHB1dCByZXN1bHRzXG5cdFx0XHRjbG9zZXN0RGlzdGFuY2VTcXVhcmVkID0gc3FEaXN0O1xuXHRcdFx0ZmFjZUluZGljZXMgPSB1dmVjNCggaW5kaWNlcy54eXosIGkgKTtcblx0XHRcdGZhY2VOb3JtYWwgPSBub3JtYWxpemUoIGNyb3NzKCBhIC0gYiwgYiAtIGMgKSApO1xuXHRcdFx0YmFyeWNvb3JkID0gbG9jYWxCYXJ5Y29vcmQ7XG5cdFx0XHRvdXRQb2ludCA9IGNsb3Nlc3RQb2ludDtcblx0XHRcdHNpZGUgPSBzaWduKCBkb3QoIGZhY2VOb3JtYWwsIGRlbHRhICkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQ7XG5cbn1cblxuZmxvYXQgZGlzdGFuY2VTcVRvQm91bmRzKCB2ZWMzIHBvaW50LCB2ZWMzIGJvdW5kc01pbiwgdmVjMyBib3VuZHNNYXggKSB7XG5cblx0dmVjMyBjbGFtcGVkUG9pbnQgPSBjbGFtcCggcG9pbnQsIGJvdW5kc01pbiwgYm91bmRzTWF4ICk7XG5cdHZlYzMgZGVsdGEgPSBwb2ludCAtIGNsYW1wZWRQb2ludDtcblx0cmV0dXJuIGRvdCggZGVsdGEsIGRlbHRhICk7XG5cbn1cblxuZmxvYXQgZGlzdGFuY2VTcVRvQlZITm9kZUJvdW5kc1BvaW50KCB2ZWMzIHBvaW50LCBzYW1wbGVyMkQgYnZoQm91bmRzLCB1aW50IGN1cnJOb2RlSW5kZXggKSB7XG5cblx0dWludCBjbmkyID0gY3Vyck5vZGVJbmRleCAqIDJ1O1xuXHR2ZWMzIGJvdW5kc01pbiA9IHRleGVsRmV0Y2gxRCggYnZoQm91bmRzLCBjbmkyICkueHl6O1xuXHR2ZWMzIGJvdW5kc01heCA9IHRleGVsRmV0Y2gxRCggYnZoQm91bmRzLCBjbmkyICsgMXUgKS54eXo7XG5cdHJldHVybiBkaXN0YW5jZVNxVG9Cb3VuZHMoIHBvaW50LCBib3VuZHNNaW4sIGJvdW5kc01heCApO1xuXG59XG5cbi8vIHVzZSBhIG1hY3JvIHRvIGhpZGUgdGhlIGZhY3QgdGhhdCB3ZSBuZWVkIHRvIGV4cGFuZCB0aGUgc3RydWN0IGludG8gc2VwYXJhdGUgZmllbGRzXG4jZGVmaW5lXFxcblx0YnZoQ2xvc2VzdFBvaW50VG9Qb2ludChcXFxuXHRcdGJ2aCxcXFxuXHRcdHBvaW50LCBmYWNlSW5kaWNlcywgZmFjZU5vcm1hbCwgYmFyeWNvb3JkLCBzaWRlLCBvdXRQb2ludFxcXG5cdClcXFxuXHRfYnZoQ2xvc2VzdFBvaW50VG9Qb2ludChcXFxuXHRcdGJ2aC5wb3NpdGlvbiwgYnZoLmluZGV4LCBidmguYnZoQm91bmRzLCBidmguYnZoQ29udGVudHMsXFxcblx0XHRwb2ludCwgZmFjZUluZGljZXMsIGZhY2VOb3JtYWwsIGJhcnljb29yZCwgc2lkZSwgb3V0UG9pbnRcXFxuXHQpXG5cbmZsb2F0IF9idmhDbG9zZXN0UG9pbnRUb1BvaW50KFxuXHQvLyBidmggaW5mb1xuXHRzYW1wbGVyMkQgYnZoX3Bvc2l0aW9uLCB1c2FtcGxlcjJEIGJ2aF9pbmRleCwgc2FtcGxlcjJEIGJ2aF9idmhCb3VuZHMsIHVzYW1wbGVyMkQgYnZoX2J2aENvbnRlbnRzLFxuXG5cdC8vIHBvaW50IHRvIGNoZWNrXG5cdHZlYzMgcG9pbnQsXG5cblx0Ly8gb3V0cHV0IHZhcmlhYmxlc1xuXHRpbm91dCB1dmVjNCBmYWNlSW5kaWNlcywgaW5vdXQgdmVjMyBmYWNlTm9ybWFsLCBpbm91dCB2ZWMzIGJhcnljb29yZCxcblx0aW5vdXQgZmxvYXQgc2lkZSwgaW5vdXQgdmVjMyBvdXRQb2ludFxuICkge1xuXG5cdC8vIHN0YWNrIG5lZWRzIHRvIGJlIHR3aWNlIGFzIGxvbmcgYXMgdGhlIGRlZXBlc3QgdHJlZSB3ZSBleHBlY3QgYmVjYXVzZVxuXHQvLyB3ZSBwdXNoIGJvdGggdGhlIGxlZnQgYW5kIHJpZ2h0IGNoaWxkIG9udG8gdGhlIHN0YWNrIGV2ZXJ5IHRyYXZlcnNhbFxuXHRpbnQgcHRyID0gMDtcblx0dWludCBzdGFja1sgQlZIX1NUQUNLX0RFUFRIIF07XG5cdHN0YWNrWyAwIF0gPSAwdTtcblxuXHRmbG9hdCBjbG9zZXN0RGlzdGFuY2VTcXVhcmVkID0gcG93KCAxMDAwMDAuMCwgMi4wICk7XG5cdGJvb2wgZm91bmQgPSBmYWxzZTtcblx0d2hpbGUgKCBwdHIgPiAtIDEgJiYgcHRyIDwgQlZIX1NUQUNLX0RFUFRIICkge1xuXG5cdFx0dWludCBjdXJyTm9kZUluZGV4ID0gc3RhY2tbIHB0ciBdO1xuXHRcdHB0ciAtLTtcblxuXHRcdC8vIGNoZWNrIGlmIHdlIGludGVyc2VjdCB0aGUgY3VycmVudCBib3VuZHNcblx0XHRmbG9hdCBib3VuZHNIaXREaXN0YW5jZSA9IGRpc3RhbmNlU3FUb0JWSE5vZGVCb3VuZHNQb2ludCggcG9pbnQsIGJ2aF9idmhCb3VuZHMsIGN1cnJOb2RlSW5kZXggKTtcblx0XHRpZiAoIGJvdW5kc0hpdERpc3RhbmNlID4gY2xvc2VzdERpc3RhbmNlU3F1YXJlZCApIHtcblxuXHRcdFx0Y29udGludWU7XG5cblx0XHR9XG5cblx0XHR1dmVjMiBib3VuZHNJbmZvID0gdVRleGVsRmV0Y2gxRCggYnZoX2J2aENvbnRlbnRzLCBjdXJyTm9kZUluZGV4ICkueHk7XG5cdFx0Ym9vbCBpc0xlYWYgPSBib29sKCBib3VuZHNJbmZvLnggJiAweGZmZmYwMDAwdSApO1xuXHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHR1aW50IGNvdW50ID0gYm91bmRzSW5mby54ICYgMHgwMDAwZmZmZnU7XG5cdFx0XHR1aW50IG9mZnNldCA9IGJvdW5kc0luZm8ueTtcblx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQgPSBkaXN0YW5jZVRvVHJpYW5nbGVzKFxuXHRcdFx0XHRidmhfcG9zaXRpb24sIGJ2aF9pbmRleCwgb2Zmc2V0LCBjb3VudCwgcG9pbnQsIGNsb3Nlc3REaXN0YW5jZVNxdWFyZWQsXG5cblx0XHRcdFx0Ly8gb3V0cHV0c1xuXHRcdFx0XHRmYWNlSW5kaWNlcywgZmFjZU5vcm1hbCwgYmFyeWNvb3JkLCBzaWRlLCBvdXRQb2ludFxuXHRcdFx0KTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHVpbnQgbGVmdEluZGV4ID0gY3Vyck5vZGVJbmRleCArIDF1O1xuXHRcdFx0dWludCBzcGxpdEF4aXMgPSBib3VuZHNJbmZvLnggJiAweDAwMDBmZmZmdTtcblx0XHRcdHVpbnQgcmlnaHRJbmRleCA9IGJvdW5kc0luZm8ueTtcblx0XHRcdGJvb2wgbGVmdFRvUmlnaHQgPSBkaXN0YW5jZVNxVG9CVkhOb2RlQm91bmRzUG9pbnQoIHBvaW50LCBidmhfYnZoQm91bmRzLCBsZWZ0SW5kZXggKSA8IGRpc3RhbmNlU3FUb0JWSE5vZGVCb3VuZHNQb2ludCggcG9pbnQsIGJ2aF9idmhCb3VuZHMsIHJpZ2h0SW5kZXggKTsvL3JheURpcmVjdGlvblsgc3BsaXRBeGlzIF0gPj0gMC4wO1xuXHRcdFx0dWludCBjMSA9IGxlZnRUb1JpZ2h0ID8gbGVmdEluZGV4IDogcmlnaHRJbmRleDtcblx0XHRcdHVpbnQgYzIgPSBsZWZ0VG9SaWdodCA/IHJpZ2h0SW5kZXggOiBsZWZ0SW5kZXg7XG5cblx0XHRcdC8vIHNldCBjMiBpbiB0aGUgc3RhY2sgc28gd2UgdHJhdmVyc2UgaXQgbGF0ZXIuIFdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBhIHBvaW50ZXIgaW5cblx0XHRcdC8vIHRoZSBzdGFjayB3aGlsZSB3ZSB0cmF2ZXJzZS4gVGhlIHNlY29uZCBwb2ludGVyIGFkZGVkIGlzIHRoZSBvbmUgdGhhdCB3aWxsIGJlXG5cdFx0XHQvLyB0cmF2ZXJzZWQgZmlyc3Rcblx0XHRcdHB0ciArKztcblx0XHRcdHN0YWNrWyBwdHIgXSA9IGMyO1xuXHRcdFx0cHRyICsrO1xuXHRcdFx0c3RhY2tbIHB0ciBdID0gYzE7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiBzcXJ0KCBjbG9zZXN0RGlzdGFuY2VTcXVhcmVkICk7XG5cbn1cbmA7XG5cblx0Y29uc3QgYnZoX3JheV9mdW5jdGlvbnMgPSAvKiBnbHNsICovYFxuXG4jaWZuZGVmIFRSSV9JTlRFUlNFQ1RfRVBTSUxPTlxuI2RlZmluZSBUUklfSU5URVJTRUNUX0VQU0lMT04gMWUtNVxuI2VuZGlmXG5cbi8vIFJheWNhc3RpbmdcbmJvb2wgaW50ZXJzZWN0c0JvdW5kcyggdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLCB2ZWMzIGJvdW5kc01pbiwgdmVjMyBib3VuZHNNYXgsIG91dCBmbG9hdCBkaXN0ICkge1xuXG5cdC8vIGh0dHBzOi8vd3d3LnJlZGRpdC5jb20vci9vcGVuZ2wvY29tbWVudHMvOG50eno1L2Zhc3RfZ2xzbF9yYXlfYm94X2ludGVyc2VjdGlvbi9cblx0Ly8gaHR0cHM6Ly90YXZpYW5hdG9yLmNvbS8yMDExL3JheV9ib3guaHRtbFxuXHR2ZWMzIGludkRpciA9IDEuMCAvIHJheURpcmVjdGlvbjtcblxuXHQvLyBmaW5kIGludGVyc2VjdGlvbiBkaXN0YW5jZXMgZm9yIGVhY2ggcGxhbmVcblx0dmVjMyB0TWluUGxhbmUgPSBpbnZEaXIgKiAoIGJvdW5kc01pbiAtIHJheU9yaWdpbiApO1xuXHR2ZWMzIHRNYXhQbGFuZSA9IGludkRpciAqICggYm91bmRzTWF4IC0gcmF5T3JpZ2luICk7XG5cblx0Ly8gZ2V0IHRoZSBtaW4gYW5kIG1heCBkaXN0YW5jZXMgZnJvbSBlYWNoIGludGVyc2VjdGlvblxuXHR2ZWMzIHRNaW5IaXQgPSBtaW4oIHRNYXhQbGFuZSwgdE1pblBsYW5lICk7XG5cdHZlYzMgdE1heEhpdCA9IG1heCggdE1heFBsYW5lLCB0TWluUGxhbmUgKTtcblxuXHQvLyBnZXQgdGhlIGZ1cnRoZXN0IGhpdCBkaXN0YW5jZVxuXHR2ZWMyIHQgPSBtYXgoIHRNaW5IaXQueHgsIHRNaW5IaXQueXogKTtcblx0ZmxvYXQgdDAgPSBtYXgoIHQueCwgdC55ICk7XG5cblx0Ly8gZ2V0IHRoZSBtaW5pbXVtIGhpdCBkaXN0YW5jZVxuXHR0ID0gbWluKCB0TWF4SGl0Lnh4LCB0TWF4SGl0Lnl6ICk7XG5cdGZsb2F0IHQxID0gbWluKCB0LngsIHQueSApO1xuXG5cdC8vIHNldCBkaXN0YW5jZSB0byAwLjAgaWYgdGhlIHJheSBzdGFydHMgaW5zaWRlIHRoZSBib3hcblx0ZGlzdCA9IG1heCggdDAsIDAuMCApO1xuXG5cdHJldHVybiB0MSA+PSBkaXN0O1xuXG59XG5cbmJvb2wgaW50ZXJzZWN0c1RyaWFuZ2xlKFxuXHR2ZWMzIHJheU9yaWdpbiwgdmVjMyByYXlEaXJlY3Rpb24sIHZlYzMgYSwgdmVjMyBiLCB2ZWMzIGMsXG5cdG91dCB2ZWMzIGJhcnljb29yZCwgb3V0IHZlYzMgbm9ybSwgb3V0IGZsb2F0IGRpc3QsIG91dCBmbG9hdCBzaWRlXG4pIHtcblxuXHQvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80Mjc0MDc2NS9pbnRlcnNlY3Rpb24tYmV0d2Vlbi1saW5lLWFuZC10cmlhbmdsZS1pbi0zZFxuXHR2ZWMzIGVkZ2UxID0gYiAtIGE7XG5cdHZlYzMgZWRnZTIgPSBjIC0gYTtcblx0bm9ybSA9IGNyb3NzKCBlZGdlMSwgZWRnZTIgKTtcblxuXHRmbG9hdCBkZXQgPSAtIGRvdCggcmF5RGlyZWN0aW9uLCBub3JtICk7XG5cdGZsb2F0IGludmRldCA9IDEuMCAvIGRldDtcblxuXHR2ZWMzIEFPID0gcmF5T3JpZ2luIC0gYTtcblx0dmVjMyBEQU8gPSBjcm9zcyggQU8sIHJheURpcmVjdGlvbiApO1xuXG5cdHZlYzQgdXZ0O1xuXHR1dnQueCA9IGRvdCggZWRnZTIsIERBTyApICogaW52ZGV0O1xuXHR1dnQueSA9IC0gZG90KCBlZGdlMSwgREFPICkgKiBpbnZkZXQ7XG5cdHV2dC56ID0gZG90KCBBTywgbm9ybSApICogaW52ZGV0O1xuXHR1dnQudyA9IDEuMCAtIHV2dC54IC0gdXZ0Lnk7XG5cblx0Ly8gc2V0IHRoZSBoaXQgaW5mb3JtYXRpb25cblx0YmFyeWNvb3JkID0gdXZ0Lnd4eTsgLy8gYXJyYW5nZWQgaW4gQSwgQiwgQyBvcmRlclxuXHRkaXN0ID0gdXZ0Lno7XG5cdHNpZGUgPSBzaWduKCBkZXQgKTtcblx0bm9ybSA9IHNpZGUgKiBub3JtYWxpemUoIG5vcm0gKTtcblxuXHQvLyBhZGQgYW4gZXBzaWxvbiB0byBhdm9pZCBtaXNzZXMgYmV0d2VlbiB0cmlhbmdsZXNcblx0dXZ0ICs9IHZlYzQoIFRSSV9JTlRFUlNFQ1RfRVBTSUxPTiApO1xuXG5cdHJldHVybiBhbGwoIGdyZWF0ZXJUaGFuRXF1YWwoIHV2dCwgdmVjNCggMC4wICkgKSApO1xuXG59XG5cbmJvb2wgaW50ZXJzZWN0VHJpYW5nbGVzKFxuXHQvLyBnZW9tZXRyeSBpbmZvIGFuZCB0cmlhbmdsZSByYW5nZVxuXHRzYW1wbGVyMkQgcG9zaXRpb25BdHRyLCB1c2FtcGxlcjJEIGluZGV4QXR0ciwgdWludCBvZmZzZXQsIHVpbnQgY291bnQsXG5cblx0Ly8gcmF5XG5cdHZlYzMgcmF5T3JpZ2luLCB2ZWMzIHJheURpcmVjdGlvbixcblxuXHQvLyBvdXRwdXRzXG5cdGlub3V0IGZsb2F0IG1pbkRpc3RhbmNlLCBpbm91dCB1dmVjNCBmYWNlSW5kaWNlcywgaW5vdXQgdmVjMyBmYWNlTm9ybWFsLCBpbm91dCB2ZWMzIGJhcnljb29yZCxcblx0aW5vdXQgZmxvYXQgc2lkZSwgaW5vdXQgZmxvYXQgZGlzdFxuKSB7XG5cblx0Ym9vbCBmb3VuZCA9IGZhbHNlO1xuXHR2ZWMzIGxvY2FsQmFyeWNvb3JkLCBsb2NhbE5vcm1hbDtcblx0ZmxvYXQgbG9jYWxEaXN0LCBsb2NhbFNpZGU7XG5cdGZvciAoIHVpbnQgaSA9IG9mZnNldCwgbCA9IG9mZnNldCArIGNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdHV2ZWMzIGluZGljZXMgPSB1VGV4ZWxGZXRjaDFEKCBpbmRleEF0dHIsIGkgKS54eXo7XG5cdFx0dmVjMyBhID0gdGV4ZWxGZXRjaDFEKCBwb3NpdGlvbkF0dHIsIGluZGljZXMueCApLnJnYjtcblx0XHR2ZWMzIGIgPSB0ZXhlbEZldGNoMUQoIHBvc2l0aW9uQXR0ciwgaW5kaWNlcy55ICkucmdiO1xuXHRcdHZlYzMgYyA9IHRleGVsRmV0Y2gxRCggcG9zaXRpb25BdHRyLCBpbmRpY2VzLnogKS5yZ2I7XG5cblx0XHRpZiAoXG5cdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGUoIHJheU9yaWdpbiwgcmF5RGlyZWN0aW9uLCBhLCBiLCBjLCBsb2NhbEJhcnljb29yZCwgbG9jYWxOb3JtYWwsIGxvY2FsRGlzdCwgbG9jYWxTaWRlIClcblx0XHRcdCYmIGxvY2FsRGlzdCA8IG1pbkRpc3RhbmNlXG5cdFx0KSB7XG5cblx0XHRcdGZvdW5kID0gdHJ1ZTtcblx0XHRcdG1pbkRpc3RhbmNlID0gbG9jYWxEaXN0O1xuXG5cdFx0XHRmYWNlSW5kaWNlcyA9IHV2ZWM0KCBpbmRpY2VzLnh5eiwgaSApO1xuXHRcdFx0ZmFjZU5vcm1hbCA9IGxvY2FsTm9ybWFsO1xuXG5cdFx0XHRzaWRlID0gbG9jYWxTaWRlO1xuXHRcdFx0YmFyeWNvb3JkID0gbG9jYWxCYXJ5Y29vcmQ7XG5cdFx0XHRkaXN0ID0gbG9jYWxEaXN0O1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gZm91bmQ7XG5cbn1cblxuYm9vbCBpbnRlcnNlY3RzQlZITm9kZUJvdW5kcyggdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLCBzYW1wbGVyMkQgYnZoQm91bmRzLCB1aW50IGN1cnJOb2RlSW5kZXgsIG91dCBmbG9hdCBkaXN0ICkge1xuXG5cdHVpbnQgY25pMiA9IGN1cnJOb2RlSW5kZXggKiAydTtcblx0dmVjMyBib3VuZHNNaW4gPSB0ZXhlbEZldGNoMUQoIGJ2aEJvdW5kcywgY25pMiApLnh5ejtcblx0dmVjMyBib3VuZHNNYXggPSB0ZXhlbEZldGNoMUQoIGJ2aEJvdW5kcywgY25pMiArIDF1ICkueHl6O1xuXHRyZXR1cm4gaW50ZXJzZWN0c0JvdW5kcyggcmF5T3JpZ2luLCByYXlEaXJlY3Rpb24sIGJvdW5kc01pbiwgYm91bmRzTWF4LCBkaXN0ICk7XG5cbn1cblxuLy8gdXNlIGEgbWFjcm8gdG8gaGlkZSB0aGUgZmFjdCB0aGF0IHdlIG5lZWQgdG8gZXhwYW5kIHRoZSBzdHJ1Y3QgaW50byBzZXBhcmF0ZSBmaWVsZHNcbiNkZWZpbmVcXFxuXHRidmhJbnRlcnNlY3RGaXJzdEhpdChcXFxuXHRcdGJ2aCxcXFxuXHRcdHJheU9yaWdpbiwgcmF5RGlyZWN0aW9uLCBmYWNlSW5kaWNlcywgZmFjZU5vcm1hbCwgYmFyeWNvb3JkLCBzaWRlLCBkaXN0XFxcblx0KVxcXG5cdF9idmhJbnRlcnNlY3RGaXJzdEhpdChcXFxuXHRcdGJ2aC5wb3NpdGlvbiwgYnZoLmluZGV4LCBidmguYnZoQm91bmRzLCBidmguYnZoQ29udGVudHMsXFxcblx0XHRyYXlPcmlnaW4sIHJheURpcmVjdGlvbiwgZmFjZUluZGljZXMsIGZhY2VOb3JtYWwsIGJhcnljb29yZCwgc2lkZSwgZGlzdFxcXG5cdClcblxuYm9vbCBfYnZoSW50ZXJzZWN0Rmlyc3RIaXQoXG5cdC8vIGJ2aCBpbmZvXG5cdHNhbXBsZXIyRCBidmhfcG9zaXRpb24sIHVzYW1wbGVyMkQgYnZoX2luZGV4LCBzYW1wbGVyMkQgYnZoX2J2aEJvdW5kcywgdXNhbXBsZXIyRCBidmhfYnZoQ29udGVudHMsXG5cblx0Ly8gcmF5XG5cdHZlYzMgcmF5T3JpZ2luLCB2ZWMzIHJheURpcmVjdGlvbixcblxuXHQvLyBvdXRwdXQgdmFyaWFibGVzIHNwbGl0IGludG8gc2VwYXJhdGUgdmFyaWFibGVzIGR1ZSB0byBvdXRwdXQgcHJlY2lzaW9uXG5cdGlub3V0IHV2ZWM0IGZhY2VJbmRpY2VzLCBpbm91dCB2ZWMzIGZhY2VOb3JtYWwsIGlub3V0IHZlYzMgYmFyeWNvb3JkLFxuXHRpbm91dCBmbG9hdCBzaWRlLCBpbm91dCBmbG9hdCBkaXN0XG4pIHtcblxuXHQvLyBzdGFjayBuZWVkcyB0byBiZSB0d2ljZSBhcyBsb25nIGFzIHRoZSBkZWVwZXN0IHRyZWUgd2UgZXhwZWN0IGJlY2F1c2Vcblx0Ly8gd2UgcHVzaCBib3RoIHRoZSBsZWZ0IGFuZCByaWdodCBjaGlsZCBvbnRvIHRoZSBzdGFjayBldmVyeSB0cmF2ZXJzYWxcblx0aW50IHB0ciA9IDA7XG5cdHVpbnQgc3RhY2tbIEJWSF9TVEFDS19ERVBUSCBdO1xuXHRzdGFja1sgMCBdID0gMHU7XG5cblx0ZmxvYXQgdHJpYW5nbGVEaXN0YW5jZSA9IElORklOSVRZO1xuXHRib29sIGZvdW5kID0gZmFsc2U7XG5cdHdoaWxlICggcHRyID4gLSAxICYmIHB0ciA8IEJWSF9TVEFDS19ERVBUSCApIHtcblxuXHRcdHVpbnQgY3Vyck5vZGVJbmRleCA9IHN0YWNrWyBwdHIgXTtcblx0XHRwdHIgLS07XG5cblx0XHQvLyBjaGVjayBpZiB3ZSBpbnRlcnNlY3QgdGhlIGN1cnJlbnQgYm91bmRzXG5cdFx0ZmxvYXQgYm91bmRzSGl0RGlzdGFuY2U7XG5cdFx0aWYgKFxuXHRcdFx0ISBpbnRlcnNlY3RzQlZITm9kZUJvdW5kcyggcmF5T3JpZ2luLCByYXlEaXJlY3Rpb24sIGJ2aF9idmhCb3VuZHMsIGN1cnJOb2RlSW5kZXgsIGJvdW5kc0hpdERpc3RhbmNlIClcblx0XHRcdHx8IGJvdW5kc0hpdERpc3RhbmNlID4gdHJpYW5nbGVEaXN0YW5jZVxuXHRcdCkge1xuXG5cdFx0XHRjb250aW51ZTtcblxuXHRcdH1cblxuXHRcdHV2ZWMyIGJvdW5kc0luZm8gPSB1VGV4ZWxGZXRjaDFEKCBidmhfYnZoQ29udGVudHMsIGN1cnJOb2RlSW5kZXggKS54eTtcblx0XHRib29sIGlzTGVhZiA9IGJvb2woIGJvdW5kc0luZm8ueCAmIDB4ZmZmZjAwMDB1ICk7XG5cblx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0dWludCBjb3VudCA9IGJvdW5kc0luZm8ueCAmIDB4MDAwMGZmZmZ1O1xuXHRcdFx0dWludCBvZmZzZXQgPSBib3VuZHNJbmZvLnk7XG5cblx0XHRcdGZvdW5kID0gaW50ZXJzZWN0VHJpYW5nbGVzKFxuXHRcdFx0XHRidmhfcG9zaXRpb24sIGJ2aF9pbmRleCwgb2Zmc2V0LCBjb3VudCxcblx0XHRcdFx0cmF5T3JpZ2luLCByYXlEaXJlY3Rpb24sIHRyaWFuZ2xlRGlzdGFuY2UsXG5cdFx0XHRcdGZhY2VJbmRpY2VzLCBmYWNlTm9ybWFsLCBiYXJ5Y29vcmQsIHNpZGUsIGRpc3Rcblx0XHRcdCkgfHwgZm91bmQ7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR1aW50IGxlZnRJbmRleCA9IGN1cnJOb2RlSW5kZXggKyAxdTtcblx0XHRcdHVpbnQgc3BsaXRBeGlzID0gYm91bmRzSW5mby54ICYgMHgwMDAwZmZmZnU7XG5cdFx0XHR1aW50IHJpZ2h0SW5kZXggPSBib3VuZHNJbmZvLnk7XG5cblx0XHRcdGJvb2wgbGVmdFRvUmlnaHQgPSByYXlEaXJlY3Rpb25bIHNwbGl0QXhpcyBdID49IDAuMDtcblx0XHRcdHVpbnQgYzEgPSBsZWZ0VG9SaWdodCA/IGxlZnRJbmRleCA6IHJpZ2h0SW5kZXg7XG5cdFx0XHR1aW50IGMyID0gbGVmdFRvUmlnaHQgPyByaWdodEluZGV4IDogbGVmdEluZGV4O1xuXG5cdFx0XHQvLyBzZXQgYzIgaW4gdGhlIHN0YWNrIHNvIHdlIHRyYXZlcnNlIGl0IGxhdGVyLiBXZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgYSBwb2ludGVyIGluXG5cdFx0XHQvLyB0aGUgc3RhY2sgd2hpbGUgd2UgdHJhdmVyc2UuIFRoZSBzZWNvbmQgcG9pbnRlciBhZGRlZCBpcyB0aGUgb25lIHRoYXQgd2lsbCBiZVxuXHRcdFx0Ly8gdHJhdmVyc2VkIGZpcnN0XG5cdFx0XHRwdHIgKys7XG5cdFx0XHRzdGFja1sgcHRyIF0gPSBjMjtcblxuXHRcdFx0cHRyICsrO1xuXHRcdFx0c3RhY2tbIHB0ciBdID0gYzE7XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiBmb3VuZDtcblxufVxuYDtcblxuXHQvLyBOb3RlIHRoYXQgYSBzdHJ1Y3QgY2Fubm90IGJlIHVzZWQgZm9yIHRoZSBoaXQgcmVjb3JkIGluY2x1ZGluZyBmYWNlSW5kaWNlcywgZmFjZU5vcm1hbCwgYmFyeWNvb3JkLFxuXHQvLyBzaWRlLCBhbmQgZGlzdCBiZWNhdXNlIG9uIHNvbWUgbW9iaWxlIEdQVVMgKHN1Y2ggYXMgQWRyZW5vKSBudW1iZXJzIGFyZSBhZmZvcmRlZCBsZXNzIHByZWNpc2lvbiBzcGVjaWZpY2FsbHlcblx0Ly8gd2hlbiBpbiBhIHN0cnVjdCBsZWFkaW5nIHRvIGluYWNjdXJhdGUgaGl0IHJlc3VsdHMuIFNlZSBLaHJvbm9zR3JvdXAvV2ViR0wjMzM1MSBmb3IgbW9yZSBkZXRhaWxzLlxuXHRjb25zdCBidmhfc3RydWN0X2RlZmluaXRpb25zID0gLyogZ2xzbCAqL2BcbnN0cnVjdCBCVkgge1xuXG5cdHVzYW1wbGVyMkQgaW5kZXg7XG5cdHNhbXBsZXIyRCBwb3NpdGlvbjtcblxuXHRzYW1wbGVyMkQgYnZoQm91bmRzO1xuXHR1c2FtcGxlcjJEIGJ2aENvbnRlbnRzO1xuXG59O1xuYDtcblxuXHR2YXIgQlZIU2hhZGVyR0xTTCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0XHRfX3Byb3RvX186IG51bGwsXG5cdFx0YnZoX2Rpc3RhbmNlX2Z1bmN0aW9uczogYnZoX2Rpc3RhbmNlX2Z1bmN0aW9ucyxcblx0XHRidmhfcmF5X2Z1bmN0aW9uczogYnZoX3JheV9mdW5jdGlvbnMsXG5cdFx0YnZoX3N0cnVjdF9kZWZpbml0aW9uczogYnZoX3N0cnVjdF9kZWZpbml0aW9ucyxcblx0XHRjb21tb25fZnVuY3Rpb25zOiBjb21tb25fZnVuY3Rpb25zXG5cdH0pO1xuXG5cdGNvbnN0IHNoYWRlclN0cnVjdHMgPSBidmhfc3RydWN0X2RlZmluaXRpb25zO1xuXHRjb25zdCBzaGFkZXJEaXN0YW5jZUZ1bmN0aW9uID0gYnZoX2Rpc3RhbmNlX2Z1bmN0aW9ucztcblx0Y29uc3Qgc2hhZGVySW50ZXJzZWN0RnVuY3Rpb24gPSBgXG5cdCR7IGNvbW1vbl9mdW5jdGlvbnMgfVxuXHQkeyBidmhfcmF5X2Z1bmN0aW9ucyB9XG5gO1xuXG5cdGV4cG9ydHMuQVZFUkFHRSA9IEFWRVJBR0U7XG5cdGV4cG9ydHMuQlZIU2hhZGVyR0xTTCA9IEJWSFNoYWRlckdMU0w7XG5cdGV4cG9ydHMuQ0VOVEVSID0gQ0VOVEVSO1xuXHRleHBvcnRzLkNPTlRBSU5FRCA9IENPTlRBSU5FRDtcblx0ZXhwb3J0cy5FeHRlbmRlZFRyaWFuZ2xlID0gRXh0ZW5kZWRUcmlhbmdsZTtcblx0ZXhwb3J0cy5GbG9hdFZlcnRleEF0dHJpYnV0ZVRleHR1cmUgPSBGbG9hdFZlcnRleEF0dHJpYnV0ZVRleHR1cmU7XG5cdGV4cG9ydHMuSU5URVJTRUNURUQgPSBJTlRFUlNFQ1RFRDtcblx0ZXhwb3J0cy5JbnRWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlID0gSW50VmVydGV4QXR0cmlidXRlVGV4dHVyZTtcblx0ZXhwb3J0cy5NZXNoQlZIID0gTWVzaEJWSDtcblx0ZXhwb3J0cy5NZXNoQlZISGVscGVyID0gTWVzaEJWSEhlbHBlcjtcblx0ZXhwb3J0cy5NZXNoQlZIVW5pZm9ybVN0cnVjdCA9IE1lc2hCVkhVbmlmb3JtU3RydWN0O1xuXHRleHBvcnRzLk5PVF9JTlRFUlNFQ1RFRCA9IE5PVF9JTlRFUlNFQ1RFRDtcblx0ZXhwb3J0cy5PcmllbnRlZEJveCA9IE9yaWVudGVkQm94O1xuXHRleHBvcnRzLlNBSCA9IFNBSDtcblx0ZXhwb3J0cy5TdGF0aWNHZW9tZXRyeUdlbmVyYXRvciA9IFN0YXRpY0dlb21ldHJ5R2VuZXJhdG9yO1xuXHRleHBvcnRzLlVJbnRWZXJ0ZXhBdHRyaWJ1dGVUZXh0dXJlID0gVUludFZlcnRleEF0dHJpYnV0ZVRleHR1cmU7XG5cdGV4cG9ydHMuVmVydGV4QXR0cmlidXRlVGV4dHVyZSA9IFZlcnRleEF0dHJpYnV0ZVRleHR1cmU7XG5cdGV4cG9ydHMuYWNjZWxlcmF0ZWRSYXljYXN0ID0gYWNjZWxlcmF0ZWRSYXljYXN0O1xuXHRleHBvcnRzLmNvbXB1dGVCYXRjaGVkQm91bmRzVHJlZSA9IGNvbXB1dGVCYXRjaGVkQm91bmRzVHJlZTtcblx0ZXhwb3J0cy5jb21wdXRlQm91bmRzVHJlZSA9IGNvbXB1dGVCb3VuZHNUcmVlO1xuXHRleHBvcnRzLmRpc3Bvc2VCYXRjaGVkQm91bmRzVHJlZSA9IGRpc3Bvc2VCYXRjaGVkQm91bmRzVHJlZTtcblx0ZXhwb3J0cy5kaXNwb3NlQm91bmRzVHJlZSA9IGRpc3Bvc2VCb3VuZHNUcmVlO1xuXHRleHBvcnRzLmVzdGltYXRlTWVtb3J5SW5CeXRlcyA9IGVzdGltYXRlTWVtb3J5SW5CeXRlcztcblx0ZXhwb3J0cy5nZXRCVkhFeHRyZW1lcyA9IGdldEJWSEV4dHJlbWVzO1xuXHRleHBvcnRzLmdldEpTT05TdHJ1Y3R1cmUgPSBnZXRKU09OU3RydWN0dXJlO1xuXHRleHBvcnRzLmdldFRyaWFuZ2xlSGl0UG9pbnRJbmZvID0gZ2V0VHJpYW5nbGVIaXRQb2ludEluZm87XG5cdGV4cG9ydHMuc2hhZGVyRGlzdGFuY2VGdW5jdGlvbiA9IHNoYWRlckRpc3RhbmNlRnVuY3Rpb247XG5cdGV4cG9ydHMuc2hhZGVySW50ZXJzZWN0RnVuY3Rpb24gPSBzaGFkZXJJbnRlcnNlY3RGdW5jdGlvbjtcblx0ZXhwb3J0cy5zaGFkZXJTdHJ1Y3RzID0gc2hhZGVyU3RydWN0cztcblx0ZXhwb3J0cy52YWxpZGF0ZUJvdW5kcyA9IHZhbGlkYXRlQm91bmRzO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC51bWQuY2pzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-mesh-bvh/build/index.umd.cjs\n");

/***/ })

};
;