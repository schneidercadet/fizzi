/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/troika-three-text";
exports.ids = ["vendor-chunks/troika-three-text"];
exports.modules = {

/***/ "(ssr)/./node_modules/troika-three-text/dist/troika-three-text.umd.js":
/*!**********************************************************************!*\
  !*** ./node_modules/troika-three-text/dist/troika-three-text.umd.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.cjs\"), __webpack_require__(/*! troika-worker-utils */ \"(ssr)/./node_modules/troika-worker-utils/dist/troika-worker-utils.umd.js\"), __webpack_require__(/*! webgl-sdf-generator */ \"(ssr)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.js\"), __webpack_require__(/*! bidi-js */ \"(ssr)/./node_modules/bidi-js/dist/bidi.js\"), __webpack_require__(/*! troika-three-utils */ \"(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.umd.js\")) :\n  0;\n}(this, (function (exports, three, troikaWorkerUtils, createSDFGenerator, bidiFactory, troikaThreeUtils) { 'use strict';\n\n  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n  var createSDFGenerator__default = /*#__PURE__*/_interopDefaultLegacy(createSDFGenerator);\n  var bidiFactory__default = /*#__PURE__*/_interopDefaultLegacy(bidiFactory);\n\n  /*!\n  Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.\n  Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE\n  */\n  function typrFactory(){return \"undefined\"==typeof window&&(self.window=self),function(r){var e={parse:function(r){var t=e._bin,a=new Uint8Array(r);if(\"ttcf\"==t.readASCII(a,0,4)){var n=4;t.readUshort(a,n),n+=2,t.readUshort(a,n),n+=2;var o=t.readUint(a,n);n+=4;for(var s=[],i=0;i<o;i++){var h=t.readUint(a,n);n+=4,s.push(e._readFont(a,h));}return s}return [e._readFont(a,0)]},_readFont:function(r,t){var a=e._bin,n=t;a.readFixed(r,t),t+=4;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2;for(var s=[\"cmap\",\"head\",\"hhea\",\"maxp\",\"hmtx\",\"name\",\"OS/2\",\"post\",\"loca\",\"glyf\",\"kern\",\"CFF \",\"GDEF\",\"GPOS\",\"GSUB\",\"SVG \"],i={_data:r,_offset:n},h={},d=0;d<o;d++){var f=a.readASCII(r,t,4);t+=4,a.readUint(r,t),t+=4;var u=a.readUint(r,t);t+=4;var l=a.readUint(r,t);t+=4,h[f]={offset:u,length:l};}for(d=0;d<s.length;d++){var v=s[d];h[v]&&(i[v.trim()]=e[v.trim()].parse(r,h[v].offset,h[v].length,i));}return i},_tabOffset:function(r,t,a){for(var n=e._bin,o=n.readUshort(r,a+4),s=a+12,i=0;i<o;i++){var h=n.readASCII(r,s,4);s+=4,n.readUint(r,s),s+=4;var d=n.readUint(r,s);if(s+=4,n.readUint(r,s),s+=4,h==t)return d}return 0}};e._bin={readFixed:function(r,e){return (r[e]<<8|r[e+1])+(r[e+2]<<8|r[e+3])/65540},readF2dot14:function(r,t){return e._bin.readShort(r,t)/16384},readInt:function(r,t){return e._bin._view(r).getInt32(t)},readInt8:function(r,t){return e._bin._view(r).getInt8(t)},readShort:function(r,t){return e._bin._view(r).getInt16(t)},readUshort:function(r,t){return e._bin._view(r).getUint16(t)},readUshorts:function(r,t,a){for(var n=[],o=0;o<a;o++)n.push(e._bin.readUshort(r,t+2*o));return n},readUint:function(r,t){return e._bin._view(r).getUint32(t)},readUint64:function(r,t){return 4294967296*e._bin.readUint(r,t)+e._bin.readUint(r,t+4)},readASCII:function(r,e,t){for(var a=\"\",n=0;n<t;n++)a+=String.fromCharCode(r[e+n]);return a},readUnicode:function(r,e,t){for(var a=\"\",n=0;n<t;n++){var o=r[e++]<<8|r[e++];a+=String.fromCharCode(o);}return a},_tdec:\"undefined\"!=typeof window&&window.TextDecoder?new window.TextDecoder:null,readUTF8:function(r,t,a){var n=e._bin._tdec;return n&&0==t&&a==r.length?n.decode(r):e._bin.readASCII(r,t,a)},readBytes:function(r,e,t){for(var a=[],n=0;n<t;n++)a.push(r[e+n]);return a},readASCIIArray:function(r,e,t){for(var a=[],n=0;n<t;n++)a.push(String.fromCharCode(r[e+n]));return a},_view:function(r){return r._dataView||(r._dataView=r.buffer?new DataView(r.buffer,r.byteOffset,r.byteLength):new DataView(new Uint8Array(r).buffer))}},e._lctf={},e._lctf.parse=function(r,t,a,n,o){var s=e._bin,i={},h=t;s.readFixed(r,t),t+=4;var d=s.readUshort(r,t);t+=2;var f=s.readUshort(r,t);t+=2;var u=s.readUshort(r,t);return t+=2,i.scriptList=e._lctf.readScriptList(r,h+d),i.featureList=e._lctf.readFeatureList(r,h+f),i.lookupList=e._lctf.readLookupList(r,h+u,o),i},e._lctf.readLookupList=function(r,t,a){var n=e._bin,o=t,s=[],i=n.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var d=n.readUshort(r,t);t+=2;var f=e._lctf.readLookupTable(r,o+d,a);s.push(f);}return s},e._lctf.readLookupTable=function(r,t,a){var n=e._bin,o=t,s={tabs:[]};s.ltype=n.readUshort(r,t),t+=2,s.flag=n.readUshort(r,t),t+=2;var i=n.readUshort(r,t);t+=2;for(var h=s.ltype,d=0;d<i;d++){var f=n.readUshort(r,t);t+=2;var u=a(r,h,o+f,s);s.tabs.push(u);}return s},e._lctf.numOfOnes=function(r){for(var e=0,t=0;t<32;t++)0!=(r>>>t&1)&&e++;return e},e._lctf.readClassDef=function(r,t){var a=e._bin,n=[],o=a.readUshort(r,t);if(t+=2,1==o){var s=a.readUshort(r,t);t+=2;var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++)n.push(s+h),n.push(s+h),n.push(a.readUshort(r,t)),t+=2;}if(2==o){var d=a.readUshort(r,t);t+=2;for(h=0;h<d;h++)n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2;}return n},e._lctf.getInterval=function(r,e){for(var t=0;t<r.length;t+=3){var a=r[t],n=r[t+1];if(r[t+2],a<=e&&e<=n)return t}return -1},e._lctf.readCoverage=function(r,t){var a=e._bin,n={};n.fmt=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,1==n.fmt&&(n.tab=a.readUshorts(r,t,o)),2==n.fmt&&(n.tab=a.readUshorts(r,t,3*o)),n},e._lctf.coverageIndex=function(r,t){var a=r.tab;if(1==r.fmt)return a.indexOf(t);if(2==r.fmt){var n=e._lctf.getInterval(a,t);if(-1!=n)return a[n+2]+(t-a[n])}return -1},e._lctf.readFeatureList=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var d=a.readUshort(r,t);t+=2;var f=e._lctf.readFeatureTable(r,n+d);f.tag=h.trim(),o.push(f);}return o},e._lctf.readFeatureTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,s>0&&(o.featureParams=n+s);var i=a.readUshort(r,t);t+=2,o.tab=[];for(var h=0;h<i;h++)o.tab.push(a.readUshort(r,t+2*h));return o},e._lctf.readScriptList=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var d=a.readUshort(r,t);t+=2,o[h.trim()]=e._lctf.readScriptTable(r,n+d);}return o},e._lctf.readScriptTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,s>0&&(o.default=e._lctf.readLangSysTable(r,n+s));var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var d=a.readASCII(r,t,4);t+=4;var f=a.readUshort(r,t);t+=2,o[d.trim()]=e._lctf.readLangSysTable(r,n+f);}return o},e._lctf.readLangSysTable=function(r,t){var a=e._bin,n={};a.readUshort(r,t),t+=2,n.reqFeature=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,n.features=a.readUshorts(r,t,o),n},e.CFF={},e.CFF.parse=function(r,t,a){var n=e._bin;(r=new Uint8Array(r.buffer,t,a))[t=0],r[++t],r[++t],r[++t],t++;var o=[];t=e.CFF.readIndex(r,t,o);for(var s=[],i=0;i<o.length-1;i++)s.push(n.readASCII(r,t+o[i],o[i+1]-o[i]));t+=o[o.length-1];var h=[];t=e.CFF.readIndex(r,t,h);var d=[];for(i=0;i<h.length-1;i++)d.push(e.CFF.readDict(r,t+h[i],t+h[i+1]));t+=h[h.length-1];var f=d[0],u=[];t=e.CFF.readIndex(r,t,u);var l=[];for(i=0;i<u.length-1;i++)l.push(n.readASCII(r,t+u[i],u[i+1]-u[i]));if(t+=u[u.length-1],e.CFF.readSubrs(r,t,f),f.CharStrings){t=f.CharStrings;u=[];t=e.CFF.readIndex(r,t,u);var v=[];for(i=0;i<u.length-1;i++)v.push(n.readBytes(r,t+u[i],u[i+1]-u[i]));f.CharStrings=v;}if(f.ROS){t=f.FDArray;var c=[];t=e.CFF.readIndex(r,t,c),f.FDArray=[];for(i=0;i<c.length-1;i++){var p=e.CFF.readDict(r,t+c[i],t+c[i+1]);e.CFF._readFDict(r,p,l),f.FDArray.push(p);}t+=c[c.length-1],t=f.FDSelect,f.FDSelect=[];var U=r[t];if(t++,3!=U)throw U;var g=n.readUshort(r,t);t+=2;for(i=0;i<g+1;i++)f.FDSelect.push(n.readUshort(r,t),r[t+2]),t+=3;}return f.Encoding&&(f.Encoding=e.CFF.readEncoding(r,f.Encoding,f.CharStrings.length)),f.charset&&(f.charset=e.CFF.readCharset(r,f.charset,f.CharStrings.length)),e.CFF._readFDict(r,f,l),f},e.CFF._readFDict=function(r,t,a){var n;for(var o in t.Private&&(n=t.Private[1],t.Private=e.CFF.readDict(r,n,n+t.Private[0]),t.Private.Subrs&&e.CFF.readSubrs(r,n+t.Private.Subrs,t.Private)),t)-1!=[\"FamilyName\",\"FontName\",\"FullName\",\"Notice\",\"version\",\"Copyright\"].indexOf(o)&&(t[o]=a[t[o]-426+35]);},e.CFF.readSubrs=function(r,t,a){var n=e._bin,o=[];t=e.CFF.readIndex(r,t,o);var s,i=o.length;s=i<1240?107:i<33900?1131:32768,a.Bias=s,a.Subrs=[];for(var h=0;h<o.length-1;h++)a.Subrs.push(n.readBytes(r,t+o[h],o[h+1]-o[h]));},e.CFF.tableSE=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,0,111,112,113,114,0,115,116,117,118,119,120,121,122,0,123,0,124,125,126,127,128,129,130,131,0,132,133,0,134,135,136,137,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,138,0,139,0,0,0,0,140,141,142,143,0,0,0,0,0,144,0,0,0,145,0,0,146,147,148,149,0,0,0,0],e.CFF.glyphByUnicode=function(r,e){for(var t=0;t<r.charset.length;t++)if(r.charset[t]==e)return t;return -1},e.CFF.glyphBySE=function(r,t){return t<0||t>255?-1:e.CFF.glyphByUnicode(r,e.CFF.tableSE[t])},e.CFF.readEncoding=function(r,t,a){e._bin;var n=[\".notdef\"],o=r[t];if(t++,0!=o)throw \"error: unknown encoding format: \"+o;var s=r[t];t++;for(var i=0;i<s;i++)n.push(r[t+i]);return n},e.CFF.readCharset=function(r,t,a){var n=e._bin,o=[\".notdef\"],s=r[t];if(t++,0==s)for(var i=0;i<a;i++){var h=n.readUshort(r,t);t+=2,o.push(h);}else {if(1!=s&&2!=s)throw \"error: format: \"+s;for(;o.length<a;){h=n.readUshort(r,t);t+=2;var d=0;1==s?(d=r[t],t++):(d=n.readUshort(r,t),t+=2);for(i=0;i<=d;i++)o.push(h),h++;}}return o},e.CFF.readIndex=function(r,t,a){var n=e._bin,o=n.readUshort(r,t)+1,s=r[t+=2];if(t++,1==s)for(var i=0;i<o;i++)a.push(r[t+i]);else if(2==s)for(i=0;i<o;i++)a.push(n.readUshort(r,t+2*i));else if(3==s)for(i=0;i<o;i++)a.push(16777215&n.readUint(r,t+3*i-1));else if(1!=o)throw \"unsupported offset size: \"+s+\", count: \"+o;return (t+=o*s)-1},e.CFF.getCharString=function(r,t,a){var n=e._bin,o=r[t],s=r[t+1];r[t+2],r[t+3],r[t+4];var i=1,h=null,d=null;o<=20&&(h=o,i=1),12==o&&(h=100*o+s,i=2),21<=o&&o<=27&&(h=o,i=1),28==o&&(d=n.readShort(r,t+1),i=3),29<=o&&o<=31&&(h=o,i=1),32<=o&&o<=246&&(d=o-139,i=1),247<=o&&o<=250&&(d=256*(o-247)+s+108,i=2),251<=o&&o<=254&&(d=256*-(o-251)-s-108,i=2),255==o&&(d=n.readInt(r,t+1)/65535,i=5),a.val=null!=d?d:\"o\"+h,a.size=i;},e.CFF.readCharString=function(r,t,a){for(var n=t+a,o=e._bin,s=[];t<n;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var d=1,f=null,u=null;i<=20&&(f=i,d=1),12==i&&(f=100*i+h,d=2),19!=i&&20!=i||(f=i,d=2),21<=i&&i<=27&&(f=i,d=1),28==i&&(u=o.readShort(r,t+1),d=3),29<=i&&i<=31&&(f=i,d=1),32<=i&&i<=246&&(u=i-139,d=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,d=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,d=2),255==i&&(u=o.readInt(r,t+1)/65535,d=5),s.push(null!=u?u:\"o\"+f),t+=d;}return s},e.CFF.readDict=function(r,t,a){for(var n=e._bin,o={},s=[];t<a;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var d=1,f=null,u=null;if(28==i&&(u=n.readShort(r,t+1),d=3),29==i&&(u=n.readInt(r,t+1),d=5),32<=i&&i<=246&&(u=i-139,d=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,d=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,d=2),255==i)throw u=n.readInt(r,t+1)/65535,d=5,\"unknown number\";if(30==i){var l=[];for(d=1;;){var v=r[t+d];d++;var c=v>>4,p=15&v;if(15!=c&&l.push(c),15!=p&&l.push(p),15==p)break}for(var U=\"\",g=[0,1,2,3,4,5,6,7,8,9,\".\",\"e\",\"e-\",\"reserved\",\"-\",\"endOfNumber\"],S=0;S<l.length;S++)U+=g[l[S]];u=parseFloat(U);}if(i<=21)if(f=[\"version\",\"Notice\",\"FullName\",\"FamilyName\",\"Weight\",\"FontBBox\",\"BlueValues\",\"OtherBlues\",\"FamilyBlues\",\"FamilyOtherBlues\",\"StdHW\",\"StdVW\",\"escape\",\"UniqueID\",\"XUID\",\"charset\",\"Encoding\",\"CharStrings\",\"Private\",\"Subrs\",\"defaultWidthX\",\"nominalWidthX\"][i],d=1,12==i)f=[\"Copyright\",\"isFixedPitch\",\"ItalicAngle\",\"UnderlinePosition\",\"UnderlineThickness\",\"PaintType\",\"CharstringType\",\"FontMatrix\",\"StrokeWidth\",\"BlueScale\",\"BlueShift\",\"BlueFuzz\",\"StemSnapH\",\"StemSnapV\",\"ForceBold\",0,0,\"LanguageGroup\",\"ExpansionFactor\",\"initialRandomSeed\",\"SyntheticBase\",\"PostScript\",\"BaseFontName\",\"BaseFontBlend\",0,0,0,0,0,0,\"ROS\",\"CIDFontVersion\",\"CIDFontRevision\",\"CIDFontType\",\"CIDCount\",\"UIDBase\",\"FDArray\",\"FDSelect\",\"FontName\"][h],d=2;null!=f?(o[f]=1==s.length?s[0]:s,s=[]):s.push(u),t+=d;}return o},e.cmap={},e.cmap.parse=function(r,t,a){r=new Uint8Array(r.buffer,t,a),t=0;var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2;var i=[];o.tables=[];for(var h=0;h<s;h++){var d=n.readUshort(r,t);t+=2;var f=n.readUshort(r,t);t+=2;var u=n.readUint(r,t);t+=4;var l=\"p\"+d+\"e\"+f,v=i.indexOf(u);if(-1==v){var c;v=o.tables.length,i.push(u);var p=n.readUshort(r,u);0==p?c=e.cmap.parse0(r,u):4==p?c=e.cmap.parse4(r,u):6==p?c=e.cmap.parse6(r,u):12==p?c=e.cmap.parse12(r,u):console.debug(\"unknown format: \"+p,d,f,u),o.tables.push(c);}if(null!=o[l])throw \"multiple tables for one platform+encoding\";o[l]=v;}return o},e.cmap.parse0=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,n.map=[];for(var s=0;s<o-6;s++)n.map.push(r[t+s]);return n},e.cmap.parse4=function(r,t){var a=e._bin,n=t,o={};o.format=a.readUshort(r,t),t+=2;var s=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2;var i=a.readUshort(r,t);t+=2;var h=i/2;o.searchRange=a.readUshort(r,t),t+=2,o.entrySelector=a.readUshort(r,t),t+=2,o.rangeShift=a.readUshort(r,t),t+=2,o.endCount=a.readUshorts(r,t,h),t+=2*h,t+=2,o.startCount=a.readUshorts(r,t,h),t+=2*h,o.idDelta=[];for(var d=0;d<h;d++)o.idDelta.push(a.readShort(r,t)),t+=2;for(o.idRangeOffset=a.readUshorts(r,t,h),t+=2*h,o.glyphIdArray=[];t<n+s;)o.glyphIdArray.push(a.readUshort(r,t)),t+=2;return o},e.cmap.parse6=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,n.firstCode=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,n.glyphIdArray=[];for(var s=0;s<o;s++)n.glyphIdArray.push(a.readUshort(r,t)),t+=2;return n},e.cmap.parse12=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,t+=2,a.readUint(r,t),t+=4,a.readUint(r,t),t+=4;var o=a.readUint(r,t);t+=4,n.groups=[];for(var s=0;s<o;s++){var i=t+12*s,h=a.readUint(r,i+0),d=a.readUint(r,i+4),f=a.readUint(r,i+8);n.groups.push([h,d,f]);}return n},e.glyf={},e.glyf.parse=function(r,e,t,a){for(var n=[],o=0;o<a.maxp.numGlyphs;o++)n.push(null);return n},e.glyf._parseGlyf=function(r,t){var a=e._bin,n=r._data,o=e._tabOffset(n,\"glyf\",r._offset)+r.loca[t];if(r.loca[t]==r.loca[t+1])return null;var s={};if(s.noc=a.readShort(n,o),o+=2,s.xMin=a.readShort(n,o),o+=2,s.yMin=a.readShort(n,o),o+=2,s.xMax=a.readShort(n,o),o+=2,s.yMax=a.readShort(n,o),o+=2,s.xMin>=s.xMax||s.yMin>=s.yMax)return null;if(s.noc>0){s.endPts=[];for(var i=0;i<s.noc;i++)s.endPts.push(a.readUshort(n,o)),o+=2;var h=a.readUshort(n,o);if(o+=2,n.length-o<h)return null;s.instructions=a.readBytes(n,o,h),o+=h;var d=s.endPts[s.noc-1]+1;s.flags=[];for(i=0;i<d;i++){var f=n[o];if(o++,s.flags.push(f),0!=(8&f)){var u=n[o];o++;for(var l=0;l<u;l++)s.flags.push(f),i++;}}s.xs=[];for(i=0;i<d;i++){var v=0!=(2&s.flags[i]),c=0!=(16&s.flags[i]);v?(s.xs.push(c?n[o]:-n[o]),o++):c?s.xs.push(0):(s.xs.push(a.readShort(n,o)),o+=2);}s.ys=[];for(i=0;i<d;i++){v=0!=(4&s.flags[i]),c=0!=(32&s.flags[i]);v?(s.ys.push(c?n[o]:-n[o]),o++):c?s.ys.push(0):(s.ys.push(a.readShort(n,o)),o+=2);}var p=0,U=0;for(i=0;i<d;i++)p+=s.xs[i],U+=s.ys[i],s.xs[i]=p,s.ys[i]=U;}else {var g;s.parts=[];do{g=a.readUshort(n,o),o+=2;var S={m:{a:1,b:0,c:0,d:1,tx:0,ty:0},p1:-1,p2:-1};if(s.parts.push(S),S.glyphIndex=a.readUshort(n,o),o+=2,1&g){var m=a.readShort(n,o);o+=2;var b=a.readShort(n,o);o+=2;}else {m=a.readInt8(n,o);o++;b=a.readInt8(n,o);o++;}2&g?(S.m.tx=m,S.m.ty=b):(S.p1=m,S.p2=b),8&g?(S.m.a=S.m.d=a.readF2dot14(n,o),o+=2):64&g?(S.m.a=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2):128&g&&(S.m.a=a.readF2dot14(n,o),o+=2,S.m.b=a.readF2dot14(n,o),o+=2,S.m.c=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2);}while(32&g);if(256&g){var y=a.readUshort(n,o);o+=2,s.instr=[];for(i=0;i<y;i++)s.instr.push(n[o]),o++;}}return s},e.GDEF={},e.GDEF.parse=function(r,t,a,n){var o=t;t+=4;var s=e._bin.readUshort(r,t);return {glyphClassDef:0===s?null:e._lctf.readClassDef(r,o+s)}},e.GPOS={},e.GPOS.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GPOS.subt)},e.GPOS.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1==t||2==t||3==t||7==t||8==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,h+s);}if(1==t&&1==i.fmt){var d=o.readUshort(r,a);a+=2,0!=d&&(i.pos=e.GPOS.readValueRecord(r,a,d));}else if(2==t&&i.fmt>=1&&i.fmt<=2){d=o.readUshort(r,a);a+=2;var f=o.readUshort(r,a);a+=2;var u=e._lctf.numOfOnes(d),l=e._lctf.numOfOnes(f);if(1==i.fmt){i.pairsets=[];var v=o.readUshort(r,a);a+=2;for(var c=0;c<v;c++){var p=s+o.readUshort(r,a);a+=2;var U=o.readUshort(r,p);p+=2;for(var g=[],S=0;S<U;S++){var m=o.readUshort(r,p);p+=2,0!=d&&(P=e.GPOS.readValueRecord(r,p,d),p+=2*u),0!=f&&(x=e.GPOS.readValueRecord(r,p,f),p+=2*l),g.push({gid2:m,val1:P,val2:x});}i.pairsets.push(g);}}if(2==i.fmt){var b=o.readUshort(r,a);a+=2;var y=o.readUshort(r,a);a+=2;var F=o.readUshort(r,a);a+=2;var C=o.readUshort(r,a);a+=2,i.classDef1=e._lctf.readClassDef(r,s+b),i.classDef2=e._lctf.readClassDef(r,s+y),i.matrix=[];for(c=0;c<F;c++){var _=[];for(S=0;S<C;S++){var P=null,x=null;0!=d&&(P=e.GPOS.readValueRecord(r,a,d),a+=2*u),0!=f&&(x=e.GPOS.readValueRecord(r,a,f),a+=2*l),_.push({val1:P,val2:x});}i.matrix.push(_);}}}else if(4==t&&1==i.fmt)i.markCoverage=e._lctf.readCoverage(r,o.readUshort(r,a)+s),i.baseCoverage=e._lctf.readCoverage(r,o.readUshort(r,a+2)+s),i.markClassCount=o.readUshort(r,a+4),i.markArray=e.GPOS.readMarkArray(r,o.readUshort(r,a+6)+s),i.baseArray=e.GPOS.readBaseArray(r,o.readUshort(r,a+8)+s,i.markClassCount);else if(6==t&&1==i.fmt)i.mark1Coverage=e._lctf.readCoverage(r,o.readUshort(r,a)+s),i.mark2Coverage=e._lctf.readCoverage(r,o.readUshort(r,a+2)+s),i.markClassCount=o.readUshort(r,a+4),i.mark1Array=e.GPOS.readMarkArray(r,o.readUshort(r,a+6)+s),i.mark2Array=e.GPOS.readBaseArray(r,o.readUshort(r,a+8)+s,i.markClassCount);else {if(9==t&&1==i.fmt){var I=o.readUshort(r,a);a+=2;var w=o.readUint(r,a);if(a+=4,9==n.ltype)n.ltype=I;else if(n.ltype!=I)throw \"invalid extension substitution\";return e.GPOS.subt(r,n.ltype,s+w)}console.debug(\"unsupported GPOS table LookupType\",t,\"format\",i.fmt);}return i},e.GPOS.readValueRecord=function(r,t,a){var n=e._bin,o=[];return o.push(1&a?n.readShort(r,t):0),t+=1&a?2:0,o.push(2&a?n.readShort(r,t):0),t+=2&a?2:0,o.push(4&a?n.readShort(r,t):0),t+=4&a?2:0,o.push(8&a?n.readShort(r,t):0),t+=8&a?2:0,o},e.GPOS.readBaseArray=function(r,t,a){var n=e._bin,o=[],s=t,i=n.readUshort(r,t);t+=2;for(var h=0;h<i;h++){for(var d=[],f=0;f<a;f++)d.push(e.GPOS.readAnchorRecord(r,s+n.readUshort(r,t))),t+=2;o.push(d);}return o},e.GPOS.readMarkArray=function(r,t){var a=e._bin,n=[],o=t,s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=e.GPOS.readAnchorRecord(r,a.readUshort(r,t+2)+o);h.markClass=a.readUshort(r,t),n.push(h),t+=4;}return n},e.GPOS.readAnchorRecord=function(r,t){var a=e._bin,n={};return n.fmt=a.readUshort(r,t),n.x=a.readShort(r,t+2),n.y=a.readShort(r,t+4),n},e.GSUB={},e.GSUB.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GSUB.subt)},e.GSUB.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1!=t&&2!=t&&4!=t&&5!=t&&6!=t)return null;if(1==t||2==t||4==t||5==t&&i.fmt<=2||6==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,s+h);}if(1==t&&i.fmt>=1&&i.fmt<=2){if(1==i.fmt)i.delta=o.readShort(r,a),a+=2;else if(2==i.fmt){var d=o.readUshort(r,a);a+=2,i.newg=o.readUshorts(r,a,d),a+=2*i.newg.length;}}else if(2==t&&1==i.fmt){d=o.readUshort(r,a);a+=2,i.seqs=[];for(var f=0;f<d;f++){var u=o.readUshort(r,a)+s;a+=2;var l=o.readUshort(r,u);i.seqs.push(o.readUshorts(r,u+2,l));}}else if(4==t){i.vals=[];d=o.readUshort(r,a);a+=2;for(f=0;f<d;f++){var v=o.readUshort(r,a);a+=2,i.vals.push(e.GSUB.readLigatureSet(r,s+v));}}else if(5==t&&2==i.fmt){if(2==i.fmt){var c=o.readUshort(r,a);a+=2,i.cDef=e._lctf.readClassDef(r,s+c),i.scset=[];var p=o.readUshort(r,a);a+=2;for(f=0;f<p;f++){var U=o.readUshort(r,a);a+=2,i.scset.push(0==U?null:e.GSUB.readSubClassSet(r,s+U));}}}else if(6==t&&3==i.fmt){if(3==i.fmt){for(f=0;f<3;f++){d=o.readUshort(r,a);a+=2;for(var g=[],S=0;S<d;S++)g.push(e._lctf.readCoverage(r,s+o.readUshort(r,a+2*S)));a+=2*d,0==f&&(i.backCvg=g),1==f&&(i.inptCvg=g),2==f&&(i.ahedCvg=g);}d=o.readUshort(r,a);a+=2,i.lookupRec=e.GSUB.readSubstLookupRecords(r,a,d);}}else {if(7==t&&1==i.fmt){var m=o.readUshort(r,a);a+=2;var b=o.readUint(r,a);if(a+=4,9==n.ltype)n.ltype=m;else if(n.ltype!=m)throw \"invalid extension substitution\";return e.GSUB.subt(r,n.ltype,s+b)}console.debug(\"unsupported GSUB table LookupType\",t,\"format\",i.fmt);}return i},e.GSUB.readSubClassSet=function(r,t){var a=e._bin.readUshort,n=t,o=[],s=a(r,t);t+=2;for(var i=0;i<s;i++){var h=a(r,t);t+=2,o.push(e.GSUB.readSubClassRule(r,n+h));}return o},e.GSUB.readSubClassRule=function(r,t){var a=e._bin.readUshort,n={},o=a(r,t),s=a(r,t+=2);t+=2,n.input=[];for(var i=0;i<o-1;i++)n.input.push(a(r,t)),t+=2;return n.substLookupRecords=e.GSUB.readSubstLookupRecords(r,t,s),n},e.GSUB.readSubstLookupRecords=function(r,t,a){for(var n=e._bin.readUshort,o=[],s=0;s<a;s++)o.push(n(r,t),n(r,t+2)),t+=4;return o},e.GSUB.readChainSubClassSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readChainSubClassRule(r,n+h));}return o},e.GSUB.readChainSubClassRule=function(r,t){for(var a=e._bin,n={},o=[\"backtrack\",\"input\",\"lookahead\"],s=0;s<o.length;s++){var i=a.readUshort(r,t);t+=2,1==s&&i--,n[o[s]]=a.readUshorts(r,t,i),t+=2*n[o[s]].length;}i=a.readUshort(r,t);return t+=2,n.subst=a.readUshorts(r,t,2*i),t+=2*n.subst.length,n},e.GSUB.readLigatureSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readLigature(r,n+h));}return o},e.GSUB.readLigature=function(r,t){var a=e._bin,n={chain:[]};n.nglyph=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2;for(var s=0;s<o-1;s++)n.chain.push(a.readUshort(r,t)),t+=2;return n},e.head={},e.head.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.fontRevision=n.readFixed(r,t),t+=4,n.readUint(r,t),t+=4,n.readUint(r,t),t+=4,o.flags=n.readUshort(r,t),t+=2,o.unitsPerEm=n.readUshort(r,t),t+=2,o.created=n.readUint64(r,t),t+=8,o.modified=n.readUint64(r,t),t+=8,o.xMin=n.readShort(r,t),t+=2,o.yMin=n.readShort(r,t),t+=2,o.xMax=n.readShort(r,t),t+=2,o.yMax=n.readShort(r,t),t+=2,o.macStyle=n.readUshort(r,t),t+=2,o.lowestRecPPEM=n.readUshort(r,t),t+=2,o.fontDirectionHint=n.readShort(r,t),t+=2,o.indexToLocFormat=n.readShort(r,t),t+=2,o.glyphDataFormat=n.readShort(r,t),t+=2,o},e.hhea={},e.hhea.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.ascender=n.readShort(r,t),t+=2,o.descender=n.readShort(r,t),t+=2,o.lineGap=n.readShort(r,t),t+=2,o.advanceWidthMax=n.readUshort(r,t),t+=2,o.minLeftSideBearing=n.readShort(r,t),t+=2,o.minRightSideBearing=n.readShort(r,t),t+=2,o.xMaxExtent=n.readShort(r,t),t+=2,o.caretSlopeRise=n.readShort(r,t),t+=2,o.caretSlopeRun=n.readShort(r,t),t+=2,o.caretOffset=n.readShort(r,t),t+=2,t+=8,o.metricDataFormat=n.readShort(r,t),t+=2,o.numberOfHMetrics=n.readUshort(r,t),t+=2,o},e.hmtx={},e.hmtx.parse=function(r,t,a,n){for(var o=e._bin,s={aWidth:[],lsBearing:[]},i=0,h=0,d=0;d<n.maxp.numGlyphs;d++)d<n.hhea.numberOfHMetrics&&(i=o.readUshort(r,t),t+=2,h=o.readShort(r,t),t+=2),s.aWidth.push(i),s.lsBearing.push(h);return s},e.kern={},e.kern.parse=function(r,t,a,n){var o=e._bin,s=o.readUshort(r,t);if(t+=2,1==s)return e.kern.parseV1(r,t-2,a,n);var i=o.readUshort(r,t);t+=2;for(var h={glyph1:[],rval:[]},d=0;d<i;d++){t+=2;a=o.readUshort(r,t);t+=2;var f=o.readUshort(r,t);t+=2;var u=f>>>8;if(0!=(u&=15))throw \"unknown kern table format: \"+u;t=e.kern.readFormat0(r,t,h);}return h},e.kern.parseV1=function(r,t,a,n){var o=e._bin;o.readFixed(r,t),t+=4;var s=o.readUint(r,t);t+=4;for(var i={glyph1:[],rval:[]},h=0;h<s;h++){o.readUint(r,t),t+=4;var d=o.readUshort(r,t);t+=2,o.readUshort(r,t),t+=2;var f=d>>>8;if(0!=(f&=15))throw \"unknown kern table format: \"+f;t=e.kern.readFormat0(r,t,i);}return i},e.kern.readFormat0=function(r,t,a){var n=e._bin,o=-1,s=n.readUshort(r,t);t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2;for(var i=0;i<s;i++){var h=n.readUshort(r,t);t+=2;var d=n.readUshort(r,t);t+=2;var f=n.readShort(r,t);t+=2,h!=o&&(a.glyph1.push(h),a.rval.push({glyph2:[],vals:[]}));var u=a.rval[a.rval.length-1];u.glyph2.push(d),u.vals.push(f),o=h;}return t},e.loca={},e.loca.parse=function(r,t,a,n){var o=e._bin,s=[],i=n.head.indexToLocFormat,h=n.maxp.numGlyphs+1;if(0==i)for(var d=0;d<h;d++)s.push(o.readUshort(r,t+(d<<1))<<1);if(1==i)for(d=0;d<h;d++)s.push(o.readUint(r,t+(d<<2)));return s},e.maxp={},e.maxp.parse=function(r,t,a){var n=e._bin,o={},s=n.readUint(r,t);return t+=4,o.numGlyphs=n.readUshort(r,t),t+=2,65536==s&&(o.maxPoints=n.readUshort(r,t),t+=2,o.maxContours=n.readUshort(r,t),t+=2,o.maxCompositePoints=n.readUshort(r,t),t+=2,o.maxCompositeContours=n.readUshort(r,t),t+=2,o.maxZones=n.readUshort(r,t),t+=2,o.maxTwilightPoints=n.readUshort(r,t),t+=2,o.maxStorage=n.readUshort(r,t),t+=2,o.maxFunctionDefs=n.readUshort(r,t),t+=2,o.maxInstructionDefs=n.readUshort(r,t),t+=2,o.maxStackElements=n.readUshort(r,t),t+=2,o.maxSizeOfInstructions=n.readUshort(r,t),t+=2,o.maxComponentElements=n.readUshort(r,t),t+=2,o.maxComponentDepth=n.readUshort(r,t),t+=2),o},e.name={},e.name.parse=function(r,t,a){var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2,n.readUshort(r,t);for(var i,h=[\"copyright\",\"fontFamily\",\"fontSubfamily\",\"ID\",\"fullName\",\"version\",\"postScriptName\",\"trademark\",\"manufacturer\",\"designer\",\"description\",\"urlVendor\",\"urlDesigner\",\"licence\",\"licenceURL\",\"---\",\"typoFamilyName\",\"typoSubfamilyName\",\"compatibleFull\",\"sampleText\",\"postScriptCID\",\"wwsFamilyName\",\"wwsSubfamilyName\",\"lightPalette\",\"darkPalette\"],d=t+=2,f=0;f<s;f++){var u=n.readUshort(r,t);t+=2;var l=n.readUshort(r,t);t+=2;var v=n.readUshort(r,t);t+=2;var c=n.readUshort(r,t);t+=2;var p=n.readUshort(r,t);t+=2;var U=n.readUshort(r,t);t+=2;var g,S=h[c],m=d+12*s+U;if(0==u)g=n.readUnicode(r,m,p/2);else if(3==u&&0==l)g=n.readUnicode(r,m,p/2);else if(0==l)g=n.readASCII(r,m,p);else if(1==l)g=n.readUnicode(r,m,p/2);else if(3==l)g=n.readUnicode(r,m,p/2);else {if(1!=u)throw \"unknown encoding \"+l+\", platformID: \"+u;g=n.readASCII(r,m,p),console.debug(\"reading unknown MAC encoding \"+l+\" as ASCII\");}var b=\"p\"+u+\",\"+v.toString(16);null==o[b]&&(o[b]={}),o[b][void 0!==S?S:c]=g,o[b]._lang=v;}for(var y in o)if(null!=o[y].postScriptName&&1033==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName&&0==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName&&3084==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName)return o[y];for(var y in o){i=y;break}return console.debug(\"returning name table with languageID \"+o[i]._lang),o[i]},e[\"OS/2\"]={},e[\"OS/2\"].parse=function(r,t,a){var n=e._bin.readUshort(r,t);t+=2;var o={};if(0==n)e[\"OS/2\"].version0(r,t,o);else if(1==n)e[\"OS/2\"].version1(r,t,o);else if(2==n||3==n||4==n)e[\"OS/2\"].version2(r,t,o);else {if(5!=n)throw \"unknown OS/2 table version: \"+n;e[\"OS/2\"].version5(r,t,o);}return o},e[\"OS/2\"].version0=function(r,t,a){var n=e._bin;return a.xAvgCharWidth=n.readShort(r,t),t+=2,a.usWeightClass=n.readUshort(r,t),t+=2,a.usWidthClass=n.readUshort(r,t),t+=2,a.fsType=n.readUshort(r,t),t+=2,a.ySubscriptXSize=n.readShort(r,t),t+=2,a.ySubscriptYSize=n.readShort(r,t),t+=2,a.ySubscriptXOffset=n.readShort(r,t),t+=2,a.ySubscriptYOffset=n.readShort(r,t),t+=2,a.ySuperscriptXSize=n.readShort(r,t),t+=2,a.ySuperscriptYSize=n.readShort(r,t),t+=2,a.ySuperscriptXOffset=n.readShort(r,t),t+=2,a.ySuperscriptYOffset=n.readShort(r,t),t+=2,a.yStrikeoutSize=n.readShort(r,t),t+=2,a.yStrikeoutPosition=n.readShort(r,t),t+=2,a.sFamilyClass=n.readShort(r,t),t+=2,a.panose=n.readBytes(r,t,10),t+=10,a.ulUnicodeRange1=n.readUint(r,t),t+=4,a.ulUnicodeRange2=n.readUint(r,t),t+=4,a.ulUnicodeRange3=n.readUint(r,t),t+=4,a.ulUnicodeRange4=n.readUint(r,t),t+=4,a.achVendID=[n.readInt8(r,t),n.readInt8(r,t+1),n.readInt8(r,t+2),n.readInt8(r,t+3)],t+=4,a.fsSelection=n.readUshort(r,t),t+=2,a.usFirstCharIndex=n.readUshort(r,t),t+=2,a.usLastCharIndex=n.readUshort(r,t),t+=2,a.sTypoAscender=n.readShort(r,t),t+=2,a.sTypoDescender=n.readShort(r,t),t+=2,a.sTypoLineGap=n.readShort(r,t),t+=2,a.usWinAscent=n.readUshort(r,t),t+=2,a.usWinDescent=n.readUshort(r,t),t+=2},e[\"OS/2\"].version1=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version0(r,t,a),a.ulCodePageRange1=n.readUint(r,t),t+=4,a.ulCodePageRange2=n.readUint(r,t),t+=4},e[\"OS/2\"].version2=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version1(r,t,a),a.sxHeight=n.readShort(r,t),t+=2,a.sCapHeight=n.readShort(r,t),t+=2,a.usDefault=n.readUshort(r,t),t+=2,a.usBreak=n.readUshort(r,t),t+=2,a.usMaxContext=n.readUshort(r,t),t+=2},e[\"OS/2\"].version5=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version2(r,t,a),a.usLowerOpticalPointSize=n.readUshort(r,t),t+=2,a.usUpperOpticalPointSize=n.readUshort(r,t),t+=2},e.post={},e.post.parse=function(r,t,a){var n=e._bin,o={};return o.version=n.readFixed(r,t),t+=4,o.italicAngle=n.readFixed(r,t),t+=4,o.underlinePosition=n.readShort(r,t),t+=2,o.underlineThickness=n.readShort(r,t),t+=2,o},null==e&&(e={}),null==e.U&&(e.U={}),e.U.codeToGlyph=function(r,e){var t=r.cmap,a=-1;if(null!=t.p0e4?a=t.p0e4:null!=t.p3e1?a=t.p3e1:null!=t.p1e0?a=t.p1e0:null!=t.p0e3&&(a=t.p0e3),-1==a)throw \"no familiar platform and encoding!\";var n=t.tables[a];if(0==n.format)return e>=n.map.length?0:n.map[e];if(4==n.format){for(var o=-1,s=0;s<n.endCount.length;s++)if(e<=n.endCount[s]){o=s;break}if(-1==o)return 0;if(n.startCount[o]>e)return 0;return 65535&(0!=n.idRangeOffset[o]?n.glyphIdArray[e-n.startCount[o]+(n.idRangeOffset[o]>>1)-(n.idRangeOffset.length-o)]:e+n.idDelta[o])}if(12==n.format){if(e>n.groups[n.groups.length-1][1])return 0;for(s=0;s<n.groups.length;s++){var i=n.groups[s];if(i[0]<=e&&e<=i[1])return i[2]+(e-i[0])}return 0}throw \"unknown cmap table format \"+n.format},e.U.glyphToPath=function(r,t){var a={cmds:[],crds:[]};if(r.SVG&&r.SVG.entries[t]){var n=r.SVG.entries[t];return null==n?a:(\"string\"==typeof n&&(n=e.SVG.toPath(n),r.SVG.entries[t]=n),n)}if(r.CFF){var o={x:0,y:0,stack:[],nStems:0,haveWidth:!1,width:r.CFF.Private?r.CFF.Private.defaultWidthX:0,open:!1},s=r.CFF,i=r.CFF.Private;if(s.ROS){for(var h=0;s.FDSelect[h+2]<=t;)h+=2;i=s.FDArray[s.FDSelect[h+1]].Private;}e.U._drawCFF(r.CFF.CharStrings[t],o,s,i,a);}else r.glyf&&e.U._drawGlyf(t,r,a);return a},e.U._drawGlyf=function(r,t,a){var n=t.glyf[r];null==n&&(n=t.glyf[r]=e.glyf._parseGlyf(t,r)),null!=n&&(n.noc>-1?e.U._simpleGlyph(n,a):e.U._compoGlyph(n,t,a));},e.U._simpleGlyph=function(r,t){for(var a=0;a<r.noc;a++){for(var n=0==a?0:r.endPts[a-1]+1,o=r.endPts[a],s=n;s<=o;s++){var i=s==n?o:s-1,h=s==o?n:s+1,d=1&r.flags[s],f=1&r.flags[i],u=1&r.flags[h],l=r.xs[s],v=r.ys[s];if(s==n)if(d){if(!f){e.U.P.moveTo(t,l,v);continue}e.U.P.moveTo(t,r.xs[i],r.ys[i]);}else f?e.U.P.moveTo(t,r.xs[i],r.ys[i]):e.U.P.moveTo(t,(r.xs[i]+l)/2,(r.ys[i]+v)/2);d?f&&e.U.P.lineTo(t,l,v):u?e.U.P.qcurveTo(t,l,v,r.xs[h],r.ys[h]):e.U.P.qcurveTo(t,l,v,(l+r.xs[h])/2,(v+r.ys[h])/2);}e.U.P.closePath(t);}},e.U._compoGlyph=function(r,t,a){for(var n=0;n<r.parts.length;n++){var o={cmds:[],crds:[]},s=r.parts[n];e.U._drawGlyf(s.glyphIndex,t,o);for(var i=s.m,h=0;h<o.crds.length;h+=2){var d=o.crds[h],f=o.crds[h+1];a.crds.push(d*i.a+f*i.b+i.tx),a.crds.push(d*i.c+f*i.d+i.ty);}for(h=0;h<o.cmds.length;h++)a.cmds.push(o.cmds[h]);}},e.U._getGlyphClass=function(r,t){var a=e._lctf.getInterval(t,r);return -1==a?0:t[a+2]},e.U._applySubs=function(r,t,a,n){for(var o=r.length-t-1,s=0;s<a.tabs.length;s++)if(null!=a.tabs[s]){var i,h=a.tabs[s];if(!h.coverage||-1!=(i=e._lctf.coverageIndex(h.coverage,r[t])))if(1==a.ltype)r[t],1==h.fmt?r[t]=r[t]+h.delta:r[t]=h.newg[i];else if(4==a.ltype)for(var d=h.vals[i],f=0;f<d.length;f++){var u=d[f],l=u.chain.length;if(!(l>o)){for(var v=!0,c=0,p=0;p<l;p++){for(;-1==r[t+c+(1+p)];)c++;u.chain[p]!=r[t+c+(1+p)]&&(v=!1);}if(v){r[t]=u.nglyph;for(p=0;p<l+c;p++)r[t+p+1]=-1;break}}}else if(5==a.ltype&&2==h.fmt)for(var U=e._lctf.getInterval(h.cDef,r[t]),g=h.cDef[U+2],S=h.scset[g],m=0;m<S.length;m++){var b=S[m],y=b.input;if(!(y.length>o)){for(v=!0,p=0;p<y.length;p++){var F=e._lctf.getInterval(h.cDef,r[t+1+p]);if(-1==U&&h.cDef[F+2]!=y[p]){v=!1;break}}if(v){var C=b.substLookupRecords;for(f=0;f<C.length;f+=2)C[f],C[f+1];}}}else if(6==a.ltype&&3==h.fmt){if(!e.U._glsCovered(r,h.backCvg,t-h.backCvg.length))continue;if(!e.U._glsCovered(r,h.inptCvg,t))continue;if(!e.U._glsCovered(r,h.ahedCvg,t+h.inptCvg.length))continue;var _=h.lookupRec;for(m=0;m<_.length;m+=2){U=_[m];var P=n[_[m+1]];e.U._applySubs(r,t+U,P,n);}}}},e.U._glsCovered=function(r,t,a){for(var n=0;n<t.length;n++){if(-1==e._lctf.coverageIndex(t[n],r[a+n]))return !1}return !0},e.U.glyphsToPath=function(r,t,a){for(var n={cmds:[],crds:[]},o=0,s=0;s<t.length;s++){var i=t[s];if(-1!=i){for(var h=s<t.length-1&&-1!=t[s+1]?t[s+1]:0,d=e.U.glyphToPath(r,i),f=0;f<d.crds.length;f+=2)n.crds.push(d.crds[f]+o),n.crds.push(d.crds[f+1]);a&&n.cmds.push(a);for(f=0;f<d.cmds.length;f++)n.cmds.push(d.cmds[f]);a&&n.cmds.push(\"X\"),o+=r.hmtx.aWidth[i],s<t.length-1&&(o+=e.U.getPairAdjustment(r,i,h));}}return n},e.U.P={},e.U.P.moveTo=function(r,e,t){r.cmds.push(\"M\"),r.crds.push(e,t);},e.U.P.lineTo=function(r,e,t){r.cmds.push(\"L\"),r.crds.push(e,t);},e.U.P.curveTo=function(r,e,t,a,n,o,s){r.cmds.push(\"C\"),r.crds.push(e,t,a,n,o,s);},e.U.P.qcurveTo=function(r,e,t,a,n){r.cmds.push(\"Q\"),r.crds.push(e,t,a,n);},e.U.P.closePath=function(r){r.cmds.push(\"Z\");},e.U._drawCFF=function(r,t,a,n,o){for(var s=t.stack,i=t.nStems,h=t.haveWidth,d=t.width,f=t.open,u=0,l=t.x,v=t.y,c=0,p=0,U=0,g=0,S=0,m=0,b=0,y=0,F=0,C=0,_={val:0,size:0};u<r.length;){e.CFF.getCharString(r,u,_);var P=_.val;if(u+=_.size,\"o1\"==P||\"o18\"==P)s.length%2!=0&&!h&&(d=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;else if(\"o3\"==P||\"o23\"==P){s.length%2!=0&&!h&&(d=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;}else if(\"o4\"==P)s.length>1&&!h&&(d=s.shift()+n.nominalWidthX,h=!0),f&&e.U.P.closePath(o),v+=s.pop(),e.U.P.moveTo(o,l,v),f=!0;else if(\"o5\"==P)for(;s.length>0;)l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v);else if(\"o6\"==P||\"o7\"==P)for(var x=s.length,I=\"o6\"==P,w=0;w<x;w++){var k=s.shift();I?l+=k:v+=k,I=!I,e.U.P.lineTo(o,l,v);}else if(\"o8\"==P||\"o24\"==P){x=s.length;for(var G=0;G+6<=x;)c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v),G+=6;\"o24\"==P&&(l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v));}else {if(\"o11\"==P)break;if(\"o1234\"==P||\"o1235\"==P||\"o1236\"==P||\"o1237\"==P)\"o1234\"==P&&(p=v,U=(c=l+s.shift())+s.shift(),C=g=p+s.shift(),m=g,y=v,l=(b=(S=(F=U+s.shift())+s.shift())+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1235\"==P&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),C=g+s.shift(),S=F+s.shift(),m=C+s.shift(),b=S+s.shift(),y=m+s.shift(),l=b+s.shift(),v=y+s.shift(),s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1236\"==P&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),C=g=p+s.shift(),m=g,b=(S=(F=U+s.shift())+s.shift())+s.shift(),y=m+s.shift(),l=b+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1237\"==P&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),C=g+s.shift(),S=F+s.shift(),m=C+s.shift(),b=S+s.shift(),y=m+s.shift(),Math.abs(b-l)>Math.abs(y-v)?l=b+s.shift():v=y+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v));else if(\"o14\"==P){if(s.length>0&&!h&&(d=s.shift()+a.nominalWidthX,h=!0),4==s.length){var O=s.shift(),T=s.shift(),D=s.shift(),B=s.shift(),A=e.CFF.glyphBySE(a,D),R=e.CFF.glyphBySE(a,B);e.U._drawCFF(a.CharStrings[A],t,a,n,o),t.x=O,t.y=T,e.U._drawCFF(a.CharStrings[R],t,a,n,o);}f&&(e.U.P.closePath(o),f=!1);}else if(\"o19\"==P||\"o20\"==P){s.length%2!=0&&!h&&(d=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0,u+=i+7>>3;}else if(\"o21\"==P)s.length>2&&!h&&(d=s.shift()+n.nominalWidthX,h=!0),v+=s.pop(),l+=s.pop(),f&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),f=!0;else if(\"o22\"==P)s.length>1&&!h&&(d=s.shift()+n.nominalWidthX,h=!0),l+=s.pop(),f&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),f=!0;else if(\"o25\"==P){for(;s.length>6;)l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v);c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);}else if(\"o26\"==P)for(s.length%2&&(l+=s.shift());s.length>0;)c=l,p=v+s.shift(),l=U=c+s.shift(),v=(g=p+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);else if(\"o27\"==P)for(s.length%2&&(v+=s.shift());s.length>0;)p=v,U=(c=l+s.shift())+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g,e.U.P.curveTo(o,c,p,U,g,l,v);else if(\"o10\"==P||\"o29\"==P){var L=\"o10\"==P?n:a;if(0==s.length)console.debug(\"error: empty stack\");else {var W=s.pop(),M=L.Subrs[W+L.Bias];t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=d,t.open=f,e.U._drawCFF(M,t,a,n,o),l=t.x,v=t.y,i=t.nStems,h=t.haveWidth,d=t.width,f=t.open;}}else if(\"o30\"==P||\"o31\"==P){var V=s.length,E=(G=0,\"o31\"==P);for(G+=V-(x=-3&V);G<x;)E?(p=v,U=(c=l+s.shift())+s.shift(),v=(g=p+s.shift())+s.shift(),x-G==5?(l=U+s.shift(),G++):l=U,E=!1):(c=l,p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),x-G==5?(v=g+s.shift(),G++):v=g,E=!0),e.U.P.curveTo(o,c,p,U,g,l,v),G+=4;}else {if(\"o\"==(P+\"\").charAt(0))throw console.debug(\"Unknown operation: \"+P,r),P;s.push(P);}}}t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=d,t.open=f;};var t=e,a={Typr:t};return r.Typr=t,r.default=a,Object.defineProperty(r,\"__esModule\",{value:!0}),r}({}).Typr}\n\n  /*!\n  Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate\n  (https://github.com/101arrowz/fflate) for use in Troika text rendering. \n  Original licenses apply: \n  - fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)\n  - woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)\n  */\n  function woff2otfFactory(){return function(r){var e=Uint8Array,n=Uint16Array,t=Uint32Array,a=new e([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new e([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),o=new e([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),f=function(r,e){for(var a=new n(31),i=0;i<31;++i)a[i]=e+=1<<r[i-1];var o=new t(a[30]);for(i=1;i<30;++i)for(var f=a[i];f<a[i+1];++f)o[f]=f-a[i]<<5|i;return [a,o]},u=f(a,2),v=u[0],s=u[1];v[28]=258,s[258]=28;for(var l=f(i,0)[0],c=new n(32768),g=0;g<32768;++g){var h=(43690&g)>>>1|(21845&g)<<1;h=(61680&(h=(52428&h)>>>2|(13107&h)<<2))>>>4|(3855&h)<<4,c[g]=((65280&h)>>>8|(255&h)<<8)>>>1;}var w=function(r,e,t){for(var a=r.length,i=0,o=new n(e);i<a;++i)++o[r[i]-1];var f,u=new n(e);for(i=0;i<e;++i)u[i]=u[i-1]+o[i-1]<<1;if(t){f=new n(1<<e);var v=15-e;for(i=0;i<a;++i)if(r[i])for(var s=i<<4|r[i],l=e-r[i],g=u[r[i]-1]++<<l,h=g|(1<<l)-1;g<=h;++g)f[c[g]>>>v]=s;}else for(f=new n(a),i=0;i<a;++i)r[i]&&(f[i]=c[u[r[i]-1]++]>>>15-r[i]);return f},d=new e(288);for(g=0;g<144;++g)d[g]=8;for(g=144;g<256;++g)d[g]=9;for(g=256;g<280;++g)d[g]=7;for(g=280;g<288;++g)d[g]=8;var m=new e(32);for(g=0;g<32;++g)m[g]=5;var b=w(d,9,1),p=w(m,5,1),y=function(r){for(var e=r[0],n=1;n<r.length;++n)r[n]>e&&(e=r[n]);return e},L=function(r,e,n){var t=e/8|0;return (r[t]|r[t+1]<<8)>>(7&e)&n},U=function(r,e){var n=e/8|0;return (r[n]|r[n+1]<<8|r[n+2]<<16)>>(7&e)},k=[\"unexpected EOF\",\"invalid block type\",\"invalid length/literal\",\"invalid distance\",\"stream finished\",\"no stream handler\",,\"no callback\",\"invalid UTF-8 data\",\"extra field too long\",\"date not in range 1980-2099\",\"filename too long\",\"stream finishing\",\"invalid zip data\"],T=function(r,e,n){var t=new Error(e||k[r]);if(t.code=r,Error.captureStackTrace&&Error.captureStackTrace(t,T),!n)throw t;return t},O=function(r,f,u){var s=r.length;if(!s||u&&!u.l&&s<5)return f||new e(0);var c=!f||u,g=!u||u.i;u||(u={}),f||(f=new e(3*s));var h,d=function(r){var n=f.length;if(r>n){var t=new e(Math.max(2*n,r));t.set(f),f=t;}},m=u.f||0,k=u.p||0,O=u.b||0,A=u.l,x=u.d,E=u.m,D=u.n,M=8*s;do{if(!A){u.f=m=L(r,k,1);var S=L(r,k+1,3);if(k+=3,!S){var V=r[(I=((h=k)/8|0)+(7&h&&1)+4)-4]|r[I-3]<<8,_=I+V;if(_>s){g&&T(0);break}c&&d(O+V),f.set(r.subarray(I,_),O),u.b=O+=V,u.p=k=8*_;continue}if(1==S)A=b,x=p,E=9,D=5;else if(2==S){var j=L(r,k,31)+257,z=L(r,k+10,15)+4,C=j+L(r,k+5,31)+1;k+=14;for(var F=new e(C),P=new e(19),q=0;q<z;++q)P[o[q]]=L(r,k+3*q,7);k+=3*z;var B=y(P),G=(1<<B)-1,H=w(P,B,1);for(q=0;q<C;){var I,J=H[L(r,k,G)];if(k+=15&J,(I=J>>>4)<16)F[q++]=I;else {var K=0,N=0;for(16==I?(N=3+L(r,k,3),k+=2,K=F[q-1]):17==I?(N=3+L(r,k,7),k+=3):18==I&&(N=11+L(r,k,127),k+=7);N--;)F[q++]=K;}}var Q=F.subarray(0,j),R=F.subarray(j);E=y(Q),D=y(R),A=w(Q,E,1),x=w(R,D,1);}else T(1);if(k>M){g&&T(0);break}}c&&d(O+131072);for(var W=(1<<E)-1,X=(1<<D)-1,Y=k;;Y=k){var Z=(K=A[U(r,k)&W])>>>4;if((k+=15&K)>M){g&&T(0);break}if(K||T(2),Z<256)f[O++]=Z;else {if(256==Z){Y=k,A=null;break}var $=Z-254;if(Z>264){var rr=a[q=Z-257];$=L(r,k,(1<<rr)-1)+v[q],k+=rr;}var er=x[U(r,k)&X],nr=er>>>4;er||T(3),k+=15&er;R=l[nr];if(nr>3){rr=i[nr];R+=U(r,k)&(1<<rr)-1,k+=rr;}if(k>M){g&&T(0);break}c&&d(O+131072);for(var tr=O+$;O<tr;O+=4)f[O]=f[O-R],f[O+1]=f[O+1-R],f[O+2]=f[O+2-R],f[O+3]=f[O+3-R];O=tr;}}u.l=A,u.p=Y,u.b=O,A&&(m=1,u.m=E,u.d=x,u.n=D);}while(!m);return O==f.length?f:function(r,a,i){(null==a||a<0)&&(a=0),(null==i||i>r.length)&&(i=r.length);var o=new(r instanceof n?n:r instanceof t?t:e)(i-a);return o.set(r.subarray(a,i)),o}(f,0,O)},A=new e(0);var x=\"undefined\"!=typeof TextDecoder&&new TextDecoder;try{x.decode(A,{stream:!0}),1;}catch(r){}return r.convert_streams=function(r){var e=new DataView(r),n=0;function t(){var r=e.getUint16(n);return n+=2,r}function a(){var r=e.getUint32(n);return n+=4,r}function i(r){m.setUint16(b,r),b+=2;}function o(r){m.setUint32(b,r),b+=4;}for(var f={signature:a(),flavor:a(),length:a(),numTables:t(),reserved:t(),totalSfntSize:a(),majorVersion:t(),minorVersion:t(),metaOffset:a(),metaLength:a(),metaOrigLength:a(),privOffset:a(),privLength:a()},u=0;Math.pow(2,u)<=f.numTables;)u++;u--;for(var v=16*Math.pow(2,u),s=16*f.numTables-v,l=12,c=[],g=0;g<f.numTables;g++)c.push({tag:a(),offset:a(),compLength:a(),origLength:a(),origChecksum:a()}),l+=16;var h,w=new Uint8Array(12+16*c.length+c.reduce((function(r,e){return r+e.origLength+4}),0)),d=w.buffer,m=new DataView(d),b=0;return o(f.flavor),i(f.numTables),i(v),i(u),i(s),c.forEach((function(r){o(r.tag),o(r.origChecksum),o(l),o(r.origLength),r.outOffset=l,(l+=r.origLength)%4!=0&&(l+=4-l%4);})),c.forEach((function(e){var n,t=r.slice(e.offset,e.offset+e.compLength);if(e.compLength!=e.origLength){var a=new Uint8Array(e.origLength);n=new Uint8Array(t,2),O(n,a);}else a=new Uint8Array(t);w.set(a,e.outOffset);var i=0;(l=e.outOffset+e.origLength)%4!=0&&(i=4-l%4),w.set(new Uint8Array(i).buffer,e.outOffset+e.origLength),h=l+i;})),d.slice(0,h)},Object.defineProperty(r,\"__esModule\",{value:!0}),r}({}).convert_streams}\n\n  /**\n   * A factory wrapper parsing a font file using Typr.\n   * Also adds support for WOFF files (not WOFF2).\n   */\n\n  /**\n   * @typedef ParsedFont\n   * @property {number} ascender\n   * @property {number} descender\n   * @property {number} xHeight\n   * @property {(number) => boolean} supportsCodePoint\n   * @property {(text:string, fontSize:number, letterSpacing:number, callback) => number} forEachGlyph\n   * @property {number} lineGap\n   * @property {number} capHeight\n   * @property {number} unitsPerEm\n   */\n\n  /**\n   * @typedef {(buffer: ArrayBuffer) => ParsedFont} FontParser\n   */\n\n  /**\n   * @returns {FontParser}\n   */\n  function parserFactory(Typr, woff2otf) {\n    const cmdArgLengths = {\n      M: 2,\n      L: 2,\n      Q: 4,\n      C: 6,\n      Z: 0\n    };\n\n    // {joinType: \"skip+step,...\"}\n    const joiningTypeRawData = {\"C\":\"18g,ca,368,1kz\",\"D\":\"17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v\",\"R\":\"17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6\",\"L\":\"x9u,jff,a,fd,jv\",\"T\":\"4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n\"};\n\n    const JT_LEFT = 1, //indicates that a character joins with the subsequent character, but does not join with the preceding character.\n      JT_RIGHT = 2, //indicates that a character joins with the preceding character, but does not join with the subsequent character.\n      JT_DUAL = 4, //indicates that a character joins with the preceding character and joins with the subsequent character.\n      JT_TRANSPARENT = 8, //indicates that the character does not join with adjacent characters and that the character must be skipped over when the shaping engine is evaluating the joining positions in a sequence of characters. When a JT_TRANSPARENT character is encountered in a sequence, the JOINING_TYPE of the preceding character passes through. Diacritical marks are frequently assigned this value.\n      JT_JOIN_CAUSING = 16, //indicates that the character forces the use of joining forms with the preceding and subsequent characters. Kashidas and the Zero Width Joiner (U+200D) are both JOIN_CAUSING characters.\n      JT_NON_JOINING = 32; //indicates that a character does not join with the preceding or with the subsequent character.,\n\n    let joiningTypeMap;\n    function getCharJoiningType(ch) {\n      if (!joiningTypeMap) {\n        const m = {\n          R: JT_RIGHT,\n          L: JT_LEFT,\n          D: JT_DUAL,\n          C: JT_JOIN_CAUSING,\n          U: JT_NON_JOINING,\n          T: JT_TRANSPARENT\n        };\n        joiningTypeMap = new Map();\n        for (let type in joiningTypeRawData) {\n          let lastCode = 0;\n          joiningTypeRawData[type].split(',').forEach(range => {\n            let [skip, step] = range.split('+');\n            skip = parseInt(skip,36);\n            step = step ? parseInt(step, 36) : 0;\n            joiningTypeMap.set(lastCode += skip, m[type]);\n            for (let i = step; i--;) {\n              joiningTypeMap.set(++lastCode, m[type]);\n            }\n          });\n        }\n      }\n      return joiningTypeMap.get(ch) || JT_NON_JOINING\n    }\n\n    const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;\n    const formsToFeatures = [null, 'isol', 'init', 'fina', 'medi'];\n\n    function detectJoiningForms(str) {\n      // This implements the algorithm described here:\n      // https://github.com/n8willis/opentype-shaping-documents/blob/master/opentype-shaping-arabic-general.md\n      const joiningForms = new Uint8Array(str.length);\n      let prevJoiningType = JT_NON_JOINING;\n      let prevForm = ISOL;\n      let prevIndex = -1;\n      for (let i = 0; i < str.length; i++) {\n        const code = str.codePointAt(i);\n        let joiningType = getCharJoiningType(code) | 0;\n        let form = ISOL;\n        if (joiningType & JT_TRANSPARENT) {\n          continue\n        }\n        if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {\n          if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {\n            form = FINA;\n            // isol->init, fina->medi\n            if (prevForm === ISOL || prevForm === FINA) {\n              joiningForms[prevIndex]++;\n            }\n          }\n          else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {\n            // medi->fina, init->isol\n            if (prevForm === INIT || prevForm === MEDI) {\n              joiningForms[prevIndex]--;\n            }\n          }\n        }\n        else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {\n          // medi->fina, init->isol\n          if (prevForm === INIT || prevForm === MEDI) {\n            joiningForms[prevIndex]--;\n          }\n        }\n        prevForm = joiningForms[i] = form;\n        prevJoiningType = joiningType;\n        prevIndex = i;\n        if (code > 0xffff) i++;\n      }\n      // console.log(str.split('').map(ch => ch.codePointAt(0).toString(16)))\n      // console.log(str.split('').map(ch => getCharJoiningType(ch.codePointAt(0))))\n      // console.log(Array.from(joiningForms).map(f => formsToFeatures[f] || 'none'))\n      return joiningForms\n    }\n\n    function stringToGlyphs (font, str) {\n      const glyphIds = [];\n      for (let i = 0; i < str.length; i++) {\n        const cc = str.codePointAt(i);\n        if (cc > 0xffff) i++;\n        glyphIds.push(Typr.U.codeToGlyph(font, cc));\n      }\n\n      const gsub = font['GSUB'];\n      if (gsub) {\n        const {lookupList, featureList} = gsub;\n        let joiningForms;\n        const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/;\n        const usedLookups = [];\n        featureList.forEach(feature => {\n          if (supportedFeatures.test(feature.tag)) {\n            for (let ti = 0; ti < feature.tab.length; ti++) {\n              if (usedLookups[feature.tab[ti]]) continue\n              usedLookups[feature.tab[ti]] = true;\n              const tab = lookupList[feature.tab[ti]];\n              const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);\n              if (isJoiningFeature && !joiningForms) { //lazy\n                joiningForms = detectJoiningForms(str);\n              }\n              for (let ci = 0; ci < glyphIds.length; ci++) {\n                if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {\n                  Typr.U._applySubs(glyphIds, ci, tab, lookupList);\n                }\n              }\n            }\n          }\n        });\n      }\n\n      return glyphIds\n    }\n\n    // Calculate advances and x/y offsets for each glyph, e.g. kerning and mark\n    // attachments. This is a more complete version of Typr.U.getPairAdjustment\n    // and should become an upstream replacement eventually.\n    function calcGlyphPositions(font, glyphIds) {\n      const positions = new Int16Array(glyphIds.length * 3); // [offsetX, offsetY, advanceX, ...]\n      let glyphIndex = 0;\n      for (; glyphIndex < glyphIds.length; glyphIndex++) {\n        const glyphId = glyphIds[glyphIndex];\n        if (glyphId === -1) continue;\n\n        positions[glyphIndex * 3 + 2] = font.hmtx.aWidth[glyphId]; // populate advanceX in...advance.\n\n        const gpos = font.GPOS;\n        if (gpos) {\n          const llist = gpos.lookupList;\n          for (let i = 0; i < llist.length; i++) {\n            const lookup = llist[i];\n            for (let j = 0; j < lookup.tabs.length; j++) {\n              const tab = lookup.tabs[j];\n              // Single char placement\n              if (lookup.ltype === 1) {\n                const ind = Typr._lctf.coverageIndex(tab.coverage, glyphId);\n                if (ind !== -1 && tab.pos) {\n                  applyValueRecord(tab.pos, glyphIndex);\n                  break\n                }\n              }\n              // Pairs (kerning)\n              else if (lookup.ltype === 2) {\n                let adj = null;\n                let prevGlyphIndex = getPrevGlyphIndex();\n                if (prevGlyphIndex !== -1) {\n                  const coverageIndex = Typr._lctf.coverageIndex(tab.coverage, glyphIds[prevGlyphIndex]);\n                  if (coverageIndex !== -1) {\n                    if (tab.fmt === 1) {\n                      const right = tab.pairsets[coverageIndex];\n                      for (let k = 0; k < right.length; k++) {\n                        if (right[k].gid2 === glyphId) adj = right[k];\n                      }\n                    } else if (tab.fmt === 2) {\n                      const c1 = Typr.U._getGlyphClass(glyphIds[prevGlyphIndex], tab.classDef1);\n                      const c2 = Typr.U._getGlyphClass(glyphId, tab.classDef2);\n                      adj = tab.matrix[c1][c2];\n                    }\n                    if (adj) {\n                      if (adj.val1) applyValueRecord(adj.val1, prevGlyphIndex);\n                      if (adj.val2) applyValueRecord(adj.val2, glyphIndex);\n                      break\n                    }\n                  }\n                }\n              }\n              // Mark to base\n              else if (lookup.ltype === 4) {\n                const markArrIndex = Typr._lctf.coverageIndex(tab.markCoverage, glyphId);\n                if (markArrIndex !== -1) {\n                  const baseGlyphIndex = getPrevGlyphIndex(isBaseGlyph);\n                  const baseArrIndex = baseGlyphIndex === -1 ? -1 : Typr._lctf.coverageIndex(tab.baseCoverage, glyphIds[baseGlyphIndex]);\n                  if (baseArrIndex !== -1) {\n                    const markRecord = tab.markArray[markArrIndex];\n                    const baseAnchor = tab.baseArray[baseArrIndex][markRecord.markClass];\n                    positions[glyphIndex * 3] = baseAnchor.x - markRecord.x + positions[baseGlyphIndex * 3] - positions[baseGlyphIndex * 3 + 2];\n                    positions[glyphIndex * 3 + 1] = baseAnchor.y - markRecord.y + positions[baseGlyphIndex * 3 + 1];\n                    break;\n                  }\n                }\n              }\n              // Mark to mark\n              else if (lookup.ltype === 6) {\n                const mark1ArrIndex = Typr._lctf.coverageIndex(tab.mark1Coverage, glyphId);\n                if (mark1ArrIndex !== -1) {\n                  const prevGlyphIndex = getPrevGlyphIndex();\n                  if (prevGlyphIndex !== -1) {\n                    const prevGlyphId = glyphIds[prevGlyphIndex];\n                    if (getGlyphClass(font, prevGlyphId) === 3) { // only check mark glyphs\n                      const mark2ArrIndex = Typr._lctf.coverageIndex(tab.mark2Coverage, prevGlyphId);\n                      if (mark2ArrIndex !== -1) {\n                        const mark1Record = tab.mark1Array[mark1ArrIndex];\n                        const mark2Anchor = tab.mark2Array[mark2ArrIndex][mark1Record.markClass];\n                        positions[glyphIndex * 3] = mark2Anchor.x - mark1Record.x + positions[prevGlyphIndex * 3] - positions[prevGlyphIndex * 3 + 2];\n                        positions[glyphIndex * 3 + 1] = mark2Anchor.y - mark1Record.y + positions[prevGlyphIndex * 3 + 1];\n                        break;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        // Check kern table if no GPOS\n        else if (font.kern && !font.cff) {\n          const prevGlyphIndex = getPrevGlyphIndex();\n          if (prevGlyphIndex !== -1) {\n            const ind1 = font.kern.glyph1.indexOf(glyphIds[prevGlyphIndex]);\n            if (ind1 !== -1) {\n              const ind2 = font.kern.rval[ind1].glyph2.indexOf(glyphId);\n              if (ind2 !== -1) {\n                positions[prevGlyphIndex * 3 + 2] += font.kern.rval[ind1].vals[ind2];\n              }\n            }\n          }\n        }\n      }\n\n      return positions;\n\n      function getPrevGlyphIndex(filter) {\n        for (let i = glyphIndex - 1; i >=0; i--) {\n          if (glyphIds[i] !== -1 && (!filter || filter(glyphIds[i]))) {\n            return i\n          }\n        }\n        return -1;\n      }\n\n      function isBaseGlyph(glyphId) {\n        return getGlyphClass(font, glyphId) === 1;\n      }\n\n      function applyValueRecord(source, gi) {\n        for (let i = 0; i < 3; i++) {\n          positions[gi * 3 + i] += source[i] || 0;\n        }\n      }\n    }\n\n    function getGlyphClass(font, glyphId) {\n      const classDef = font.GDEF && font.GDEF.glyphClassDef;\n      return classDef ? Typr.U._getGlyphClass(glyphId, classDef) : 0;\n    }\n\n    function firstNum(...args) {\n      for (let i = 0; i < args.length; i++) {\n        if (typeof args[i] === 'number') {\n          return args[i]\n        }\n      }\n    }\n\n    /**\n     * @returns ParsedFont\n     */\n    function wrapFontObj(typrFont) {\n      const glyphMap = Object.create(null);\n\n      const os2 = typrFont['OS/2'];\n      const hhea = typrFont.hhea;\n      const unitsPerEm = typrFont.head.unitsPerEm;\n      const ascender = firstNum(os2 && os2.sTypoAscender, hhea && hhea.ascender, unitsPerEm);\n\n      /** @type ParsedFont */\n      const fontObj = {\n        unitsPerEm,\n        ascender,\n        descender: firstNum(os2 && os2.sTypoDescender, hhea && hhea.descender, 0),\n        capHeight: firstNum(os2 && os2.sCapHeight, ascender),\n        xHeight: firstNum(os2 && os2.sxHeight, ascender),\n        lineGap: firstNum(os2 && os2.sTypoLineGap, hhea && hhea.lineGap),\n        supportsCodePoint(code) {\n          return Typr.U.codeToGlyph(typrFont, code) > 0\n        },\n        forEachGlyph(text, fontSize, letterSpacing, callback) {\n          let penX = 0;\n          const fontScale = 1 / fontObj.unitsPerEm * fontSize;\n\n          const glyphIds = stringToGlyphs(typrFont, text);\n          let charIndex = 0;\n          const positions = calcGlyphPositions(typrFont, glyphIds);\n\n          glyphIds.forEach((glyphId, i) => {\n            // Typr returns a glyph index per string codepoint, with -1s in place of those that\n            // were omitted due to ligature substitution. So we can track original index in the\n            // string via simple increment, and skip everything else when seeing a -1.\n            if (glyphId !== -1) {\n              let glyphObj = glyphMap[glyphId];\n              if (!glyphObj) {\n                const {cmds, crds} = Typr.U.glyphToPath(typrFont, glyphId);\n\n                // Build path string\n                let path = '';\n                let crdsIdx = 0;\n                for (let i = 0, len = cmds.length; i < len; i++) {\n                  const numArgs = cmdArgLengths[cmds[i]];\n                  path += cmds[i];\n                  for (let j = 1; j <= numArgs; j++) {\n                    path += (j > 1 ? ',' : '') + crds[crdsIdx++];\n                  }\n                }\n\n                // Find extents - Glyf gives this in metadata but not CFF, and Typr doesn't\n                // normalize the two, so it's simplest just to iterate ourselves.\n                let xMin, yMin, xMax, yMax;\n                if (crds.length) {\n                  xMin = yMin = Infinity;\n                  xMax = yMax = -Infinity;\n                  for (let i = 0, len = crds.length; i < len; i += 2) {\n                    let x = crds[i];\n                    let y = crds[i + 1];\n                    if (x < xMin) xMin = x;\n                    if (y < yMin) yMin = y;\n                    if (x > xMax) xMax = x;\n                    if (y > yMax) yMax = y;\n                  }\n                } else {\n                  xMin = xMax = yMin = yMax = 0;\n                }\n\n                glyphObj = glyphMap[glyphId] = {\n                  index: glyphId,\n                  advanceWidth: typrFont.hmtx.aWidth[glyphId],\n                  xMin,\n                  yMin,\n                  xMax,\n                  yMax,\n                  path,\n                };\n              }\n\n              callback.call(\n                null,\n                glyphObj,\n                penX + positions[i * 3] * fontScale,\n                positions[i * 3 + 1] * fontScale,\n                charIndex\n              );\n\n              penX += positions[i * 3 + 2] * fontScale;\n              if (letterSpacing) {\n                penX += letterSpacing * fontSize;\n              }\n            }\n            charIndex += (text.codePointAt(charIndex) > 0xffff ? 2 : 1);\n          });\n\n          return penX\n        }\n      };\n\n      return fontObj\n    }\n\n    /**\n     * @type FontParser\n     */\n    return function parse(buffer) {\n      // Look to see if we have a WOFF file and convert it if so:\n      const peek = new Uint8Array(buffer, 0, 4);\n      const tag = Typr._bin.readASCII(peek, 0, 4);\n      if (tag === 'wOFF') {\n        buffer = woff2otf(buffer);\n      } else if (tag === 'wOF2') {\n        throw new Error('woff2 fonts not supported')\n      }\n      return wrapFontObj(Typr.parse(buffer)[0])\n    }\n  }\n\n\n  const workerModule = /*#__PURE__*/troikaWorkerUtils.defineWorkerModule({\n    name: 'Typr Font Parser',\n    dependencies: [typrFactory, woff2otfFactory, parserFactory],\n    init(typrFactory, woff2otfFactory, parserFactory) {\n      const Typr = typrFactory();\n      const woff2otf = woff2otfFactory();\n      return parserFactory(Typr, woff2otf)\n    }\n  });\n\n  /*!\n  Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)\n  for use in Troika text rendering. \n  Original MIT license applies\n  */\n  function unicodeFontResolverClientFactory(){return function(t){var n=function(){this.buckets=new Map;};n.prototype.add=function(t){var n=t>>5;this.buckets.set(n,(this.buckets.get(n)||0)|1<<(31&t));},n.prototype.has=function(t){var n=this.buckets.get(t>>5);return void 0!==n&&0!=(n&1<<(31&t))},n.prototype.serialize=function(){var t=[];return this.buckets.forEach((function(n,r){t.push((+r).toString(36)+\":\"+n.toString(36));})),t.join(\",\")},n.prototype.deserialize=function(t){var n=this;this.buckets.clear(),t.split(\",\").forEach((function(t){var r=t.split(\":\");n.buckets.set(parseInt(r[0],36),parseInt(r[1],36));}));};var r=Math.pow(2,8),e=r-1,o=~e;function a(t){var n=function(t){return t&o}(t).toString(16),e=function(t){return (t&o)+r-1}(t).toString(16);return \"codepoint-index/plane\"+(t>>16)+\"/\"+n+\"-\"+e+\".json\"}function i(t,n){var r=t&e,o=n.codePointAt(r/6|0);return 0!=((o=(o||48)-48)&1<<r%6)}function u(t,n){var r;(r=t,r.replace(/U\\+/gi,\"\").replace(/^,+|,+$/g,\"\").split(/,+/).map((function(t){return t.split(\"-\").map((function(t){return parseInt(t.trim(),16)}))}))).forEach((function(t){var r=t[0],e=t[1];void 0===e&&(e=r),n(r,e);}));}function c(t,n){u(t,(function(t,r){for(var e=t;e<=r;e++)n(e);}));}var s={},f={},l=new WeakMap,v=\"https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data\";function d(t){var r=l.get(t);return r||(r=new n,c(t.ranges,(function(t){return r.add(t)})),l.set(t,r)),r}var h,p=new Map;function g(t,n,r){return t[n]?n:t[r]?r:function(t){for(var n in t)return n}(t)}function w(t,n){var r=n;if(!t.includes(r)){r=1/0;for(var e=0;e<t.length;e++)Math.abs(t[e]-n)<Math.abs(r-n)&&(r=t[e]);}return r}function k(t){return h||(h=new Set,c(\"9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000\",(function(t){h.add(t);}))),h.has(t)}return t.CodePointSet=n,t.clearCache=function(){s={},f={};},t.getFontsForString=function(t,n){void 0===n&&(n={});var r,e=n.lang;void 0===e&&(e=/\\p{Script=Hangul}/u.test(r=t)?\"ko\":/\\p{Script=Hiragana}|\\p{Script=Katakana}/u.test(r)?\"ja\":\"en\");var o=n.category;void 0===o&&(o=\"sans-serif\");var u=n.style;void 0===u&&(u=\"normal\");var c=n.weight;void 0===c&&(c=400);var l=(n.dataUrl||v).replace(/\\/$/g,\"\"),h=new Map,y=new Uint8Array(t.length),b={},m={},A=new Array(t.length),S=new Map,j=!1;function M(t){var n=p.get(t);return n||(n=fetch(l+\"/\"+t).then((function(t){if(!t.ok)throw new Error(t.statusText);return t.json().then((function(t){if(!Array.isArray(t)||1!==t[0])throw new Error(\"Incorrect schema version; need 1, got \"+t[0]);return t[1]}))})).catch((function(n){if(l!==v)return j||(console.error('unicode-font-resolver: Failed loading from dataUrl \"'+l+'\", trying default CDN. '+n.message),j=!0),l=v,p.delete(t),M(t);throw n})),p.set(t,n)),n}for(var P=function(n){var r=t.codePointAt(n),e=a(r);A[n]=e,s[e]||S.has(e)||S.set(e,M(e).then((function(t){s[e]=t;}))),r>65535&&(n++,E=n);},E=0;E<t.length;E++)P(E);return Promise.all(S.values()).then((function(){S.clear();for(var n=function(n){var o=t.codePointAt(n),a=null,u=s[A[n]],c=void 0;for(var l in u){var v=m[l];if(void 0===v&&(v=m[l]=new RegExp(l).test(e||\"en\")),v){for(var d in c=l,u[l])if(i(o,u[l][d])){a=d;break}break}}if(!a)t:for(var h in u)if(h!==c)for(var p in u[h])if(i(o,u[h][p])){a=p;break t}a||(console.debug(\"No font coverage for U+\"+o.toString(16)),a=\"latin\"),A[n]=a,f[a]||S.has(a)||S.set(a,M(\"font-meta/\"+a+\".json\").then((function(t){f[a]=t;}))),o>65535&&(n++,r=n);},r=0;r<t.length;r++)n(r);return Promise.all(S.values())})).then((function(){for(var n,r=null,e=0;e<t.length;e++){var a=t.codePointAt(e);if(r&&(k(a)||d(r).has(a)))y[e]=y[e-1];else {r=f[A[e]];var i=b[r.id];if(!i){var s=r.typeforms,v=g(s,o,\"sans-serif\"),p=g(s[v],u,\"normal\"),m=w(null===(n=s[v])||void 0===n?void 0:n[p],c);i=b[r.id]=l+\"/font-files/\"+r.id+\"/\"+v+\".\"+p+\".\"+m+\".woff\";}var S=h.get(i);null==S&&(S=h.size,h.set(i,S)),y[e]=S;}a>65535&&(e++,y[e]=y[e-1]);}return {fontUrls:Array.from(h.keys()),chars:y}}))},Object.defineProperty(t,\"__esModule\",{value:!0}),t}({})}\n\n  /**\n   * @typedef {string | {src:string, label?:string, unicodeRange?:string, lang?:string}} UserFont\n   */\n\n  /**\n   * @typedef {ClientOptions} FontResolverOptions\n   * @property {Array<UserFont>|UserFont} [fonts]\n   * @property {'normal'|'italic'} [style]\n   * @property {'normal'|'bold'|number} [style]\n   * @property {string} [unicodeFontsURL]\n   */\n\n  /**\n   * @typedef {Object} FontResolverResult\n   * @property {Uint8Array} chars\n   * @property {Array<ParsedFont & {src:string}>} fonts\n   */\n\n  /**\n   * @typedef {function} FontResolver\n   * @param {string} text\n   * @param {(FontResolverResult) => void} callback\n   * @param {FontResolverOptions} [options]\n   */\n\n  /**\n   * Factory for the FontResolver function.\n   * @param {FontParser} fontParser\n   * @param {{getFontsForString: function, CodePointSet: function}} unicodeFontResolverClient\n   * @return {FontResolver}\n   */\n  function createFontResolver(fontParser, unicodeFontResolverClient) {\n    /**\n     * @type {Record<string, ParsedFont>}\n     */\n    const parsedFonts = Object.create(null);\n\n    /**\n     * @type {Record<string, Array<(ParsedFont) => void>>}\n     */\n    const loadingFonts = Object.create(null);\n\n    /**\n     * Load a given font url\n     */\n    function doLoadFont(url, callback) {\n      const onError = err => {\n        console.error(`Failure loading font ${url}`, err);\n      };\n      try {\n        const request = new XMLHttpRequest();\n        request.open('get', url, true);\n        request.responseType = 'arraybuffer';\n        request.onload = function () {\n          if (request.status >= 400) {\n            onError(new Error(request.statusText));\n          }\n          else if (request.status > 0) {\n            try {\n              const fontObj = fontParser(request.response);\n              fontObj.src = url;\n              callback(fontObj);\n            } catch (e) {\n              onError(e);\n            }\n          }\n        };\n        request.onerror = onError;\n        request.send();\n      } catch(err) {\n        onError(err);\n      }\n    }\n\n\n    /**\n     * Load a given font url if needed, invoking a callback when it's loaded. If already\n     * loaded, the callback will be called synchronously.\n     * @param {string} fontUrl\n     * @param {(font: ParsedFont) => void} callback\n     */\n    function loadFont(fontUrl, callback) {\n      let font = parsedFonts[fontUrl];\n      if (font) {\n        callback(font);\n      } else if (loadingFonts[fontUrl]) {\n        loadingFonts[fontUrl].push(callback);\n      } else {\n        loadingFonts[fontUrl] = [callback];\n        doLoadFont(fontUrl, fontObj => {\n          fontObj.src = fontUrl;\n          parsedFonts[fontUrl] = fontObj;\n          loadingFonts[fontUrl].forEach(cb => cb(fontObj));\n          delete loadingFonts[fontUrl];\n        });\n      }\n    }\n\n    /**\n     * For a given string of text, determine which fonts are required to fully render it and\n     * ensure those fonts are loaded.\n     */\n    return function (text, callback, {\n      lang,\n      fonts: userFonts = [],\n      style = 'normal',\n      weight = 'normal',\n      unicodeFontsURL\n    } = {}) {\n      const charResolutions = new Uint8Array(text.length);\n      const fontResolutions = [];\n      if (!text.length) {\n        allDone();\n      }\n\n      const fontIndices = new Map();\n      const fallbackRanges = []; // [[start, end], ...]\n\n      if (style !== 'italic') style = 'normal';\n      if (typeof weight !== 'number') {\n        weight = weight === 'bold' ? 700 : 400;\n      }\n\n      if (userFonts && !Array.isArray(userFonts)) {\n        userFonts = [userFonts];\n      }\n      userFonts = userFonts.slice()\n        // filter by language\n        .filter(def => !def.lang || def.lang.test(lang))\n        // switch order for easier iteration\n        .reverse();\n      if (userFonts.length) {\n        const UNKNOWN = 0;\n        const RESOLVED = 1;\n        const NEEDS_FALLBACK = 2;\n        let prevCharResult = UNKNOWN\n\n        ;(function resolveUserFonts (startIndex = 0) {\n          for (let i = startIndex, iLen = text.length; i < iLen; i++) {\n            const codePoint = text.codePointAt(i);\n            // Carry previous character's result forward if:\n            // - it resolved to a font that also covers this character\n            // - this character is whitespace\n            if (\n              (prevCharResult === RESOLVED && fontResolutions[charResolutions[i - 1]].supportsCodePoint(codePoint)) ||\n              (i > 0 && /\\s/.test(text[i]))\n            ) {\n              charResolutions[i] = charResolutions[i - 1];\n              if (prevCharResult === NEEDS_FALLBACK) {\n                fallbackRanges[fallbackRanges.length - 1][1] = i;\n              }\n            } else {\n              for (let j = charResolutions[i], jLen = userFonts.length; j <= jLen; j++) {\n                if (j === jLen) {\n                  // none of the user fonts matched; needs fallback\n                  const range = prevCharResult === NEEDS_FALLBACK ?\n                    fallbackRanges[fallbackRanges.length - 1] :\n                    (fallbackRanges[fallbackRanges.length] = [i, i]);\n                  range[1] = i;\n                  prevCharResult = NEEDS_FALLBACK;\n                } else {\n                  charResolutions[i] = j;\n                  const { src, unicodeRange } = userFonts[j];\n                  // filter by optional explicit unicode ranges\n                  if (!unicodeRange || isCodeInRanges(codePoint, unicodeRange)) {\n                    const fontObj = parsedFonts[src];\n                    // font not yet loaded, load it and resume\n                    if (!fontObj) {\n                      loadFont(src, () => {\n                        resolveUserFonts(i);\n                      });\n                      return;\n                    }\n                    // if the font actually contains a glyph for this char, lock it in\n                    if (fontObj.supportsCodePoint(codePoint)) {\n                      let fontIndex = fontIndices.get(fontObj);\n                      if (typeof fontIndex !== 'number') {\n                        fontIndex = fontResolutions.length;\n                        fontResolutions.push(fontObj);\n                        fontIndices.set(fontObj, fontIndex);\n                      }\n                      charResolutions[i] = fontIndex;\n                      prevCharResult = RESOLVED;\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n\n            if (codePoint > 0xffff && i + 1 < iLen) {\n              charResolutions[i + 1] = charResolutions[i];\n              i++;\n              if (prevCharResult === NEEDS_FALLBACK) {\n                fallbackRanges[fallbackRanges.length - 1][1] = i;\n              }\n            }\n          }\n          resolveFallbacks();\n        })();\n      } else {\n        fallbackRanges.push([0, text.length - 1]);\n        resolveFallbacks();\n      }\n\n      function resolveFallbacks() {\n        if (fallbackRanges.length) {\n          // Combine all fallback substrings into a single string for querying\n          const fallbackString = fallbackRanges.map(range => text.substring(range[0], range[1] + 1)).join('\\n');\n          unicodeFontResolverClient.getFontsForString(fallbackString, {\n            lang: lang || undefined,\n            style,\n            weight,\n            dataUrl: unicodeFontsURL\n          }).then(({fontUrls, chars}) => {\n            // Extract results and put them back in the main array\n            const fontIndexOffset = fontResolutions.length;\n            let charIdx = 0;\n            fallbackRanges.forEach(range => {\n              for (let i = 0, endIdx = range[1] - range[0]; i <= endIdx; i++) {\n                charResolutions[range[0] + i] = chars[charIdx++] + fontIndexOffset;\n              }\n              charIdx++; //skip segment separator\n            });\n\n            // Load and parse the fallback fonts - avoiding Promise here to prevent polyfills in the worker\n            let loadedCount = 0;\n            fontUrls.forEach((url, i) => {\n              loadFont(url, fontObj => {\n                fontResolutions[i + fontIndexOffset] = fontObj;\n                if (++loadedCount === fontUrls.length) {\n                  allDone();\n                }\n              });\n            });\n          });\n        } else {\n          allDone();\n        }\n      }\n\n      function allDone() {\n        callback({\n          chars: charResolutions,\n          fonts: fontResolutions\n        });\n      }\n\n      function isCodeInRanges(code, ranges) {\n        // todo optimize search - CodePointSet from unicode-font-resolver?\n        for (let k = 0; k < ranges.length; k++) {\n          const [start, end = start] = ranges[k];\n          if (start <= code && code <= end) {\n            return true\n          }\n        }\n        return false\n      }\n    }\n  }\n\n  const fontResolverWorkerModule = /*#__PURE__*/troikaWorkerUtils.defineWorkerModule({\n    name: 'FontResolver',\n    dependencies: [\n      createFontResolver,\n      workerModule,\n      unicodeFontResolverClientFactory,\n    ],\n    init(createFontResolver, fontParser, unicodeFontResolverClientFactory) {\n      return createFontResolver(fontParser, unicodeFontResolverClientFactory());\n    }\n  });\n\n  /**\n   * @typedef {number|'left'|'center'|'right'} AnchorXValue\n   */\n  /**\n   * @typedef {number|'top'|'top-baseline'|'top-cap'|'top-ex'|'middle'|'bottom-baseline'|'bottom'} AnchorYValue\n   */\n\n  /**\n   * @typedef {object} TypesetParams\n   * @property {string} text\n   * @property {UserFont|UserFont[]} [font]\n   * @property {string} [lang]\n   * @property {number} [sdfGlyphSize=64]\n   * @property {number} [fontSize=1]\n   * @property {number|'normal'|'bold'} [fontWeight='normal']\n   * @property {'normal'|'italic'} [fontStyle='normal']\n   * @property {number} [letterSpacing=0]\n   * @property {'normal'|number} [lineHeight='normal']\n   * @property {number} [maxWidth]\n   * @property {'ltr'|'rtl'} [direction='ltr']\n   * @property {string} [textAlign='left']\n   * @property {number} [textIndent=0]\n   * @property {'normal'|'nowrap'} [whiteSpace='normal']\n   * @property {'normal'|'break-word'} [overflowWrap='normal']\n   * @property {AnchorXValue} [anchorX=0]\n   * @property {AnchorYValue} [anchorY=0]\n   * @property {boolean} [metricsOnly=false]\n   * @property {string} [unicodeFontsURL]\n   * @property {FontResolverResult} [preResolvedFonts]\n   * @property {boolean} [includeCaretPositions=false]\n   * @property {number} [chunkedBoundsSize=8192]\n   * @property {{[rangeStartIndex]: number}} [colorRanges]\n   */\n\n  /**\n   * @typedef {object} TypesetResult\n   * @property {Uint16Array} glyphIds id for each glyph, specific to that glyph's font\n   * @property {Uint8Array} glyphFontIndices index into fontData for each glyph\n   * @property {Float32Array} glyphPositions x,y of each glyph's origin in layout\n   * @property {{[font]: {[glyphId]: {path: string, pathBounds: number[]}}}} glyphData data about each glyph appearing in the text\n   * @property {TypesetFontData[]} fontData data about each font used in the text\n   * @property {Float32Array} [caretPositions] startX,endX,bottomY caret positions for each char\n   * @property {Uint8Array} [glyphColors] color for each glyph, if color ranges supplied\n   *         chunkedBounds, //total rects per (n=chunkedBoundsSize) consecutive glyphs\n   *         fontSize, //calculated em height\n   *         topBaseline: anchorYOffset + lines[0].baseline, //y coordinate of the top line's baseline\n   *         blockBounds: [ //bounds for the whole block of text, including vertical padding for lineHeight\n   *           anchorXOffset,\n   *           anchorYOffset - totalHeight,\n   *           anchorXOffset + maxLineWidth,\n   *           anchorYOffset\n   *         ],\n   *         visibleBounds, //total bounds of visible text paths, may be larger or smaller than blockBounds\n   *         timings\n   */\n\n  /**\n   * @typedef {object} TypesetFontData\n   * @property src\n   * @property unitsPerEm\n   * @property ascender\n   * @property descender\n   * @property lineHeight\n   * @property capHeight\n   * @property xHeight\n   */\n\n  /**\n   * @typedef {function} TypesetterTypesetFunction - compute fonts and layout for some text.\n   * @param {TypesetParams} params\n   * @param {(TypesetResult) => void} callback - function called when typesetting is complete.\n   *    If the params included `preResolvedFonts`, this will be called synchronously.\n   */\n\n  /**\n   * @typedef {function} TypesetterMeasureFunction - compute width/height for some text.\n   * @param {TypesetParams} params\n   * @param {(width:number, height:number) => void} callback - function called when measurement is complete.\n   *    If the params included `preResolvedFonts`, this will be called synchronously.\n   */\n\n\n  /**\n   * Factory function that creates a self-contained environment for processing text typesetting requests.\n   *\n   * It is important that this function has no closure dependencies, so that it can be easily injected\n   * into the source for a Worker without requiring a build step or complex dependency loading. All its\n   * dependencies must be passed in at initialization.\n   *\n   * @param {FontResolver} resolveFonts - function to resolve a string to parsed fonts\n   * @param {object} bidi - the bidi.js implementation object\n   * @return {{typeset: TypesetterTypesetFunction, measure: TypesetterMeasureFunction}}\n   */\n  function createTypesetter(resolveFonts, bidi) {\n    const INF = Infinity;\n\n    // Set of Unicode Default_Ignorable_Code_Point characters, these will not produce visible glyphs\n    // eslint-disable-next-line no-misleading-character-class\n    const DEFAULT_IGNORABLE_CHARS = /[\\u00AD\\u034F\\u061C\\u115F-\\u1160\\u17B4-\\u17B5\\u180B-\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u206F\\u3164\\uFE00-\\uFE0F\\uFEFF\\uFFA0\\uFFF0-\\uFFF8]/;\n\n    // This regex (instead of /\\s/) allows us to select all whitespace EXCEPT for non-breaking white spaces\n    const lineBreakingWhiteSpace = `[^\\\\S\\\\u00A0]`;\n\n    // Incomplete set of characters that allow line breaking after them\n    // In the future we may consider a full Unicode line breaking algorithm impl: https://www.unicode.org/reports/tr14\n    const BREAK_AFTER_CHARS = new RegExp(`${lineBreakingWhiteSpace}|[\\\\-\\\\u007C\\\\u00AD\\\\u2010\\\\u2012-\\\\u2014\\\\u2027\\\\u2056\\\\u2E17\\\\u2E40]`);\n\n    /**\n     * Load and parse all the necessary fonts to render a given string of text, then group\n     * them into consecutive runs of characters sharing a font.\n     */\n    function calculateFontRuns({text, lang, fonts, style, weight, preResolvedFonts, unicodeFontsURL}, onDone) {\n      const onResolved = ({chars, fonts: parsedFonts}) => {\n        let curRun, prevVal;\n        const runs = [];\n        for (let i = 0; i < chars.length; i++) {\n          if (chars[i] !== prevVal) {\n            prevVal = chars[i];\n            runs.push(curRun = { start: i, end: i, fontObj: parsedFonts[chars[i]]});\n          } else {\n            curRun.end = i;\n          }\n        }\n        onDone(runs);\n      };\n      if (preResolvedFonts) {\n        onResolved(preResolvedFonts);\n      } else {\n        resolveFonts(\n          text,\n          onResolved,\n          { lang, fonts, style, weight, unicodeFontsURL }\n        );\n      }\n    }\n\n    /**\n     * Main entry point.\n     * Process a text string with given font and formatting parameters, and return all info\n     * necessary to render all its glyphs.\n     * @type TypesetterTypesetFunction\n     */\n    function typeset(\n      {\n        text='',\n        font,\n        lang,\n        sdfGlyphSize=64,\n        fontSize=400,\n        fontWeight=1,\n        fontStyle='normal',\n        letterSpacing=0,\n        lineHeight='normal',\n        maxWidth=INF,\n        direction,\n        textAlign='left',\n        textIndent=0,\n        whiteSpace='normal',\n        overflowWrap='normal',\n        anchorX = 0,\n        anchorY = 0,\n        metricsOnly=false,\n        unicodeFontsURL,\n        preResolvedFonts=null,\n        includeCaretPositions=false,\n        chunkedBoundsSize=8192,\n        colorRanges=null\n      },\n      callback\n    ) {\n      const mainStart = now();\n      const timings = {fontLoad: 0, typesetting: 0};\n\n      // Ensure newlines are normalized\n      if (text.indexOf('\\r') > -1) {\n        console.info('Typesetter: got text with \\\\r chars; normalizing to \\\\n');\n        text = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n      }\n\n      // Ensure we've got numbers not strings\n      fontSize = +fontSize;\n      letterSpacing = +letterSpacing;\n      maxWidth = +maxWidth;\n      lineHeight = lineHeight || 'normal';\n      textIndent = +textIndent;\n\n      calculateFontRuns({\n        text,\n        lang,\n        style: fontStyle,\n        weight: fontWeight,\n        fonts: typeof font === 'string' ? [{src: font}] : font,\n        unicodeFontsURL,\n        preResolvedFonts\n      }, runs => {\n        timings.fontLoad = now() - mainStart;\n        const hasMaxWidth = isFinite(maxWidth);\n        let glyphIds = null;\n        let glyphFontIndices = null;\n        let glyphPositions = null;\n        let glyphData = null;\n        let glyphColors = null;\n        let caretPositions = null;\n        let visibleBounds = null;\n        let chunkedBounds = null;\n        let maxLineWidth = 0;\n        let renderableGlyphCount = 0;\n        let canWrap = whiteSpace !== 'nowrap';\n        const metricsByFont = new Map(); // fontObj -> metrics\n        const typesetStart = now();\n\n        // Distribute glyphs into lines based on wrapping\n        let lineXOffset = textIndent;\n        let prevRunEndX = 0;\n        let currentLine = new TextLine();\n        const lines = [currentLine];\n        runs.forEach(run => {\n          const { fontObj } = run;\n          const { ascender, descender, unitsPerEm, lineGap, capHeight, xHeight } = fontObj;\n\n          // Calculate metrics for each font used\n          let fontData = metricsByFont.get(fontObj);\n          if (!fontData) {\n            // Find conversion between native font units and fontSize units\n            const fontSizeMult = fontSize / unitsPerEm;\n\n            // Determine appropriate value for 'normal' line height based on the font's actual metrics\n            // This does not guarantee individual glyphs won't exceed the line height, e.g. Roboto; should we use yMin/Max instead?\n            const calcLineHeight = lineHeight === 'normal' ?\n              (ascender - descender + lineGap) * fontSizeMult : lineHeight * fontSize;\n\n            // Determine line height and leading adjustments\n            const halfLeading = (calcLineHeight - (ascender - descender) * fontSizeMult) / 2;\n            const caretHeight = Math.min(calcLineHeight, (ascender - descender) * fontSizeMult);\n            const caretTop = (ascender + descender) / 2 * fontSizeMult + caretHeight / 2;\n            fontData = {\n              index: metricsByFont.size,\n              src: fontObj.src,\n              fontObj,\n              fontSizeMult,\n              unitsPerEm,\n              ascender: ascender * fontSizeMult,\n              descender: descender * fontSizeMult,\n              capHeight: capHeight * fontSizeMult,\n              xHeight: xHeight * fontSizeMult,\n              lineHeight: calcLineHeight,\n              baseline: -halfLeading - ascender * fontSizeMult, // baseline offset from top of line height\n              // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height\n              // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height\n              caretTop,\n              caretBottom: caretTop - caretHeight\n            };\n            metricsByFont.set(fontObj, fontData);\n          }\n          const { fontSizeMult } = fontData;\n\n          const runText = text.slice(run.start, run.end + 1);\n          let prevGlyphX, prevGlyphObj;\n          fontObj.forEachGlyph(runText, fontSize, letterSpacing, (glyphObj, glyphX, glyphY, charIndex) => {\n            glyphX += prevRunEndX;\n            charIndex += run.start;\n            prevGlyphX = glyphX;\n            prevGlyphObj = glyphObj;\n            const char = text.charAt(charIndex);\n            const glyphWidth = glyphObj.advanceWidth * fontSizeMult;\n            const curLineCount = currentLine.count;\n            let nextLine;\n\n            // Calc isWhitespace and isEmpty once per glyphObj\n            if (!('isEmpty' in glyphObj)) {\n              glyphObj.isWhitespace = !!char && new RegExp(lineBreakingWhiteSpace).test(char);\n              glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);\n              glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);\n            }\n            if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n              renderableGlyphCount++;\n            }\n\n            // If a non-whitespace character overflows the max width, we need to soft-wrap\n            if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {\n              // If it's the first char after a whitespace, start a new line\n              if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {\n                nextLine = new TextLine();\n                lineXOffset = -glyphX;\n              } else {\n                // Back up looking for a whitespace character to wrap at\n                for (let i = curLineCount; i--;) {\n                  // If we got the start of the line there's no soft break point; make hard break if overflowWrap='break-word'\n                  if (i === 0 && overflowWrap === 'break-word') {\n                    nextLine = new TextLine();\n                    lineXOffset = -glyphX;\n                    break\n                  }\n                  // Found a soft break point; move all chars since it to a new line\n                  else if (currentLine.glyphAt(i).glyphObj.canBreakAfter) {\n                    nextLine = currentLine.splitAt(i + 1);\n                    const adjustX = nextLine.glyphAt(0).x;\n                    lineXOffset -= adjustX;\n                    for (let j = nextLine.count; j--;) {\n                      nextLine.glyphAt(j).x -= adjustX;\n                    }\n                    break\n                  }\n                }\n              }\n              if (nextLine) {\n                currentLine.isSoftWrapped = true;\n                currentLine = nextLine;\n                lines.push(currentLine);\n                maxLineWidth = maxWidth; //after soft wrapping use maxWidth as calculated width\n              }\n            }\n\n            let fly = currentLine.glyphAt(currentLine.count);\n            fly.glyphObj = glyphObj;\n            fly.x = glyphX + lineXOffset;\n            fly.y = glyphY;\n            fly.width = glyphWidth;\n            fly.charIndex = charIndex;\n            fly.fontData = fontData;\n\n            // Handle hard line breaks\n            if (char === '\\n') {\n              currentLine = new TextLine();\n              lines.push(currentLine);\n              lineXOffset = -(glyphX + glyphWidth + (letterSpacing * fontSize)) + textIndent;\n            }\n          });\n          // At the end of a run we must capture the x position as the starting point for the next run\n          prevRunEndX = prevGlyphX + prevGlyphObj.advanceWidth * fontSizeMult + letterSpacing * fontSize;\n        });\n\n        // Calculate width/height/baseline of each line (excluding trailing whitespace) and maximum block width\n        let totalHeight = 0;\n        lines.forEach(line => {\n          let isTrailingWhitespace = true;\n          for (let i = line.count; i--;) {\n            const glyphInfo = line.glyphAt(i);\n            // omit trailing whitespace from width calculation\n            if (isTrailingWhitespace && !glyphInfo.glyphObj.isWhitespace) {\n              line.width = glyphInfo.x + glyphInfo.width;\n              if (line.width > maxLineWidth) {\n                maxLineWidth = line.width;\n              }\n              isTrailingWhitespace = false;\n            }\n            // use the tallest line height, lowest baseline, and highest cap/ex\n            let {lineHeight, capHeight, xHeight, baseline} = glyphInfo.fontData;\n            if (lineHeight > line.lineHeight) line.lineHeight = lineHeight;\n            const baselineDiff = baseline - line.baseline;\n            if (baselineDiff < 0) { //shift all metrics down\n              line.baseline += baselineDiff;\n              line.cap += baselineDiff;\n              line.ex += baselineDiff;\n            }\n            // compare cap/ex based on new lowest baseline\n            line.cap = Math.max(line.cap, line.baseline + capHeight);\n            line.ex = Math.max(line.ex, line.baseline + xHeight);\n          }\n          line.baseline -= totalHeight;\n          line.cap -= totalHeight;\n          line.ex -= totalHeight;\n          totalHeight += line.lineHeight;\n        });\n\n        // Find overall position adjustments for anchoring\n        let anchorXOffset = 0;\n        let anchorYOffset = 0;\n        if (anchorX) {\n          if (typeof anchorX === 'number') {\n            anchorXOffset = -anchorX;\n          }\n          else if (typeof anchorX === 'string') {\n            anchorXOffset = -maxLineWidth * (\n              anchorX === 'left' ? 0 :\n              anchorX === 'center' ? 0.5 :\n              anchorX === 'right' ? 1 :\n              parsePercent(anchorX)\n            );\n          }\n        }\n        if (anchorY) {\n          if (typeof anchorY === 'number') {\n            anchorYOffset = -anchorY;\n          }\n          else if (typeof anchorY === 'string') {\n            anchorYOffset = anchorY === 'top' ? 0 :\n              anchorY === 'top-baseline' ? -lines[0].baseline :\n              anchorY === 'top-cap' ? -lines[0].cap :\n              anchorY === 'top-ex' ? -lines[0].ex :\n              anchorY === 'middle' ? totalHeight / 2 :\n              anchorY === 'bottom' ? totalHeight :\n              anchorY === 'bottom-baseline' ? -lines[lines.length - 1].baseline :\n              parsePercent(anchorY) * totalHeight;\n          }\n        }\n\n        if (!metricsOnly) {\n          // Resolve bidi levels\n          const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);\n\n          // Process each line, applying alignment offsets, adding each glyph to the atlas, and\n          // collecting all renderable glyphs into a single collection.\n          glyphIds = new Uint16Array(renderableGlyphCount);\n          glyphFontIndices = new Uint8Array(renderableGlyphCount);\n          glyphPositions = new Float32Array(renderableGlyphCount * 2);\n          glyphData = {};\n          visibleBounds = [INF, INF, -INF, -INF];\n          chunkedBounds = [];\n          if (includeCaretPositions) {\n            caretPositions = new Float32Array(text.length * 4);\n          }\n          if (colorRanges) {\n            glyphColors = new Uint8Array(renderableGlyphCount * 3);\n          }\n          let renderableGlyphIndex = 0;\n          let prevCharIndex = -1;\n          let colorCharIndex = -1;\n          let chunk;\n          let currentColor;\n          lines.forEach((line, lineIndex) => {\n            let {count:lineGlyphCount, width:lineWidth} = line;\n\n            // Ignore empty lines\n            if (lineGlyphCount > 0) {\n              // Count trailing whitespaces, we want to ignore these for certain things\n              let trailingWhitespaceCount = 0;\n              for (let i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace;) {\n                trailingWhitespaceCount++;\n              }\n\n              // Apply horizontal alignment adjustments\n              let lineXOffset = 0;\n              let justifyAdjust = 0;\n              if (textAlign === 'center') {\n                lineXOffset = (maxLineWidth - lineWidth) / 2;\n              } else if (textAlign === 'right') {\n                lineXOffset = maxLineWidth - lineWidth;\n              } else if (textAlign === 'justify' && line.isSoftWrapped) {\n                // count non-trailing whitespace characters, and we'll adjust the offsets per character in the next loop\n                let whitespaceCount = 0;\n                for (let i = lineGlyphCount - trailingWhitespaceCount; i--;) {\n                  if (line.glyphAt(i).glyphObj.isWhitespace) {\n                    whitespaceCount++;\n                  }\n                }\n                justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;\n              }\n              if (justifyAdjust || lineXOffset) {\n                let justifyOffset = 0;\n                for (let i = 0; i < lineGlyphCount; i++) {\n                  let glyphInfo = line.glyphAt(i);\n                  const glyphObj = glyphInfo.glyphObj;\n                  glyphInfo.x += lineXOffset + justifyOffset;\n                  // Expand non-trailing whitespaces for justify alignment\n                  if (justifyAdjust !== 0 && glyphObj.isWhitespace && i < lineGlyphCount - trailingWhitespaceCount) {\n                    justifyOffset += justifyAdjust;\n                    glyphInfo.width += justifyAdjust;\n                  }\n                }\n              }\n\n              // Perform bidi range flipping\n              const flips = bidi.getReorderSegments(\n                text, bidiLevelsResult, line.glyphAt(0).charIndex, line.glyphAt(line.count - 1).charIndex\n              );\n              for (let fi = 0; fi < flips.length; fi++) {\n                const [start, end] = flips[fi];\n                // Map start/end string indices to indices in the line\n                let left = Infinity, right = -Infinity;\n                for (let i = 0; i < lineGlyphCount; i++) {\n                  if (line.glyphAt(i).charIndex >= start) { // gte to handle removed characters\n                    let startInLine = i, endInLine = i;\n                    for (; endInLine < lineGlyphCount; endInLine++) {\n                      let info = line.glyphAt(endInLine);\n                      if (info.charIndex > end) {\n                        break\n                      }\n                      if (endInLine < lineGlyphCount - trailingWhitespaceCount) { //don't include trailing ws in flip width\n                        left = Math.min(left, info.x);\n                        right = Math.max(right, info.x + info.width);\n                      }\n                    }\n                    for (let j = startInLine; j < endInLine; j++) {\n                      const glyphInfo = line.glyphAt(j);\n                      glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);\n                    }\n                    break\n                  }\n                }\n              }\n\n              // Assemble final data arrays\n              let glyphObj;\n              const setGlyphObj = g => glyphObj = g;\n              for (let i = 0; i < lineGlyphCount; i++) {\n                const glyphInfo = line.glyphAt(i);\n                glyphObj = glyphInfo.glyphObj;\n                const glyphId = glyphObj.index;\n\n                // Replace mirrored characters in rtl\n                const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1; //odd level means rtl\n                if (rtl) {\n                  const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);\n                  if (mirrored) {\n                    glyphInfo.fontData.fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);\n                  }\n                }\n\n                // Add caret positions\n                if (includeCaretPositions) {\n                  const {charIndex, fontData} = glyphInfo;\n                  const caretLeft = glyphInfo.x + anchorXOffset;\n                  const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;\n                  caretPositions[charIndex * 4] = rtl ? caretRight : caretLeft; //start edge x\n                  caretPositions[charIndex * 4 + 1] = rtl ? caretLeft : caretRight; //end edge x\n                  caretPositions[charIndex * 4 + 2] = line.baseline + fontData.caretBottom + anchorYOffset; //common bottom y\n                  caretPositions[charIndex * 4 + 3] = line.baseline + fontData.caretTop + anchorYOffset; //common top y\n\n                  // If we skipped any chars from the previous glyph (due to ligature subs), fill in caret\n                  // positions for those missing char indices; currently this uses a best-guess by dividing\n                  // the ligature's width evenly. In the future we may try to use the font's LigatureCaretList\n                  // table to get better interior caret positions.\n                  const ligCount = charIndex - prevCharIndex;\n                  if (ligCount > 1) {\n                    fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);\n                  }\n                  prevCharIndex = charIndex;\n                }\n\n                // Track current color range\n                if (colorRanges) {\n                  const {charIndex} = glyphInfo;\n                  while(charIndex > colorCharIndex) {\n                    colorCharIndex++;\n                    if (colorRanges.hasOwnProperty(colorCharIndex)) {\n                      currentColor = colorRanges[colorCharIndex];\n                    }\n                  }\n                }\n\n                // Get atlas data for renderable glyphs\n                if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n                  const idx = renderableGlyphIndex++;\n                  const {fontSizeMult, src: fontSrc, index: fontIndex} = glyphInfo.fontData;\n\n                  // Add this glyph's path data\n                  const fontGlyphData = glyphData[fontSrc] || (glyphData[fontSrc] = {});\n                  if (!fontGlyphData[glyphId]) {\n                    fontGlyphData[glyphId] = {\n                      path: glyphObj.path,\n                      pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]\n                    };\n                  }\n\n                  // Determine final glyph position and add to glyphPositions array\n                  const glyphX = glyphInfo.x + anchorXOffset;\n                  const glyphY = glyphInfo.y + line.baseline + anchorYOffset;\n                  glyphPositions[idx * 2] = glyphX;\n                  glyphPositions[idx * 2 + 1] = glyphY;\n\n                  // Track total visible bounds\n                  const visX0 = glyphX + glyphObj.xMin * fontSizeMult;\n                  const visY0 = glyphY + glyphObj.yMin * fontSizeMult;\n                  const visX1 = glyphX + glyphObj.xMax * fontSizeMult;\n                  const visY1 = glyphY + glyphObj.yMax * fontSizeMult;\n                  if (visX0 < visibleBounds[0]) visibleBounds[0] = visX0;\n                  if (visY0 < visibleBounds[1]) visibleBounds[1] = visY0;\n                  if (visX1 > visibleBounds[2]) visibleBounds[2] = visX1;\n                  if (visY1 > visibleBounds[3]) visibleBounds[3] = visY1;\n\n                  // Track bounding rects for each chunk of N glyphs\n                  if (idx % chunkedBoundsSize === 0) {\n                    chunk = {start: idx, end: idx, rect: [INF, INF, -INF, -INF]};\n                    chunkedBounds.push(chunk);\n                  }\n                  chunk.end++;\n                  const chunkRect = chunk.rect;\n                  if (visX0 < chunkRect[0]) chunkRect[0] = visX0;\n                  if (visY0 < chunkRect[1]) chunkRect[1] = visY0;\n                  if (visX1 > chunkRect[2]) chunkRect[2] = visX1;\n                  if (visY1 > chunkRect[3]) chunkRect[3] = visY1;\n\n                  // Add to glyph ids and font indices arrays\n                  glyphIds[idx] = glyphId;\n                  glyphFontIndices[idx] = fontIndex;\n\n                  // Add colors\n                  if (colorRanges) {\n                    const start = idx * 3;\n                    glyphColors[start] = currentColor >> 16 & 255;\n                    glyphColors[start + 1] = currentColor >> 8 & 255;\n                    glyphColors[start + 2] = currentColor & 255;\n                  }\n                }\n              }\n            }\n          });\n\n          // Fill in remaining caret positions in case the final character was a ligature\n          if (caretPositions) {\n            const ligCount = text.length - prevCharIndex;\n            if (ligCount > 1) {\n              fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);\n            }\n          }\n        }\n\n        // Assemble final data about each font used\n        const fontData = [];\n        metricsByFont.forEach(({index, src, unitsPerEm, ascender, descender, lineHeight, capHeight, xHeight}) => {\n          fontData[index] = {src, unitsPerEm, ascender, descender, lineHeight, capHeight, xHeight};\n        });\n\n        // Timing stats\n        timings.typesetting = now() - typesetStart;\n\n        callback({\n          glyphIds, //id for each glyph, specific to that glyph's font\n          glyphFontIndices, //index into fontData for each glyph\n          glyphPositions, //x,y of each glyph's origin in layout\n          glyphData, //dict holding data about each glyph appearing in the text\n          fontData, //data about each font used in the text\n          caretPositions, //startX,endX,bottomY caret positions for each char\n          // caretHeight, //height of cursor from bottom to top - todo per glyph?\n          glyphColors, //color for each glyph, if color ranges supplied\n          chunkedBounds, //total rects per (n=chunkedBoundsSize) consecutive glyphs\n          fontSize, //calculated em height\n          topBaseline: anchorYOffset + lines[0].baseline, //y coordinate of the top line's baseline\n          blockBounds: [ //bounds for the whole block of text, including vertical padding for lineHeight\n            anchorXOffset,\n            anchorYOffset - totalHeight,\n            anchorXOffset + maxLineWidth,\n            anchorYOffset\n          ],\n          visibleBounds, //total bounds of visible text paths, may be larger or smaller than blockBounds\n          timings\n        });\n      });\n    }\n\n\n    /**\n     * For a given text string and font parameters, determine the resulting block dimensions\n     * after wrapping for the given maxWidth.\n     * @param args\n     * @param callback\n     */\n    function measure(args, callback) {\n      typeset({...args, metricsOnly: true}, (result) => {\n        const [x0, y0, x1, y1] = result.blockBounds;\n        callback({\n          width: x1 - x0,\n          height: y1 - y0\n        });\n      });\n    }\n\n    function parsePercent(str) {\n      let match = str.match(/^([\\d.]+)%$/);\n      let pct = match ? parseFloat(match[1]) : NaN;\n      return isNaN(pct) ? 0 : pct / 100\n    }\n\n    function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {\n      const ligStartX = caretPositions[ligStartIndex * 4];\n      const ligEndX = caretPositions[ligStartIndex * 4 + 1];\n      const ligBottom = caretPositions[ligStartIndex * 4 + 2];\n      const ligTop = caretPositions[ligStartIndex * 4 + 3];\n      const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;\n      for (let i = 0; i < ligCount; i++) {\n        const startIndex = (ligStartIndex + i) * 4;\n        caretPositions[startIndex] = ligStartX + guessedAdvanceX * i;\n        caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i + 1);\n        caretPositions[startIndex + 2] = ligBottom;\n        caretPositions[startIndex + 3] = ligTop;\n      }\n    }\n\n    function now() {\n      return (self.performance || Date).now()\n    }\n\n    // Array-backed structure for a single line's glyphs data\n    function TextLine() {\n      this.data = [];\n    }\n    const textLineProps = ['glyphObj', 'x', 'y', 'width', 'charIndex', 'fontData'];\n    TextLine.prototype = {\n      width: 0,\n      lineHeight: 0,\n      baseline: 0,\n      cap: 0,\n      ex: 0,\n      isSoftWrapped: false,\n      get count() {\n        return Math.ceil(this.data.length / textLineProps.length)\n      },\n      glyphAt(i) {\n        let fly = TextLine.flyweight;\n        fly.data = this.data;\n        fly.index = i;\n        return fly\n      },\n      splitAt(i) {\n        let newLine = new TextLine();\n        newLine.data = this.data.splice(i * textLineProps.length);\n        return newLine\n      }\n    };\n    TextLine.flyweight = textLineProps.reduce((obj, prop, i, all) => {\n      Object.defineProperty(obj, prop, {\n        get() {\n          return this.data[this.index * textLineProps.length + i]\n        },\n        set(val) {\n          this.data[this.index * textLineProps.length + i] = val;\n        }\n      });\n      return obj\n    }, {data: null, index: 0});\n\n\n    return {\n      typeset,\n      measure,\n    }\n  }\n\n  const now = () => (self.performance || Date).now();\n\n  const mainThreadGenerator = /*#__PURE__*/ createSDFGenerator__default['default']();\n\n  let warned;\n\n  /**\n   * Generate an SDF texture image for a single glyph path, placing the result into a webgl canvas at a\n   * given location and channel. Utilizes the webgl-sdf-generator external package for GPU-accelerated SDF\n   * generation when supported.\n   */\n  function generateSDF(width, height, path, viewBox, distance, exponent, canvas, x, y, channel, useWebGL = true) {\n    // Allow opt-out\n    if (!useWebGL) {\n      return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel)\n    }\n\n    // Attempt GPU-accelerated generation first\n    return generateSDF_GL(width, height, path, viewBox, distance, exponent, canvas, x, y, channel).then(\n      null,\n      err => {\n        // WebGL failed either due to a hard error or unexpected results; fall back to JS in workers\n        if (!warned) {\n          console.warn(`WebGL SDF generation failed, falling back to JS`, err);\n          warned = true;\n        }\n        return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel)\n      }\n    )\n  }\n\n  const queue = [];\n  const chunkTimeBudget = 5; // ms\n  let timer = 0;\n\n  function nextChunk() {\n    const start = now();\n    while (queue.length && now() - start < chunkTimeBudget) {\n      queue.shift()();\n    }\n    timer = queue.length ? setTimeout(nextChunk, 0) : 0;\n  }\n\n  /**\n   * WebGL-based implementation executed on the main thread. Requests are executed in time-bounded\n   * macrotask chunks to allow render frames to execute in between.\n   */\n  const generateSDF_GL = (...args) => {\n    return new Promise((resolve, reject) => {\n      queue.push(() => {\n        const start = now();\n        try {\n          mainThreadGenerator.webgl.generateIntoCanvas(...args);\n          resolve({ timing: now() - start });\n        } catch (err) {\n          reject(err);\n        }\n      });\n      if (!timer) {\n        timer = setTimeout(nextChunk, 0);\n      }\n    })\n  };\n\n  const threadCount = 4; // how many workers to spawn\n  const idleTimeout = 2000; // workers will be terminated after being idle this many milliseconds\n  const threads = {};\n  let callNum = 0;\n\n  /**\n   * Fallback JS-based implementation, fanned out to a number of worker threads for parallelism\n   */\n  function generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel) {\n    const workerId = 'TroikaTextSDFGenerator_JS_' + ((callNum++) % threadCount);\n    let thread = threads[workerId];\n    if (!thread) {\n      thread = threads[workerId] = {\n        workerModule: troikaWorkerUtils.defineWorkerModule({\n          name: workerId,\n          workerId,\n          dependencies: [\n            createSDFGenerator__default['default'],\n            now\n          ],\n          init(_createSDFGenerator, now) {\n            const generate = _createSDFGenerator().javascript.generate;\n            return function (...args) {\n              const start = now();\n              const textureData = generate(...args);\n              return {\n                textureData,\n                timing: now() - start\n              }\n            }\n          },\n          getTransferables(result) {\n            return [result.textureData.buffer]\n          }\n        }),\n        requests: 0,\n        idleTimer: null\n      };\n    }\n\n    thread.requests++;\n    clearTimeout(thread.idleTimer);\n    return thread.workerModule(width, height, path, viewBox, distance, exponent)\n      .then(({ textureData, timing }) => {\n        // copy result data into the canvas\n        const start = now();\n        // expand single-channel data into rgba\n        const imageData = new Uint8Array(textureData.length * 4);\n        for (let i = 0; i < textureData.length; i++) {\n          imageData[i * 4 + channel] = textureData[i];\n        }\n        mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x, y, width, height, 1 << (3 - channel));\n        timing += now() - start;\n\n        // clean up workers after a while\n        if (--thread.requests === 0) {\n          thread.idleTimer = setTimeout(() => { troikaWorkerUtils.terminateWorker(workerId); }, idleTimeout);\n        }\n        return { timing }\n      })\n  }\n\n  function warmUpSDFCanvas(canvas) {\n    if (!canvas._warm) {\n      mainThreadGenerator.webgl.isSupported(canvas);\n      canvas._warm = true;\n    }\n  }\n\n  const resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;\n\n  const CONFIG = {\n    defaultFontURL: null,\n    unicodeFontsURL: null,\n    sdfGlyphSize: 64,\n    sdfMargin: 1 / 16,\n    sdfExponent: 9,\n    textureWidth: 2048,\n    useWorker: true,\n  };\n  const tempColor = /*#__PURE__*/new three.Color();\n  let hasRequested = false;\n\n  function now$1() {\n    return (self.performance || Date).now()\n  }\n\n  /**\n   * Customizes the text builder configuration. This must be called prior to the first font processing\n   * request, and applies to all fonts.\n   *\n   * @param {String} config.defaultFontURL - The URL of the default font to use for text processing\n   *                 requests, in case none is specified or the specifiede font fails to load or parse.\n   *                 Defaults to \"Roboto Regular\" from Google Fonts.\n   * @param {String} config.unicodeFontsURL - A custom location for the fallback unicode-font-resolver\n   *                 data and font files, if you don't want to use the default CDN. See\n   *                 https://github.com/lojjic/unicode-font-resolver for details. It can also be\n   *                 configured per text instance, but this lets you do it once globally.\n   * @param {Number} config.sdfGlyphSize - The default size of each glyph's SDF (signed distance field)\n   *                 texture used for rendering. Must be a power-of-two number, and applies to all fonts,\n   *                 but note that this can also be overridden per call to `getTextRenderInfo()`.\n   *                 Larger sizes can improve the quality of glyph rendering by increasing the sharpness\n   *                 of corners and preventing loss of very thin lines, at the expense of memory. Defaults\n   *                 to 64 which is generally a good balance of size and quality.\n   * @param {Number} config.sdfExponent - The exponent used when encoding the SDF values. A higher exponent\n   *                 shifts the encoded 8-bit values to achieve higher precision/accuracy at texels nearer\n   *                 the glyph's path, with lower precision further away. Defaults to 9.\n   * @param {Number} config.sdfMargin - How much space to reserve in the SDF as margin outside the glyph's\n   *                 path, as a percentage of the SDF width. A larger margin increases the quality of\n   *                 extruded glyph outlines, but decreases the precision available for the glyph itself.\n   *                 Defaults to 1/16th of the glyph size.\n   * @param {Number} config.textureWidth - The width of the SDF texture; must be a power of 2. Defaults to\n   *                 2048 which is a safe maximum texture dimension according to the stats at\n   *                 https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE and should allow for a\n   *                 reasonably large number of glyphs (default glyph size of 64^2 and safe texture size of\n   *                 2048^2, times 4 channels, allows for 4096 glyphs.) This can be increased if you need to\n   *                 increase the glyph size and/or have an extraordinary number of glyphs.\n   * @param {Boolean} config.useWorker - Whether to run typesetting in a web worker. Defaults to true.\n   */\n  function configureTextBuilder(config) {\n    if (hasRequested) {\n      console.warn('configureTextBuilder called after first font request; will be ignored.');\n    } else {\n      assign(CONFIG, config);\n    }\n  }\n\n  /**\n   * Repository for all font SDF atlas textures and their glyph mappings. There is a separate atlas for\n   * each sdfGlyphSize. Each atlas has a single Texture that holds all glyphs for all fonts.\n   *\n   *   {\n   *     [sdfGlyphSize]: {\n   *       glyphCount: number,\n   *       sdfGlyphSize: number,\n   *       sdfTexture: Texture,\n   *       sdfCanvas: HTMLCanvasElement,\n   *       contextLost: boolean,\n   *       glyphsByFont: Map<fontURL, Map<glyphID, {path, atlasIndex, sdfViewBox}>>\n   *     }\n   *   }\n   */\n  const atlases = Object.create(null);\n\n  /**\n   * @typedef {object} TroikaTextRenderInfo - Format of the result from `getTextRenderInfo`.\n   * @property {TypesetParams} parameters - The normalized input arguments to the render call.\n   * @property {Texture} sdfTexture - The SDF atlas texture.\n   * @property {number} sdfGlyphSize - The size of each glyph's SDF; see `configureTextBuilder`.\n   * @property {number} sdfExponent - The exponent used in encoding the SDF's values; see `configureTextBuilder`.\n   * @property {Float32Array} glyphBounds - List of [minX, minY, maxX, maxY] quad bounds for each glyph.\n   * @property {Float32Array} glyphAtlasIndices - List holding each glyph's index in the SDF atlas.\n   * @property {Uint8Array} [glyphColors] - List holding each glyph's [r, g, b] color, if `colorRanges` was supplied.\n   * @property {Float32Array} [caretPositions] - A list of caret positions for all characters in the string; each is\n   *           four elements: the starting X, the ending X, the bottom Y, and the top Y for the caret.\n   * @property {number} [caretHeight] - An appropriate height for all selection carets.\n   * @property {number} ascender - The font's ascender metric.\n   * @property {number} descender - The font's descender metric.\n   * @property {number} capHeight - The font's cap height metric, based on the height of Latin capital letters.\n   * @property {number} xHeight - The font's x height metric, based on the height of Latin lowercase letters.\n   * @property {number} lineHeight - The final computed lineHeight measurement.\n   * @property {number} topBaseline - The y position of the top line's baseline.\n   * @property {Array<number>} blockBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;\n   *           this can include extra vertical space beyond the visible glyphs due to lineHeight, and is\n   *           equivalent to the dimensions of a block-level text element in CSS.\n   * @property {Array<number>} visibleBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;\n   *           unlike `blockBounds` this is tightly wrapped to the visible glyph paths.\n   * @property {Array<object>} chunkedBounds - List of bounding rects for each consecutive set of N glyphs,\n   *           in the format `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`.\n   * @property {object} timings - Timing info for various parts of the rendering logic including SDF\n   *           generation, typesetting, etc.\n   * @frozen\n   */\n\n  /**\n   * @callback getTextRenderInfo~callback\n   * @param {TroikaTextRenderInfo} textRenderInfo\n   */\n\n  /**\n   * Main entry point for requesting the data needed to render a text string with given font parameters.\n   * This is an asynchronous call, performing most of the logic in a web worker thread.\n   * @param {TypesetParams} args\n   * @param {getTextRenderInfo~callback} callback\n   */\n  function getTextRenderInfo(args, callback) {\n    hasRequested = true;\n    args = assign({}, args);\n    const totalStart = now$1();\n\n    // Convert relative URL to absolute so it can be resolved in the worker, and add fallbacks.\n    // In the future we'll allow args.font to be a list with unicode ranges too.\n    const { defaultFontURL } = CONFIG;\n    const fonts = [];\n    if (defaultFontURL) {\n      fonts.push({label: 'default', src: toAbsoluteURL(defaultFontURL)});\n    }\n    if (args.font) {\n      fonts.push({label: 'user', src: toAbsoluteURL(args.font)});\n    }\n    args.font = fonts;\n\n    // Normalize text to a string\n    args.text = '' + args.text;\n\n    args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;\n    args.unicodeFontsURL = args.unicodeFontsURL || CONFIG.unicodeFontsURL;\n\n    // Normalize colors\n    if (args.colorRanges != null) {\n      let colors = {};\n      for (let key in args.colorRanges) {\n        if (args.colorRanges.hasOwnProperty(key)) {\n          let val = args.colorRanges[key];\n          if (typeof val !== 'number') {\n            val = tempColor.set(val).getHex();\n          }\n          colors[key] = val;\n        }\n      }\n      args.colorRanges = colors;\n    }\n\n    Object.freeze(args);\n\n    // Init the atlas if needed\n    const {textureWidth, sdfExponent} = CONFIG;\n    const {sdfGlyphSize} = args;\n    const glyphsPerRow = (textureWidth / sdfGlyphSize * 4);\n    let atlas = atlases[sdfGlyphSize];\n    if (!atlas) {\n      const canvas = document.createElement('canvas');\n      canvas.width = textureWidth;\n      canvas.height = sdfGlyphSize * 256 / glyphsPerRow; // start tall enough to fit 256 glyphs\n      atlas = atlases[sdfGlyphSize] = {\n        glyphCount: 0,\n        sdfGlyphSize,\n        sdfCanvas: canvas,\n        sdfTexture: new three.Texture(\n          canvas,\n          undefined,\n          undefined,\n          undefined,\n          three.LinearFilter,\n          three.LinearFilter\n        ),\n        contextLost: false,\n        glyphsByFont: new Map()\n      };\n      atlas.sdfTexture.generateMipmaps = false;\n      initContextLossHandling(atlas);\n    }\n\n    const {sdfTexture, sdfCanvas} = atlas;\n\n    // Issue request to the typesetting engine in the worker\n    const typeset = CONFIG.useWorker ? typesetInWorker : typesetOnMainThread;\n    typeset(args).then(result => {\n      const {glyphIds, glyphFontIndices, fontData, glyphPositions, fontSize, timings} = result;\n      const neededSDFs = [];\n      const glyphBounds = new Float32Array(glyphIds.length * 4);\n      let boundsIdx = 0;\n      let positionsIdx = 0;\n      const quadsStart = now$1();\n\n      const fontGlyphMaps = fontData.map(font => {\n        let map = atlas.glyphsByFont.get(font.src);\n        if (!map) {\n          atlas.glyphsByFont.set(font.src, map = new Map());\n        }\n        return map\n      });\n\n      glyphIds.forEach((glyphId, i) => {\n        const fontIndex = glyphFontIndices[i];\n        const {src: fontSrc, unitsPerEm} = fontData[fontIndex];\n        let glyphInfo = fontGlyphMaps[fontIndex].get(glyphId);\n\n        // If this is a glyphId not seen before, add it to the atlas\n        if (!glyphInfo) {\n          const {path, pathBounds} = result.glyphData[fontSrc][glyphId];\n\n          // Margin around path edges in SDF, based on a percentage of the glyph's max dimension.\n          // Note we add an extra 0.5 px over the configured value because the outer 0.5 doesn't contain\n          // useful interpolated values and will be ignored anyway.\n          const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1])\n            / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);\n\n          const atlasIndex = atlas.glyphCount++;\n          const sdfViewBox = [\n            pathBounds[0] - fontUnitsMargin,\n            pathBounds[1] - fontUnitsMargin,\n            pathBounds[2] + fontUnitsMargin,\n            pathBounds[3] + fontUnitsMargin,\n          ];\n          fontGlyphMaps[fontIndex].set(glyphId, (glyphInfo = { path, atlasIndex, sdfViewBox }));\n\n          // Collect those that need SDF generation\n          neededSDFs.push(glyphInfo);\n        }\n\n        // Calculate bounds for renderable quads\n        // TODO can we get this back off the main thread?\n        const {sdfViewBox} = glyphInfo;\n        const posX = glyphPositions[positionsIdx++];\n        const posY = glyphPositions[positionsIdx++];\n        const fontSizeMult = fontSize / unitsPerEm;\n        glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;\n        glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;\n        glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;\n        glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;\n\n        // Convert glyphId to SDF index for the shader\n        glyphIds[i] = glyphInfo.atlasIndex;\n      });\n      timings.quads = (timings.quads || 0) + (now$1() - quadsStart);\n\n      const sdfStart = now$1();\n      timings.sdf = {};\n\n      // Grow the texture height by power of 2 if needed\n      const currentHeight = sdfCanvas.height;\n      const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);\n      const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));\n      if (neededHeight > currentHeight) {\n        // Since resizing the canvas clears its render buffer, it needs special handling to copy the old contents over\n        console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);\n        resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);\n        // As of Three r136 textures cannot be resized once they're allocated on the GPU, we must dispose to reallocate it\n        sdfTexture.dispose();\n      }\n\n      Promise.all(neededSDFs.map(glyphInfo =>\n        generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({timing}) => {\n          timings.sdf[glyphInfo.atlasIndex] = timing;\n        })\n      )).then(() => {\n        if (neededSDFs.length && !atlas.contextLost) {\n          safariPre15Workaround(atlas);\n          sdfTexture.needsUpdate = true;\n        }\n        timings.sdfTotal = now$1() - sdfStart;\n        timings.total = now$1() - totalStart;\n        // console.log(`SDF - ${timings.sdfTotal}, Total - ${timings.total - timings.fontLoad}`)\n\n        // Invoke callback with the text layout arrays and updated texture\n        callback(Object.freeze({\n          parameters: args,\n          sdfTexture,\n          sdfGlyphSize,\n          sdfExponent,\n          glyphBounds,\n          glyphAtlasIndices: glyphIds,\n          glyphColors: result.glyphColors,\n          caretPositions: result.caretPositions,\n          chunkedBounds: result.chunkedBounds,\n          ascender: result.ascender,\n          descender: result.descender,\n          lineHeight: result.lineHeight,\n          capHeight: result.capHeight,\n          xHeight: result.xHeight,\n          topBaseline: result.topBaseline,\n          blockBounds: result.blockBounds,\n          visibleBounds: result.visibleBounds,\n          timings: result.timings,\n        }));\n      });\n    });\n\n    // While the typesetting request is being handled, go ahead and make sure the atlas canvas context is\n    // \"warmed up\"; the first request will be the longest due to shader program compilation so this gets\n    // a head start on that process before SDFs actually start getting processed.\n    Promise.resolve().then(() => {\n      if (!atlas.contextLost) {\n        warmUpSDFCanvas(sdfCanvas);\n      }\n    });\n  }\n\n  function generateGlyphSDF({path, atlasIndex, sdfViewBox}, {sdfGlyphSize, sdfCanvas, contextLost}, useGPU) {\n    if (contextLost) {\n      // If the context is lost there's nothing we can do, just quit silently and let it\n      // get regenerated when the context is restored\n      return Promise.resolve({timing: -1})\n    }\n    const {textureWidth, sdfExponent} = CONFIG;\n    const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);\n    const squareIndex = Math.floor(atlasIndex / 4);\n    const x = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;\n    const y = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;\n    const channel = atlasIndex % 4;\n    return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x, y, channel, useGPU)\n  }\n\n  function initContextLossHandling(atlas) {\n    const canvas = atlas.sdfCanvas;\n\n    /*\n    // Begin context loss simulation\n    if (!window.WebGLDebugUtils) {\n      let script = document.getElementById('WebGLDebugUtilsScript')\n      if (!script) {\n        script = document.createElement('script')\n        script.id = 'WebGLDebugUtils'\n        document.head.appendChild(script)\n        script.src = 'https://cdn.jsdelivr.net/gh/KhronosGroup/WebGLDeveloperTools@b42e702/src/debug/webgl-debug.js'\n      }\n      script.addEventListener('load', () => {\n        initContextLossHandling(atlas)\n      })\n      return\n    }\n    window.WebGLDebugUtils.makeLostContextSimulatingCanvas(canvas)\n    canvas.loseContextInNCalls(500)\n    canvas.addEventListener('webglcontextrestored', (event) => {\n      canvas.loseContextInNCalls(5000)\n    })\n    // End context loss simulation\n    */\n\n    canvas.addEventListener('webglcontextlost', (event) => {\n      console.log('Context Lost', event);\n      event.preventDefault();\n      atlas.contextLost = true;\n    });\n    canvas.addEventListener('webglcontextrestored', (event) => {\n      console.log('Context Restored', event);\n      atlas.contextLost = false;\n      // Regenerate all glyphs into the restored canvas:\n      const promises = [];\n      atlas.glyphsByFont.forEach(glyphMap => {\n        glyphMap.forEach(glyph => {\n          promises.push(generateGlyphSDF(glyph, atlas, true));\n        });\n      });\n      Promise.all(promises).then(() => {\n        safariPre15Workaround(atlas);\n        atlas.sdfTexture.needsUpdate = true;\n      });\n    });\n  }\n\n  /**\n   * Preload a given font and optionally pre-generate glyph SDFs for one or more character sequences.\n   * This can be useful to avoid long pauses when first showing text in a scene, by preloading the\n   * needed fonts and glyphs up front along with other assets.\n   *\n   * @param {object} options\n   * @param {string} options.font - URL of the font file to preload. If not given, the default font will\n   *        be loaded.\n   * @param {string|string[]} options.characters - One or more character sequences for which to pre-\n   *        generate glyph SDFs. Note that this will honor ligature substitution, so you may need\n   *        to specify ligature sequences in addition to their individual characters to get all\n   *        possible glyphs, e.g. `[\"t\", \"h\", \"th\"]` to get the \"t\" and \"h\" glyphs plus the \"th\" ligature.\n   * @param {number} options.sdfGlyphSize - The size at which to prerender the SDF textures for the\n   *        specified `characters`.\n   * @param {function} callback - A function that will be called when the preloading is complete.\n   */\n  function preloadFont({font, characters, sdfGlyphSize}, callback) {\n    let text = Array.isArray(characters) ? characters.join('\\n') : '' + characters;\n    getTextRenderInfo({ font, sdfGlyphSize, text }, callback);\n  }\n\n\n  // Local assign impl so we don't have to import troika-core\n  function assign(toObj, fromObj) {\n    for (let key in fromObj) {\n      if (fromObj.hasOwnProperty(key)) {\n        toObj[key] = fromObj[key];\n      }\n    }\n    return toObj\n  }\n\n  // Utility for making URLs absolute\n  let linkEl;\n  function toAbsoluteURL(path) {\n    if (!linkEl) {\n      linkEl = typeof document === 'undefined' ? {} : document.createElement('a');\n    }\n    linkEl.href = path;\n    return linkEl.href\n  }\n\n  /**\n   * Safari < v15 seems unable to use the SDF webgl canvas as a texture. This applies a workaround\n   * where it reads the pixels out of that canvas and uploads them as a data texture instead, at\n   * a slight performance cost.\n   */\n  function safariPre15Workaround(atlas) {\n    // Use createImageBitmap support as a proxy for Safari<15, all other mainstream browsers\n    // have supported it for a long while so any false positives should be minimal.\n    if (typeof createImageBitmap !== 'function') {\n      console.info('Safari<15: applying SDF canvas workaround');\n      const {sdfCanvas, sdfTexture} = atlas;\n      const {width, height} = sdfCanvas;\n      const gl = atlas.sdfCanvas.getContext('webgl');\n      let pixels = sdfTexture.image.data;\n      if (!pixels || pixels.length !== width * height * 4) {\n        pixels = new Uint8Array(width * height * 4);\n        sdfTexture.image = {width, height, data: pixels};\n        sdfTexture.flipY = false;\n        sdfTexture.isDataTexture = true;\n      }\n      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n    }\n  }\n\n  const typesetterWorkerModule = /*#__PURE__*/troikaWorkerUtils.defineWorkerModule({\n    name: 'Typesetter',\n    dependencies: [\n      createTypesetter,\n      fontResolverWorkerModule,\n      bidiFactory__default['default'],\n    ],\n    init(createTypesetter, fontResolver, bidiFactory) {\n      return createTypesetter(fontResolver, bidiFactory())\n    }\n  });\n\n  const typesetInWorker = /*#__PURE__*/troikaWorkerUtils.defineWorkerModule({\n    name: 'Typesetter',\n    dependencies: [\n      typesetterWorkerModule,\n    ],\n    init(typesetter) {\n      return function(args) {\n        return new Promise(resolve => {\n          typesetter.typeset(args, resolve);\n        })\n      }\n    },\n    getTransferables(result) {\n      // Mark array buffers as transferable to avoid cloning during postMessage\n      const transferables = [];\n      for (let p in result) {\n        if (result[p] && result[p].buffer) {\n          transferables.push(result[p].buffer);\n        }\n      }\n      return transferables\n    }\n  });\n\n  const typesetOnMainThread = typesetInWorker.onMainThread;\n\n  function dumpSDFTextures() {\n    Object.keys(atlases).forEach(size => {\n      const canvas = atlases[size].sdfCanvas;\n      const {width, height} = canvas;\n      console.log(\"%c.\", `\n      background: url(${canvas.toDataURL()});\n      background-size: ${width}px ${height}px;\n      color: transparent;\n      font-size: 0;\n      line-height: ${height}px;\n      padding-left: ${width}px;\n    `);\n    });\n  }\n\n  const templateGeometries = {};\n\n  function getTemplateGeometry(detail) {\n    let geom = templateGeometries[detail];\n    if (!geom) {\n      geom = templateGeometries[detail] = new three.PlaneGeometry(1, 1, detail, detail).translate(0.5, 0.5, 0);\n    }\n    return geom\n  }\n\n  const glyphBoundsAttrName = 'aTroikaGlyphBounds';\n  const glyphIndexAttrName = 'aTroikaGlyphIndex';\n  const glyphColorAttrName = 'aTroikaGlyphColor';\n\n  /**\n  @class GlyphsGeometry\n\n  A specialized Geometry for rendering a set of text glyphs. Uses InstancedBufferGeometry to\n  render the glyphs using GPU instancing of a single quad, rather than constructing a whole\n  geometry with vertices, for much smaller attribute arraybuffers according to this math:\n\n    Where N = number of glyphs...\n\n    Instanced:\n    - position: 4 * 3\n    - index: 2 * 3\n    - normal: 4 * 3\n    - uv: 4 * 2\n    - glyph x/y bounds: N * 4\n    - glyph indices: N * 1\n    = 5N + 38\n\n    Non-instanced:\n    - position: N * 4 * 3\n    - index: N * 2 * 3\n    - normal: N * 4 * 3\n    - uv: N * 4 * 2\n    - glyph indices: N * 1\n    = 39N\n\n  A downside of this is the rare-but-possible lack of the instanced arrays extension,\n  which we could potentially work around with a fallback non-instanced implementation.\n\n  */\n  class GlyphsGeometry extends three.InstancedBufferGeometry {\n    constructor() {\n      super();\n\n      this.detail = 1;\n      this.curveRadius = 0;\n\n      // Define groups for rendering text outline as a separate pass; these will only\n      // be used when the `material` getter returns an array, i.e. outlineWidth > 0.\n      this.groups = [\n        {start: 0, count: Infinity, materialIndex: 0},\n        {start: 0, count: Infinity, materialIndex: 1}\n      ];\n\n      // Preallocate empty bounding objects\n      this.boundingSphere = new three.Sphere();\n      this.boundingBox = new three.Box3();\n    }\n\n    computeBoundingSphere () {\n      // No-op; we'll sync the boundingSphere proactively when needed.\n    }\n\n    computeBoundingBox() {\n      // No-op; we'll sync the boundingBox proactively when needed.\n    }\n\n    set detail(detail) {\n      if (detail !== this._detail) {\n        this._detail = detail;\n        if (typeof detail !== 'number' || detail < 1) {\n          detail = 1;\n        }\n        let tpl = getTemplateGeometry(detail)\n        ;['position', 'normal', 'uv'].forEach(attr => {\n          this.attributes[attr] = tpl.attributes[attr].clone();\n        });\n        this.setIndex(tpl.getIndex().clone());\n      }\n    }\n    get detail() {\n      return this._detail\n    }\n\n    set curveRadius(r) {\n      if (r !== this._curveRadius) {\n        this._curveRadius = r;\n        this._updateBounds();\n      }\n    }\n    get curveRadius() {\n      return this._curveRadius\n    }\n\n    /**\n     * Update the geometry for a new set of glyphs.\n     * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs\n     *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1\n     * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within\n     *        the SDF atlas texture.\n     * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs\n     * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N\n     *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be\n     *        used with `applyClipRect` to choose an optimized `instanceCount`.\n     * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.\n     */\n    updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {\n      // Update the instance attributes\n      this.updateAttributeData(glyphBoundsAttrName, glyphBounds, 4);\n      this.updateAttributeData(glyphIndexAttrName, glyphAtlasIndices, 1);\n      this.updateAttributeData(glyphColorAttrName, glyphColors, 3);\n      this._blockBounds = blockBounds;\n      this._chunkedBounds = chunkedBounds;\n      this.instanceCount = glyphAtlasIndices.length;\n      this._updateBounds();\n    }\n\n    _updateBounds() {\n      const bounds = this._blockBounds;\n      if (bounds) {\n        const { curveRadius, boundingBox: bbox } = this;\n        if (curveRadius) {\n          const { PI, floor, min, max, sin, cos } = Math;\n          const halfPi = PI / 2;\n          const twoPi = PI * 2;\n          const absR = Math.abs(curveRadius);\n          const leftAngle = bounds[0] / absR;\n          const rightAngle = bounds[2] / absR;\n          const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi)\n            ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);\n          const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi)\n            ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);\n          const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi)\n            ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);\n          bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);\n          bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);\n        } else {\n          bbox.min.set(bounds[0], bounds[1], 0);\n          bbox.max.set(bounds[2], bounds[3], 0);\n        }\n        bbox.getBoundingSphere(this.boundingSphere);\n      }\n    }\n\n    /**\n     * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest\n     * `instanceCount` that will show all glyphs within the clipped view. This is an optimization\n     * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would\n     * be clipped anyway.\n     *\n     * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting\n     * offset, this optimization becomes less effective as the clipRect moves closer to the end of the\n     * text block. We could fix that by switching from instancing to a full geometry with a drawRange,\n     * but at the expense of much larger attribute buffers (see classdoc above.)\n     *\n     * @param {Vector4} clipRect\n     */\n    applyClipRect(clipRect) {\n      let count = this.getAttribute(glyphIndexAttrName).count;\n      let chunks = this._chunkedBounds;\n      if (chunks) {\n        for (let i = chunks.length; i--;) {\n          count = chunks[i].end;\n          let rect = chunks[i].rect;\n          // note: both rects are l-b-r-t\n          if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {\n            break\n          }\n        }\n      }\n      this.instanceCount = count;\n    }\n\n    /**\n     * Utility for updating instance attributes with automatic resizing\n     */\n    updateAttributeData(attrName, newArray, itemSize) {\n      const attr = this.getAttribute(attrName);\n      if (newArray) {\n        // If length isn't changing, just update the attribute's array data\n        if (attr && attr.array.length === newArray.length) {\n          attr.array.set(newArray);\n          attr.needsUpdate = true;\n        } else {\n          this.setAttribute(attrName, new three.InstancedBufferAttribute(newArray, itemSize));\n          // If the new attribute has a different size, we also have to (as of r117) manually clear the\n          // internal cached max instance count. See https://github.com/mrdoob/three.js/issues/19706\n          // It's unclear if this is a threejs bug or a truly unsupported scenario; discussion in\n          // that ticket is ambiguous as to whether replacing a BufferAttribute with one of a\n          // different size is supported, but https://github.com/mrdoob/three.js/pull/17418 strongly\n          // implies it should be supported. It's possible we need to\n          delete this._maxInstanceCount; //for r117+, could be fragile\n          this.dispose(); //for r118+, more robust feeling, but more heavy-handed than I'd like\n        }\n      } else if (attr) {\n        this.deleteAttribute(attrName);\n      }\n    }\n  }\n\n  // language=GLSL\n  const VERTEX_DEFS = `\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform vec4 uTroikaTotalBounds;\nuniform vec4 uTroikaClipRect;\nuniform mat3 uTroikaOrient;\nuniform bool uTroikaUseGlyphColors;\nuniform float uTroikaEdgeOffset;\nuniform float uTroikaBlurRadius;\nuniform vec2 uTroikaPositionOffset;\nuniform float uTroikaCurveRadius;\nattribute vec4 aTroikaGlyphBounds;\nattribute float aTroikaGlyphIndex;\nattribute vec3 aTroikaGlyphColor;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec3 vTroikaGlyphColor;\nvarying vec2 vTroikaGlyphDimensions;\n`;\n\n  // language=GLSL prefix=\"void main() {\" suffix=\"}\"\n  const VERTEX_TRANSFORM = `\nvec4 bounds = aTroikaGlyphBounds;\nbounds.xz += uTroikaPositionOffset.x;\nbounds.yw -= uTroikaPositionOffset.y;\n\nvec4 outlineBounds = vec4(\n  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,\n  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius\n);\nvec4 clippedBounds = vec4(\n  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),\n  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)\n);\n\nvec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);\n\nposition.xy = mix(bounds.xy, bounds.zw, clippedXY);\n\nuv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);\n\nfloat rad = uTroikaCurveRadius;\nif (rad != 0.0) {\n  float angle = position.x / rad;\n  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);\n  normal.xz = vec2(sin(angle), cos(angle));\n}\n  \nposition = uTroikaOrient * position;\nnormal = uTroikaOrient * normal;\n\nvTroikaGlyphUV = clippedXY.xy;\nvTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);\n\n${''/* NOTE: it seems important to calculate the glyph's bounding texture UVs here in the\n  vertex shader, rather than in the fragment shader, as the latter gives strange artifacts\n  on some glyphs (those in the leftmost texture column) on some systems. The exact reason\n  isn't understood but doing this here, then mix()-ing in the fragment shader, seems to work. */}\nfloat txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;\nvec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;\nvec2 txStartUV = txUvPerSquare * vec2(\n  mod(floor(aTroikaGlyphIndex / 4.0), txCols),\n  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)\n);\nvTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);\nvTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);\n`;\n\n  // language=GLSL\n  const FRAGMENT_DEFS = `\nuniform sampler2D uTroikaSDFTexture;\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform float uTroikaSDFExponent;\nuniform float uTroikaEdgeOffset;\nuniform float uTroikaFillOpacity;\nuniform float uTroikaBlurRadius;\nuniform vec3 uTroikaStrokeColor;\nuniform float uTroikaStrokeWidth;\nuniform float uTroikaStrokeOpacity;\nuniform bool uTroikaSDFDebug;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec2 vTroikaGlyphDimensions;\n\nfloat troikaSdfValueToSignedDistance(float alpha) {\n  // Inverse of exponential encoding in webgl-sdf-generator\n  ${''/* TODO - there's some slight inaccuracy here when dealing with interpolated alpha values; those\n    are linearly interpolated where the encoding is exponential. Look into improving this by rounding\n    to nearest 2 whole texels, decoding those exponential values, and linearly interpolating the result.\n  */}\n  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);\n  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;\n  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);\n  return signedDist;\n}\n\nfloat troikaGlyphUvToSdfValue(vec2 glyphUV) {\n  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);\n  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);\n  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1\n  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;\n}\n\nfloat troikaGlyphUvToDistance(vec2 uv) {\n  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));\n}\n\nfloat troikaGetAADist() {\n  ${''/*\n    When the standard derivatives extension is available, we choose an antialiasing alpha threshold based\n    on the potential change in the SDF's alpha from this fragment to its neighbor. This strategy maximizes \n    readability and edge crispness at all sizes and screen resolutions.\n  */}\n  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300\n  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;\n  #else\n  return vTroikaGlyphDimensions.x / 64.0;\n  #endif\n}\n\nfloat troikaGetFragDistValue() {\n  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);\n  float distance = troikaGlyphUvToDistance(clampedGlyphUV);\n \n  // Extrapolate distance when outside bounds:\n  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : \n    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n\n  ${''/* \n  // TODO more refined extrapolated distance by adjusting for angle of gradient at edge...\n  // This has potential but currently gives very jagged extensions, maybe due to precision issues?\n  float uvStep = 1.0 / uTroikaSDFGlyphSize;\n  vec2 neighbor1UV = clampedGlyphUV + (\n    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * sign(0.5 - vTroikaGlyphUV.y)) :\n    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * sign(0.5 - vTroikaGlyphUV.x), 0.0) :\n    vec2(0.0)\n  );\n  vec2 neighbor2UV = clampedGlyphUV + (\n    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * -sign(0.5 - vTroikaGlyphUV.y)) :\n    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * -sign(0.5 - vTroikaGlyphUV.x), 0.0) :\n    vec2(0.0)\n  );\n  float neighbor1Distance = troikaGlyphUvToDistance(neighbor1UV);\n  float neighbor2Distance = troikaGlyphUvToDistance(neighbor2UV);\n  float distToUnclamped = length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n  float distToNeighbor = length((clampedGlyphUV - neighbor1UV) * vTroikaGlyphDimensions);\n  float gradientAngle1 = min(asin(abs(neighbor1Distance - distance) / distToNeighbor), PI / 2.0);\n  float gradientAngle2 = min(asin(abs(neighbor2Distance - distance) / distToNeighbor), PI / 2.0);\n  distance += (cos(gradientAngle1) + cos(gradientAngle2)) / 2.0 * distToUnclamped;\n  */}\n\n  return distance;\n}\n\nfloat troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {\n  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)\n  float alpha = step(-distanceOffset, -distance);\n  #else\n\n  float alpha = smoothstep(\n    distanceOffset + aaDist,\n    distanceOffset - aaDist,\n    distance\n  );\n  #endif\n\n  return alpha;\n}\n`;\n\n  // language=GLSL prefix=\"void main() {\" suffix=\"}\"\n  const FRAGMENT_TRANSFORM = `\nfloat aaDist = troikaGetAADist();\nfloat fragDistance = troikaGetFragDistValue();\nfloat edgeAlpha = uTroikaSDFDebug ?\n  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :\n  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));\n\n#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)\nvec4 fillRGBA = gl_FragColor;\nfillRGBA.a *= uTroikaFillOpacity;\nvec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);\nif (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;\ngl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(\n  -uTroikaStrokeWidth - aaDist,\n  -uTroikaStrokeWidth + aaDist,\n  fragDistance\n));\ngl_FragColor.a *= edgeAlpha;\n#endif\n\nif (edgeAlpha == 0.0) {\n  discard;\n}\n`;\n\n\n  /**\n   * Create a material for rendering text, derived from a baseMaterial\n   */\n  function createTextDerivedMaterial(baseMaterial) {\n    const textMaterial = troikaThreeUtils.createDerivedMaterial(baseMaterial, {\n      chained: true,\n      extensions: {\n        derivatives: true\n      },\n      uniforms: {\n        uTroikaSDFTexture: {value: null},\n        uTroikaSDFTextureSize: {value: new three.Vector2()},\n        uTroikaSDFGlyphSize: {value: 0},\n        uTroikaSDFExponent: {value: 0},\n        uTroikaTotalBounds: {value: new three.Vector4(0,0,0,0)},\n        uTroikaClipRect: {value: new three.Vector4(0,0,0,0)},\n        uTroikaEdgeOffset: {value: 0},\n        uTroikaFillOpacity: {value: 1},\n        uTroikaPositionOffset: {value: new three.Vector2()},\n        uTroikaCurveRadius: {value: 0},\n        uTroikaBlurRadius: {value: 0},\n        uTroikaStrokeWidth: {value: 0},\n        uTroikaStrokeColor: {value: new three.Color()},\n        uTroikaStrokeOpacity: {value: 1},\n        uTroikaOrient: {value: new three.Matrix3()},\n        uTroikaUseGlyphColors: {value: true},\n        uTroikaSDFDebug: {value: false}\n      },\n      vertexDefs: VERTEX_DEFS,\n      vertexTransform: VERTEX_TRANSFORM,\n      fragmentDefs: FRAGMENT_DEFS,\n      fragmentColorTransform: FRAGMENT_TRANSFORM,\n      customRewriter({vertexShader, fragmentShader}) {\n        let uDiffuseRE = /\\buniform\\s+vec3\\s+diffuse\\b/;\n        if (uDiffuseRE.test(fragmentShader)) {\n          // Replace all instances of `diffuse` with our varying\n          fragmentShader = fragmentShader\n            .replace(uDiffuseRE, 'varying vec3 vTroikaGlyphColor')\n            .replace(/\\bdiffuse\\b/g, 'vTroikaGlyphColor');\n          // Make sure the vertex shader declares the uniform so we can grab it as a fallback\n          if (!uDiffuseRE.test(vertexShader)) {\n            vertexShader = vertexShader.replace(\n              troikaThreeUtils.voidMainRegExp,\n              'uniform vec3 diffuse;\\n$&\\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\\n'\n            );\n          }\n        }\n        return { vertexShader, fragmentShader }\n      }\n    });\n\n    // Force transparency - TODO is this reasonable?\n    textMaterial.transparent = true;\n\n    // Force single draw call when double-sided\n    textMaterial.forceSinglePass = true;\n\n    Object.defineProperties(textMaterial, {\n      isTroikaTextMaterial: {value: true},\n\n      // WebGLShadowMap reverses the side of the shadow material by default, which fails\n      // for planes, so here we force the `shadowSide` to always match the main side.\n      shadowSide: {\n        get() {\n          return this.side\n        },\n        set() {\n          //no-op\n        }\n      }\n    });\n\n    return textMaterial\n  }\n\n  const defaultMaterial = /*#__PURE__*/ new three.MeshBasicMaterial({\n    color: 0xffffff,\n    side: three.DoubleSide,\n    transparent: true\n  });\n  const defaultStrokeColor = 0x808080;\n\n  const tempMat4 = /*#__PURE__*/ new three.Matrix4();\n  const tempVec3a = /*#__PURE__*/ new three.Vector3();\n  const tempVec3b = /*#__PURE__*/ new three.Vector3();\n  const tempArray = [];\n  const origin = /*#__PURE__*/ new three.Vector3();\n  const defaultOrient = '+x+y';\n\n  function first(o) {\n    return Array.isArray(o) ? o[0] : o\n  }\n\n  let getFlatRaycastMesh = () => {\n    const mesh = new three.Mesh(\n      new three.PlaneGeometry(1, 1),\n      defaultMaterial\n    );\n    getFlatRaycastMesh = () => mesh;\n    return mesh\n  };\n  let getCurvedRaycastMesh = () => {\n    const mesh = new three.Mesh(\n      new three.PlaneGeometry(1, 1, 32, 1),\n      defaultMaterial\n    );\n    getCurvedRaycastMesh = () => mesh;\n    return mesh\n  };\n\n  const syncStartEvent = { type: 'syncstart' };\n  const syncCompleteEvent = { type: 'synccomplete' };\n\n  const SYNCABLE_PROPS = [\n    'font',\n    'fontSize',\n    'fontStyle',\n    'fontWeight',\n    'lang',\n    'letterSpacing',\n    'lineHeight',\n    'maxWidth',\n    'overflowWrap',\n    'text',\n    'direction',\n    'textAlign',\n    'textIndent',\n    'whiteSpace',\n    'anchorX',\n    'anchorY',\n    'colorRanges',\n    'sdfGlyphSize'\n  ];\n\n  const COPYABLE_PROPS = SYNCABLE_PROPS.concat(\n    'material',\n    'color',\n    'depthOffset',\n    'clipRect',\n    'curveRadius',\n    'orientation',\n    'glyphGeometryDetail'\n  );\n\n  /**\n   * @class Text\n   *\n   * A ThreeJS Mesh that renders a string of text on a plane in 3D space using signed distance\n   * fields (SDF).\n   */\n  class Text extends three.Mesh {\n    constructor() {\n      const geometry = new GlyphsGeometry();\n      super(geometry, null);\n\n      // === Text layout properties: === //\n\n      /**\n       * @member {string} text\n       * The string of text to be rendered.\n       */\n      this.text = '';\n\n      /**\n       * @member {number|string} anchorX\n       * Defines the horizontal position in the text block that should line up with the local origin.\n       * Can be specified as a numeric x position in local units, a string percentage of the total\n       * text block width e.g. `'25%'`, or one of the following keyword strings: 'left', 'center',\n       * or 'right'.\n       */\n      this.anchorX = 0;\n\n      /**\n       * @member {number|string} anchorY\n       * Defines the vertical position in the text block that should line up with the local origin.\n       * Can be specified as a numeric y position in local units (note: down is negative y), a string\n       * percentage of the total text block height e.g. `'25%'`, or one of the following keyword strings:\n       * 'top', 'top-baseline', 'top-cap', 'top-ex', 'middle', 'bottom-baseline', or 'bottom'.\n       */\n      this.anchorY = 0;\n\n      /**\n       * @member {number} curveRadius\n       * Defines a cylindrical radius along which the text's plane will be curved. Positive numbers put\n       * the cylinder's centerline (oriented vertically) that distance in front of the text, for a concave\n       * curvature, while negative numbers put it behind the text for a convex curvature. The centerline\n       * will be aligned with the text's local origin; you can use `anchorX` to offset it.\n       *\n       * Since each glyph is by default rendered with a simple quad, each glyph remains a flat plane\n       * internally. You can use `glyphGeometryDetail` to add more vertices for curvature inside glyphs.\n       */\n      this.curveRadius = 0;\n\n      /**\n       * @member {string} direction\n       * Sets the base direction for the text. The default value of \"auto\" will choose a direction based\n       * on the text's content according to the bidi spec. A value of \"ltr\" or \"rtl\" will force the direction.\n       */\n      this.direction = 'auto';\n\n      /**\n       * @member {string|null} font\n       * URL of a custom font to be used. Font files can be in .ttf, .otf, or .woff (not .woff2) formats.\n       * Defaults to Noto Sans.\n       */\n      this.font = null; //will use default from TextBuilder\n\n      this.unicodeFontsURL = null; //defaults to CDN\n\n      /**\n       * @member {number} fontSize\n       * The size at which to render the font in local units; corresponds to the em-box height\n       * of the chosen `font`.\n       */\n      this.fontSize = 0.1;\n\n      /**\n       * @member {number|'normal'|'bold'}\n       * The weight of the font. Currently only used for fallback Noto fonts.\n       */\n      this.fontWeight = 'normal';\n\n      /**\n       * @member {'normal'|'italic'}\n       * The style of the font. Currently only used for fallback Noto fonts.\n       */\n      this.fontStyle = 'normal';\n\n      /**\n       * @member {string|null} lang\n       * The language code of this text; can be used for explicitly selecting certain CJK fonts.\n       */\n      this.lang = null;\n\n        /**\n       * @member {number} letterSpacing\n       * Sets a uniform adjustment to spacing between letters after kerning is applied. Positive\n       * numbers increase spacing and negative numbers decrease it.\n       */\n      this.letterSpacing = 0;\n\n      /**\n       * @member {number|string} lineHeight\n       * Sets the height of each line of text, as a multiple of the `fontSize`. Defaults to 'normal'\n       * which chooses a reasonable height based on the chosen font's ascender/descender metrics.\n       */\n      this.lineHeight = 'normal';\n\n      /**\n       * @member {number} maxWidth\n       * The maximum width of the text block, above which text may start wrapping according to the\n       * `whiteSpace` and `overflowWrap` properties.\n       */\n      this.maxWidth = Infinity;\n\n      /**\n       * @member {string} overflowWrap\n       * Defines how text wraps if the `whiteSpace` property is `normal`. Can be either `'normal'`\n       * to break at whitespace characters, or `'break-word'` to allow breaking within words.\n       * Defaults to `'normal'`.\n       */\n      this.overflowWrap = 'normal';\n\n      /**\n       * @member {string} textAlign\n       * The horizontal alignment of each line of text within the overall text bounding box.\n       */\n      this.textAlign = 'left';\n\n      /**\n       * @member {number} textIndent\n       * Indentation for the first character of a line; see CSS `text-indent`.\n       */\n      this.textIndent = 0;\n\n      /**\n       * @member {string} whiteSpace\n       * Defines whether text should wrap when a line reaches the `maxWidth`. Can\n       * be either `'normal'` (the default), to allow wrapping according to the `overflowWrap` property,\n       * or `'nowrap'` to prevent wrapping. Note that `'normal'` here honors newline characters to\n       * manually break lines, making it behave more like `'pre-wrap'` does in CSS.\n       */\n      this.whiteSpace = 'normal';\n\n\n      // === Presentation properties: === //\n\n      /**\n       * @member {THREE.Material} material\n       * Defines a _base_ material to be used when rendering the text. This material will be\n       * automatically replaced with a material derived from it, that adds shader code to\n       * decrease the alpha for each fragment (pixel) outside the text glyphs, with antialiasing.\n       * By default it will derive from a simple white MeshBasicMaterial, but you can use any\n       * of the other mesh materials to gain other features like lighting, texture maps, etc.\n       *\n       * Also see the `color` shortcut property.\n       */\n      this.material = null;\n\n      /**\n       * @member {string|number|THREE.Color} color\n       * This is a shortcut for setting the `color` of the text's material. You can use this\n       * if you don't want to specify a whole custom `material`. Also, if you do use a custom\n       * `material`, this color will only be used for this particuar Text instance, even if\n       * that same material instance is shared across multiple Text objects.\n       */\n      this.color = null;\n\n      /**\n       * @member {object|null} colorRanges\n       * WARNING: This API is experimental and may change.\n       * This allows more fine-grained control of colors for individual or ranges of characters,\n       * taking precedence over the material's `color`. Its format is an Object whose keys each\n       * define a starting character index for a range, and whose values are the color for each\n       * range. The color value can be a numeric hex color value, a `THREE.Color` object, or\n       * any of the strings accepted by `THREE.Color`.\n       */\n      this.colorRanges = null;\n\n      /**\n       * @member {number|string} outlineWidth\n       * WARNING: This API is experimental and may change.\n       * The width of an outline/halo to be drawn around each text glyph using the `outlineColor` and `outlineOpacity`.\n       * Can be specified as either an absolute number in local units, or as a percentage string e.g.\n       * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`, which means\n       * no outline will be drawn unless an `outlineOffsetX/Y` or `outlineBlur` is set.\n       */\n      this.outlineWidth = 0;\n\n      /**\n       * @member {string|number|THREE.Color} outlineColor\n       * WARNING: This API is experimental and may change.\n       * The color of the text outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.\n       * Defaults to black.\n       */\n      this.outlineColor = 0x000000;\n\n      /**\n       * @member {number} outlineOpacity\n       * WARNING: This API is experimental and may change.\n       * The opacity of the outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.\n       * Defaults to `1`.\n       */\n      this.outlineOpacity = 1;\n\n      /**\n       * @member {number|string} outlineBlur\n       * WARNING: This API is experimental and may change.\n       * A blur radius applied to the outer edge of the text's outline. If the `outlineWidth` is\n       * zero, the blur will be applied at the glyph edge, like CSS's `text-shadow` blur radius.\n       * Can be specified as either an absolute number in local units, or as a percentage string e.g.\n       * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`.\n       */\n      this.outlineBlur = 0;\n\n      /**\n       * @member {number|string} outlineOffsetX\n       * WARNING: This API is experimental and may change.\n       * A horizontal offset for the text outline.\n       * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n       * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n       */\n      this.outlineOffsetX = 0;\n\n      /**\n       * @member {number|string} outlineOffsetY\n       * WARNING: This API is experimental and may change.\n       * A vertical offset for the text outline.\n       * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n       * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n       */\n      this.outlineOffsetY = 0;\n\n      /**\n       * @member {number|string} strokeWidth\n       * WARNING: This API is experimental and may change.\n       * The width of an inner stroke drawn inside each text glyph using the `strokeColor` and `strokeOpacity`.\n       * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n       * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n       */\n      this.strokeWidth = 0;\n\n      /**\n       * @member {string|number|THREE.Color} strokeColor\n       * WARNING: This API is experimental and may change.\n       * The color of the text stroke, if `strokeWidth` is greater than zero. Defaults to gray.\n       */\n      this.strokeColor = defaultStrokeColor;\n\n      /**\n       * @member {number} strokeOpacity\n       * WARNING: This API is experimental and may change.\n       * The opacity of the stroke, if `strokeWidth` is greater than zero. Defaults to `1`.\n       */\n      this.strokeOpacity = 1;\n\n      /**\n       * @member {number} fillOpacity\n       * WARNING: This API is experimental and may change.\n       * The opacity of the glyph's fill from 0 to 1. This behaves like the material's `opacity` but allows\n       * giving the fill a different opacity than the `strokeOpacity`. A fillOpacity of `0` makes the\n       * interior of the glyph invisible, leaving just the `strokeWidth`. Defaults to `1`.\n       */\n      this.fillOpacity = 1;\n\n      /**\n       * @member {number} depthOffset\n       * This is a shortcut for setting the material's `polygonOffset` and related properties,\n       * which can be useful in preventing z-fighting when this text is laid on top of another\n       * plane in the scene. Positive numbers are further from the camera, negatives closer.\n       */\n      this.depthOffset = 0;\n\n      /**\n       * @member {Array<number>} clipRect\n       * If specified, defines a `[minX, minY, maxX, maxY]` of a rectangle outside of which all\n       * pixels will be discarded. This can be used for example to clip overflowing text when\n       * `whiteSpace='nowrap'`.\n       */\n      this.clipRect = null;\n\n      /**\n       * @member {string} orientation\n       * Defines the axis plane on which the text should be laid out when the mesh has no extra\n       * rotation transform. It is specified as a string with two axes: the horizontal axis with\n       * positive pointing right, and the vertical axis with positive pointing up. By default this\n       * is '+x+y', meaning the text sits on the xy plane with the text's top toward positive y\n       * and facing positive z. A value of '+x-z' would place it on the xz plane with the text's\n       * top toward negative z and facing positive y.\n       */\n      this.orientation = defaultOrient;\n\n      /**\n       * @member {number} glyphGeometryDetail\n       * Controls number of vertical/horizontal segments that make up each glyph's rectangular\n       * plane. Defaults to 1. This can be increased to provide more geometrical detail for custom\n       * vertex shader effects, for example.\n       */\n      this.glyphGeometryDetail = 1;\n\n      /**\n       * @member {number|null} sdfGlyphSize\n       * The size of each glyph's SDF (signed distance field) used for rendering. This must be a\n       * power-of-two number. Defaults to 64 which is generally a good balance of size and quality\n       * for most fonts. Larger sizes can improve the quality of glyph rendering by increasing\n       * the sharpness of corners and preventing loss of very thin lines, at the expense of\n       * increased memory footprint and longer SDF generation time.\n       */\n      this.sdfGlyphSize = null;\n\n      /**\n       * @member {boolean} gpuAccelerateSDF\n       * When `true`, the SDF generation process will be GPU-accelerated with WebGL when possible,\n       * making it much faster especially for complex glyphs, and falling back to a JavaScript version\n       * executed in web workers when support isn't available. It should automatically detect support,\n       * but it's still somewhat experimental, so you can set it to `false` to force it to use the JS\n       * version if you encounter issues with it.\n       */\n      this.gpuAccelerateSDF = true;\n\n      this.debugSDF = false;\n    }\n\n    /**\n     * Updates the text rendering according to the current text-related configuration properties.\n     * This is an async process, so you can pass in a callback function to be executed when it\n     * finishes.\n     * @param {function} [callback]\n     */\n    sync(callback) {\n      if (this._needsSync) {\n        this._needsSync = false;\n\n        // If there's another sync still in progress, queue\n        if (this._isSyncing) {\n          (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);\n        } else {\n          this._isSyncing = true;\n          this.dispatchEvent(syncStartEvent);\n\n          getTextRenderInfo({\n            text: this.text,\n            font: this.font,\n            lang: this.lang,\n            fontSize: this.fontSize || 0.1,\n            fontWeight: this.fontWeight || 'normal',\n            fontStyle: this.fontStyle || 'normal',\n            letterSpacing: this.letterSpacing || 0,\n            lineHeight: this.lineHeight || 'normal',\n            maxWidth: this.maxWidth,\n            direction: this.direction || 'auto',\n            textAlign: this.textAlign,\n            textIndent: this.textIndent,\n            whiteSpace: this.whiteSpace,\n            overflowWrap: this.overflowWrap,\n            anchorX: this.anchorX,\n            anchorY: this.anchorY,\n            colorRanges: this.colorRanges,\n            includeCaretPositions: true, //TODO parameterize\n            sdfGlyphSize: this.sdfGlyphSize,\n            gpuAccelerateSDF: this.gpuAccelerateSDF,\n            unicodeFontsURL: this.unicodeFontsURL,\n          }, textRenderInfo => {\n            this._isSyncing = false;\n\n            // Save result for later use in onBeforeRender\n            this._textRenderInfo = textRenderInfo;\n\n            // Update the geometry attributes\n            this.geometry.updateGlyphs(\n              textRenderInfo.glyphBounds,\n              textRenderInfo.glyphAtlasIndices,\n              textRenderInfo.blockBounds,\n              textRenderInfo.chunkedBounds,\n              textRenderInfo.glyphColors\n            );\n\n            // If we had extra sync requests queued up, kick it off\n            const queued = this._queuedSyncs;\n            if (queued) {\n              this._queuedSyncs = null;\n              this._needsSync = true;\n              this.sync(() => {\n                queued.forEach(fn => fn && fn());\n              });\n            }\n\n            this.dispatchEvent(syncCompleteEvent);\n            if (callback) {\n              callback();\n            }\n          });\n        }\n      }\n    }\n\n    /**\n     * Initiate a sync if needed - note it won't complete until next frame at the\n     * earliest so if possible it's a good idea to call sync() manually as soon as\n     * all the properties have been set.\n     * @override\n     */\n    onBeforeRender(renderer, scene, camera, geometry, material, group) {\n      this.sync();\n\n      // This may not always be a text material, e.g. if there's a scene.overrideMaterial present\n      if (material.isTroikaTextMaterial) {\n        this._prepareForRender(material);\n      }\n    }\n\n    /**\n     * Shortcut to dispose the geometry specific to this instance.\n     * Note: we don't also dispose the derived material here because if anything else is\n     * sharing the same base material it will result in a pause next frame as the program\n     * is recompiled. Instead users can dispose the base material manually, like normal,\n     * and we'll also dispose the derived material at that time.\n     */\n    dispose() {\n      this.geometry.dispose();\n    }\n\n    /**\n     * @property {TroikaTextRenderInfo|null} textRenderInfo\n     * @readonly\n     * The current processed rendering data for this TextMesh, returned by the TextBuilder after\n     * a `sync()` call. This will be `null` initially, and may be stale for a short period until\n     * the asynchrous `sync()` process completes.\n     */\n    get textRenderInfo() {\n      return this._textRenderInfo || null\n    }\n\n    /**\n     * Create the text derived material from the base material. Can be overridden to use a custom\n     * derived material.\n     */\n    createDerivedMaterial(baseMaterial) {\n      return createTextDerivedMaterial(baseMaterial)\n    }\n\n    // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n    // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n    get material() {\n      let derivedMaterial = this._derivedMaterial;\n      const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());\n      if (!derivedMaterial || !derivedMaterial.isDerivedFrom(baseMaterial)) {\n        derivedMaterial = this._derivedMaterial = this.createDerivedMaterial(baseMaterial);\n        // dispose the derived material when its base material is disposed:\n        baseMaterial.addEventListener('dispose', function onDispose() {\n          baseMaterial.removeEventListener('dispose', onDispose);\n          derivedMaterial.dispose();\n        });\n      }\n      // If text outline is configured, render it as a preliminary draw using Three's multi-material\n      // feature (see GlyphsGeometry which sets up `groups` for this purpose) Doing it with multi\n      // materials ensures the layers are always rendered consecutively in a consistent order.\n      // Each layer will trigger onBeforeRender with the appropriate material.\n      if (this.hasOutline()) {\n        let outlineMaterial = derivedMaterial._outlineMtl;\n        if (!outlineMaterial) {\n          outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {\n            id: {value: derivedMaterial.id + 0.1}\n          });\n          outlineMaterial.isTextOutlineMaterial = true;\n          outlineMaterial.depthWrite = false;\n          outlineMaterial.map = null; //???\n          derivedMaterial.addEventListener('dispose', function onDispose() {\n            derivedMaterial.removeEventListener('dispose', onDispose);\n            outlineMaterial.dispose();\n          });\n        }\n        return [\n          outlineMaterial,\n          derivedMaterial\n        ]\n      } else {\n        return derivedMaterial\n      }\n    }\n    set material(baseMaterial) {\n      if (baseMaterial && baseMaterial.isTroikaTextMaterial) { //prevent double-derivation\n        this._derivedMaterial = baseMaterial;\n        this._baseMaterial = baseMaterial.baseMaterial;\n      } else {\n        this._baseMaterial = baseMaterial;\n      }\n    }\n\n    hasOutline() {\n      return !!(this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY)\n    }\n\n    get glyphGeometryDetail() {\n      return this.geometry.detail\n    }\n    set glyphGeometryDetail(detail) {\n      this.geometry.detail = detail;\n    }\n\n    get curveRadius() {\n      return this.geometry.curveRadius\n    }\n    set curveRadius(r) {\n      this.geometry.curveRadius = r;\n    }\n\n    // Create and update material for shadows upon request:\n    get customDepthMaterial() {\n      return first(this.material).getDepthMaterial()\n    }\n    get customDistanceMaterial() {\n      return first(this.material).getDistanceMaterial()\n    }\n\n    _prepareForRender(material) {\n      const isOutline = material.isTextOutlineMaterial;\n      const uniforms = material.uniforms;\n      const textInfo = this.textRenderInfo;\n      if (textInfo) {\n        const {sdfTexture, blockBounds} = textInfo;\n        uniforms.uTroikaSDFTexture.value = sdfTexture;\n        uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);\n        uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;\n        uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;\n        uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);\n        uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;\n\n        let distanceOffset = 0;\n        let blurRadius = 0;\n        let strokeWidth = 0;\n        let fillOpacity;\n        let strokeOpacity;\n        let strokeColor;\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (isOutline) {\n          let {outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity} = this;\n          distanceOffset = this._parsePercent(outlineWidth) || 0;\n          blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);\n          fillOpacity = outlineOpacity;\n          offsetX = this._parsePercent(outlineOffsetX) || 0;\n          offsetY = this._parsePercent(outlineOffsetY) || 0;\n        } else {\n          strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);\n          if (strokeWidth) {\n            strokeColor = this.strokeColor;\n            uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);\n            strokeOpacity = this.strokeOpacity;\n            if (strokeOpacity == null) strokeOpacity = 1;\n          }\n          fillOpacity = this.fillOpacity;\n        }\n\n        uniforms.uTroikaEdgeOffset.value = distanceOffset;\n        uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);\n        uniforms.uTroikaBlurRadius.value = blurRadius;\n        uniforms.uTroikaStrokeWidth.value = strokeWidth;\n        uniforms.uTroikaStrokeOpacity.value = strokeOpacity;\n        uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;\n        uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;\n\n        let clipRect = this.clipRect;\n        if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {\n          uniforms.uTroikaClipRect.value.fromArray(clipRect);\n        } else {\n          // no clipping - choose a finite rect that shouldn't ever be reached by overflowing glyphs or outlines\n          const pad = (this.fontSize || 0.1) * 100;\n          uniforms.uTroikaClipRect.value.set(\n            blockBounds[0] - pad,\n            blockBounds[1] - pad,\n            blockBounds[2] + pad,\n            blockBounds[3] + pad\n          );\n        }\n        this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);\n      }\n      uniforms.uTroikaSDFDebug.value = !!this.debugSDF;\n      material.polygonOffset = !!this.depthOffset;\n      material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;\n\n      // Shortcut for setting material color via `color` prop on the mesh; this is\n      // applied only to the derived material to avoid mutating a shared base material.\n      const color = isOutline ? (this.outlineColor || 0) : this.color;\n\n      if (color == null) {\n        delete material.color; //inherit from base\n      } else {\n        const colorObj = material.hasOwnProperty('color') ? material.color : (material.color = new three.Color());\n        if (color !== colorObj._input || typeof color === 'object') {\n          colorObj.set(colorObj._input = color);\n        }\n      }\n\n      // base orientation\n      let orient = this.orientation || defaultOrient;\n      if (orient !== material._orientation) {\n        let rotMat = uniforms.uTroikaOrient.value;\n        orient = orient.replace(/[^-+xyz]/g, '');\n        let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);\n        if (match) {\n          let [, hSign, hAxis, vSign, vAxis] = match;\n          tempVec3a.set(0, 0, 0)[hAxis] = hSign === '-' ? 1 : -1;\n          tempVec3b.set(0, 0, 0)[vAxis] = vSign === '-' ? -1 : 1;\n          tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);\n          rotMat.setFromMatrix4(tempMat4);\n        } else {\n          rotMat.identity();\n        }\n        material._orientation = orient;\n      }\n    }\n\n    _parsePercent(value) {\n      if (typeof value === 'string') {\n        let match = value.match(/^(-?[\\d.]+)%$/);\n        let pct = match ? parseFloat(match[1]) : NaN;\n        value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;\n      }\n      return value\n    }\n\n    /**\n     * Translate a point in local space to an x/y in the text plane.\n     */\n    localPositionToTextCoords(position, target = new three.Vector2()) {\n      target.copy(position); //simple non-curved case is 1:1\n      const r = this.curveRadius;\n      if (r) { //flatten the curve\n        target.x = Math.atan2(position.x, Math.abs(r) - Math.abs(position.z)) * Math.abs(r);\n      }\n      return target\n    }\n\n    /**\n     * Translate a point in world space to an x/y in the text plane.\n     */\n    worldPositionToTextCoords(position, target = new three.Vector2()) {\n      tempVec3a.copy(position);\n      return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target)\n    }\n\n    /**\n     * @override Custom raycasting to test against the whole text block's max rectangular bounds\n     * TODO is there any reason to make this more granular, like within individual line or glyph rects?\n     */\n    raycast(raycaster, intersects) {\n      const {textRenderInfo, curveRadius} = this;\n      if (textRenderInfo) {\n        const bounds = textRenderInfo.blockBounds;\n        const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();\n        const geom = raycastMesh.geometry;\n        const {position, uv} = geom.attributes;\n        for (let i = 0; i < uv.count; i++) {\n          let x = bounds[0] + (uv.getX(i) * (bounds[2] - bounds[0]));\n          const y = bounds[1] + (uv.getY(i) * (bounds[3] - bounds[1]));\n          let z = 0;\n          if (curveRadius) {\n            z = curveRadius - Math.cos(x / curveRadius) * curveRadius;\n            x = Math.sin(x / curveRadius) * curveRadius;\n          }\n          position.setXYZ(i, x, y, z);\n        }\n        geom.boundingSphere = this.geometry.boundingSphere;\n        geom.boundingBox = this.geometry.boundingBox;\n        raycastMesh.matrixWorld = this.matrixWorld;\n        raycastMesh.material.side = this.material.side;\n        tempArray.length = 0;\n        raycastMesh.raycast(raycaster, tempArray);\n        for (let i = 0; i < tempArray.length; i++) {\n          tempArray[i].object = this;\n          intersects.push(tempArray[i]);\n        }\n      }\n    }\n\n    copy(source) {\n      // Prevent copying the geometry reference so we don't end up sharing attributes between instances\n      const geom = this.geometry;\n      super.copy(source);\n      this.geometry = geom;\n\n      COPYABLE_PROPS.forEach(prop => {\n        this[prop] = source[prop];\n      });\n      return this\n    }\n\n    clone() {\n      return new this.constructor().copy(this)\n    }\n  }\n\n\n  // Create setters for properties that affect text layout:\n  SYNCABLE_PROPS.forEach(prop => {\n    const privateKey = '_private_' + prop;\n    Object.defineProperty(Text.prototype, prop, {\n      get() {\n        return this[privateKey]\n      },\n      set(value) {\n        if (value !== this[privateKey]) {\n          this[privateKey] = value;\n          this._needsSync = true;\n        }\n      }\n    });\n  });\n\n  const syncStartEvent$1 = { type: \"syncstart\" };\n  const syncCompleteEvent$1 = { type: \"synccomplete\" };\n  const memberIndexAttrName = \"aTroikaTextBatchMemberIndex\";\n\n\n  /*\n  Data texture packing strategy:\n\n  # Common:\n  0-15: matrix\n  16-19: uTroikaTotalBounds\n  20-23: uTroikaClipRect\n  24: diffuse (color/outlineColor)\n  25: uTroikaFillOpacity (fillOpacity/outlineOpacity)\n  26: uTroikaCurveRadius\n  27: <blank>\n\n  # Main:\n  28: uTroikaStrokeWidth\n  29: uTroikaStrokeColor\n  30: uTroikaStrokeOpacity\n\n  # Outline:\n  28-29: uTroikaPositionOffset\n  30: uTroikaEdgeOffset\n  31: uTroikaBlurRadius\n  */\n  const floatsPerMember = 32;\n\n  const tempBox3 = new three.Box3();\n  const tempColor$1 = new three.Color();\n\n  /**\n   * @experimental\n   *\n   * A specialized `Text` implementation that accepts any number of `Text` children\n   * and automatically batches them together to render in a single draw call.\n   *\n   * The `material` of each child `Text` will be ignored, and the `material` of the\n   * `BatchedText` will be used for all of them instead.\n   *\n   * NOTE: This only works in WebGL2 or where the OES_texture_float extension is available.\n   */\n  class BatchedText extends Text {\n    constructor () {\n      super();\n\n      /**\n       * @typedef {Object} PackingInfo\n       * @property {number} index - the packing order index when last packed, or -1\n       * @property {boolean} dirty - whether it has synced since last pack\n       */\n\n      /**\n       * @type {Map<Text, PackingInfo>}\n       */\n      this._members = new Map();\n      this._dataTextures = {};\n\n      this._onMemberSynced = (e) => {\n        this._members.get(e.target).dirty = true;\n      };\n    }\n\n    /**\n     * @override\n     * Batch any Text objects added as children\n     */\n    add (...objects) {\n      for (let i = 0; i < objects.length; i++) {\n        if (objects[i] instanceof Text) {\n          this.addText(objects[i]);\n        } else {\n          super.add(objects[i]);\n        }\n      }\n      return this;\n    }\n\n    /**\n     * @override\n     */\n    remove (...objects) {\n      for (let i = 0; i < objects.length; i++) {\n        if (objects[i] instanceof Text) {\n          this.removeText(objects[i]);\n        } else {\n          super.remove(objects[i]);\n        }\n      }\n      return this;\n    }\n\n    /**\n     * @param {Text} text\n     */\n    addText (text) {\n      if (!this._members.has(text)) {\n        this._members.set(text, {\n          index: -1,\n          glyphCount: -1,\n          dirty: true\n        });\n        text.addEventListener(\"synccomplete\", this._onMemberSynced);\n      }\n    }\n\n    /**\n     * @param {Text} text\n     */\n    removeText (text) {\n      this._needsRepack = true;\n      text.removeEventListener(\"synccomplete\", this._onMemberSynced);\n      this._members.delete(text);\n    }\n\n    /**\n     * Use the custom derivation with extra batching logic\n     */\n    createDerivedMaterial (baseMaterial) {\n      return createBatchedTextMaterial(baseMaterial);\n    }\n\n    updateMatrixWorld (force) {\n      super.updateMatrixWorld(force);\n      this.updateBounds();\n    }\n\n    /**\n     * Update the batched geometry bounds to hold all members\n     */\n    updateBounds () {\n      // Update member local matrices and the overall bounds\n      const bbox = this.geometry.boundingBox.makeEmpty();\n      this._members.forEach((_, text) => {\n        if (text.matrixAutoUpdate) text.updateMatrix(); // ignore world matrix\n        tempBox3.copy(text.geometry.boundingBox).applyMatrix4(text.matrix);\n        bbox.union(tempBox3);\n      });\n      bbox.getBoundingSphere(this.geometry.boundingSphere);\n    }\n\n    /** @override */\n    hasOutline() {\n      // Iterator.some() not supported in Safari\n      for (let member of this._members.keys()) {\n        if (member.hasOutline()) return true;\n      }\n      return false;\n    }\n\n    /**\n     * @override\n     * Copy member matrices and uniform values into the data texture\n     */\n    _prepareForRender (material) {\n      const isOutline = material.isTextOutlineMaterial;\n      material.uniforms.uTroikaIsOutline.value = isOutline;\n\n      // Resize the texture to fit in powers of 2\n      let texture = this._dataTextures[isOutline ? 'outline' : 'main'];\n      const dataLength = Math.pow(2, Math.ceil(Math.log2(this._members.size * floatsPerMember)));\n      if (!texture || dataLength !== texture.image.data.length) {\n        // console.log(`resizing: ${dataLength}`);\n        if (texture) texture.dispose();\n        const width = Math.min(dataLength / 4, 1024);\n        texture = this._dataTextures[isOutline ? 'outline' : 'main'] = new three.DataTexture(\n          new Float32Array(dataLength),\n          width,\n          dataLength / 4 / width,\n          three.RGBAFormat,\n          three.FloatType\n        );\n      }\n\n      const texData = texture.image.data;\n      const setTexData = (index, value) => {\n        if (value !== texData[index]) {\n          texData[index] = value;\n          texture.needsUpdate = true;\n        }\n      };\n      this._members.forEach(({ index, dirty }, text) => {\n        if (index > -1) {\n          const startIndex = index * floatsPerMember;\n\n          // Matrix\n          const matrix = text.matrix.elements;\n          for (let i = 0; i < 16; i++) {\n            setTexData(startIndex + i, matrix[i]);\n          }\n\n          // Let the member populate the uniforms, since that does all the appropriate\n          // logic and handling of defaults, and we'll just grab the results from there\n          text._prepareForRender(material);\n          const {\n            uTroikaTotalBounds,\n            uTroikaClipRect,\n            uTroikaPositionOffset,\n            uTroikaEdgeOffset,\n            uTroikaBlurRadius,\n            uTroikaStrokeWidth,\n            uTroikaStrokeColor,\n            uTroikaStrokeOpacity,\n            uTroikaFillOpacity,\n            uTroikaCurveRadius,\n          } = material.uniforms;\n\n          // Total bounds for uv\n          for (let i = 0; i < 4; i++) {\n            setTexData(startIndex + 16 + i, uTroikaTotalBounds.value.getComponent(i));\n          }\n\n          // Clip rect\n          for (let i = 0; i < 4; i++) {\n            setTexData(startIndex + 20 + i, uTroikaClipRect.value.getComponent(i));\n          }\n\n          // Color\n          let color = isOutline ? (text.outlineColor || 0) : text.color;\n          if (color == null) color = this.color;\n          if (color == null) color = this.material.color;\n          if (color == null) color = 0xffffff;\n          setTexData(startIndex + 24, tempColor$1.set(color).getHex());\n\n          // Fill opacity / outline opacity\n          setTexData(startIndex + 25, uTroikaFillOpacity.value);\n\n          // Curve radius\n          setTexData(startIndex + 26, uTroikaCurveRadius.value);\n\n          if (isOutline) {\n            // Outline properties\n            setTexData(startIndex + 28, uTroikaPositionOffset.value.x);\n            setTexData(startIndex + 29, uTroikaPositionOffset.value.y);\n            setTexData(startIndex + 30, uTroikaEdgeOffset.value);\n            setTexData(startIndex + 31, uTroikaBlurRadius.value);\n          } else {\n            // Stroke properties\n            setTexData(startIndex + 28, uTroikaStrokeWidth.value);\n            setTexData(startIndex + 29, tempColor$1.set(uTroikaStrokeColor.value).getHex());\n            setTexData(startIndex + 30, uTroikaStrokeOpacity.value);\n          }\n        }\n      });\n      material.setMatrixTexture(texture);\n\n      // For the non-member-specific uniforms:\n      super._prepareForRender(material);\n    }\n\n    sync (callback) {\n      // TODO: skip members updating their geometries, just use textRenderInfo directly\n\n      // Trigger sync on all members that need it\n      let syncPromises = this._needsRepack ? [] : null;\n      this._needsRepack = false;\n      this._members.forEach((packingInfo, text) => {\n        if (packingInfo.dirty || text._needsSync) {\n          packingInfo.dirty = false;\n          (syncPromises || (syncPromises = [])).push(new Promise(resolve => {\n            if (text._needsSync) {\n              text.sync(resolve);\n            } else {\n              resolve();\n            }\n          }));\n        }\n      });\n\n      // If any needed syncing, wait for them and then repack the batched geometry\n      if (syncPromises) {\n        this.dispatchEvent(syncStartEvent$1);\n\n        Promise.all(syncPromises).then(() => {\n          const { geometry } = this;\n          const batchedAttributes = geometry.attributes;\n          let memberIndexes = batchedAttributes[memberIndexAttrName] && batchedAttributes[memberIndexAttrName].array || new Uint16Array(0);\n          let batchedGlyphIndexes = batchedAttributes[glyphIndexAttrName] && batchedAttributes[glyphIndexAttrName].array || new Float32Array(0);\n          let batchedGlyphBounds = batchedAttributes[glyphBoundsAttrName] && batchedAttributes[glyphBoundsAttrName].array || new Float32Array(0);\n\n          // Initial pass to collect total glyph count and resize the arrays if needed\n          let totalGlyphCount = 0;\n          this._members.forEach((packingInfo, { textRenderInfo }) => {\n            if (textRenderInfo) {\n              totalGlyphCount += textRenderInfo.glyphAtlasIndices.length;\n              this._textRenderInfo = textRenderInfo; // TODO - need this, but be smarter\n            }\n          });\n          if (totalGlyphCount !== memberIndexes.length) {\n            memberIndexes = cloneAndResize(memberIndexes, totalGlyphCount);\n            batchedGlyphIndexes = cloneAndResize(batchedGlyphIndexes, totalGlyphCount);\n            batchedGlyphBounds = cloneAndResize(batchedGlyphBounds, totalGlyphCount * 4);\n          }\n\n          // Populate batch arrays\n          let memberIndex = 0;\n          let glyphIndex = 0;\n          this._members.forEach((packingInfo, { textRenderInfo }) => {\n            if (textRenderInfo) {\n              const glyphCount = textRenderInfo.glyphAtlasIndices.length;\n              memberIndexes.fill(memberIndex, glyphIndex, glyphIndex + glyphCount);\n\n              // TODO can skip these for members that are not dirty or shifting overall position:\n              batchedGlyphIndexes.set(textRenderInfo.glyphAtlasIndices, glyphIndex, glyphIndex + glyphCount);\n              batchedGlyphBounds.set(textRenderInfo.glyphBounds, glyphIndex * 4, (glyphIndex + glyphCount) * 4);\n\n              glyphIndex += glyphCount;\n              packingInfo.index = memberIndex++;\n            }\n          });\n\n          // Update the geometry attributes\n          geometry.updateAttributeData(memberIndexAttrName, memberIndexes, 1);\n          geometry.getAttribute(memberIndexAttrName).setUsage(three.DynamicDrawUsage);\n          geometry.updateAttributeData(glyphIndexAttrName, batchedGlyphIndexes, 1);\n          geometry.updateAttributeData(glyphBoundsAttrName, batchedGlyphBounds, 4);\n\n          this.updateBounds();\n\n          this.dispatchEvent(syncCompleteEvent$1);\n          if (callback) {\n            callback();\n          }\n        });\n      }\n    }\n\n    copy (source) {\n      if (source instanceof BatchedText) {\n        super.copy(source);\n        this._members.forEach((_, text) => this.removeText(text));\n        source._members.forEach((_, text) => this.addText(text));\n      }\n      return this;\n    }\n\n    dispose () {\n      super.dispose();\n      Object.values(this._dataTextures).forEach(tex => tex.dispose());\n    }\n  }\n\n  function cloneAndResize (source, newLength) {\n    const copy = new source.constructor(newLength);\n    copy.set(source.subarray(0, newLength));\n    return copy;\n  }\n\n  function createBatchedTextMaterial (baseMaterial) {\n    const texUniformName = \"uTroikaMatricesTexture\";\n    const texSizeUniformName = \"uTroikaMatricesTextureSize\";\n\n    // Due to how vertexTransform gets injected, the matrix transforms must happen\n    // in the base material of TextDerivedMaterial, but other transforms to its\n    // shader must come after, so we sandwich it between two derivations.\n\n    // Transform the vertex position\n    let batchMaterial = troikaThreeUtils.createDerivedMaterial(baseMaterial, {\n      chained: true,\n      uniforms: {\n        [texSizeUniformName]: { value: new three.Vector2() },\n        [texUniformName]: { value: null }\n      },\n      // language=GLSL\n      vertexDefs: `\n      uniform highp sampler2D ${texUniformName};\n      uniform vec2 ${texSizeUniformName};\n      attribute float ${memberIndexAttrName};\n\n      vec4 troikaBatchTexel(float offset) {\n        offset += ${memberIndexAttrName} * ${floatsPerMember.toFixed(1)} / 4.0;\n        float w = ${texSizeUniformName}.x;\n        vec2 uv = (vec2(mod(offset, w), floor(offset / w)) + 0.5) / ${texSizeUniformName};\n        return texture2D(${texUniformName}, uv);\n      }\n    `,\n      // language=GLSL prefix=\"void main() {\" suffix=\"}\"\n      vertexTransform: `\n      mat4 matrix = mat4(\n        troikaBatchTexel(0.0),\n        troikaBatchTexel(1.0),\n        troikaBatchTexel(2.0),\n        troikaBatchTexel(3.0)\n      );\n      position.xyz = (matrix * vec4(position, 1.0)).xyz;\n    `,\n    });\n\n    // Add the text shaders\n    batchMaterial = createTextDerivedMaterial(batchMaterial);\n\n    // Now make other changes to the derived text shader code\n    batchMaterial = troikaThreeUtils.createDerivedMaterial(batchMaterial, {\n      chained: true,\n      uniforms: {\n        uTroikaIsOutline: {value: false},\n      },\n      customRewriter(shaders) {\n        // Convert some text shader uniforms to varyings\n        const varyingUniforms = [\n          'uTroikaTotalBounds',\n          'uTroikaClipRect',\n          'uTroikaPositionOffset',\n          'uTroikaEdgeOffset',\n          'uTroikaBlurRadius',\n          'uTroikaStrokeWidth',\n          'uTroikaStrokeColor',\n          'uTroikaStrokeOpacity',\n          'uTroikaFillOpacity',\n          'uTroikaCurveRadius',\n          'diffuse'\n        ];\n        varyingUniforms.forEach(uniformName => {\n          shaders = uniformToVarying(shaders, uniformName);\n        });\n        return shaders\n      },\n      // language=GLSL\n      vertexDefs: `\n      uniform bool uTroikaIsOutline;\n      vec3 troikaFloatToColor(float v) {\n        return mod(floor(vec3(v / 65536.0, v / 256.0, v)), 256.0) / 256.0;\n      }\n    `,\n      // language=GLSL prefix=\"void main() {\" suffix=\"}\"\n      vertexTransform: `\n      uTroikaTotalBounds = troikaBatchTexel(4.0);\n      uTroikaClipRect = troikaBatchTexel(5.0);\n      \n      vec4 data = troikaBatchTexel(6.0);\n      diffuse = troikaFloatToColor(data.x);\n      uTroikaFillOpacity = data.y;\n      uTroikaCurveRadius = data.z;\n      \n      data = troikaBatchTexel(7.0);\n      if (uTroikaIsOutline) {\n        if (data == vec4(0.0)) { // degenerate if zero outline\n          position = vec3(0.0);\n        } else {\n          uTroikaPositionOffset = data.xy;\n          uTroikaEdgeOffset = data.z;\n          uTroikaBlurRadius = data.w;\n        }\n      } else {\n        uTroikaStrokeWidth = data.x;\n        uTroikaStrokeColor = troikaFloatToColor(data.y);\n        uTroikaStrokeOpacity = data.z;\n      }\n    `,\n    });\n\n    batchMaterial.setMatrixTexture = (texture) => {\n      batchMaterial.uniforms[texUniformName].value = texture;\n      batchMaterial.uniforms[texSizeUniformName].value.set(texture.image.width, texture.image.height);\n    };\n    return batchMaterial;\n  }\n\n  /**\n   * Turn a uniform into a varying/writeable value.\n   * - If the uniform was used in the fragment shader, it will become a varying in both shaders.\n   * - If the uniform was only used in the vertex shader, it will become a writeable var.\n   */\n  function uniformToVarying({vertexShader, fragmentShader}, uniformName, varyingName = uniformName) {\n    const uniformRE = new RegExp(`uniform\\\\s+(bool|float|vec[234]|mat[34])\\\\s+${uniformName}\\\\b`);\n\n    let type;\n    let hadFragmentUniform = false;\n    fragmentShader = fragmentShader.replace(uniformRE, ($0, $1) => {\n      hadFragmentUniform = true;\n      return `varying ${type = $1} ${varyingName}`\n    });\n\n    let hadVertexUniform = false;\n    vertexShader = vertexShader.replace(uniformRE, (_, $1) => {\n      hadVertexUniform = true;\n      return `${hadFragmentUniform ? 'varying' : ''} ${type = $1} ${varyingName}`\n    });\n    if (!hadVertexUniform) {\n      vertexShader = `${hadFragmentUniform ? 'varying' : ''} ${type} ${varyingName};\\n${vertexShader}`;\n    }\n    return {vertexShader, fragmentShader}\n  }\n\n  //=== Utility functions for dealing with carets and selection ranges ===//\n\n  /**\n   * @typedef {object} TextCaret\n   * @property {number} x - x position of the caret\n   * @property {number} y - y position of the caret's bottom\n   * @property {number} height - height of the caret\n   * @property {number} charIndex - the index in the original input string of this caret's target\n   *   character; the caret will be for the position _before_ that character.\n   */\n\n  /**\n   * Given a local x/y coordinate in the text block plane, find the nearest caret position.\n   * @param {TroikaTextRenderInfo} textRenderInfo - a result object from TextBuilder#getTextRenderInfo\n   * @param {number} x\n   * @param {number} y\n   * @return {TextCaret | null}\n   */\n  function getCaretAtPoint(textRenderInfo, x, y) {\n    let closestCaret = null;\n    const rows = groupCaretsByRow(textRenderInfo);\n\n    // Find nearest row by y first\n    let closestRow = null;\n    rows.forEach(row => {\n      if (!closestRow || Math.abs(y - (row.top + row.bottom) / 2) < Math.abs(y - (closestRow.top + closestRow.bottom) / 2)) {\n        closestRow = row;\n      }\n    });\n\n    // Then find closest caret by x within that row\n    closestRow.carets.forEach(caret => {\n      if (!closestCaret || Math.abs(x - caret.x) < Math.abs(x - closestCaret.x)) {\n        closestCaret = caret;\n      }\n    });\n    return closestCaret\n  }\n\n\n  const _rectsCache = new WeakMap();\n\n  /**\n   * Given start and end character indexes, return a list of rectangles covering all the\n   * characters within that selection.\n   * @param {TroikaTextRenderInfo} textRenderInfo\n   * @param {number} start - index of the first char in the selection\n   * @param {number} end - index of the first char after the selection\n   * @return {Array<{left, top, right, bottom}> | null}\n   */\n  function getSelectionRects(textRenderInfo, start, end) {\n    let rects;\n    if (textRenderInfo) {\n      // Check cache - textRenderInfo is frozen so it's safe to cache based on it\n      let prevResult = _rectsCache.get(textRenderInfo);\n      if (prevResult && prevResult.start === start && prevResult.end === end) {\n        return prevResult.rects\n      }\n\n      const {caretPositions} = textRenderInfo;\n\n      // Normalize\n      if (end < start) {\n        const s = start;\n        start = end;\n        end = s;\n      }\n      start = Math.max(start, 0);\n      end = Math.min(end, caretPositions.length + 1);\n\n      // Build list of rects, expanding the current rect for all characters in a run and starting\n      // a new rect whenever reaching a new line or a new bidi direction\n      rects = [];\n      let currentRect = null;\n      for (let i = start; i < end; i++) {\n        const x1 = caretPositions[i * 4];\n        const x2 = caretPositions[i * 4 + 1];\n        const left = Math.min(x1, x2);\n        const right = Math.max(x1, x2);\n        const bottom = caretPositions[i * 4 + 2];\n        const top = caretPositions[i * 4 + 3];\n        if (!currentRect || bottom !== currentRect.bottom || top !== currentRect.top || left > currentRect.right || right < currentRect.left) {\n          currentRect = {\n            left: Infinity,\n            right: -Infinity,\n            bottom,\n            top,\n          };\n          rects.push(currentRect);\n        }\n        currentRect.left = Math.min(left, currentRect.left);\n        currentRect.right = Math.max(right, currentRect.right);\n      }\n\n      // Merge any overlapping rects, e.g. those formed by adjacent bidi runs\n      rects.sort((a, b) => b.bottom - a.bottom || a.left - b.left);\n      for (let i = rects.length - 1; i-- > 0;) {\n        const rectA = rects[i];\n        const rectB = rects[i + 1];\n        if (rectA.bottom === rectB.bottom && rectA.top === rectB.top && rectA.left <= rectB.right && rectA.right >= rectB.left) {\n          rectB.left = Math.min(rectB.left, rectA.left);\n          rectB.right = Math.max(rectB.right, rectA.right);\n          rects.splice(i, 1);\n        }\n      }\n\n      _rectsCache.set(textRenderInfo, {start, end, rects});\n    }\n    return rects\n  }\n\n  const _caretsByRowCache = new WeakMap();\n\n  /**\n   * Group a set of carets by row of text, caching the result. A single row of text may contain carets of\n   * differing positions/heights if it has multiple fonts, and they may overlap slightly across rows, so this\n   * uses an assumption of \"at least overlapping by half\" to put them in the same row.\n   * @return Array<{bottom: number, top: number, carets: TextCaret[]}>\n   */\n  function groupCaretsByRow(textRenderInfo) {\n    // textRenderInfo is frozen so it's safe to cache based on it\n    let rows = _caretsByRowCache.get(textRenderInfo);\n    if (!rows) {\n      rows = [];\n      const {caretPositions} = textRenderInfo;\n      let curRow;\n\n      const visitCaret = (x, bottom, top, charIndex) => {\n        // new row if not overlapping by at least half\n        if (!curRow || (top < (curRow.top + curRow.bottom) / 2)) {\n          rows.push(curRow = {bottom, top, carets: []});\n        }\n        // expand vertical limits if necessary\n        if (top > curRow.top) curRow.top = top;\n        if (bottom < curRow.bottom) curRow.bottom = bottom;\n        curRow.carets.push({\n          x,\n          y: bottom,\n          height: top - bottom,\n          charIndex,\n        });\n      };\n\n      let i = 0;\n      for (; i < caretPositions.length; i += 4) {\n        visitCaret(caretPositions[i], caretPositions[i + 2], caretPositions[i + 3], i / 4);\n      }\n      // Add one more caret after the final char\n      visitCaret(caretPositions[i - 3], caretPositions[i - 2], caretPositions[i - 1], i / 4);\n    }\n    _caretsByRowCache.set(textRenderInfo, rows);\n    return rows\n  }\n\n  exports.BatchedText = BatchedText;\n  exports.GlyphsGeometry = GlyphsGeometry;\n  exports.Text = Text;\n  exports.configureTextBuilder = configureTextBuilder;\n  exports.createTextDerivedMaterial = createTextDerivedMaterial;\n  exports.dumpSDFTextures = dumpSDFTextures;\n  exports.fontResolverWorkerModule = fontResolverWorkerModule;\n  exports.getCaretAtPoint = getCaretAtPoint;\n  exports.getSelectionRects = getSelectionRects;\n  exports.getTextRenderInfo = getTextRenderInfo;\n  exports.preloadFont = preloadFont;\n  exports.typesetterWorkerModule = typesetterWorkerModule;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXRleHQvZGlzdC90cm9pa2EtdGhyZWUtdGV4dC51bWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxFQUFFLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLHlEQUFPLEdBQUcsbUJBQU8sQ0FBQyxxR0FBcUIsR0FBRyxtQkFBTyxDQUFDLGlHQUFxQixHQUFHLG1CQUFPLENBQUMsMERBQVMsR0FBRyxtQkFBTyxDQUFDLGtHQUFvQjtBQUNwTixFQUFFLENBQ21PO0FBQ3JPLENBQUMsMEdBQTBHOztBQUUzRyx1Q0FBdUMsNERBQTREOztBQUVuRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtFQUFrRSxPQUFPLGtCQUFrQixpQ0FBaUMsK0JBQStCLFFBQVEsOENBQThDLHNCQUFzQixLQUFLLGlCQUFpQixJQUFJLEtBQUssc0JBQXNCLCtCQUErQixTQUFTLDBCQUEwQix5QkFBeUIsaUJBQWlCLHNCQUFzQix3QkFBd0IsMEVBQTBFLCtIQUErSCxrQkFBa0IsS0FBSyxLQUFLLElBQUksS0FBSyx5QkFBeUIsMEJBQTBCLHNCQUFzQixLQUFLLHNCQUFzQixXQUFXLG9CQUFvQixRQUFRLFdBQVcsS0FBSyxXQUFXLG9FQUFvRSxTQUFTLDRCQUE0QixrREFBa0QsSUFBSSxLQUFLLHlCQUF5QiwwQkFBMEIsc0JBQXNCLDJDQUEyQyxXQUFXLFFBQVEsd0JBQXdCLGlEQUFpRCwyQkFBMkIsbUNBQW1DLHVCQUF1QixtQ0FBbUMsd0JBQXdCLGtDQUFrQyx5QkFBeUIsbUNBQW1DLDBCQUEwQixvQ0FBb0MsNkJBQTZCLGlCQUFpQixJQUFJLHVDQUF1QyxTQUFTLHdCQUF3QixvQ0FBb0MsMEJBQTBCLDhEQUE4RCwyQkFBMkIsaUJBQWlCLElBQUksbUNBQW1DLFNBQVMsNkJBQTZCLGlCQUFpQixJQUFJLEtBQUssdUJBQXVCLDJCQUEyQixTQUFTLDJHQUEyRyxtQkFBbUIsZ0VBQWdFLDJCQUEyQixpQkFBaUIs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QWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztB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Q3pEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpREFBaUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxhQUFhLDJCQUEyQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsYUFBYTs7QUFFOUQsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1zdGFydGVyLXByaXNtaWMtbWluaW1hbC8uL25vZGVfbW9kdWxlcy90cm9pa2EtdGhyZWUtdGV4dC9kaXN0L3Ryb2lrYS10aHJlZS10ZXh0LnVtZC5qcz9iYTJhIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgndGhyZWUnKSwgcmVxdWlyZSgndHJvaWthLXdvcmtlci11dGlscycpLCByZXF1aXJlKCd3ZWJnbC1zZGYtZ2VuZXJhdG9yJyksIHJlcXVpcmUoJ2JpZGktanMnKSwgcmVxdWlyZSgndHJvaWthLXRocmVlLXV0aWxzJykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICd0aHJlZScsICd0cm9pa2Etd29ya2VyLXV0aWxzJywgJ3dlYmdsLXNkZi1nZW5lcmF0b3InLCAnYmlkaS1qcycsICd0cm9pa2EtdGhyZWUtdXRpbHMnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC50cm9pa2FfdGhyZWVfdGV4dCA9IHt9LCBnbG9iYWwuVEhSRUUsIGdsb2JhbC50cm9pa2Ffd29ya2VyX3V0aWxzLCBnbG9iYWwud2ViZ2xfc2RmX2dlbmVyYXRvciwgZ2xvYmFsLmJpZGlfanMsIGdsb2JhbC50cm9pa2FfdGhyZWVfdXRpbHMpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCB0aHJlZSwgdHJvaWthV29ya2VyVXRpbHMsIGNyZWF0ZVNERkdlbmVyYXRvciwgYmlkaUZhY3RvcnksIHRyb2lrYVRocmVlVXRpbHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdExlZ2FjeSAoZSkgeyByZXR1cm4gZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGUgPyBlIDogeyAnZGVmYXVsdCc6IGUgfTsgfVxuXG4gIHZhciBjcmVhdGVTREZHZW5lcmF0b3JfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KGNyZWF0ZVNERkdlbmVyYXRvcik7XG4gIHZhciBiaWRpRmFjdG9yeV9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koYmlkaUZhY3RvcnkpO1xuXG4gIC8qIVxuICBDdXN0b20gYnVpbGQgb2YgVHlwci50cyAoaHR0cHM6Ly9naXRodWIuY29tL2ZyZWRsaTc0L1R5cHIudHMpIGZvciB1c2UgaW4gVHJvaWthIHRleHQgcmVuZGVyaW5nLlxuICBPcmlnaW5hbCBNSVQgbGljZW5zZSBhcHBsaWVzOiBodHRwczovL2dpdGh1Yi5jb20vZnJlZGxpNzQvVHlwci50cy9ibG9iL21hc3Rlci9MSUNFTlNFXG4gICovXG4gIGZ1bmN0aW9uIHR5cHJGYWN0b3J5KCl7cmV0dXJuIFwidW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3cmJihzZWxmLndpbmRvdz1zZWxmKSxmdW5jdGlvbihyKXt2YXIgZT17cGFyc2U6ZnVuY3Rpb24ocil7dmFyIHQ9ZS5fYmluLGE9bmV3IFVpbnQ4QXJyYXkocik7aWYoXCJ0dGNmXCI9PXQucmVhZEFTQ0lJKGEsMCw0KSl7dmFyIG49NDt0LnJlYWRVc2hvcnQoYSxuKSxuKz0yLHQucmVhZFVzaG9ydChhLG4pLG4rPTI7dmFyIG89dC5yZWFkVWludChhLG4pO24rPTQ7Zm9yKHZhciBzPVtdLGk9MDtpPG87aSsrKXt2YXIgaD10LnJlYWRVaW50KGEsbik7bis9NCxzLnB1c2goZS5fcmVhZEZvbnQoYSxoKSk7fXJldHVybiBzfXJldHVybiBbZS5fcmVhZEZvbnQoYSwwKV19LF9yZWFkRm9udDpmdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXQ7YS5yZWFkRml4ZWQocix0KSx0Kz00O3ZhciBvPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTI7Zm9yKHZhciBzPVtcImNtYXBcIixcImhlYWRcIixcImhoZWFcIixcIm1heHBcIixcImhtdHhcIixcIm5hbWVcIixcIk9TLzJcIixcInBvc3RcIixcImxvY2FcIixcImdseWZcIixcImtlcm5cIixcIkNGRiBcIixcIkdERUZcIixcIkdQT1NcIixcIkdTVUJcIixcIlNWRyBcIl0saT17X2RhdGE6cixfb2Zmc2V0Om59LGg9e30sZD0wO2Q8bztkKyspe3ZhciBmPWEucmVhZEFTQ0lJKHIsdCw0KTt0Kz00LGEucmVhZFVpbnQocix0KSx0Kz00O3ZhciB1PWEucmVhZFVpbnQocix0KTt0Kz00O3ZhciBsPWEucmVhZFVpbnQocix0KTt0Kz00LGhbZl09e29mZnNldDp1LGxlbmd0aDpsfTt9Zm9yKGQ9MDtkPHMubGVuZ3RoO2QrKyl7dmFyIHY9c1tkXTtoW3ZdJiYoaVt2LnRyaW0oKV09ZVt2LnRyaW0oKV0ucGFyc2UocixoW3ZdLm9mZnNldCxoW3ZdLmxlbmd0aCxpKSk7fXJldHVybiBpfSxfdGFiT2Zmc2V0OmZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49ZS5fYmluLG89bi5yZWFkVXNob3J0KHIsYSs0KSxzPWErMTIsaT0wO2k8bztpKyspe3ZhciBoPW4ucmVhZEFTQ0lJKHIscyw0KTtzKz00LG4ucmVhZFVpbnQocixzKSxzKz00O3ZhciBkPW4ucmVhZFVpbnQocixzKTtpZihzKz00LG4ucmVhZFVpbnQocixzKSxzKz00LGg9PXQpcmV0dXJuIGR9cmV0dXJuIDB9fTtlLl9iaW49e3JlYWRGaXhlZDpmdW5jdGlvbihyLGUpe3JldHVybiAocltlXTw8OHxyW2UrMV0pKyhyW2UrMl08PDh8cltlKzNdKS82NTU0MH0scmVhZEYyZG90MTQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLnJlYWRTaG9ydChyLHQpLzE2Mzg0fSxyZWFkSW50OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIGUuX2Jpbi5fdmlldyhyKS5nZXRJbnQzMih0KX0scmVhZEludDg6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLl92aWV3KHIpLmdldEludDgodCl9LHJlYWRTaG9ydDpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4uX3ZpZXcocikuZ2V0SW50MTYodCl9LHJlYWRVc2hvcnQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLl92aWV3KHIpLmdldFVpbnQxNih0KX0scmVhZFVzaG9ydHM6ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj1bXSxvPTA7bzxhO28rKyluLnB1c2goZS5fYmluLnJlYWRVc2hvcnQocix0KzIqbykpO3JldHVybiBufSxyZWFkVWludDpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4uX3ZpZXcocikuZ2V0VWludDMyKHQpfSxyZWFkVWludDY0OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIDQyOTQ5NjcyOTYqZS5fYmluLnJlYWRVaW50KHIsdCkrZS5fYmluLnJlYWRVaW50KHIsdCs0KX0scmVhZEFTQ0lJOmZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9XCJcIixuPTA7bjx0O24rKylhKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHJbZStuXSk7cmV0dXJuIGF9LHJlYWRVbmljb2RlOmZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9XCJcIixuPTA7bjx0O24rKyl7dmFyIG89cltlKytdPDw4fHJbZSsrXTthKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG8pO31yZXR1cm4gYX0sX3RkZWM6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93LlRleHREZWNvZGVyP25ldyB3aW5kb3cuVGV4dERlY29kZXI6bnVsbCxyZWFkVVRGODpmdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLl90ZGVjO3JldHVybiBuJiYwPT10JiZhPT1yLmxlbmd0aD9uLmRlY29kZShyKTplLl9iaW4ucmVhZEFTQ0lJKHIsdCxhKX0scmVhZEJ5dGVzOmZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9W10sbj0wO248dDtuKyspYS5wdXNoKHJbZStuXSk7cmV0dXJuIGF9LHJlYWRBU0NJSUFycmF5OmZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9W10sbj0wO248dDtuKyspYS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUocltlK25dKSk7cmV0dXJuIGF9LF92aWV3OmZ1bmN0aW9uKHIpe3JldHVybiByLl9kYXRhVmlld3x8KHIuX2RhdGFWaWV3PXIuYnVmZmVyP25ldyBEYXRhVmlldyhyLmJ1ZmZlcixyLmJ5dGVPZmZzZXQsci5ieXRlTGVuZ3RoKTpuZXcgRGF0YVZpZXcobmV3IFVpbnQ4QXJyYXkocikuYnVmZmVyKSl9fSxlLl9sY3RmPXt9LGUuX2xjdGYucGFyc2U9ZnVuY3Rpb24ocix0LGEsbixvKXt2YXIgcz1lLl9iaW4saT17fSxoPXQ7cy5yZWFkRml4ZWQocix0KSx0Kz00O3ZhciBkPXMucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGY9cy5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgdT1zLnJlYWRVc2hvcnQocix0KTtyZXR1cm4gdCs9MixpLnNjcmlwdExpc3Q9ZS5fbGN0Zi5yZWFkU2NyaXB0TGlzdChyLGgrZCksaS5mZWF0dXJlTGlzdD1lLl9sY3RmLnJlYWRGZWF0dXJlTGlzdChyLGgrZiksaS5sb29rdXBMaXN0PWUuX2xjdGYucmVhZExvb2t1cExpc3QocixoK3UsbyksaX0sZS5fbGN0Zi5yZWFkTG9va3VwTGlzdD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89dCxzPVtdLGk9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGg9MDtoPGk7aCsrKXt2YXIgZD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBmPWUuX2xjdGYucmVhZExvb2t1cFRhYmxlKHIsbytkLGEpO3MucHVzaChmKTt9cmV0dXJuIHN9LGUuX2xjdGYucmVhZExvb2t1cFRhYmxlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz10LHM9e3RhYnM6W119O3MubHR5cGU9bi5yZWFkVXNob3J0KHIsdCksdCs9MixzLmZsYWc9bi5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgaT1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD1zLmx0eXBlLGQ9MDtkPGk7ZCsrKXt2YXIgZj1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciB1PWEocixoLG8rZixzKTtzLnRhYnMucHVzaCh1KTt9cmV0dXJuIHN9LGUuX2xjdGYubnVtT2ZPbmVzPWZ1bmN0aW9uKHIpe2Zvcih2YXIgZT0wLHQ9MDt0PDMyO3QrKykwIT0ocj4+PnQmMSkmJmUrKztyZXR1cm4gZX0sZS5fbGN0Zi5yZWFkQ2xhc3NEZWY9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj1bXSxvPWEucmVhZFVzaG9ydChyLHQpO2lmKHQrPTIsMT09byl7dmFyIHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD0wO2g8aTtoKyspbi5wdXNoKHMraCksbi5wdXNoKHMraCksbi5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yO31pZigyPT1vKXt2YXIgZD1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2ZvcihoPTA7aDxkO2grKyluLnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTIsbi5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yLG4ucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9Mjt9cmV0dXJuIG59LGUuX2xjdGYuZ2V0SW50ZXJ2YWw9ZnVuY3Rpb24ocixlKXtmb3IodmFyIHQ9MDt0PHIubGVuZ3RoO3QrPTMpe3ZhciBhPXJbdF0sbj1yW3QrMV07aWYoclt0KzJdLGE8PWUmJmU8PW4pcmV0dXJuIHR9cmV0dXJuIC0xfSxlLl9sY3RmLnJlYWRDb3ZlcmFnZT1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXt9O24uZm10PWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7cmV0dXJuIHQrPTIsMT09bi5mbXQmJihuLnRhYj1hLnJlYWRVc2hvcnRzKHIsdCxvKSksMj09bi5mbXQmJihuLnRhYj1hLnJlYWRVc2hvcnRzKHIsdCwzKm8pKSxufSxlLl9sY3RmLmNvdmVyYWdlSW5kZXg9ZnVuY3Rpb24ocix0KXt2YXIgYT1yLnRhYjtpZigxPT1yLmZtdClyZXR1cm4gYS5pbmRleE9mKHQpO2lmKDI9PXIuZm10KXt2YXIgbj1lLl9sY3RmLmdldEludGVydmFsKGEsdCk7aWYoLTEhPW4pcmV0dXJuIGFbbisyXSsodC1hW25dKX1yZXR1cm4gLTF9LGUuX2xjdGYucmVhZEZlYXR1cmVMaXN0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPVtdLHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1hLnJlYWRBU0NJSShyLHQsNCk7dCs9NDt2YXIgZD1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBmPWUuX2xjdGYucmVhZEZlYXR1cmVUYWJsZShyLG4rZCk7Zi50YWc9aC50cmltKCksby5wdXNoKGYpO31yZXR1cm4gb30sZS5fbGN0Zi5yZWFkRmVhdHVyZVRhYmxlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPXt9LHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixzPjAmJihvLmZlYXR1cmVQYXJhbXM9bitzKTt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG8udGFiPVtdO2Zvcih2YXIgaD0wO2g8aTtoKyspby50YWIucHVzaChhLnJlYWRVc2hvcnQocix0KzIqaCkpO3JldHVybiBvfSxlLl9sY3RmLnJlYWRTY3JpcHRMaXN0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPXt9LHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1hLnJlYWRBU0NJSShyLHQsNCk7dCs9NDt2YXIgZD1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG9baC50cmltKCldPWUuX2xjdGYucmVhZFNjcmlwdFRhYmxlKHIsbitkKTt9cmV0dXJuIG99LGUuX2xjdGYucmVhZFNjcmlwdFRhYmxlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPXt9LHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixzPjAmJihvLmRlZmF1bHQ9ZS5fbGN0Zi5yZWFkTGFuZ1N5c1RhYmxlKHIsbitzKSk7dmFyIGk9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGg9MDtoPGk7aCsrKXt2YXIgZD1hLnJlYWRBU0NJSShyLHQsNCk7dCs9NDt2YXIgZj1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG9bZC50cmltKCldPWUuX2xjdGYucmVhZExhbmdTeXNUYWJsZShyLG4rZik7fXJldHVybiBvfSxlLl9sY3RmLnJlYWRMYW5nU3lzVGFibGU9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj17fTthLnJlYWRVc2hvcnQocix0KSx0Kz0yLG4ucmVxRmVhdHVyZT1hLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBvPWEucmVhZFVzaG9ydChyLHQpO3JldHVybiB0Kz0yLG4uZmVhdHVyZXM9YS5yZWFkVXNob3J0cyhyLHQsbyksbn0sZS5DRkY9e30sZS5DRkYucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2Jpbjsocj1uZXcgVWludDhBcnJheShyLmJ1ZmZlcix0LGEpKVt0PTBdLHJbKyt0XSxyWysrdF0sclsrK3RdLHQrKzt2YXIgbz1bXTt0PWUuQ0ZGLnJlYWRJbmRleChyLHQsbyk7Zm9yKHZhciBzPVtdLGk9MDtpPG8ubGVuZ3RoLTE7aSsrKXMucHVzaChuLnJlYWRBU0NJSShyLHQrb1tpXSxvW2krMV0tb1tpXSkpO3QrPW9bby5sZW5ndGgtMV07dmFyIGg9W107dD1lLkNGRi5yZWFkSW5kZXgocix0LGgpO3ZhciBkPVtdO2ZvcihpPTA7aTxoLmxlbmd0aC0xO2krKylkLnB1c2goZS5DRkYucmVhZERpY3Qocix0K2hbaV0sdCtoW2krMV0pKTt0Kz1oW2gubGVuZ3RoLTFdO3ZhciBmPWRbMF0sdT1bXTt0PWUuQ0ZGLnJlYWRJbmRleChyLHQsdSk7dmFyIGw9W107Zm9yKGk9MDtpPHUubGVuZ3RoLTE7aSsrKWwucHVzaChuLnJlYWRBU0NJSShyLHQrdVtpXSx1W2krMV0tdVtpXSkpO2lmKHQrPXVbdS5sZW5ndGgtMV0sZS5DRkYucmVhZFN1YnJzKHIsdCxmKSxmLkNoYXJTdHJpbmdzKXt0PWYuQ2hhclN0cmluZ3M7dT1bXTt0PWUuQ0ZGLnJlYWRJbmRleChyLHQsdSk7dmFyIHY9W107Zm9yKGk9MDtpPHUubGVuZ3RoLTE7aSsrKXYucHVzaChuLnJlYWRCeXRlcyhyLHQrdVtpXSx1W2krMV0tdVtpXSkpO2YuQ2hhclN0cmluZ3M9djt9aWYoZi5ST1Mpe3Q9Zi5GREFycmF5O3ZhciBjPVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCxjKSxmLkZEQXJyYXk9W107Zm9yKGk9MDtpPGMubGVuZ3RoLTE7aSsrKXt2YXIgcD1lLkNGRi5yZWFkRGljdChyLHQrY1tpXSx0K2NbaSsxXSk7ZS5DRkYuX3JlYWRGRGljdChyLHAsbCksZi5GREFycmF5LnB1c2gocCk7fXQrPWNbYy5sZW5ndGgtMV0sdD1mLkZEU2VsZWN0LGYuRkRTZWxlY3Q9W107dmFyIFU9clt0XTtpZih0KyssMyE9VSl0aHJvdyBVO3ZhciBnPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKGk9MDtpPGcrMTtpKyspZi5GRFNlbGVjdC5wdXNoKG4ucmVhZFVzaG9ydChyLHQpLHJbdCsyXSksdCs9Mzt9cmV0dXJuIGYuRW5jb2RpbmcmJihmLkVuY29kaW5nPWUuQ0ZGLnJlYWRFbmNvZGluZyhyLGYuRW5jb2RpbmcsZi5DaGFyU3RyaW5ncy5sZW5ndGgpKSxmLmNoYXJzZXQmJihmLmNoYXJzZXQ9ZS5DRkYucmVhZENoYXJzZXQocixmLmNoYXJzZXQsZi5DaGFyU3RyaW5ncy5sZW5ndGgpKSxlLkNGRi5fcmVhZEZEaWN0KHIsZixsKSxmfSxlLkNGRi5fcmVhZEZEaWN0PWZ1bmN0aW9uKHIsdCxhKXt2YXIgbjtmb3IodmFyIG8gaW4gdC5Qcml2YXRlJiYobj10LlByaXZhdGVbMV0sdC5Qcml2YXRlPWUuQ0ZGLnJlYWREaWN0KHIsbixuK3QuUHJpdmF0ZVswXSksdC5Qcml2YXRlLlN1YnJzJiZlLkNGRi5yZWFkU3VicnMocixuK3QuUHJpdmF0ZS5TdWJycyx0LlByaXZhdGUpKSx0KS0xIT1bXCJGYW1pbHlOYW1lXCIsXCJGb250TmFtZVwiLFwiRnVsbE5hbWVcIixcIk5vdGljZVwiLFwidmVyc2lvblwiLFwiQ29weXJpZ2h0XCJdLmluZGV4T2YobykmJih0W29dPWFbdFtvXS00MjYrMzVdKTt9LGUuQ0ZGLnJlYWRTdWJycz1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89W107dD1lLkNGRi5yZWFkSW5kZXgocix0LG8pO3ZhciBzLGk9by5sZW5ndGg7cz1pPDEyNDA/MTA3Omk8MzM5MDA/MTEzMTozMjc2OCxhLkJpYXM9cyxhLlN1YnJzPVtdO2Zvcih2YXIgaD0wO2g8by5sZW5ndGgtMTtoKyspYS5TdWJycy5wdXNoKG4ucmVhZEJ5dGVzKHIsdCtvW2hdLG9baCsxXS1vW2hdKSk7fSxlLkNGRi50YWJsZVNFPVswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksMzAsMzEsMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzksNDAsNDEsNDIsNDMsNDQsNDUsNDYsNDcsNDgsNDksNTAsNTEsNTIsNTMsNTQsNTUsNTYsNTcsNTgsNTksNjAsNjEsNjIsNjMsNjQsNjUsNjYsNjcsNjgsNjksNzAsNzEsNzIsNzMsNzQsNzUsNzYsNzcsNzgsNzksODAsODEsODIsODMsODQsODUsODYsODcsODgsODksOTAsOTEsOTIsOTMsOTQsOTUsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCw5Niw5Nyw5OCw5OSwxMDAsMTAxLDEwMiwxMDMsMTA0LDEwNSwxMDYsMTA3LDEwOCwxMDksMTEwLDAsMTExLDExMiwxMTMsMTE0LDAsMTE1LDExNiwxMTcsMTE4LDExOSwxMjAsMTIxLDEyMiwwLDEyMywwLDEyNCwxMjUsMTI2LDEyNywxMjgsMTI5LDEzMCwxMzEsMCwxMzIsMTMzLDAsMTM0LDEzNSwxMzYsMTM3LDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMTM4LDAsMTM5LDAsMCwwLDAsMTQwLDE0MSwxNDIsMTQzLDAsMCwwLDAsMCwxNDQsMCwwLDAsMTQ1LDAsMCwxNDYsMTQ3LDE0OCwxNDksMCwwLDAsMF0sZS5DRkYuZ2x5cGhCeVVuaWNvZGU9ZnVuY3Rpb24ocixlKXtmb3IodmFyIHQ9MDt0PHIuY2hhcnNldC5sZW5ndGg7dCsrKWlmKHIuY2hhcnNldFt0XT09ZSlyZXR1cm4gdDtyZXR1cm4gLTF9LGUuQ0ZGLmdseXBoQnlTRT1mdW5jdGlvbihyLHQpe3JldHVybiB0PDB8fHQ+MjU1Py0xOmUuQ0ZGLmdseXBoQnlVbmljb2RlKHIsZS5DRkYudGFibGVTRVt0XSl9LGUuQ0ZGLnJlYWRFbmNvZGluZz1mdW5jdGlvbihyLHQsYSl7ZS5fYmluO3ZhciBuPVtcIi5ub3RkZWZcIl0sbz1yW3RdO2lmKHQrKywwIT1vKXRocm93IFwiZXJyb3I6IHVua25vd24gZW5jb2RpbmcgZm9ybWF0OiBcIitvO3ZhciBzPXJbdF07dCsrO2Zvcih2YXIgaT0wO2k8cztpKyspbi5wdXNoKHJbdCtpXSk7cmV0dXJuIG59LGUuQ0ZGLnJlYWRDaGFyc2V0PWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz1bXCIubm90ZGVmXCJdLHM9clt0XTtpZih0KyssMD09cylmb3IodmFyIGk9MDtpPGE7aSsrKXt2YXIgaD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yLG8ucHVzaChoKTt9ZWxzZSB7aWYoMSE9cyYmMiE9cyl0aHJvdyBcImVycm9yOiBmb3JtYXQ6IFwiK3M7Zm9yKDtvLmxlbmd0aDxhOyl7aD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBkPTA7MT09cz8oZD1yW3RdLHQrKyk6KGQ9bi5yZWFkVXNob3J0KHIsdCksdCs9Mik7Zm9yKGk9MDtpPD1kO2krKylvLnB1c2goaCksaCsrO319cmV0dXJuIG99LGUuQ0ZGLnJlYWRJbmRleD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89bi5yZWFkVXNob3J0KHIsdCkrMSxzPXJbdCs9Ml07aWYodCsrLDE9PXMpZm9yKHZhciBpPTA7aTxvO2krKylhLnB1c2goclt0K2ldKTtlbHNlIGlmKDI9PXMpZm9yKGk9MDtpPG87aSsrKWEucHVzaChuLnJlYWRVc2hvcnQocix0KzIqaSkpO2Vsc2UgaWYoMz09cylmb3IoaT0wO2k8bztpKyspYS5wdXNoKDE2Nzc3MjE1Jm4ucmVhZFVpbnQocix0KzMqaS0xKSk7ZWxzZSBpZigxIT1vKXRocm93IFwidW5zdXBwb3J0ZWQgb2Zmc2V0IHNpemU6IFwiK3MrXCIsIGNvdW50OiBcIitvO3JldHVybiAodCs9bypzKS0xfSxlLkNGRi5nZXRDaGFyU3RyaW5nPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz1yW3RdLHM9clt0KzFdO3JbdCsyXSxyW3QrM10sclt0KzRdO3ZhciBpPTEsaD1udWxsLGQ9bnVsbDtvPD0yMCYmKGg9byxpPTEpLDEyPT1vJiYoaD0xMDAqbytzLGk9MiksMjE8PW8mJm88PTI3JiYoaD1vLGk9MSksMjg9PW8mJihkPW4ucmVhZFNob3J0KHIsdCsxKSxpPTMpLDI5PD1vJiZvPD0zMSYmKGg9byxpPTEpLDMyPD1vJiZvPD0yNDYmJihkPW8tMTM5LGk9MSksMjQ3PD1vJiZvPD0yNTAmJihkPTI1Niooby0yNDcpK3MrMTA4LGk9MiksMjUxPD1vJiZvPD0yNTQmJihkPTI1NiotKG8tMjUxKS1zLTEwOCxpPTIpLDI1NT09byYmKGQ9bi5yZWFkSW50KHIsdCsxKS82NTUzNSxpPTUpLGEudmFsPW51bGwhPWQ/ZDpcIm9cIitoLGEuc2l6ZT1pO30sZS5DRkYucmVhZENoYXJTdHJpbmc9ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj10K2Esbz1lLl9iaW4scz1bXTt0PG47KXt2YXIgaT1yW3RdLGg9clt0KzFdO3JbdCsyXSxyW3QrM10sclt0KzRdO3ZhciBkPTEsZj1udWxsLHU9bnVsbDtpPD0yMCYmKGY9aSxkPTEpLDEyPT1pJiYoZj0xMDAqaStoLGQ9MiksMTkhPWkmJjIwIT1pfHwoZj1pLGQ9MiksMjE8PWkmJmk8PTI3JiYoZj1pLGQ9MSksMjg9PWkmJih1PW8ucmVhZFNob3J0KHIsdCsxKSxkPTMpLDI5PD1pJiZpPD0zMSYmKGY9aSxkPTEpLDMyPD1pJiZpPD0yNDYmJih1PWktMTM5LGQ9MSksMjQ3PD1pJiZpPD0yNTAmJih1PTI1NiooaS0yNDcpK2grMTA4LGQ9MiksMjUxPD1pJiZpPD0yNTQmJih1PTI1NiotKGktMjUxKS1oLTEwOCxkPTIpLDI1NT09aSYmKHU9by5yZWFkSW50KHIsdCsxKS82NTUzNSxkPTUpLHMucHVzaChudWxsIT11P3U6XCJvXCIrZiksdCs9ZDt9cmV0dXJuIHN9LGUuQ0ZGLnJlYWREaWN0PWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49ZS5fYmluLG89e30scz1bXTt0PGE7KXt2YXIgaT1yW3RdLGg9clt0KzFdO3JbdCsyXSxyW3QrM10sclt0KzRdO3ZhciBkPTEsZj1udWxsLHU9bnVsbDtpZigyOD09aSYmKHU9bi5yZWFkU2hvcnQocix0KzEpLGQ9MyksMjk9PWkmJih1PW4ucmVhZEludChyLHQrMSksZD01KSwzMjw9aSYmaTw9MjQ2JiYodT1pLTEzOSxkPTEpLDI0Nzw9aSYmaTw9MjUwJiYodT0yNTYqKGktMjQ3KStoKzEwOCxkPTIpLDI1MTw9aSYmaTw9MjU0JiYodT0yNTYqLShpLTI1MSktaC0xMDgsZD0yKSwyNTU9PWkpdGhyb3cgdT1uLnJlYWRJbnQocix0KzEpLzY1NTM1LGQ9NSxcInVua25vd24gbnVtYmVyXCI7aWYoMzA9PWkpe3ZhciBsPVtdO2ZvcihkPTE7Oyl7dmFyIHY9clt0K2RdO2QrKzt2YXIgYz12Pj40LHA9MTUmdjtpZigxNSE9YyYmbC5wdXNoKGMpLDE1IT1wJiZsLnB1c2gocCksMTU9PXApYnJlYWt9Zm9yKHZhciBVPVwiXCIsZz1bMCwxLDIsMyw0LDUsNiw3LDgsOSxcIi5cIixcImVcIixcImUtXCIsXCJyZXNlcnZlZFwiLFwiLVwiLFwiZW5kT2ZOdW1iZXJcIl0sUz0wO1M8bC5sZW5ndGg7UysrKVUrPWdbbFtTXV07dT1wYXJzZUZsb2F0KFUpO31pZihpPD0yMSlpZihmPVtcInZlcnNpb25cIixcIk5vdGljZVwiLFwiRnVsbE5hbWVcIixcIkZhbWlseU5hbWVcIixcIldlaWdodFwiLFwiRm9udEJCb3hcIixcIkJsdWVWYWx1ZXNcIixcIk90aGVyQmx1ZXNcIixcIkZhbWlseUJsdWVzXCIsXCJGYW1pbHlPdGhlckJsdWVzXCIsXCJTdGRIV1wiLFwiU3RkVldcIixcImVzY2FwZVwiLFwiVW5pcXVlSURcIixcIlhVSURcIixcImNoYXJzZXRcIixcIkVuY29kaW5nXCIsXCJDaGFyU3RyaW5nc1wiLFwiUHJpdmF0ZVwiLFwiU3VicnNcIixcImRlZmF1bHRXaWR0aFhcIixcIm5vbWluYWxXaWR0aFhcIl1baV0sZD0xLDEyPT1pKWY9W1wiQ29weXJpZ2h0XCIsXCJpc0ZpeGVkUGl0Y2hcIixcIkl0YWxpY0FuZ2xlXCIsXCJVbmRlcmxpbmVQb3NpdGlvblwiLFwiVW5kZXJsaW5lVGhpY2tuZXNzXCIsXCJQYWludFR5cGVcIixcIkNoYXJzdHJpbmdUeXBlXCIsXCJGb250TWF0cml4XCIsXCJTdHJva2VXaWR0aFwiLFwiQmx1ZVNjYWxlXCIsXCJCbHVlU2hpZnRcIixcIkJsdWVGdXp6XCIsXCJTdGVtU25hcEhcIixcIlN0ZW1TbmFwVlwiLFwiRm9yY2VCb2xkXCIsMCwwLFwiTGFuZ3VhZ2VHcm91cFwiLFwiRXhwYW5zaW9uRmFjdG9yXCIsXCJpbml0aWFsUmFuZG9tU2VlZFwiLFwiU3ludGhldGljQmFzZVwiLFwiUG9zdFNjcmlwdFwiLFwiQmFzZUZvbnROYW1lXCIsXCJCYXNlRm9udEJsZW5kXCIsMCwwLDAsMCwwLDAsXCJST1NcIixcIkNJREZvbnRWZXJzaW9uXCIsXCJDSURGb250UmV2aXNpb25cIixcIkNJREZvbnRUeXBlXCIsXCJDSURDb3VudFwiLFwiVUlEQmFzZVwiLFwiRkRBcnJheVwiLFwiRkRTZWxlY3RcIixcIkZvbnROYW1lXCJdW2hdLGQ9MjtudWxsIT1mPyhvW2ZdPTE9PXMubGVuZ3RoP3NbMF06cyxzPVtdKTpzLnB1c2godSksdCs9ZDt9cmV0dXJuIG99LGUuY21hcD17fSxlLmNtYXAucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3I9bmV3IFVpbnQ4QXJyYXkoci5idWZmZXIsdCxhKSx0PTA7dmFyIG49ZS5fYmluLG89e307bi5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgcz1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBpPVtdO28udGFibGVzPVtdO2Zvcih2YXIgaD0wO2g8cztoKyspe3ZhciBkPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGY9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgdT1uLnJlYWRVaW50KHIsdCk7dCs9NDt2YXIgbD1cInBcIitkK1wiZVwiK2Ysdj1pLmluZGV4T2YodSk7aWYoLTE9PXYpe3ZhciBjO3Y9by50YWJsZXMubGVuZ3RoLGkucHVzaCh1KTt2YXIgcD1uLnJlYWRVc2hvcnQocix1KTswPT1wP2M9ZS5jbWFwLnBhcnNlMChyLHUpOjQ9PXA/Yz1lLmNtYXAucGFyc2U0KHIsdSk6Nj09cD9jPWUuY21hcC5wYXJzZTYocix1KToxMj09cD9jPWUuY21hcC5wYXJzZTEyKHIsdSk6Y29uc29sZS5kZWJ1ZyhcInVua25vd24gZm9ybWF0OiBcIitwLGQsZix1KSxvLnRhYmxlcy5wdXNoKGMpO31pZihudWxsIT1vW2xdKXRocm93IFwibXVsdGlwbGUgdGFibGVzIGZvciBvbmUgcGxhdGZvcm0rZW5jb2RpbmdcIjtvW2xdPXY7fXJldHVybiBvfSxlLmNtYXAucGFyc2UwPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e307bi5mb3JtYXQ9YS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgbz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTIsbi5tYXA9W107Zm9yKHZhciBzPTA7czxvLTY7cysrKW4ubWFwLnB1c2goclt0K3NdKTtyZXR1cm4gbn0sZS5jbWFwLnBhcnNlND1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXQsbz17fTtvLmZvcm1hdD1hLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBzPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBoPWkvMjtvLnNlYXJjaFJhbmdlPWEucmVhZFVzaG9ydChyLHQpLHQrPTIsby5lbnRyeVNlbGVjdG9yPWEucmVhZFVzaG9ydChyLHQpLHQrPTIsby5yYW5nZVNoaWZ0PWEucmVhZFVzaG9ydChyLHQpLHQrPTIsby5lbmRDb3VudD1hLnJlYWRVc2hvcnRzKHIsdCxoKSx0Kz0yKmgsdCs9MixvLnN0YXJ0Q291bnQ9YS5yZWFkVXNob3J0cyhyLHQsaCksdCs9MipoLG8uaWREZWx0YT1bXTtmb3IodmFyIGQ9MDtkPGg7ZCsrKW8uaWREZWx0YS5wdXNoKGEucmVhZFNob3J0KHIsdCkpLHQrPTI7Zm9yKG8uaWRSYW5nZU9mZnNldD1hLnJlYWRVc2hvcnRzKHIsdCxoKSx0Kz0yKmgsby5nbHlwaElkQXJyYXk9W107dDxuK3M7KW8uZ2x5cGhJZEFycmF5LnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTI7cmV0dXJuIG99LGUuY21hcC5wYXJzZTY9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj17fTtuLmZvcm1hdD1hLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9MixuLmZpcnN0Q29kZT1hLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBvPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsbi5nbHlwaElkQXJyYXk9W107Zm9yKHZhciBzPTA7czxvO3MrKyluLmdseXBoSWRBcnJheS5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yO3JldHVybiBufSxlLmNtYXAucGFyc2UxMj1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXt9O24uZm9ybWF0PWEucmVhZFVzaG9ydChyLHQpLHQrPTIsdCs9MixhLnJlYWRVaW50KHIsdCksdCs9NCxhLnJlYWRVaW50KHIsdCksdCs9NDt2YXIgbz1hLnJlYWRVaW50KHIsdCk7dCs9NCxuLmdyb3Vwcz1bXTtmb3IodmFyIHM9MDtzPG87cysrKXt2YXIgaT10KzEyKnMsaD1hLnJlYWRVaW50KHIsaSswKSxkPWEucmVhZFVpbnQocixpKzQpLGY9YS5yZWFkVWludChyLGkrOCk7bi5ncm91cHMucHVzaChbaCxkLGZdKTt9cmV0dXJuIG59LGUuZ2x5Zj17fSxlLmdseWYucGFyc2U9ZnVuY3Rpb24ocixlLHQsYSl7Zm9yKHZhciBuPVtdLG89MDtvPGEubWF4cC5udW1HbHlwaHM7bysrKW4ucHVzaChudWxsKTtyZXR1cm4gbn0sZS5nbHlmLl9wYXJzZUdseWY9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj1yLl9kYXRhLG89ZS5fdGFiT2Zmc2V0KG4sXCJnbHlmXCIsci5fb2Zmc2V0KStyLmxvY2FbdF07aWYoci5sb2NhW3RdPT1yLmxvY2FbdCsxXSlyZXR1cm4gbnVsbDt2YXIgcz17fTtpZihzLm5vYz1hLnJlYWRTaG9ydChuLG8pLG8rPTIscy54TWluPWEucmVhZFNob3J0KG4sbyksbys9MixzLnlNaW49YS5yZWFkU2hvcnQobixvKSxvKz0yLHMueE1heD1hLnJlYWRTaG9ydChuLG8pLG8rPTIscy55TWF4PWEucmVhZFNob3J0KG4sbyksbys9MixzLnhNaW4+PXMueE1heHx8cy55TWluPj1zLnlNYXgpcmV0dXJuIG51bGw7aWYocy5ub2M+MCl7cy5lbmRQdHM9W107Zm9yKHZhciBpPTA7aTxzLm5vYztpKyspcy5lbmRQdHMucHVzaChhLnJlYWRVc2hvcnQobixvKSksbys9Mjt2YXIgaD1hLnJlYWRVc2hvcnQobixvKTtpZihvKz0yLG4ubGVuZ3RoLW88aClyZXR1cm4gbnVsbDtzLmluc3RydWN0aW9ucz1hLnJlYWRCeXRlcyhuLG8saCksbys9aDt2YXIgZD1zLmVuZFB0c1tzLm5vYy0xXSsxO3MuZmxhZ3M9W107Zm9yKGk9MDtpPGQ7aSsrKXt2YXIgZj1uW29dO2lmKG8rKyxzLmZsYWdzLnB1c2goZiksMCE9KDgmZikpe3ZhciB1PW5bb107bysrO2Zvcih2YXIgbD0wO2w8dTtsKyspcy5mbGFncy5wdXNoKGYpLGkrKzt9fXMueHM9W107Zm9yKGk9MDtpPGQ7aSsrKXt2YXIgdj0wIT0oMiZzLmZsYWdzW2ldKSxjPTAhPSgxNiZzLmZsYWdzW2ldKTt2PyhzLnhzLnB1c2goYz9uW29dOi1uW29dKSxvKyspOmM/cy54cy5wdXNoKDApOihzLnhzLnB1c2goYS5yZWFkU2hvcnQobixvKSksbys9Mik7fXMueXM9W107Zm9yKGk9MDtpPGQ7aSsrKXt2PTAhPSg0JnMuZmxhZ3NbaV0pLGM9MCE9KDMyJnMuZmxhZ3NbaV0pO3Y/KHMueXMucHVzaChjP25bb106LW5bb10pLG8rKyk6Yz9zLnlzLnB1c2goMCk6KHMueXMucHVzaChhLnJlYWRTaG9ydChuLG8pKSxvKz0yKTt9dmFyIHA9MCxVPTA7Zm9yKGk9MDtpPGQ7aSsrKXArPXMueHNbaV0sVSs9cy55c1tpXSxzLnhzW2ldPXAscy55c1tpXT1VO31lbHNlIHt2YXIgZztzLnBhcnRzPVtdO2Rve2c9YS5yZWFkVXNob3J0KG4sbyksbys9Mjt2YXIgUz17bTp7YToxLGI6MCxjOjAsZDoxLHR4OjAsdHk6MH0scDE6LTEscDI6LTF9O2lmKHMucGFydHMucHVzaChTKSxTLmdseXBoSW5kZXg9YS5yZWFkVXNob3J0KG4sbyksbys9MiwxJmcpe3ZhciBtPWEucmVhZFNob3J0KG4sbyk7bys9Mjt2YXIgYj1hLnJlYWRTaG9ydChuLG8pO28rPTI7fWVsc2Uge209YS5yZWFkSW50OChuLG8pO28rKztiPWEucmVhZEludDgobixvKTtvKys7fTImZz8oUy5tLnR4PW0sUy5tLnR5PWIpOihTLnAxPW0sUy5wMj1iKSw4Jmc/KFMubS5hPVMubS5kPWEucmVhZEYyZG90MTQobixvKSxvKz0yKTo2NCZnPyhTLm0uYT1hLnJlYWRGMmRvdDE0KG4sbyksbys9MixTLm0uZD1hLnJlYWRGMmRvdDE0KG4sbyksbys9Mik6MTI4JmcmJihTLm0uYT1hLnJlYWRGMmRvdDE0KG4sbyksbys9MixTLm0uYj1hLnJlYWRGMmRvdDE0KG4sbyksbys9MixTLm0uYz1hLnJlYWRGMmRvdDE0KG4sbyksbys9MixTLm0uZD1hLnJlYWRGMmRvdDE0KG4sbyksbys9Mik7fXdoaWxlKDMyJmcpO2lmKDI1NiZnKXt2YXIgeT1hLnJlYWRVc2hvcnQobixvKTtvKz0yLHMuaW5zdHI9W107Zm9yKGk9MDtpPHk7aSsrKXMuaW5zdHIucHVzaChuW29dKSxvKys7fX1yZXR1cm4gc30sZS5HREVGPXt9LGUuR0RFRi5wYXJzZT1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz10O3QrPTQ7dmFyIHM9ZS5fYmluLnJlYWRVc2hvcnQocix0KTtyZXR1cm4ge2dseXBoQ2xhc3NEZWY6MD09PXM/bnVsbDplLl9sY3RmLnJlYWRDbGFzc0RlZihyLG8rcyl9fSxlLkdQT1M9e30sZS5HUE9TLnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe3JldHVybiBlLl9sY3RmLnBhcnNlKHIsdCxhLG4sZS5HUE9TLnN1YnQpfSxlLkdQT1Muc3VidD1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz1lLl9iaW4scz1hLGk9e307aWYoaS5mbXQ9by5yZWFkVXNob3J0KHIsYSksYSs9MiwxPT10fHwyPT10fHwzPT10fHw3PT10fHw4PT10JiZpLmZtdDw9Mil7dmFyIGg9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmNvdmVyYWdlPWUuX2xjdGYucmVhZENvdmVyYWdlKHIsaCtzKTt9aWYoMT09dCYmMT09aS5mbXQpe3ZhciBkPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsMCE9ZCYmKGkucG9zPWUuR1BPUy5yZWFkVmFsdWVSZWNvcmQocixhLGQpKTt9ZWxzZSBpZigyPT10JiZpLmZtdD49MSYmaS5mbXQ8PTIpe2Q9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgZj1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciB1PWUuX2xjdGYubnVtT2ZPbmVzKGQpLGw9ZS5fbGN0Zi5udW1PZk9uZXMoZik7aWYoMT09aS5mbXQpe2kucGFpcnNldHM9W107dmFyIHY9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjtmb3IodmFyIGM9MDtjPHY7YysrKXt2YXIgcD1zK28ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIFU9by5yZWFkVXNob3J0KHIscCk7cCs9Mjtmb3IodmFyIGc9W10sUz0wO1M8VTtTKyspe3ZhciBtPW8ucmVhZFVzaG9ydChyLHApO3ArPTIsMCE9ZCYmKFA9ZS5HUE9TLnJlYWRWYWx1ZVJlY29yZChyLHAsZCkscCs9Mip1KSwwIT1mJiYoeD1lLkdQT1MucmVhZFZhbHVlUmVjb3JkKHIscCxmKSxwKz0yKmwpLGcucHVzaCh7Z2lkMjptLHZhbDE6UCx2YWwyOnh9KTt9aS5wYWlyc2V0cy5wdXNoKGcpO319aWYoMj09aS5mbXQpe3ZhciBiPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIHk9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgRj1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciBDPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5jbGFzc0RlZjE9ZS5fbGN0Zi5yZWFkQ2xhc3NEZWYocixzK2IpLGkuY2xhc3NEZWYyPWUuX2xjdGYucmVhZENsYXNzRGVmKHIscyt5KSxpLm1hdHJpeD1bXTtmb3IoYz0wO2M8RjtjKyspe3ZhciBfPVtdO2ZvcihTPTA7UzxDO1MrKyl7dmFyIFA9bnVsbCx4PW51bGw7MCE9ZCYmKFA9ZS5HUE9TLnJlYWRWYWx1ZVJlY29yZChyLGEsZCksYSs9Mip1KSwwIT1mJiYoeD1lLkdQT1MucmVhZFZhbHVlUmVjb3JkKHIsYSxmKSxhKz0yKmwpLF8ucHVzaCh7dmFsMTpQLHZhbDI6eH0pO31pLm1hdHJpeC5wdXNoKF8pO319fWVsc2UgaWYoND09dCYmMT09aS5mbXQpaS5tYXJrQ292ZXJhZ2U9ZS5fbGN0Zi5yZWFkQ292ZXJhZ2UocixvLnJlYWRVc2hvcnQocixhKStzKSxpLmJhc2VDb3ZlcmFnZT1lLl9sY3RmLnJlYWRDb3ZlcmFnZShyLG8ucmVhZFVzaG9ydChyLGErMikrcyksaS5tYXJrQ2xhc3NDb3VudD1vLnJlYWRVc2hvcnQocixhKzQpLGkubWFya0FycmF5PWUuR1BPUy5yZWFkTWFya0FycmF5KHIsby5yZWFkVXNob3J0KHIsYSs2KStzKSxpLmJhc2VBcnJheT1lLkdQT1MucmVhZEJhc2VBcnJheShyLG8ucmVhZFVzaG9ydChyLGErOCkrcyxpLm1hcmtDbGFzc0NvdW50KTtlbHNlIGlmKDY9PXQmJjE9PWkuZm10KWkubWFyazFDb3ZlcmFnZT1lLl9sY3RmLnJlYWRDb3ZlcmFnZShyLG8ucmVhZFVzaG9ydChyLGEpK3MpLGkubWFyazJDb3ZlcmFnZT1lLl9sY3RmLnJlYWRDb3ZlcmFnZShyLG8ucmVhZFVzaG9ydChyLGErMikrcyksaS5tYXJrQ2xhc3NDb3VudD1vLnJlYWRVc2hvcnQocixhKzQpLGkubWFyazFBcnJheT1lLkdQT1MucmVhZE1hcmtBcnJheShyLG8ucmVhZFVzaG9ydChyLGErNikrcyksaS5tYXJrMkFycmF5PWUuR1BPUy5yZWFkQmFzZUFycmF5KHIsby5yZWFkVXNob3J0KHIsYSs4KStzLGkubWFya0NsYXNzQ291bnQpO2Vsc2Uge2lmKDk9PXQmJjE9PWkuZm10KXt2YXIgST1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciB3PW8ucmVhZFVpbnQocixhKTtpZihhKz00LDk9PW4ubHR5cGUpbi5sdHlwZT1JO2Vsc2UgaWYobi5sdHlwZSE9SSl0aHJvdyBcImludmFsaWQgZXh0ZW5zaW9uIHN1YnN0aXR1dGlvblwiO3JldHVybiBlLkdQT1Muc3VidChyLG4ubHR5cGUscyt3KX1jb25zb2xlLmRlYnVnKFwidW5zdXBwb3J0ZWQgR1BPUyB0YWJsZSBMb29rdXBUeXBlXCIsdCxcImZvcm1hdFwiLGkuZm10KTt9cmV0dXJuIGl9LGUuR1BPUy5yZWFkVmFsdWVSZWNvcmQ9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPVtdO3JldHVybiBvLnB1c2goMSZhP24ucmVhZFNob3J0KHIsdCk6MCksdCs9MSZhPzI6MCxvLnB1c2goMiZhP24ucmVhZFNob3J0KHIsdCk6MCksdCs9MiZhPzI6MCxvLnB1c2goNCZhP24ucmVhZFNob3J0KHIsdCk6MCksdCs9NCZhPzI6MCxvLnB1c2goOCZhP24ucmVhZFNob3J0KHIsdCk6MCksdCs9OCZhPzI6MCxvfSxlLkdQT1MucmVhZEJhc2VBcnJheT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89W10scz10LGk9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGg9MDtoPGk7aCsrKXtmb3IodmFyIGQ9W10sZj0wO2Y8YTtmKyspZC5wdXNoKGUuR1BPUy5yZWFkQW5jaG9yUmVjb3JkKHIscytuLnJlYWRVc2hvcnQocix0KSkpLHQrPTI7by5wdXNoKGQpO31yZXR1cm4gb30sZS5HUE9TLnJlYWRNYXJrQXJyYXk9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj1bXSxvPXQscz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWUuR1BPUy5yZWFkQW5jaG9yUmVjb3JkKHIsYS5yZWFkVXNob3J0KHIsdCsyKStvKTtoLm1hcmtDbGFzcz1hLnJlYWRVc2hvcnQocix0KSxuLnB1c2goaCksdCs9NDt9cmV0dXJuIG59LGUuR1BPUy5yZWFkQW5jaG9yUmVjb3JkPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e307cmV0dXJuIG4uZm10PWEucmVhZFVzaG9ydChyLHQpLG4ueD1hLnJlYWRTaG9ydChyLHQrMiksbi55PWEucmVhZFNob3J0KHIsdCs0KSxufSxlLkdTVUI9e30sZS5HU1VCLnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe3JldHVybiBlLl9sY3RmLnBhcnNlKHIsdCxhLG4sZS5HU1VCLnN1YnQpfSxlLkdTVUIuc3VidD1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz1lLl9iaW4scz1hLGk9e307aWYoaS5mbXQ9by5yZWFkVXNob3J0KHIsYSksYSs9MiwxIT10JiYyIT10JiY0IT10JiY1IT10JiY2IT10KXJldHVybiBudWxsO2lmKDE9PXR8fDI9PXR8fDQ9PXR8fDU9PXQmJmkuZm10PD0yfHw2PT10JiZpLmZtdDw9Mil7dmFyIGg9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmNvdmVyYWdlPWUuX2xjdGYucmVhZENvdmVyYWdlKHIscytoKTt9aWYoMT09dCYmaS5mbXQ+PTEmJmkuZm10PD0yKXtpZigxPT1pLmZtdClpLmRlbHRhPW8ucmVhZFNob3J0KHIsYSksYSs9MjtlbHNlIGlmKDI9PWkuZm10KXt2YXIgZD1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkubmV3Zz1vLnJlYWRVc2hvcnRzKHIsYSxkKSxhKz0yKmkubmV3Zy5sZW5ndGg7fX1lbHNlIGlmKDI9PXQmJjE9PWkuZm10KXtkPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5zZXFzPVtdO2Zvcih2YXIgZj0wO2Y8ZDtmKyspe3ZhciB1PW8ucmVhZFVzaG9ydChyLGEpK3M7YSs9Mjt2YXIgbD1vLnJlYWRVc2hvcnQocix1KTtpLnNlcXMucHVzaChvLnJlYWRVc2hvcnRzKHIsdSsyLGwpKTt9fWVsc2UgaWYoND09dCl7aS52YWxzPVtdO2Q9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjtmb3IoZj0wO2Y8ZDtmKyspe3ZhciB2PW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS52YWxzLnB1c2goZS5HU1VCLnJlYWRMaWdhdHVyZVNldChyLHMrdikpO319ZWxzZSBpZig1PT10JiYyPT1pLmZtdCl7aWYoMj09aS5mbXQpe3ZhciBjPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5jRGVmPWUuX2xjdGYucmVhZENsYXNzRGVmKHIscytjKSxpLnNjc2V0PVtdO3ZhciBwPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7Zm9yKGY9MDtmPHA7ZisrKXt2YXIgVT1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkuc2NzZXQucHVzaCgwPT1VP251bGw6ZS5HU1VCLnJlYWRTdWJDbGFzc1NldChyLHMrVSkpO319fWVsc2UgaWYoNj09dCYmMz09aS5mbXQpe2lmKDM9PWkuZm10KXtmb3IoZj0wO2Y8MztmKyspe2Q9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjtmb3IodmFyIGc9W10sUz0wO1M8ZDtTKyspZy5wdXNoKGUuX2xjdGYucmVhZENvdmVyYWdlKHIscytvLnJlYWRVc2hvcnQocixhKzIqUykpKTthKz0yKmQsMD09ZiYmKGkuYmFja0N2Zz1nKSwxPT1mJiYoaS5pbnB0Q3ZnPWcpLDI9PWYmJihpLmFoZWRDdmc9Zyk7fWQ9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmxvb2t1cFJlYz1lLkdTVUIucmVhZFN1YnN0TG9va3VwUmVjb3JkcyhyLGEsZCk7fX1lbHNlIHtpZig3PT10JiYxPT1pLmZtdCl7dmFyIG09by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgYj1vLnJlYWRVaW50KHIsYSk7aWYoYSs9NCw5PT1uLmx0eXBlKW4ubHR5cGU9bTtlbHNlIGlmKG4ubHR5cGUhPW0pdGhyb3cgXCJpbnZhbGlkIGV4dGVuc2lvbiBzdWJzdGl0dXRpb25cIjtyZXR1cm4gZS5HU1VCLnN1YnQocixuLmx0eXBlLHMrYil9Y29uc29sZS5kZWJ1ZyhcInVuc3VwcG9ydGVkIEdTVUIgdGFibGUgTG9va3VwVHlwZVwiLHQsXCJmb3JtYXRcIixpLmZtdCk7fXJldHVybiBpfSxlLkdTVUIucmVhZFN1YkNsYXNzU2V0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLnJlYWRVc2hvcnQsbj10LG89W10scz1hKHIsdCk7dCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1hKHIsdCk7dCs9MixvLnB1c2goZS5HU1VCLnJlYWRTdWJDbGFzc1J1bGUocixuK2gpKTt9cmV0dXJuIG99LGUuR1NVQi5yZWFkU3ViQ2xhc3NSdWxlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLnJlYWRVc2hvcnQsbj17fSxvPWEocix0KSxzPWEocix0Kz0yKTt0Kz0yLG4uaW5wdXQ9W107Zm9yKHZhciBpPTA7aTxvLTE7aSsrKW4uaW5wdXQucHVzaChhKHIsdCkpLHQrPTI7cmV0dXJuIG4uc3Vic3RMb29rdXBSZWNvcmRzPWUuR1NVQi5yZWFkU3Vic3RMb29rdXBSZWNvcmRzKHIsdCxzKSxufSxlLkdTVUIucmVhZFN1YnN0TG9va3VwUmVjb3Jkcz1mdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPWUuX2Jpbi5yZWFkVXNob3J0LG89W10scz0wO3M8YTtzKyspby5wdXNoKG4ocix0KSxuKHIsdCsyKSksdCs9NDtyZXR1cm4gb30sZS5HU1VCLnJlYWRDaGFpblN1YkNsYXNzU2V0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPVtdLHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG8ucHVzaChlLkdTVUIucmVhZENoYWluU3ViQ2xhc3NSdWxlKHIsbitoKSk7fXJldHVybiBvfSxlLkdTVUIucmVhZENoYWluU3ViQ2xhc3NSdWxlPWZ1bmN0aW9uKHIsdCl7Zm9yKHZhciBhPWUuX2JpbixuPXt9LG89W1wiYmFja3RyYWNrXCIsXCJpbnB1dFwiLFwibG9va2FoZWFkXCJdLHM9MDtzPG8ubGVuZ3RoO3MrKyl7dmFyIGk9YS5yZWFkVXNob3J0KHIsdCk7dCs9MiwxPT1zJiZpLS0sbltvW3NdXT1hLnJlYWRVc2hvcnRzKHIsdCxpKSx0Kz0yKm5bb1tzXV0ubGVuZ3RoO31pPWEucmVhZFVzaG9ydChyLHQpO3JldHVybiB0Kz0yLG4uc3Vic3Q9YS5yZWFkVXNob3J0cyhyLHQsMippKSx0Kz0yKm4uc3Vic3QubGVuZ3RoLG59LGUuR1NVQi5yZWFkTGlnYXR1cmVTZXQ9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89W10scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsby5wdXNoKGUuR1NVQi5yZWFkTGlnYXR1cmUocixuK2gpKTt9cmV0dXJuIG99LGUuR1NVQi5yZWFkTGlnYXR1cmU9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj17Y2hhaW46W119O24ubmdseXBoPWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIHM9MDtzPG8tMTtzKyspbi5jaGFpbi5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yO3JldHVybiBufSxlLmhlYWQ9e30sZS5oZWFkLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz17fTtyZXR1cm4gbi5yZWFkRml4ZWQocix0KSx0Kz00LG8uZm9udFJldmlzaW9uPW4ucmVhZEZpeGVkKHIsdCksdCs9NCxuLnJlYWRVaW50KHIsdCksdCs9NCxuLnJlYWRVaW50KHIsdCksdCs9NCxvLmZsYWdzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby51bml0c1BlckVtPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5jcmVhdGVkPW4ucmVhZFVpbnQ2NChyLHQpLHQrPTgsby5tb2RpZmllZD1uLnJlYWRVaW50NjQocix0KSx0Kz04LG8ueE1pbj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby55TWluPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLnhNYXg9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ueU1heD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5tYWNTdHlsZT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubG93ZXN0UmVjUFBFTT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8uZm9udERpcmVjdGlvbkhpbnQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uaW5kZXhUb0xvY0Zvcm1hdD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5nbHlwaERhdGFGb3JtYXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG99LGUuaGhlYT17fSxlLmhoZWEucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXt9O3JldHVybiBuLnJlYWRGaXhlZChyLHQpLHQrPTQsby5hc2NlbmRlcj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5kZXNjZW5kZXI9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ubGluZUdhcD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5hZHZhbmNlV2lkdGhNYXg9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1pbkxlZnRTaWRlQmVhcmluZz1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5taW5SaWdodFNpZGVCZWFyaW5nPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLnhNYXhFeHRlbnQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uY2FyZXRTbG9wZVJpc2U9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uY2FyZXRTbG9wZVJ1bj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5jYXJldE9mZnNldD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsdCs9OCxvLm1ldHJpY0RhdGFGb3JtYXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ubnVtYmVyT2ZITWV0cmljcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG99LGUuaG10eD17fSxlLmhtdHgucGFyc2U9ZnVuY3Rpb24ocix0LGEsbil7Zm9yKHZhciBvPWUuX2JpbixzPXthV2lkdGg6W10sbHNCZWFyaW5nOltdfSxpPTAsaD0wLGQ9MDtkPG4ubWF4cC5udW1HbHlwaHM7ZCsrKWQ8bi5oaGVhLm51bWJlck9mSE1ldHJpY3MmJihpPW8ucmVhZFVzaG9ydChyLHQpLHQrPTIsaD1vLnJlYWRTaG9ydChyLHQpLHQrPTIpLHMuYVdpZHRoLnB1c2goaSkscy5sc0JlYXJpbmcucHVzaChoKTtyZXR1cm4gc30sZS5rZXJuPXt9LGUua2Vybi5wYXJzZT1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz1lLl9iaW4scz1vLnJlYWRVc2hvcnQocix0KTtpZih0Kz0yLDE9PXMpcmV0dXJuIGUua2Vybi5wYXJzZVYxKHIsdC0yLGEsbik7dmFyIGk9by5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGg9e2dseXBoMTpbXSxydmFsOltdfSxkPTA7ZDxpO2QrKyl7dCs9MjthPW8ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGY9by5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgdT1mPj4+ODtpZigwIT0odSY9MTUpKXRocm93IFwidW5rbm93biBrZXJuIHRhYmxlIGZvcm1hdDogXCIrdTt0PWUua2Vybi5yZWFkRm9ybWF0MChyLHQsaCk7fXJldHVybiBofSxlLmtlcm4ucGFyc2VWMT1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz1lLl9iaW47by5yZWFkRml4ZWQocix0KSx0Kz00O3ZhciBzPW8ucmVhZFVpbnQocix0KTt0Kz00O2Zvcih2YXIgaT17Z2x5cGgxOltdLHJ2YWw6W119LGg9MDtoPHM7aCsrKXtvLnJlYWRVaW50KHIsdCksdCs9NDt2YXIgZD1vLnJlYWRVc2hvcnQocix0KTt0Kz0yLG8ucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIGY9ZD4+Pjg7aWYoMCE9KGYmPTE1KSl0aHJvdyBcInVua25vd24ga2VybiB0YWJsZSBmb3JtYXQ6IFwiK2Y7dD1lLmtlcm4ucmVhZEZvcm1hdDAocix0LGkpO31yZXR1cm4gaX0sZS5rZXJuLnJlYWRGb3JtYXQwPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz0tMSxzPW4ucmVhZFVzaG9ydChyLHQpO3QrPTIsbi5yZWFkVXNob3J0KHIsdCksdCs9MixuLnJlYWRVc2hvcnQocix0KSx0Kz0yLG4ucmVhZFVzaG9ydChyLHQpLHQrPTI7Zm9yKHZhciBpPTA7aTxzO2krKyl7dmFyIGg9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBmPW4ucmVhZFNob3J0KHIsdCk7dCs9MixoIT1vJiYoYS5nbHlwaDEucHVzaChoKSxhLnJ2YWwucHVzaCh7Z2x5cGgyOltdLHZhbHM6W119KSk7dmFyIHU9YS5ydmFsW2EucnZhbC5sZW5ndGgtMV07dS5nbHlwaDIucHVzaChkKSx1LnZhbHMucHVzaChmKSxvPWg7fXJldHVybiB0fSxlLmxvY2E9e30sZS5sb2NhLnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPWUuX2JpbixzPVtdLGk9bi5oZWFkLmluZGV4VG9Mb2NGb3JtYXQsaD1uLm1heHAubnVtR2x5cGhzKzE7aWYoMD09aSlmb3IodmFyIGQ9MDtkPGg7ZCsrKXMucHVzaChvLnJlYWRVc2hvcnQocix0KyhkPDwxKSk8PDEpO2lmKDE9PWkpZm9yKGQ9MDtkPGg7ZCsrKXMucHVzaChvLnJlYWRVaW50KHIsdCsoZDw8MikpKTtyZXR1cm4gc30sZS5tYXhwPXt9LGUubWF4cC5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89e30scz1uLnJlYWRVaW50KHIsdCk7cmV0dXJuIHQrPTQsby5udW1HbHlwaHM9bi5yZWFkVXNob3J0KHIsdCksdCs9Miw2NTUzNj09cyYmKG8ubWF4UG9pbnRzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhDb250b3Vycz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4Q29tcG9zaXRlUG9pbnRzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhDb21wb3NpdGVDb250b3Vycz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4Wm9uZXM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heFR3aWxpZ2h0UG9pbnRzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhTdG9yYWdlPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhGdW5jdGlvbkRlZnM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heEluc3RydWN0aW9uRGVmcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4U3RhY2tFbGVtZW50cz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4U2l6ZU9mSW5zdHJ1Y3Rpb25zPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhDb21wb25lbnRFbGVtZW50cz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4Q29tcG9uZW50RGVwdGg9bi5yZWFkVXNob3J0KHIsdCksdCs9Miksb30sZS5uYW1lPXt9LGUubmFtZS5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89e307bi5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgcz1uLnJlYWRVc2hvcnQocix0KTt0Kz0yLG4ucmVhZFVzaG9ydChyLHQpO2Zvcih2YXIgaSxoPVtcImNvcHlyaWdodFwiLFwiZm9udEZhbWlseVwiLFwiZm9udFN1YmZhbWlseVwiLFwiSURcIixcImZ1bGxOYW1lXCIsXCJ2ZXJzaW9uXCIsXCJwb3N0U2NyaXB0TmFtZVwiLFwidHJhZGVtYXJrXCIsXCJtYW51ZmFjdHVyZXJcIixcImRlc2lnbmVyXCIsXCJkZXNjcmlwdGlvblwiLFwidXJsVmVuZG9yXCIsXCJ1cmxEZXNpZ25lclwiLFwibGljZW5jZVwiLFwibGljZW5jZVVSTFwiLFwiLS0tXCIsXCJ0eXBvRmFtaWx5TmFtZVwiLFwidHlwb1N1YmZhbWlseU5hbWVcIixcImNvbXBhdGlibGVGdWxsXCIsXCJzYW1wbGVUZXh0XCIsXCJwb3N0U2NyaXB0Q0lEXCIsXCJ3d3NGYW1pbHlOYW1lXCIsXCJ3d3NTdWJmYW1pbHlOYW1lXCIsXCJsaWdodFBhbGV0dGVcIixcImRhcmtQYWxldHRlXCJdLGQ9dCs9MixmPTA7ZjxzO2YrKyl7dmFyIHU9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgbD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciB2PW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGM9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgcD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBVPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGcsUz1oW2NdLG09ZCsxMipzK1U7aWYoMD09dSlnPW4ucmVhZFVuaWNvZGUocixtLHAvMik7ZWxzZSBpZigzPT11JiYwPT1sKWc9bi5yZWFkVW5pY29kZShyLG0scC8yKTtlbHNlIGlmKDA9PWwpZz1uLnJlYWRBU0NJSShyLG0scCk7ZWxzZSBpZigxPT1sKWc9bi5yZWFkVW5pY29kZShyLG0scC8yKTtlbHNlIGlmKDM9PWwpZz1uLnJlYWRVbmljb2RlKHIsbSxwLzIpO2Vsc2Uge2lmKDEhPXUpdGhyb3cgXCJ1bmtub3duIGVuY29kaW5nIFwiK2wrXCIsIHBsYXRmb3JtSUQ6IFwiK3U7Zz1uLnJlYWRBU0NJSShyLG0scCksY29uc29sZS5kZWJ1ZyhcInJlYWRpbmcgdW5rbm93biBNQUMgZW5jb2RpbmcgXCIrbCtcIiBhcyBBU0NJSVwiKTt9dmFyIGI9XCJwXCIrdStcIixcIit2LnRvU3RyaW5nKDE2KTtudWxsPT1vW2JdJiYob1tiXT17fSksb1tiXVt2b2lkIDAhPT1TP1M6Y109ZyxvW2JdLl9sYW5nPXY7fWZvcih2YXIgeSBpbiBvKWlmKG51bGwhPW9beV0ucG9zdFNjcmlwdE5hbWUmJjEwMzM9PW9beV0uX2xhbmcpcmV0dXJuIG9beV07Zm9yKHZhciB5IGluIG8paWYobnVsbCE9b1t5XS5wb3N0U2NyaXB0TmFtZSYmMD09b1t5XS5fbGFuZylyZXR1cm4gb1t5XTtmb3IodmFyIHkgaW4gbylpZihudWxsIT1vW3ldLnBvc3RTY3JpcHROYW1lJiYzMDg0PT1vW3ldLl9sYW5nKXJldHVybiBvW3ldO2Zvcih2YXIgeSBpbiBvKWlmKG51bGwhPW9beV0ucG9zdFNjcmlwdE5hbWUpcmV0dXJuIG9beV07Zm9yKHZhciB5IGluIG8pe2k9eTticmVha31yZXR1cm4gY29uc29sZS5kZWJ1ZyhcInJldHVybmluZyBuYW1lIHRhYmxlIHdpdGggbGFuZ3VhZ2VJRCBcIitvW2ldLl9sYW5nKSxvW2ldfSxlW1wiT1MvMlwiXT17fSxlW1wiT1MvMlwiXS5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBvPXt9O2lmKDA9PW4pZVtcIk9TLzJcIl0udmVyc2lvbjAocix0LG8pO2Vsc2UgaWYoMT09billW1wiT1MvMlwiXS52ZXJzaW9uMShyLHQsbyk7ZWxzZSBpZigyPT1ufHwzPT1ufHw0PT1uKWVbXCJPUy8yXCJdLnZlcnNpb24yKHIsdCxvKTtlbHNlIHtpZig1IT1uKXRocm93IFwidW5rbm93biBPUy8yIHRhYmxlIHZlcnNpb246IFwiK247ZVtcIk9TLzJcIl0udmVyc2lvbjUocix0LG8pO31yZXR1cm4gb30sZVtcIk9TLzJcIl0udmVyc2lvbjA9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbjtyZXR1cm4gYS54QXZnQ2hhcldpZHRoPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnVzV2VpZ2h0Q2xhc3M9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzV2lkdGhDbGFzcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEuZnNUeXBlPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS55U3Vic2NyaXB0WFNpemU9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1YnNjcmlwdFlTaXplPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdWJzY3JpcHRYT2Zmc2V0PW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdWJzY3JpcHRZT2Zmc2V0PW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdXBlcnNjcmlwdFhTaXplPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdXBlcnNjcmlwdFlTaXplPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdXBlcnNjcmlwdFhPZmZzZXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1cGVyc2NyaXB0WU9mZnNldD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3RyaWtlb3V0U2l6ZT1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3RyaWtlb3V0UG9zaXRpb249bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEuc0ZhbWlseUNsYXNzPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnBhbm9zZT1uLnJlYWRCeXRlcyhyLHQsMTApLHQrPTEwLGEudWxVbmljb2RlUmFuZ2UxPW4ucmVhZFVpbnQocix0KSx0Kz00LGEudWxVbmljb2RlUmFuZ2UyPW4ucmVhZFVpbnQocix0KSx0Kz00LGEudWxVbmljb2RlUmFuZ2UzPW4ucmVhZFVpbnQocix0KSx0Kz00LGEudWxVbmljb2RlUmFuZ2U0PW4ucmVhZFVpbnQocix0KSx0Kz00LGEuYWNoVmVuZElEPVtuLnJlYWRJbnQ4KHIsdCksbi5yZWFkSW50OChyLHQrMSksbi5yZWFkSW50OChyLHQrMiksbi5yZWFkSW50OChyLHQrMyldLHQrPTQsYS5mc1NlbGVjdGlvbj1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNGaXJzdENoYXJJbmRleD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNMYXN0Q2hhckluZGV4PW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS5zVHlwb0FzY2VuZGVyPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnNUeXBvRGVzY2VuZGVyPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnNUeXBvTGluZUdhcD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS51c1dpbkFzY2VudD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNXaW5EZXNjZW50PW4ucmVhZFVzaG9ydChyLHQpLHQrPTJ9LGVbXCJPUy8yXCJdLnZlcnNpb24xPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW47cmV0dXJuIHQ9ZVtcIk9TLzJcIl0udmVyc2lvbjAocix0LGEpLGEudWxDb2RlUGFnZVJhbmdlMT1uLnJlYWRVaW50KHIsdCksdCs9NCxhLnVsQ29kZVBhZ2VSYW5nZTI9bi5yZWFkVWludChyLHQpLHQrPTR9LGVbXCJPUy8yXCJdLnZlcnNpb24yPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW47cmV0dXJuIHQ9ZVtcIk9TLzJcIl0udmVyc2lvbjEocix0LGEpLGEuc3hIZWlnaHQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEuc0NhcEhlaWdodD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS51c0RlZmF1bHQ9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzQnJlYWs9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzTWF4Q29udGV4dD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yfSxlW1wiT1MvMlwiXS52ZXJzaW9uNT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluO3JldHVybiB0PWVbXCJPUy8yXCJdLnZlcnNpb24yKHIsdCxhKSxhLnVzTG93ZXJPcHRpY2FsUG9pbnRTaXplPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c1VwcGVyT3B0aWNhbFBvaW50U2l6ZT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yfSxlLnBvc3Q9e30sZS5wb3N0LnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz17fTtyZXR1cm4gby52ZXJzaW9uPW4ucmVhZEZpeGVkKHIsdCksdCs9NCxvLml0YWxpY0FuZ2xlPW4ucmVhZEZpeGVkKHIsdCksdCs9NCxvLnVuZGVybGluZVBvc2l0aW9uPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLnVuZGVybGluZVRoaWNrbmVzcz1uLnJlYWRTaG9ydChyLHQpLHQrPTIsb30sbnVsbD09ZSYmKGU9e30pLG51bGw9PWUuVSYmKGUuVT17fSksZS5VLmNvZGVUb0dseXBoPWZ1bmN0aW9uKHIsZSl7dmFyIHQ9ci5jbWFwLGE9LTE7aWYobnVsbCE9dC5wMGU0P2E9dC5wMGU0Om51bGwhPXQucDNlMT9hPXQucDNlMTpudWxsIT10LnAxZTA/YT10LnAxZTA6bnVsbCE9dC5wMGUzJiYoYT10LnAwZTMpLC0xPT1hKXRocm93IFwibm8gZmFtaWxpYXIgcGxhdGZvcm0gYW5kIGVuY29kaW5nIVwiO3ZhciBuPXQudGFibGVzW2FdO2lmKDA9PW4uZm9ybWF0KXJldHVybiBlPj1uLm1hcC5sZW5ndGg/MDpuLm1hcFtlXTtpZig0PT1uLmZvcm1hdCl7Zm9yKHZhciBvPS0xLHM9MDtzPG4uZW5kQ291bnQubGVuZ3RoO3MrKylpZihlPD1uLmVuZENvdW50W3NdKXtvPXM7YnJlYWt9aWYoLTE9PW8pcmV0dXJuIDA7aWYobi5zdGFydENvdW50W29dPmUpcmV0dXJuIDA7cmV0dXJuIDY1NTM1JigwIT1uLmlkUmFuZ2VPZmZzZXRbb10/bi5nbHlwaElkQXJyYXlbZS1uLnN0YXJ0Q291bnRbb10rKG4uaWRSYW5nZU9mZnNldFtvXT4+MSktKG4uaWRSYW5nZU9mZnNldC5sZW5ndGgtbyldOmUrbi5pZERlbHRhW29dKX1pZigxMj09bi5mb3JtYXQpe2lmKGU+bi5ncm91cHNbbi5ncm91cHMubGVuZ3RoLTFdWzFdKXJldHVybiAwO2ZvcihzPTA7czxuLmdyb3Vwcy5sZW5ndGg7cysrKXt2YXIgaT1uLmdyb3Vwc1tzXTtpZihpWzBdPD1lJiZlPD1pWzFdKXJldHVybiBpWzJdKyhlLWlbMF0pfXJldHVybiAwfXRocm93IFwidW5rbm93biBjbWFwIHRhYmxlIGZvcm1hdCBcIituLmZvcm1hdH0sZS5VLmdseXBoVG9QYXRoPWZ1bmN0aW9uKHIsdCl7dmFyIGE9e2NtZHM6W10sY3JkczpbXX07aWYoci5TVkcmJnIuU1ZHLmVudHJpZXNbdF0pe3ZhciBuPXIuU1ZHLmVudHJpZXNbdF07cmV0dXJuIG51bGw9PW4/YTooXCJzdHJpbmdcIj09dHlwZW9mIG4mJihuPWUuU1ZHLnRvUGF0aChuKSxyLlNWRy5lbnRyaWVzW3RdPW4pLG4pfWlmKHIuQ0ZGKXt2YXIgbz17eDowLHk6MCxzdGFjazpbXSxuU3RlbXM6MCxoYXZlV2lkdGg6ITEsd2lkdGg6ci5DRkYuUHJpdmF0ZT9yLkNGRi5Qcml2YXRlLmRlZmF1bHRXaWR0aFg6MCxvcGVuOiExfSxzPXIuQ0ZGLGk9ci5DRkYuUHJpdmF0ZTtpZihzLlJPUyl7Zm9yKHZhciBoPTA7cy5GRFNlbGVjdFtoKzJdPD10OyloKz0yO2k9cy5GREFycmF5W3MuRkRTZWxlY3RbaCsxXV0uUHJpdmF0ZTt9ZS5VLl9kcmF3Q0ZGKHIuQ0ZGLkNoYXJTdHJpbmdzW3RdLG8scyxpLGEpO31lbHNlIHIuZ2x5ZiYmZS5VLl9kcmF3R2x5Zih0LHIsYSk7cmV0dXJuIGF9LGUuVS5fZHJhd0dseWY9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPXQuZ2x5ZltyXTtudWxsPT1uJiYobj10LmdseWZbcl09ZS5nbHlmLl9wYXJzZUdseWYodCxyKSksbnVsbCE9biYmKG4ubm9jPi0xP2UuVS5fc2ltcGxlR2x5cGgobixhKTplLlUuX2NvbXBvR2x5cGgobix0LGEpKTt9LGUuVS5fc2ltcGxlR2x5cGg9ZnVuY3Rpb24ocix0KXtmb3IodmFyIGE9MDthPHIubm9jO2ErKyl7Zm9yKHZhciBuPTA9PWE/MDpyLmVuZFB0c1thLTFdKzEsbz1yLmVuZFB0c1thXSxzPW47czw9bztzKyspe3ZhciBpPXM9PW4/bzpzLTEsaD1zPT1vP246cysxLGQ9MSZyLmZsYWdzW3NdLGY9MSZyLmZsYWdzW2ldLHU9MSZyLmZsYWdzW2hdLGw9ci54c1tzXSx2PXIueXNbc107aWYocz09bilpZihkKXtpZighZil7ZS5VLlAubW92ZVRvKHQsbCx2KTtjb250aW51ZX1lLlUuUC5tb3ZlVG8odCxyLnhzW2ldLHIueXNbaV0pO31lbHNlIGY/ZS5VLlAubW92ZVRvKHQsci54c1tpXSxyLnlzW2ldKTplLlUuUC5tb3ZlVG8odCwoci54c1tpXStsKS8yLChyLnlzW2ldK3YpLzIpO2Q/ZiYmZS5VLlAubGluZVRvKHQsbCx2KTp1P2UuVS5QLnFjdXJ2ZVRvKHQsbCx2LHIueHNbaF0sci55c1toXSk6ZS5VLlAucWN1cnZlVG8odCxsLHYsKGwrci54c1toXSkvMiwodityLnlzW2hdKS8yKTt9ZS5VLlAuY2xvc2VQYXRoKHQpO319LGUuVS5fY29tcG9HbHlwaD1mdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPTA7bjxyLnBhcnRzLmxlbmd0aDtuKyspe3ZhciBvPXtjbWRzOltdLGNyZHM6W119LHM9ci5wYXJ0c1tuXTtlLlUuX2RyYXdHbHlmKHMuZ2x5cGhJbmRleCx0LG8pO2Zvcih2YXIgaT1zLm0saD0wO2g8by5jcmRzLmxlbmd0aDtoKz0yKXt2YXIgZD1vLmNyZHNbaF0sZj1vLmNyZHNbaCsxXTthLmNyZHMucHVzaChkKmkuYStmKmkuYitpLnR4KSxhLmNyZHMucHVzaChkKmkuYytmKmkuZCtpLnR5KTt9Zm9yKGg9MDtoPG8uY21kcy5sZW5ndGg7aCsrKWEuY21kcy5wdXNoKG8uY21kc1toXSk7fX0sZS5VLl9nZXRHbHlwaENsYXNzPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fbGN0Zi5nZXRJbnRlcnZhbCh0LHIpO3JldHVybiAtMT09YT8wOnRbYSsyXX0sZS5VLl9hcHBseVN1YnM9ZnVuY3Rpb24ocix0LGEsbil7Zm9yKHZhciBvPXIubGVuZ3RoLXQtMSxzPTA7czxhLnRhYnMubGVuZ3RoO3MrKylpZihudWxsIT1hLnRhYnNbc10pe3ZhciBpLGg9YS50YWJzW3NdO2lmKCFoLmNvdmVyYWdlfHwtMSE9KGk9ZS5fbGN0Zi5jb3ZlcmFnZUluZGV4KGguY292ZXJhZ2Usclt0XSkpKWlmKDE9PWEubHR5cGUpclt0XSwxPT1oLmZtdD9yW3RdPXJbdF0raC5kZWx0YTpyW3RdPWgubmV3Z1tpXTtlbHNlIGlmKDQ9PWEubHR5cGUpZm9yKHZhciBkPWgudmFsc1tpXSxmPTA7ZjxkLmxlbmd0aDtmKyspe3ZhciB1PWRbZl0sbD11LmNoYWluLmxlbmd0aDtpZighKGw+bykpe2Zvcih2YXIgdj0hMCxjPTAscD0wO3A8bDtwKyspe2Zvcig7LTE9PXJbdCtjKygxK3ApXTspYysrO3UuY2hhaW5bcF0hPXJbdCtjKygxK3ApXSYmKHY9ITEpO31pZih2KXtyW3RdPXUubmdseXBoO2ZvcihwPTA7cDxsK2M7cCsrKXJbdCtwKzFdPS0xO2JyZWFrfX19ZWxzZSBpZig1PT1hLmx0eXBlJiYyPT1oLmZtdClmb3IodmFyIFU9ZS5fbGN0Zi5nZXRJbnRlcnZhbChoLmNEZWYsclt0XSksZz1oLmNEZWZbVSsyXSxTPWguc2NzZXRbZ10sbT0wO208Uy5sZW5ndGg7bSsrKXt2YXIgYj1TW21dLHk9Yi5pbnB1dDtpZighKHkubGVuZ3RoPm8pKXtmb3Iodj0hMCxwPTA7cDx5Lmxlbmd0aDtwKyspe3ZhciBGPWUuX2xjdGYuZ2V0SW50ZXJ2YWwoaC5jRGVmLHJbdCsxK3BdKTtpZigtMT09VSYmaC5jRGVmW0YrMl0hPXlbcF0pe3Y9ITE7YnJlYWt9fWlmKHYpe3ZhciBDPWIuc3Vic3RMb29rdXBSZWNvcmRzO2ZvcihmPTA7ZjxDLmxlbmd0aDtmKz0yKUNbZl0sQ1tmKzFdO319fWVsc2UgaWYoNj09YS5sdHlwZSYmMz09aC5mbXQpe2lmKCFlLlUuX2dsc0NvdmVyZWQocixoLmJhY2tDdmcsdC1oLmJhY2tDdmcubGVuZ3RoKSljb250aW51ZTtpZighZS5VLl9nbHNDb3ZlcmVkKHIsaC5pbnB0Q3ZnLHQpKWNvbnRpbnVlO2lmKCFlLlUuX2dsc0NvdmVyZWQocixoLmFoZWRDdmcsdCtoLmlucHRDdmcubGVuZ3RoKSljb250aW51ZTt2YXIgXz1oLmxvb2t1cFJlYztmb3IobT0wO208Xy5sZW5ndGg7bSs9Mil7VT1fW21dO3ZhciBQPW5bX1ttKzFdXTtlLlUuX2FwcGx5U3VicyhyLHQrVSxQLG4pO319fX0sZS5VLl9nbHNDb3ZlcmVkPWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7aWYoLTE9PWUuX2xjdGYuY292ZXJhZ2VJbmRleCh0W25dLHJbYStuXSkpcmV0dXJuICExfXJldHVybiAhMH0sZS5VLmdseXBoc1RvUGF0aD1mdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPXtjbWRzOltdLGNyZHM6W119LG89MCxzPTA7czx0Lmxlbmd0aDtzKyspe3ZhciBpPXRbc107aWYoLTEhPWkpe2Zvcih2YXIgaD1zPHQubGVuZ3RoLTEmJi0xIT10W3MrMV0/dFtzKzFdOjAsZD1lLlUuZ2x5cGhUb1BhdGgocixpKSxmPTA7ZjxkLmNyZHMubGVuZ3RoO2YrPTIpbi5jcmRzLnB1c2goZC5jcmRzW2ZdK28pLG4uY3Jkcy5wdXNoKGQuY3Jkc1tmKzFdKTthJiZuLmNtZHMucHVzaChhKTtmb3IoZj0wO2Y8ZC5jbWRzLmxlbmd0aDtmKyspbi5jbWRzLnB1c2goZC5jbWRzW2ZdKTthJiZuLmNtZHMucHVzaChcIlhcIiksbys9ci5obXR4LmFXaWR0aFtpXSxzPHQubGVuZ3RoLTEmJihvKz1lLlUuZ2V0UGFpckFkanVzdG1lbnQocixpLGgpKTt9fXJldHVybiBufSxlLlUuUD17fSxlLlUuUC5tb3ZlVG89ZnVuY3Rpb24ocixlLHQpe3IuY21kcy5wdXNoKFwiTVwiKSxyLmNyZHMucHVzaChlLHQpO30sZS5VLlAubGluZVRvPWZ1bmN0aW9uKHIsZSx0KXtyLmNtZHMucHVzaChcIkxcIiksci5jcmRzLnB1c2goZSx0KTt9LGUuVS5QLmN1cnZlVG89ZnVuY3Rpb24ocixlLHQsYSxuLG8scyl7ci5jbWRzLnB1c2goXCJDXCIpLHIuY3Jkcy5wdXNoKGUsdCxhLG4sbyxzKTt9LGUuVS5QLnFjdXJ2ZVRvPWZ1bmN0aW9uKHIsZSx0LGEsbil7ci5jbWRzLnB1c2goXCJRXCIpLHIuY3Jkcy5wdXNoKGUsdCxhLG4pO30sZS5VLlAuY2xvc2VQYXRoPWZ1bmN0aW9uKHIpe3IuY21kcy5wdXNoKFwiWlwiKTt9LGUuVS5fZHJhd0NGRj1mdW5jdGlvbihyLHQsYSxuLG8pe2Zvcih2YXIgcz10LnN0YWNrLGk9dC5uU3RlbXMsaD10LmhhdmVXaWR0aCxkPXQud2lkdGgsZj10Lm9wZW4sdT0wLGw9dC54LHY9dC55LGM9MCxwPTAsVT0wLGc9MCxTPTAsbT0wLGI9MCx5PTAsRj0wLEM9MCxfPXt2YWw6MCxzaXplOjB9O3U8ci5sZW5ndGg7KXtlLkNGRi5nZXRDaGFyU3RyaW5nKHIsdSxfKTt2YXIgUD1fLnZhbDtpZih1Kz1fLnNpemUsXCJvMVwiPT1QfHxcIm8xOFwiPT1QKXMubGVuZ3RoJTIhPTAmJiFoJiYoZD1zLnNoaWZ0KCkrbi5ub21pbmFsV2lkdGhYKSxpKz1zLmxlbmd0aD4+MSxzLmxlbmd0aD0wLGg9ITA7ZWxzZSBpZihcIm8zXCI9PVB8fFwibzIzXCI9PVApe3MubGVuZ3RoJTIhPTAmJiFoJiYoZD1zLnNoaWZ0KCkrbi5ub21pbmFsV2lkdGhYKSxpKz1zLmxlbmd0aD4+MSxzLmxlbmd0aD0wLGg9ITA7fWVsc2UgaWYoXCJvNFwiPT1QKXMubGVuZ3RoPjEmJiFoJiYoZD1zLnNoaWZ0KCkrbi5ub21pbmFsV2lkdGhYLGg9ITApLGYmJmUuVS5QLmNsb3NlUGF0aChvKSx2Kz1zLnBvcCgpLGUuVS5QLm1vdmVUbyhvLGwsdiksZj0hMDtlbHNlIGlmKFwibzVcIj09UClmb3IoO3MubGVuZ3RoPjA7KWwrPXMuc2hpZnQoKSx2Kz1zLnNoaWZ0KCksZS5VLlAubGluZVRvKG8sbCx2KTtlbHNlIGlmKFwibzZcIj09UHx8XCJvN1wiPT1QKWZvcih2YXIgeD1zLmxlbmd0aCxJPVwibzZcIj09UCx3PTA7dzx4O3crKyl7dmFyIGs9cy5zaGlmdCgpO0k/bCs9azp2Kz1rLEk9IUksZS5VLlAubGluZVRvKG8sbCx2KTt9ZWxzZSBpZihcIm84XCI9PVB8fFwibzI0XCI9PVApe3g9cy5sZW5ndGg7Zm9yKHZhciBHPTA7Rys2PD14OyljPWwrcy5zaGlmdCgpLHA9ditzLnNoaWZ0KCksVT1jK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLGw9VStzLnNoaWZ0KCksdj1nK3Muc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxsLHYpLEcrPTY7XCJvMjRcIj09UCYmKGwrPXMuc2hpZnQoKSx2Kz1zLnNoaWZ0KCksZS5VLlAubGluZVRvKG8sbCx2KSk7fWVsc2Uge2lmKFwibzExXCI9PVApYnJlYWs7aWYoXCJvMTIzNFwiPT1QfHxcIm8xMjM1XCI9PVB8fFwibzEyMzZcIj09UHx8XCJvMTIzN1wiPT1QKVwibzEyMzRcIj09UCYmKHA9dixVPShjPWwrcy5zaGlmdCgpKStzLnNoaWZ0KCksQz1nPXArcy5zaGlmdCgpLG09Zyx5PXYsbD0oYj0oUz0oRj1VK3Muc2hpZnQoKSkrcy5zaGlmdCgpKStzLnNoaWZ0KCkpK3Muc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxGLEMpLGUuVS5QLmN1cnZlVG8obyxTLG0sYix5LGwsdikpLFwibzEyMzVcIj09UCYmKGM9bCtzLnNoaWZ0KCkscD12K3Muc2hpZnQoKSxVPWMrcy5zaGlmdCgpLGc9cCtzLnNoaWZ0KCksRj1VK3Muc2hpZnQoKSxDPWcrcy5zaGlmdCgpLFM9RitzLnNoaWZ0KCksbT1DK3Muc2hpZnQoKSxiPVMrcy5zaGlmdCgpLHk9bStzLnNoaWZ0KCksbD1iK3Muc2hpZnQoKSx2PXkrcy5zaGlmdCgpLHMuc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxGLEMpLGUuVS5QLmN1cnZlVG8obyxTLG0sYix5LGwsdikpLFwibzEyMzZcIj09UCYmKGM9bCtzLnNoaWZ0KCkscD12K3Muc2hpZnQoKSxVPWMrcy5zaGlmdCgpLEM9Zz1wK3Muc2hpZnQoKSxtPWcsYj0oUz0oRj1VK3Muc2hpZnQoKSkrcy5zaGlmdCgpKStzLnNoaWZ0KCkseT1tK3Muc2hpZnQoKSxsPWIrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLEYsQyksZS5VLlAuY3VydmVUbyhvLFMsbSxiLHksbCx2KSksXCJvMTIzN1wiPT1QJiYoYz1sK3Muc2hpZnQoKSxwPXYrcy5zaGlmdCgpLFU9YytzLnNoaWZ0KCksZz1wK3Muc2hpZnQoKSxGPVUrcy5zaGlmdCgpLEM9ZytzLnNoaWZ0KCksUz1GK3Muc2hpZnQoKSxtPUMrcy5zaGlmdCgpLGI9UytzLnNoaWZ0KCkseT1tK3Muc2hpZnQoKSxNYXRoLmFicyhiLWwpPk1hdGguYWJzKHktdik/bD1iK3Muc2hpZnQoKTp2PXkrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLEYsQyksZS5VLlAuY3VydmVUbyhvLFMsbSxiLHksbCx2KSk7ZWxzZSBpZihcIm8xNFwiPT1QKXtpZihzLmxlbmd0aD4wJiYhaCYmKGQ9cy5zaGlmdCgpK2Eubm9taW5hbFdpZHRoWCxoPSEwKSw0PT1zLmxlbmd0aCl7dmFyIE89cy5zaGlmdCgpLFQ9cy5zaGlmdCgpLEQ9cy5zaGlmdCgpLEI9cy5zaGlmdCgpLEE9ZS5DRkYuZ2x5cGhCeVNFKGEsRCksUj1lLkNGRi5nbHlwaEJ5U0UoYSxCKTtlLlUuX2RyYXdDRkYoYS5DaGFyU3RyaW5nc1tBXSx0LGEsbixvKSx0Lng9Tyx0Lnk9VCxlLlUuX2RyYXdDRkYoYS5DaGFyU3RyaW5nc1tSXSx0LGEsbixvKTt9ZiYmKGUuVS5QLmNsb3NlUGF0aChvKSxmPSExKTt9ZWxzZSBpZihcIm8xOVwiPT1QfHxcIm8yMFwiPT1QKXtzLmxlbmd0aCUyIT0wJiYhaCYmKGQ9cy5zaGlmdCgpK24ubm9taW5hbFdpZHRoWCksaSs9cy5sZW5ndGg+PjEscy5sZW5ndGg9MCxoPSEwLHUrPWkrNz4+Mzt9ZWxzZSBpZihcIm8yMVwiPT1QKXMubGVuZ3RoPjImJiFoJiYoZD1zLnNoaWZ0KCkrbi5ub21pbmFsV2lkdGhYLGg9ITApLHYrPXMucG9wKCksbCs9cy5wb3AoKSxmJiZlLlUuUC5jbG9zZVBhdGgobyksZS5VLlAubW92ZVRvKG8sbCx2KSxmPSEwO2Vsc2UgaWYoXCJvMjJcIj09UClzLmxlbmd0aD4xJiYhaCYmKGQ9cy5zaGlmdCgpK24ubm9taW5hbFdpZHRoWCxoPSEwKSxsKz1zLnBvcCgpLGYmJmUuVS5QLmNsb3NlUGF0aChvKSxlLlUuUC5tb3ZlVG8obyxsLHYpLGY9ITA7ZWxzZSBpZihcIm8yNVwiPT1QKXtmb3IoO3MubGVuZ3RoPjY7KWwrPXMuc2hpZnQoKSx2Kz1zLnNoaWZ0KCksZS5VLlAubGluZVRvKG8sbCx2KTtjPWwrcy5zaGlmdCgpLHA9ditzLnNoaWZ0KCksVT1jK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLGw9VStzLnNoaWZ0KCksdj1nK3Muc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxsLHYpO31lbHNlIGlmKFwibzI2XCI9PVApZm9yKHMubGVuZ3RoJTImJihsKz1zLnNoaWZ0KCkpO3MubGVuZ3RoPjA7KWM9bCxwPXYrcy5zaGlmdCgpLGw9VT1jK3Muc2hpZnQoKSx2PShnPXArcy5zaGlmdCgpKStzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsbCx2KTtlbHNlIGlmKFwibzI3XCI9PVApZm9yKHMubGVuZ3RoJTImJih2Kz1zLnNoaWZ0KCkpO3MubGVuZ3RoPjA7KXA9dixVPShjPWwrcy5zaGlmdCgpKStzLnNoaWZ0KCksZz1wK3Muc2hpZnQoKSxsPVUrcy5zaGlmdCgpLHY9ZyxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxsLHYpO2Vsc2UgaWYoXCJvMTBcIj09UHx8XCJvMjlcIj09UCl7dmFyIEw9XCJvMTBcIj09UD9uOmE7aWYoMD09cy5sZW5ndGgpY29uc29sZS5kZWJ1ZyhcImVycm9yOiBlbXB0eSBzdGFja1wiKTtlbHNlIHt2YXIgVz1zLnBvcCgpLE09TC5TdWJyc1tXK0wuQmlhc107dC54PWwsdC55PXYsdC5uU3RlbXM9aSx0LmhhdmVXaWR0aD1oLHQud2lkdGg9ZCx0Lm9wZW49ZixlLlUuX2RyYXdDRkYoTSx0LGEsbixvKSxsPXQueCx2PXQueSxpPXQublN0ZW1zLGg9dC5oYXZlV2lkdGgsZD10LndpZHRoLGY9dC5vcGVuO319ZWxzZSBpZihcIm8zMFwiPT1QfHxcIm8zMVwiPT1QKXt2YXIgVj1zLmxlbmd0aCxFPShHPTAsXCJvMzFcIj09UCk7Zm9yKEcrPVYtKHg9LTMmVik7Rzx4OylFPyhwPXYsVT0oYz1sK3Muc2hpZnQoKSkrcy5zaGlmdCgpLHY9KGc9cCtzLnNoaWZ0KCkpK3Muc2hpZnQoKSx4LUc9PTU/KGw9VStzLnNoaWZ0KCksRysrKTpsPVUsRT0hMSk6KGM9bCxwPXYrcy5zaGlmdCgpLFU9YytzLnNoaWZ0KCksZz1wK3Muc2hpZnQoKSxsPVUrcy5zaGlmdCgpLHgtRz09NT8odj1nK3Muc2hpZnQoKSxHKyspOnY9ZyxFPSEwKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxsLHYpLEcrPTQ7fWVsc2Uge2lmKFwib1wiPT0oUCtcIlwiKS5jaGFyQXQoMCkpdGhyb3cgY29uc29sZS5kZWJ1ZyhcIlVua25vd24gb3BlcmF0aW9uOiBcIitQLHIpLFA7cy5wdXNoKFApO319fXQueD1sLHQueT12LHQublN0ZW1zPWksdC5oYXZlV2lkdGg9aCx0LndpZHRoPWQsdC5vcGVuPWY7fTt2YXIgdD1lLGE9e1R5cHI6dH07cmV0dXJuIHIuVHlwcj10LHIuZGVmYXVsdD1hLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHJ9KHt9KS5UeXByfVxuXG4gIC8qIVxuICBDdXN0b20gYnVuZGxlIG9mIHdvZmYyb3RmIChodHRwczovL2dpdGh1Yi5jb20vYXJ0eS1uYW1lL3dvZmYyb3RmKSB3aXRoIGZmbGF0ZVxuICAoaHR0cHM6Ly9naXRodWIuY29tLzEwMWFycm93ei9mZmxhdGUpIGZvciB1c2UgaW4gVHJvaWthIHRleHQgcmVuZGVyaW5nLiBcbiAgT3JpZ2luYWwgbGljZW5zZXMgYXBwbHk6IFxuICAtIGZmbGF0ZTogaHR0cHM6Ly9naXRodWIuY29tLzEwMWFycm93ei9mZmxhdGUvYmxvYi9tYXN0ZXIvTElDRU5TRSAoTUlUKVxuICAtIHdvZmYyb3RmLmpzOiBodHRwczovL2dpdGh1Yi5jb20vYXJ0eS1uYW1lL3dvZmYyb3RmL2Jsb2IvbWFzdGVyL3dvZmYyb3RmLmpzIChBcGFjaGUyKVxuICAqL1xuICBmdW5jdGlvbiB3b2ZmMm90ZkZhY3RvcnkoKXtyZXR1cm4gZnVuY3Rpb24ocil7dmFyIGU9VWludDhBcnJheSxuPVVpbnQxNkFycmF5LHQ9VWludDMyQXJyYXksYT1uZXcgZShbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwLDAsMCwwXSksaT1uZXcgZShbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxMywwLDBdKSxvPW5ldyBlKFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XSksZj1mdW5jdGlvbihyLGUpe2Zvcih2YXIgYT1uZXcgbigzMSksaT0wO2k8MzE7KytpKWFbaV09ZSs9MTw8cltpLTFdO3ZhciBvPW5ldyB0KGFbMzBdKTtmb3IoaT0xO2k8MzA7KytpKWZvcih2YXIgZj1hW2ldO2Y8YVtpKzFdOysrZilvW2ZdPWYtYVtpXTw8NXxpO3JldHVybiBbYSxvXX0sdT1mKGEsMiksdj11WzBdLHM9dVsxXTt2WzI4XT0yNTgsc1syNThdPTI4O2Zvcih2YXIgbD1mKGksMClbMF0sYz1uZXcgbigzMjc2OCksZz0wO2c8MzI3Njg7KytnKXt2YXIgaD0oNDM2OTAmZyk+Pj4xfCgyMTg0NSZnKTw8MTtoPSg2MTY4MCYoaD0oNTI0MjgmaCk+Pj4yfCgxMzEwNyZoKTw8MikpPj4+NHwoMzg1NSZoKTw8NCxjW2ddPSgoNjUyODAmaCk+Pj44fCgyNTUmaCk8PDgpPj4+MTt9dmFyIHc9ZnVuY3Rpb24ocixlLHQpe2Zvcih2YXIgYT1yLmxlbmd0aCxpPTAsbz1uZXcgbihlKTtpPGE7KytpKSsrb1tyW2ldLTFdO3ZhciBmLHU9bmV3IG4oZSk7Zm9yKGk9MDtpPGU7KytpKXVbaV09dVtpLTFdK29baS0xXTw8MTtpZih0KXtmPW5ldyBuKDE8PGUpO3ZhciB2PTE1LWU7Zm9yKGk9MDtpPGE7KytpKWlmKHJbaV0pZm9yKHZhciBzPWk8PDR8cltpXSxsPWUtcltpXSxnPXVbcltpXS0xXSsrPDxsLGg9Z3woMTw8bCktMTtnPD1oOysrZylmW2NbZ10+Pj52XT1zO31lbHNlIGZvcihmPW5ldyBuKGEpLGk9MDtpPGE7KytpKXJbaV0mJihmW2ldPWNbdVtyW2ldLTFdKytdPj4+MTUtcltpXSk7cmV0dXJuIGZ9LGQ9bmV3IGUoMjg4KTtmb3IoZz0wO2c8MTQ0OysrZylkW2ddPTg7Zm9yKGc9MTQ0O2c8MjU2OysrZylkW2ddPTk7Zm9yKGc9MjU2O2c8MjgwOysrZylkW2ddPTc7Zm9yKGc9MjgwO2c8Mjg4OysrZylkW2ddPTg7dmFyIG09bmV3IGUoMzIpO2ZvcihnPTA7ZzwzMjsrK2cpbVtnXT01O3ZhciBiPXcoZCw5LDEpLHA9dyhtLDUsMSkseT1mdW5jdGlvbihyKXtmb3IodmFyIGU9clswXSxuPTE7bjxyLmxlbmd0aDsrK24pcltuXT5lJiYoZT1yW25dKTtyZXR1cm4gZX0sTD1mdW5jdGlvbihyLGUsbil7dmFyIHQ9ZS84fDA7cmV0dXJuIChyW3RdfHJbdCsxXTw8OCk+Pig3JmUpJm59LFU9ZnVuY3Rpb24ocixlKXt2YXIgbj1lLzh8MDtyZXR1cm4gKHJbbl18cltuKzFdPDw4fHJbbisyXTw8MTYpPj4oNyZlKX0saz1bXCJ1bmV4cGVjdGVkIEVPRlwiLFwiaW52YWxpZCBibG9jayB0eXBlXCIsXCJpbnZhbGlkIGxlbmd0aC9saXRlcmFsXCIsXCJpbnZhbGlkIGRpc3RhbmNlXCIsXCJzdHJlYW0gZmluaXNoZWRcIixcIm5vIHN0cmVhbSBoYW5kbGVyXCIsLFwibm8gY2FsbGJhY2tcIixcImludmFsaWQgVVRGLTggZGF0YVwiLFwiZXh0cmEgZmllbGQgdG9vIGxvbmdcIixcImRhdGUgbm90IGluIHJhbmdlIDE5ODAtMjA5OVwiLFwiZmlsZW5hbWUgdG9vIGxvbmdcIixcInN0cmVhbSBmaW5pc2hpbmdcIixcImludmFsaWQgemlwIGRhdGFcIl0sVD1mdW5jdGlvbihyLGUsbil7dmFyIHQ9bmV3IEVycm9yKGV8fGtbcl0pO2lmKHQuY29kZT1yLEVycm9yLmNhcHR1cmVTdGFja1RyYWNlJiZFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0LFQpLCFuKXRocm93IHQ7cmV0dXJuIHR9LE89ZnVuY3Rpb24ocixmLHUpe3ZhciBzPXIubGVuZ3RoO2lmKCFzfHx1JiYhdS5sJiZzPDUpcmV0dXJuIGZ8fG5ldyBlKDApO3ZhciBjPSFmfHx1LGc9IXV8fHUuaTt1fHwodT17fSksZnx8KGY9bmV3IGUoMypzKSk7dmFyIGgsZD1mdW5jdGlvbihyKXt2YXIgbj1mLmxlbmd0aDtpZihyPm4pe3ZhciB0PW5ldyBlKE1hdGgubWF4KDIqbixyKSk7dC5zZXQoZiksZj10O319LG09dS5mfHwwLGs9dS5wfHwwLE89dS5ifHwwLEE9dS5sLHg9dS5kLEU9dS5tLEQ9dS5uLE09OCpzO2Rve2lmKCFBKXt1LmY9bT1MKHIsaywxKTt2YXIgUz1MKHIsaysxLDMpO2lmKGsrPTMsIVMpe3ZhciBWPXJbKEk9KChoPWspLzh8MCkrKDcmaCYmMSkrNCktNF18cltJLTNdPDw4LF89SStWO2lmKF8+cyl7ZyYmVCgwKTticmVha31jJiZkKE8rViksZi5zZXQoci5zdWJhcnJheShJLF8pLE8pLHUuYj1PKz1WLHUucD1rPTgqXztjb250aW51ZX1pZigxPT1TKUE9Yix4PXAsRT05LEQ9NTtlbHNlIGlmKDI9PVMpe3ZhciBqPUwocixrLDMxKSsyNTcsej1MKHIsaysxMCwxNSkrNCxDPWorTChyLGsrNSwzMSkrMTtrKz0xNDtmb3IodmFyIEY9bmV3IGUoQyksUD1uZXcgZSgxOSkscT0wO3E8ejsrK3EpUFtvW3FdXT1MKHIsayszKnEsNyk7ays9Myp6O3ZhciBCPXkoUCksRz0oMTw8QiktMSxIPXcoUCxCLDEpO2ZvcihxPTA7cTxDOyl7dmFyIEksSj1IW0wocixrLEcpXTtpZihrKz0xNSZKLChJPUo+Pj40KTwxNilGW3ErK109STtlbHNlIHt2YXIgSz0wLE49MDtmb3IoMTY9PUk/KE49MytMKHIsaywzKSxrKz0yLEs9RltxLTFdKToxNz09ST8oTj0zK0wocixrLDcpLGsrPTMpOjE4PT1JJiYoTj0xMStMKHIsaywxMjcpLGsrPTcpO04tLTspRltxKytdPUs7fX12YXIgUT1GLnN1YmFycmF5KDAsaiksUj1GLnN1YmFycmF5KGopO0U9eShRKSxEPXkoUiksQT13KFEsRSwxKSx4PXcoUixELDEpO31lbHNlIFQoMSk7aWYoaz5NKXtnJiZUKDApO2JyZWFrfX1jJiZkKE8rMTMxMDcyKTtmb3IodmFyIFc9KDE8PEUpLTEsWD0oMTw8RCktMSxZPWs7O1k9ayl7dmFyIFo9KEs9QVtVKHIsaykmV10pPj4+NDtpZigoays9MTUmSyk+TSl7ZyYmVCgwKTticmVha31pZihLfHxUKDIpLFo8MjU2KWZbTysrXT1aO2Vsc2Uge2lmKDI1Nj09Wil7WT1rLEE9bnVsbDticmVha312YXIgJD1aLTI1NDtpZihaPjI2NCl7dmFyIHJyPWFbcT1aLTI1N107JD1MKHIsaywoMTw8cnIpLTEpK3ZbcV0says9cnI7fXZhciBlcj14W1UocixrKSZYXSxucj1lcj4+PjQ7ZXJ8fFQoMyksays9MTUmZXI7Uj1sW25yXTtpZihucj4zKXtycj1pW25yXTtSKz1VKHIsaykmKDE8PHJyKS0xLGsrPXJyO31pZihrPk0pe2cmJlQoMCk7YnJlYWt9YyYmZChPKzEzMTA3Mik7Zm9yKHZhciB0cj1PKyQ7Tzx0cjtPKz00KWZbT109ZltPLVJdLGZbTysxXT1mW08rMS1SXSxmW08rMl09ZltPKzItUl0sZltPKzNdPWZbTyszLVJdO089dHI7fX11Lmw9QSx1LnA9WSx1LmI9TyxBJiYobT0xLHUubT1FLHUuZD14LHUubj1EKTt9d2hpbGUoIW0pO3JldHVybiBPPT1mLmxlbmd0aD9mOmZ1bmN0aW9uKHIsYSxpKXsobnVsbD09YXx8YTwwKSYmKGE9MCksKG51bGw9PWl8fGk+ci5sZW5ndGgpJiYoaT1yLmxlbmd0aCk7dmFyIG89bmV3KHIgaW5zdGFuY2VvZiBuP246ciBpbnN0YW5jZW9mIHQ/dDplKShpLWEpO3JldHVybiBvLnNldChyLnN1YmFycmF5KGEsaSkpLG99KGYsMCxPKX0sQT1uZXcgZSgwKTt2YXIgeD1cInVuZGVmaW5lZFwiIT10eXBlb2YgVGV4dERlY29kZXImJm5ldyBUZXh0RGVjb2Rlcjt0cnl7eC5kZWNvZGUoQSx7c3RyZWFtOiEwfSksMTt9Y2F0Y2gocil7fXJldHVybiByLmNvbnZlcnRfc3RyZWFtcz1mdW5jdGlvbihyKXt2YXIgZT1uZXcgRGF0YVZpZXcociksbj0wO2Z1bmN0aW9uIHQoKXt2YXIgcj1lLmdldFVpbnQxNihuKTtyZXR1cm4gbis9MixyfWZ1bmN0aW9uIGEoKXt2YXIgcj1lLmdldFVpbnQzMihuKTtyZXR1cm4gbis9NCxyfWZ1bmN0aW9uIGkocil7bS5zZXRVaW50MTYoYixyKSxiKz0yO31mdW5jdGlvbiBvKHIpe20uc2V0VWludDMyKGIsciksYis9NDt9Zm9yKHZhciBmPXtzaWduYXR1cmU6YSgpLGZsYXZvcjphKCksbGVuZ3RoOmEoKSxudW1UYWJsZXM6dCgpLHJlc2VydmVkOnQoKSx0b3RhbFNmbnRTaXplOmEoKSxtYWpvclZlcnNpb246dCgpLG1pbm9yVmVyc2lvbjp0KCksbWV0YU9mZnNldDphKCksbWV0YUxlbmd0aDphKCksbWV0YU9yaWdMZW5ndGg6YSgpLHByaXZPZmZzZXQ6YSgpLHByaXZMZW5ndGg6YSgpfSx1PTA7TWF0aC5wb3coMix1KTw9Zi5udW1UYWJsZXM7KXUrKzt1LS07Zm9yKHZhciB2PTE2Kk1hdGgucG93KDIsdSkscz0xNipmLm51bVRhYmxlcy12LGw9MTIsYz1bXSxnPTA7ZzxmLm51bVRhYmxlcztnKyspYy5wdXNoKHt0YWc6YSgpLG9mZnNldDphKCksY29tcExlbmd0aDphKCksb3JpZ0xlbmd0aDphKCksb3JpZ0NoZWNrc3VtOmEoKX0pLGwrPTE2O3ZhciBoLHc9bmV3IFVpbnQ4QXJyYXkoMTIrMTYqYy5sZW5ndGgrYy5yZWR1Y2UoKGZ1bmN0aW9uKHIsZSl7cmV0dXJuIHIrZS5vcmlnTGVuZ3RoKzR9KSwwKSksZD13LmJ1ZmZlcixtPW5ldyBEYXRhVmlldyhkKSxiPTA7cmV0dXJuIG8oZi5mbGF2b3IpLGkoZi5udW1UYWJsZXMpLGkodiksaSh1KSxpKHMpLGMuZm9yRWFjaCgoZnVuY3Rpb24ocil7byhyLnRhZyksbyhyLm9yaWdDaGVja3N1bSksbyhsKSxvKHIub3JpZ0xlbmd0aCksci5vdXRPZmZzZXQ9bCwobCs9ci5vcmlnTGVuZ3RoKSU0IT0wJiYobCs9NC1sJTQpO30pKSxjLmZvckVhY2goKGZ1bmN0aW9uKGUpe3ZhciBuLHQ9ci5zbGljZShlLm9mZnNldCxlLm9mZnNldCtlLmNvbXBMZW5ndGgpO2lmKGUuY29tcExlbmd0aCE9ZS5vcmlnTGVuZ3RoKXt2YXIgYT1uZXcgVWludDhBcnJheShlLm9yaWdMZW5ndGgpO249bmV3IFVpbnQ4QXJyYXkodCwyKSxPKG4sYSk7fWVsc2UgYT1uZXcgVWludDhBcnJheSh0KTt3LnNldChhLGUub3V0T2Zmc2V0KTt2YXIgaT0wOyhsPWUub3V0T2Zmc2V0K2Uub3JpZ0xlbmd0aCklNCE9MCYmKGk9NC1sJTQpLHcuc2V0KG5ldyBVaW50OEFycmF5KGkpLmJ1ZmZlcixlLm91dE9mZnNldCtlLm9yaWdMZW5ndGgpLGg9bCtpO30pKSxkLnNsaWNlKDAsaCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHJ9KHt9KS5jb252ZXJ0X3N0cmVhbXN9XG5cbiAgLyoqXG4gICAqIEEgZmFjdG9yeSB3cmFwcGVyIHBhcnNpbmcgYSBmb250IGZpbGUgdXNpbmcgVHlwci5cbiAgICogQWxzbyBhZGRzIHN1cHBvcnQgZm9yIFdPRkYgZmlsZXMgKG5vdCBXT0ZGMikuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiBQYXJzZWRGb250XG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhc2NlbmRlclxuICAgKiBAcHJvcGVydHkge251bWJlcn0gZGVzY2VuZGVyXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4SGVpZ2h0XG4gICAqIEBwcm9wZXJ0eSB7KG51bWJlcikgPT4gYm9vbGVhbn0gc3VwcG9ydHNDb2RlUG9pbnRcbiAgICogQHByb3BlcnR5IHsodGV4dDpzdHJpbmcsIGZvbnRTaXplOm51bWJlciwgbGV0dGVyU3BhY2luZzpudW1iZXIsIGNhbGxiYWNrKSA9PiBudW1iZXJ9IGZvckVhY2hHbHlwaFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gbGluZUdhcFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gY2FwSGVpZ2h0XG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1bml0c1BlckVtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7KGJ1ZmZlcjogQXJyYXlCdWZmZXIpID0+IFBhcnNlZEZvbnR9IEZvbnRQYXJzZXJcbiAgICovXG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtGb250UGFyc2VyfVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VyRmFjdG9yeShUeXByLCB3b2ZmMm90Zikge1xuICAgIGNvbnN0IGNtZEFyZ0xlbmd0aHMgPSB7XG4gICAgICBNOiAyLFxuICAgICAgTDogMixcbiAgICAgIFE6IDQsXG4gICAgICBDOiA2LFxuICAgICAgWjogMFxuICAgIH07XG5cbiAgICAvLyB7am9pblR5cGU6IFwic2tpcCtzdGVwLC4uLlwifVxuICAgIGNvbnN0IGpvaW5pbmdUeXBlUmF3RGF0YSA9IHtcIkNcIjpcIjE4ZyxjYSwzNjgsMWt6XCIsXCJEXCI6XCIxN2ssNiwyLDIrNCw1K2MsMis2LDIrMSwxMCsxLDkrZixqKzExLDIrMSxhLDIsMisxLDE1KzIsMyxqKzIsNiszLDIrOCwyLDIsMisxLHcrYSw0K2UsMyszLDIsMysyLDMrNSwyMyt3LDJmKzQsMywyKzksMixiLDIrMywzLDFrKzksNisxLDMrMSwyKzIsMitkLDMwZyxwK3ksMSwxKzFnLGYreCwyLHNkMisxZCxqZjMrNCxmKzMsMis0LDIrMixiKzMsNDIsMiw0KzIsMisxLDIsMyx0KzEsOWYrdywyLGVsKzIsMitnLGQrMiwybCwyKzEsNSwzKzEsMisxLDIsMyw2LDE2d20rMXZcIixcIlJcIjpcIjE3bSszLDIsMiw2KzMsbSwxNSsyLDIrMixoK2gsMTMsMys4LDIsMiwzKzEsMixwKzEseCw1KzQsNSxhLDIsMiwzLHUsYysyLGcrMSw1LDIrMSw0KzEsNWosNisxLDIsYiwyKzIsZiwyKzEsMXMrMiwyLDMrMSw3LDFlejAsMiwyKzEsNCs0LGIsNCwzLGIsNDIsMisyLDQsMywyKzEsMixvKzMsYWUsZXAseCwybysyLDMrMSwzLDUrMSw2XCIsXCJMXCI6XCJ4OXUsamZmLGEsZmQsanZcIixcIlRcIjpcIjR0LGdqKzMzLDdvKzQsMSsxLDdjKzE4LDIsMisxLDIrMSwyLDIxK2EsMiwxYitrLGgsMnUrNiwzKzUsMysxLDIrMyx5LDIsditxLDJrK2EsMW4rOCxhLHArMywyKzgsMisyLDIrNCwxOCsyLDNjK2UsMit2LDFrLDIsNSs3LDUsNCs2LGIrMSx1LDFuLDUrMyw5LGwrMSxyLDMrMSwxbSw1KzEsNSsxLDMrMiw0LHYrMSw0LGMrMSwxbSw1KzQsMisxLDUsbCsxLG4rNSwyLDFuLDMsMiszLDksOCsxLGMrMSx2LDFxLGQsMWYsNCwxbSsyLDYrMiwyKzMsOCsxLGMrMSx1LDFuLDMsNyw2KzEsbCsxLHQrMSwxbSsxLDUrMyw5LGwrMSx1LDIxLDgrMiwyLDJqLDMrNixkKzcsMnIsMys4LGMrNSwyMysxLHMsMiwyLDFrK2QsMis0LDIrMSw2K2EsMit6LGEsMnYrMywyKzUsMisxLDMrMSxxKzEsNSsyLGgrMyxlLDMrMSw3LGcsamsrMixxYisyLHUrMix1KzEsdisxLDF0KzEsMis2LDksMythLGEsMWErMiwzYysxLHosM2IrMiw1KzEsYSw3KzIsNjQrMSwzLDFuLDIrNiwyLDIsMys3LDcrOSwzLDFkK2QsMSwxKzEsMXMrMywxZCwyKzQsMiw2LDE1KzgsZCsxLHgrMywzKzEsMisyLDFsLDIrMSw0LDIrMiwxbis3LDMrMSw0OSsyLDIrYywyKzYsNSw3LDQrMSw1aisxbCwyKzQsZWssMysxLHIrNCwxZSs0LDYrNSwycCtjLDErMywxLDErMiwxK2IsMmRiKzIsM3ksMnArdixmZiszLDMwKzEsbjl4LDErMiwyKzkseCsxLDI5KzEsN2wsNCw1LHErMSw2LDQ4KzEscitoLGUsMTMrNyxxK2EsMWIrMiwxZCwzKzMsMysxLDE0LDF3KzUsMysxLDMrMSxkLDksMWMsMWcsMisyLDMrMSw2KzEsMiwxNysxLDksNm4sMyw1LGZuNSxraStmLGgrZiw1cyw2eSsyLGVhLDZiLDQ2KzQsMWFmKzIsMisxLDYrMywxNSsyLDUsNG0rMSxmeSszLGFzKzEsNGErYSw0eCwxaitlLDFsKzIsMWUrMywzKzEsMXkrMiwxMSs0LDIrNywxcixkKzEsMWgrOCxiKzMsMywybysyLDMsMisxLDcsNGgsNCs3LG0rMSwxbSsxLDQsMTIrNiw0KzQsNWcrNywzKzIsMixvLDJkKzUsMiw1KzEsMisxLDZuKzMsNysxLDIrMSxzKzEsMmUrNywzLDIrMSwyeiwyLDMrNSwyLDJ1KzIsMyszLDIrNCw3OCs4LDIrMSw3NSsxLDIsNSw0MSszLDMrMSw1LHgrOSwxNSs1LDMrMyw5LGErNSwzKzIsMWIrYywyKzEsYmIrNiwyKzUsMiwyYitsLDMrNiwyKzEsMisxLDNmKzUsNCwyKzEsMis2LDIsMjErMSw0LDIsOW8rMSw0NzArOCxhdDQrNCwxbys2LHQ1LDFzKzMsMmEsZjVsKzEsMiszLDQzbysyLGErNywxKzcsMys2LHYrMyw0NSsyLDFqMCsxaSw1KzFkLDksZixuKzQsMitlLDExdCs2LDIrZywzKzYsMisxLDIrNCw3YSs2LGM2KzMsMTV0KzYsMzIrNiwxLGd6YXUsdisybiwzbCs2blwifTtcblxuICAgIGNvbnN0IEpUX0xFRlQgPSAxLCAvL2luZGljYXRlcyB0aGF0IGEgY2hhcmFjdGVyIGpvaW5zIHdpdGggdGhlIHN1YnNlcXVlbnQgY2hhcmFjdGVyLCBidXQgZG9lcyBub3Qgam9pbiB3aXRoIHRoZSBwcmVjZWRpbmcgY2hhcmFjdGVyLlxuICAgICAgSlRfUklHSFQgPSAyLCAvL2luZGljYXRlcyB0aGF0IGEgY2hhcmFjdGVyIGpvaW5zIHdpdGggdGhlIHByZWNlZGluZyBjaGFyYWN0ZXIsIGJ1dCBkb2VzIG5vdCBqb2luIHdpdGggdGhlIHN1YnNlcXVlbnQgY2hhcmFjdGVyLlxuICAgICAgSlRfRFVBTCA9IDQsIC8vaW5kaWNhdGVzIHRoYXQgYSBjaGFyYWN0ZXIgam9pbnMgd2l0aCB0aGUgcHJlY2VkaW5nIGNoYXJhY3RlciBhbmQgam9pbnMgd2l0aCB0aGUgc3Vic2VxdWVudCBjaGFyYWN0ZXIuXG4gICAgICBKVF9UUkFOU1BBUkVOVCA9IDgsIC8vaW5kaWNhdGVzIHRoYXQgdGhlIGNoYXJhY3RlciBkb2VzIG5vdCBqb2luIHdpdGggYWRqYWNlbnQgY2hhcmFjdGVycyBhbmQgdGhhdCB0aGUgY2hhcmFjdGVyIG11c3QgYmUgc2tpcHBlZCBvdmVyIHdoZW4gdGhlIHNoYXBpbmcgZW5naW5lIGlzIGV2YWx1YXRpbmcgdGhlIGpvaW5pbmcgcG9zaXRpb25zIGluIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycy4gV2hlbiBhIEpUX1RSQU5TUEFSRU5UIGNoYXJhY3RlciBpcyBlbmNvdW50ZXJlZCBpbiBhIHNlcXVlbmNlLCB0aGUgSk9JTklOR19UWVBFIG9mIHRoZSBwcmVjZWRpbmcgY2hhcmFjdGVyIHBhc3NlcyB0aHJvdWdoLiBEaWFjcml0aWNhbCBtYXJrcyBhcmUgZnJlcXVlbnRseSBhc3NpZ25lZCB0aGlzIHZhbHVlLlxuICAgICAgSlRfSk9JTl9DQVVTSU5HID0gMTYsIC8vaW5kaWNhdGVzIHRoYXQgdGhlIGNoYXJhY3RlciBmb3JjZXMgdGhlIHVzZSBvZiBqb2luaW5nIGZvcm1zIHdpdGggdGhlIHByZWNlZGluZyBhbmQgc3Vic2VxdWVudCBjaGFyYWN0ZXJzLiBLYXNoaWRhcyBhbmQgdGhlIFplcm8gV2lkdGggSm9pbmVyIChVKzIwMEQpIGFyZSBib3RoIEpPSU5fQ0FVU0lORyBjaGFyYWN0ZXJzLlxuICAgICAgSlRfTk9OX0pPSU5JTkcgPSAzMjsgLy9pbmRpY2F0ZXMgdGhhdCBhIGNoYXJhY3RlciBkb2VzIG5vdCBqb2luIHdpdGggdGhlIHByZWNlZGluZyBvciB3aXRoIHRoZSBzdWJzZXF1ZW50IGNoYXJhY3Rlci4sXG5cbiAgICBsZXQgam9pbmluZ1R5cGVNYXA7XG4gICAgZnVuY3Rpb24gZ2V0Q2hhckpvaW5pbmdUeXBlKGNoKSB7XG4gICAgICBpZiAoIWpvaW5pbmdUeXBlTWFwKSB7XG4gICAgICAgIGNvbnN0IG0gPSB7XG4gICAgICAgICAgUjogSlRfUklHSFQsXG4gICAgICAgICAgTDogSlRfTEVGVCxcbiAgICAgICAgICBEOiBKVF9EVUFMLFxuICAgICAgICAgIEM6IEpUX0pPSU5fQ0FVU0lORyxcbiAgICAgICAgICBVOiBKVF9OT05fSk9JTklORyxcbiAgICAgICAgICBUOiBKVF9UUkFOU1BBUkVOVFxuICAgICAgICB9O1xuICAgICAgICBqb2luaW5nVHlwZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBqb2luaW5nVHlwZVJhd0RhdGEpIHtcbiAgICAgICAgICBsZXQgbGFzdENvZGUgPSAwO1xuICAgICAgICAgIGpvaW5pbmdUeXBlUmF3RGF0YVt0eXBlXS5zcGxpdCgnLCcpLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICAgICAgbGV0IFtza2lwLCBzdGVwXSA9IHJhbmdlLnNwbGl0KCcrJyk7XG4gICAgICAgICAgICBza2lwID0gcGFyc2VJbnQoc2tpcCwzNik7XG4gICAgICAgICAgICBzdGVwID0gc3RlcCA/IHBhcnNlSW50KHN0ZXAsIDM2KSA6IDA7XG4gICAgICAgICAgICBqb2luaW5nVHlwZU1hcC5zZXQobGFzdENvZGUgKz0gc2tpcCwgbVt0eXBlXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RlcDsgaS0tOykge1xuICAgICAgICAgICAgICBqb2luaW5nVHlwZU1hcC5zZXQoKytsYXN0Q29kZSwgbVt0eXBlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBqb2luaW5nVHlwZU1hcC5nZXQoY2gpIHx8IEpUX05PTl9KT0lOSU5HXG4gICAgfVxuXG4gICAgY29uc3QgSVNPTCA9IDEsIElOSVQgPSAyLCBGSU5BID0gMywgTUVESSA9IDQ7XG4gICAgY29uc3QgZm9ybXNUb0ZlYXR1cmVzID0gW251bGwsICdpc29sJywgJ2luaXQnLCAnZmluYScsICdtZWRpJ107XG5cbiAgICBmdW5jdGlvbiBkZXRlY3RKb2luaW5nRm9ybXMoc3RyKSB7XG4gICAgICAvLyBUaGlzIGltcGxlbWVudHMgdGhlIGFsZ29yaXRobSBkZXNjcmliZWQgaGVyZTpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uOHdpbGxpcy9vcGVudHlwZS1zaGFwaW5nLWRvY3VtZW50cy9ibG9iL21hc3Rlci9vcGVudHlwZS1zaGFwaW5nLWFyYWJpYy1nZW5lcmFsLm1kXG4gICAgICBjb25zdCBqb2luaW5nRm9ybXMgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgICAgIGxldCBwcmV2Sm9pbmluZ1R5cGUgPSBKVF9OT05fSk9JTklORztcbiAgICAgIGxldCBwcmV2Rm9ybSA9IElTT0w7XG4gICAgICBsZXQgcHJldkluZGV4ID0gLTE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gc3RyLmNvZGVQb2ludEF0KGkpO1xuICAgICAgICBsZXQgam9pbmluZ1R5cGUgPSBnZXRDaGFySm9pbmluZ1R5cGUoY29kZSkgfCAwO1xuICAgICAgICBsZXQgZm9ybSA9IElTT0w7XG4gICAgICAgIGlmIChqb2luaW5nVHlwZSAmIEpUX1RSQU5TUEFSRU5UKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldkpvaW5pbmdUeXBlICYgKEpUX0xFRlQgfCBKVF9EVUFMIHwgSlRfSk9JTl9DQVVTSU5HKSkge1xuICAgICAgICAgIGlmIChqb2luaW5nVHlwZSAmIChKVF9SSUdIVCB8IEpUX0RVQUwgfCBKVF9KT0lOX0NBVVNJTkcpKSB7XG4gICAgICAgICAgICBmb3JtID0gRklOQTtcbiAgICAgICAgICAgIC8vIGlzb2wtPmluaXQsIGZpbmEtPm1lZGlcbiAgICAgICAgICAgIGlmIChwcmV2Rm9ybSA9PT0gSVNPTCB8fCBwcmV2Rm9ybSA9PT0gRklOQSkge1xuICAgICAgICAgICAgICBqb2luaW5nRm9ybXNbcHJldkluZGV4XSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChqb2luaW5nVHlwZSAmIChKVF9MRUZUIHwgSlRfTk9OX0pPSU5JTkcpKSB7XG4gICAgICAgICAgICAvLyBtZWRpLT5maW5hLCBpbml0LT5pc29sXG4gICAgICAgICAgICBpZiAocHJldkZvcm0gPT09IElOSVQgfHwgcHJldkZvcm0gPT09IE1FREkpIHtcbiAgICAgICAgICAgICAgam9pbmluZ0Zvcm1zW3ByZXZJbmRleF0tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJldkpvaW5pbmdUeXBlICYgKEpUX1JJR0hUIHwgSlRfTk9OX0pPSU5JTkcpKSB7XG4gICAgICAgICAgLy8gbWVkaS0+ZmluYSwgaW5pdC0+aXNvbFxuICAgICAgICAgIGlmIChwcmV2Rm9ybSA9PT0gSU5JVCB8fCBwcmV2Rm9ybSA9PT0gTUVESSkge1xuICAgICAgICAgICAgam9pbmluZ0Zvcm1zW3ByZXZJbmRleF0tLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJldkZvcm0gPSBqb2luaW5nRm9ybXNbaV0gPSBmb3JtO1xuICAgICAgICBwcmV2Sm9pbmluZ1R5cGUgPSBqb2luaW5nVHlwZTtcbiAgICAgICAgcHJldkluZGV4ID0gaTtcbiAgICAgICAgaWYgKGNvZGUgPiAweGZmZmYpIGkrKztcbiAgICAgIH1cbiAgICAgIC8vIGNvbnNvbGUubG9nKHN0ci5zcGxpdCgnJykubWFwKGNoID0+IGNoLmNvZGVQb2ludEF0KDApLnRvU3RyaW5nKDE2KSkpXG4gICAgICAvLyBjb25zb2xlLmxvZyhzdHIuc3BsaXQoJycpLm1hcChjaCA9PiBnZXRDaGFySm9pbmluZ1R5cGUoY2guY29kZVBvaW50QXQoMCkpKSlcbiAgICAgIC8vIGNvbnNvbGUubG9nKEFycmF5LmZyb20oam9pbmluZ0Zvcm1zKS5tYXAoZiA9PiBmb3Jtc1RvRmVhdHVyZXNbZl0gfHwgJ25vbmUnKSlcbiAgICAgIHJldHVybiBqb2luaW5nRm9ybXNcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJpbmdUb0dseXBocyAoZm9udCwgc3RyKSB7XG4gICAgICBjb25zdCBnbHlwaElkcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2MgPSBzdHIuY29kZVBvaW50QXQoaSk7XG4gICAgICAgIGlmIChjYyA+IDB4ZmZmZikgaSsrO1xuICAgICAgICBnbHlwaElkcy5wdXNoKFR5cHIuVS5jb2RlVG9HbHlwaChmb250LCBjYykpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBnc3ViID0gZm9udFsnR1NVQiddO1xuICAgICAgaWYgKGdzdWIpIHtcbiAgICAgICAgY29uc3Qge2xvb2t1cExpc3QsIGZlYXR1cmVMaXN0fSA9IGdzdWI7XG4gICAgICAgIGxldCBqb2luaW5nRm9ybXM7XG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZEZlYXR1cmVzID0gL14ocmxpZ3xsaWdhfG1zZXR8aXNvbHxpbml0fGZpbmF8bWVkaXxoYWxmfHByZXN8Ymx3c3xjY21wKSQvO1xuICAgICAgICBjb25zdCB1c2VkTG9va3VwcyA9IFtdO1xuICAgICAgICBmZWF0dXJlTGlzdC5mb3JFYWNoKGZlYXR1cmUgPT4ge1xuICAgICAgICAgIGlmIChzdXBwb3J0ZWRGZWF0dXJlcy50ZXN0KGZlYXR1cmUudGFnKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgdGkgPSAwOyB0aSA8IGZlYXR1cmUudGFiLmxlbmd0aDsgdGkrKykge1xuICAgICAgICAgICAgICBpZiAodXNlZExvb2t1cHNbZmVhdHVyZS50YWJbdGldXSkgY29udGludWVcbiAgICAgICAgICAgICAgdXNlZExvb2t1cHNbZmVhdHVyZS50YWJbdGldXSA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnN0IHRhYiA9IGxvb2t1cExpc3RbZmVhdHVyZS50YWJbdGldXTtcbiAgICAgICAgICAgICAgY29uc3QgaXNKb2luaW5nRmVhdHVyZSA9IC9eKGlzb2x8aW5pdHxmaW5hfG1lZGkpJC8udGVzdChmZWF0dXJlLnRhZyk7XG4gICAgICAgICAgICAgIGlmIChpc0pvaW5pbmdGZWF0dXJlICYmICFqb2luaW5nRm9ybXMpIHsgLy9sYXp5XG4gICAgICAgICAgICAgICAgam9pbmluZ0Zvcm1zID0gZGV0ZWN0Sm9pbmluZ0Zvcm1zKHN0cik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChsZXQgY2kgPSAwOyBjaSA8IGdseXBoSWRzLmxlbmd0aDsgY2krKykge1xuICAgICAgICAgICAgICAgIGlmICgham9pbmluZ0Zvcm1zIHx8ICFpc0pvaW5pbmdGZWF0dXJlIHx8IGZvcm1zVG9GZWF0dXJlc1tqb2luaW5nRm9ybXNbY2ldXSA9PT0gZmVhdHVyZS50YWcpIHtcbiAgICAgICAgICAgICAgICAgIFR5cHIuVS5fYXBwbHlTdWJzKGdseXBoSWRzLCBjaSwgdGFiLCBsb29rdXBMaXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2x5cGhJZHNcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgYWR2YW5jZXMgYW5kIHgveSBvZmZzZXRzIGZvciBlYWNoIGdseXBoLCBlLmcuIGtlcm5pbmcgYW5kIG1hcmtcbiAgICAvLyBhdHRhY2htZW50cy4gVGhpcyBpcyBhIG1vcmUgY29tcGxldGUgdmVyc2lvbiBvZiBUeXByLlUuZ2V0UGFpckFkanVzdG1lbnRcbiAgICAvLyBhbmQgc2hvdWxkIGJlY29tZSBhbiB1cHN0cmVhbSByZXBsYWNlbWVudCBldmVudHVhbGx5LlxuICAgIGZ1bmN0aW9uIGNhbGNHbHlwaFBvc2l0aW9ucyhmb250LCBnbHlwaElkcykge1xuICAgICAgY29uc3QgcG9zaXRpb25zID0gbmV3IEludDE2QXJyYXkoZ2x5cGhJZHMubGVuZ3RoICogMyk7IC8vIFtvZmZzZXRYLCBvZmZzZXRZLCBhZHZhbmNlWCwgLi4uXVxuICAgICAgbGV0IGdseXBoSW5kZXggPSAwO1xuICAgICAgZm9yICg7IGdseXBoSW5kZXggPCBnbHlwaElkcy5sZW5ndGg7IGdseXBoSW5kZXgrKykge1xuICAgICAgICBjb25zdCBnbHlwaElkID0gZ2x5cGhJZHNbZ2x5cGhJbmRleF07XG4gICAgICAgIGlmIChnbHlwaElkID09PSAtMSkgY29udGludWU7XG5cbiAgICAgICAgcG9zaXRpb25zW2dseXBoSW5kZXggKiAzICsgMl0gPSBmb250LmhtdHguYVdpZHRoW2dseXBoSWRdOyAvLyBwb3B1bGF0ZSBhZHZhbmNlWCBpbi4uLmFkdmFuY2UuXG5cbiAgICAgICAgY29uc3QgZ3BvcyA9IGZvbnQuR1BPUztcbiAgICAgICAgaWYgKGdwb3MpIHtcbiAgICAgICAgICBjb25zdCBsbGlzdCA9IGdwb3MubG9va3VwTGlzdDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsb29rdXAgPSBsbGlzdFtpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbG9va3VwLnRhYnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgdGFiID0gbG9va3VwLnRhYnNbal07XG4gICAgICAgICAgICAgIC8vIFNpbmdsZSBjaGFyIHBsYWNlbWVudFxuICAgICAgICAgICAgICBpZiAobG9va3VwLmx0eXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kID0gVHlwci5fbGN0Zi5jb3ZlcmFnZUluZGV4KHRhYi5jb3ZlcmFnZSwgZ2x5cGhJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZCAhPT0gLTEgJiYgdGFiLnBvcykge1xuICAgICAgICAgICAgICAgICAgYXBwbHlWYWx1ZVJlY29yZCh0YWIucG9zLCBnbHlwaEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFBhaXJzIChrZXJuaW5nKVxuICAgICAgICAgICAgICBlbHNlIGlmIChsb29rdXAubHR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWRqID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgcHJldkdseXBoSW5kZXggPSBnZXRQcmV2R2x5cGhJbmRleCgpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2R2x5cGhJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNvdmVyYWdlSW5kZXggPSBUeXByLl9sY3RmLmNvdmVyYWdlSW5kZXgodGFiLmNvdmVyYWdlLCBnbHlwaElkc1twcmV2R2x5cGhJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgaWYgKGNvdmVyYWdlSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWIuZm10ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB0YWIucGFpcnNldHNbY292ZXJhZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByaWdodC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0W2tdLmdpZDIgPT09IGdseXBoSWQpIGFkaiA9IHJpZ2h0W2tdO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YWIuZm10ID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgYzEgPSBUeXByLlUuX2dldEdseXBoQ2xhc3MoZ2x5cGhJZHNbcHJldkdseXBoSW5kZXhdLCB0YWIuY2xhc3NEZWYxKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjMiA9IFR5cHIuVS5fZ2V0R2x5cGhDbGFzcyhnbHlwaElkLCB0YWIuY2xhc3NEZWYyKTtcbiAgICAgICAgICAgICAgICAgICAgICBhZGogPSB0YWIubWF0cml4W2MxXVtjMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkaikge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGoudmFsMSkgYXBwbHlWYWx1ZVJlY29yZChhZGoudmFsMSwgcHJldkdseXBoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGoudmFsMikgYXBwbHlWYWx1ZVJlY29yZChhZGoudmFsMiwgZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBNYXJrIHRvIGJhc2VcbiAgICAgICAgICAgICAgZWxzZSBpZiAobG9va3VwLmx0eXBlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFya0FyckluZGV4ID0gVHlwci5fbGN0Zi5jb3ZlcmFnZUluZGV4KHRhYi5tYXJrQ292ZXJhZ2UsIGdseXBoSWQpO1xuICAgICAgICAgICAgICAgIGlmIChtYXJrQXJySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBiYXNlR2x5cGhJbmRleCA9IGdldFByZXZHbHlwaEluZGV4KGlzQmFzZUdseXBoKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VBcnJJbmRleCA9IGJhc2VHbHlwaEluZGV4ID09PSAtMSA/IC0xIDogVHlwci5fbGN0Zi5jb3ZlcmFnZUluZGV4KHRhYi5iYXNlQ292ZXJhZ2UsIGdseXBoSWRzW2Jhc2VHbHlwaEluZGV4XSk7XG4gICAgICAgICAgICAgICAgICBpZiAoYmFzZUFyckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXJrUmVjb3JkID0gdGFiLm1hcmtBcnJheVttYXJrQXJySW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlQW5jaG9yID0gdGFiLmJhc2VBcnJheVtiYXNlQXJySW5kZXhdW21hcmtSZWNvcmQubWFya0NsYXNzXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zW2dseXBoSW5kZXggKiAzXSA9IGJhc2VBbmNob3IueCAtIG1hcmtSZWNvcmQueCArIHBvc2l0aW9uc1tiYXNlR2x5cGhJbmRleCAqIDNdIC0gcG9zaXRpb25zW2Jhc2VHbHlwaEluZGV4ICogMyArIDJdO1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnNbZ2x5cGhJbmRleCAqIDMgKyAxXSA9IGJhc2VBbmNob3IueSAtIG1hcmtSZWNvcmQueSArIHBvc2l0aW9uc1tiYXNlR2x5cGhJbmRleCAqIDMgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIE1hcmsgdG8gbWFya1xuICAgICAgICAgICAgICBlbHNlIGlmIChsb29rdXAubHR5cGUgPT09IDYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrMUFyckluZGV4ID0gVHlwci5fbGN0Zi5jb3ZlcmFnZUluZGV4KHRhYi5tYXJrMUNvdmVyYWdlLCBnbHlwaElkKTtcbiAgICAgICAgICAgICAgICBpZiAobWFyazFBcnJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZHbHlwaEluZGV4ID0gZ2V0UHJldkdseXBoSW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwcmV2R2x5cGhJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldkdseXBoSWQgPSBnbHlwaElkc1twcmV2R2x5cGhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRHbHlwaENsYXNzKGZvbnQsIHByZXZHbHlwaElkKSA9PT0gMykgeyAvLyBvbmx5IGNoZWNrIG1hcmsgZ2x5cGhzXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFyazJBcnJJbmRleCA9IFR5cHIuX2xjdGYuY292ZXJhZ2VJbmRleCh0YWIubWFyazJDb3ZlcmFnZSwgcHJldkdseXBoSWQpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXJrMkFyckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFyazFSZWNvcmQgPSB0YWIubWFyazFBcnJheVttYXJrMUFyckluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmsyQW5jaG9yID0gdGFiLm1hcmsyQXJyYXlbbWFyazJBcnJJbmRleF1bbWFyazFSZWNvcmQubWFya0NsYXNzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tnbHlwaEluZGV4ICogM10gPSBtYXJrMkFuY2hvci54IC0gbWFyazFSZWNvcmQueCArIHBvc2l0aW9uc1twcmV2R2x5cGhJbmRleCAqIDNdIC0gcG9zaXRpb25zW3ByZXZHbHlwaEluZGV4ICogMyArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zW2dseXBoSW5kZXggKiAzICsgMV0gPSBtYXJrMkFuY2hvci55IC0gbWFyazFSZWNvcmQueSArIHBvc2l0aW9uc1twcmV2R2x5cGhJbmRleCAqIDMgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBrZXJuIHRhYmxlIGlmIG5vIEdQT1NcbiAgICAgICAgZWxzZSBpZiAoZm9udC5rZXJuICYmICFmb250LmNmZikge1xuICAgICAgICAgIGNvbnN0IHByZXZHbHlwaEluZGV4ID0gZ2V0UHJldkdseXBoSW5kZXgoKTtcbiAgICAgICAgICBpZiAocHJldkdseXBoSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBpbmQxID0gZm9udC5rZXJuLmdseXBoMS5pbmRleE9mKGdseXBoSWRzW3ByZXZHbHlwaEluZGV4XSk7XG4gICAgICAgICAgICBpZiAoaW5kMSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgY29uc3QgaW5kMiA9IGZvbnQua2Vybi5ydmFsW2luZDFdLmdseXBoMi5pbmRleE9mKGdseXBoSWQpO1xuICAgICAgICAgICAgICBpZiAoaW5kMiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnNbcHJldkdseXBoSW5kZXggKiAzICsgMl0gKz0gZm9udC5rZXJuLnJ2YWxbaW5kMV0udmFsc1tpbmQyXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9zaXRpb25zO1xuXG4gICAgICBmdW5jdGlvbiBnZXRQcmV2R2x5cGhJbmRleChmaWx0ZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGdseXBoSW5kZXggLSAxOyBpID49MDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGdseXBoSWRzW2ldICE9PSAtMSAmJiAoIWZpbHRlciB8fCBmaWx0ZXIoZ2x5cGhJZHNbaV0pKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0Jhc2VHbHlwaChnbHlwaElkKSB7XG4gICAgICAgIHJldHVybiBnZXRHbHlwaENsYXNzKGZvbnQsIGdseXBoSWQpID09PSAxO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhcHBseVZhbHVlUmVjb3JkKHNvdXJjZSwgZ2kpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICBwb3NpdGlvbnNbZ2kgKiAzICsgaV0gKz0gc291cmNlW2ldIHx8IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRHbHlwaENsYXNzKGZvbnQsIGdseXBoSWQpIHtcbiAgICAgIGNvbnN0IGNsYXNzRGVmID0gZm9udC5HREVGICYmIGZvbnQuR0RFRi5nbHlwaENsYXNzRGVmO1xuICAgICAgcmV0dXJuIGNsYXNzRGVmID8gVHlwci5VLl9nZXRHbHlwaENsYXNzKGdseXBoSWQsIGNsYXNzRGVmKSA6IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlyc3ROdW0oLi4uYXJncykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1tpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1tpXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgUGFyc2VkRm9udFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBGb250T2JqKHR5cHJGb250KSB7XG4gICAgICBjb25zdCBnbHlwaE1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIGNvbnN0IG9zMiA9IHR5cHJGb250WydPUy8yJ107XG4gICAgICBjb25zdCBoaGVhID0gdHlwckZvbnQuaGhlYTtcbiAgICAgIGNvbnN0IHVuaXRzUGVyRW0gPSB0eXByRm9udC5oZWFkLnVuaXRzUGVyRW07XG4gICAgICBjb25zdCBhc2NlbmRlciA9IGZpcnN0TnVtKG9zMiAmJiBvczIuc1R5cG9Bc2NlbmRlciwgaGhlYSAmJiBoaGVhLmFzY2VuZGVyLCB1bml0c1BlckVtKTtcblxuICAgICAgLyoqIEB0eXBlIFBhcnNlZEZvbnQgKi9cbiAgICAgIGNvbnN0IGZvbnRPYmogPSB7XG4gICAgICAgIHVuaXRzUGVyRW0sXG4gICAgICAgIGFzY2VuZGVyLFxuICAgICAgICBkZXNjZW5kZXI6IGZpcnN0TnVtKG9zMiAmJiBvczIuc1R5cG9EZXNjZW5kZXIsIGhoZWEgJiYgaGhlYS5kZXNjZW5kZXIsIDApLFxuICAgICAgICBjYXBIZWlnaHQ6IGZpcnN0TnVtKG9zMiAmJiBvczIuc0NhcEhlaWdodCwgYXNjZW5kZXIpLFxuICAgICAgICB4SGVpZ2h0OiBmaXJzdE51bShvczIgJiYgb3MyLnN4SGVpZ2h0LCBhc2NlbmRlciksXG4gICAgICAgIGxpbmVHYXA6IGZpcnN0TnVtKG9zMiAmJiBvczIuc1R5cG9MaW5lR2FwLCBoaGVhICYmIGhoZWEubGluZUdhcCksXG4gICAgICAgIHN1cHBvcnRzQ29kZVBvaW50KGNvZGUpIHtcbiAgICAgICAgICByZXR1cm4gVHlwci5VLmNvZGVUb0dseXBoKHR5cHJGb250LCBjb2RlKSA+IDBcbiAgICAgICAgfSxcbiAgICAgICAgZm9yRWFjaEdseXBoKHRleHQsIGZvbnRTaXplLCBsZXR0ZXJTcGFjaW5nLCBjYWxsYmFjaykge1xuICAgICAgICAgIGxldCBwZW5YID0gMDtcbiAgICAgICAgICBjb25zdCBmb250U2NhbGUgPSAxIC8gZm9udE9iai51bml0c1BlckVtICogZm9udFNpemU7XG5cbiAgICAgICAgICBjb25zdCBnbHlwaElkcyA9IHN0cmluZ1RvR2x5cGhzKHR5cHJGb250LCB0ZXh0KTtcbiAgICAgICAgICBsZXQgY2hhckluZGV4ID0gMDtcbiAgICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBjYWxjR2x5cGhQb3NpdGlvbnModHlwckZvbnQsIGdseXBoSWRzKTtcblxuICAgICAgICAgIGdseXBoSWRzLmZvckVhY2goKGdseXBoSWQsIGkpID0+IHtcbiAgICAgICAgICAgIC8vIFR5cHIgcmV0dXJucyBhIGdseXBoIGluZGV4IHBlciBzdHJpbmcgY29kZXBvaW50LCB3aXRoIC0xcyBpbiBwbGFjZSBvZiB0aG9zZSB0aGF0XG4gICAgICAgICAgICAvLyB3ZXJlIG9taXR0ZWQgZHVlIHRvIGxpZ2F0dXJlIHN1YnN0aXR1dGlvbi4gU28gd2UgY2FuIHRyYWNrIG9yaWdpbmFsIGluZGV4IGluIHRoZVxuICAgICAgICAgICAgLy8gc3RyaW5nIHZpYSBzaW1wbGUgaW5jcmVtZW50LCBhbmQgc2tpcCBldmVyeXRoaW5nIGVsc2Ugd2hlbiBzZWVpbmcgYSAtMS5cbiAgICAgICAgICAgIGlmIChnbHlwaElkICE9PSAtMSkge1xuICAgICAgICAgICAgICBsZXQgZ2x5cGhPYmogPSBnbHlwaE1hcFtnbHlwaElkXTtcbiAgICAgICAgICAgICAgaWYgKCFnbHlwaE9iaikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHtjbWRzLCBjcmRzfSA9IFR5cHIuVS5nbHlwaFRvUGF0aCh0eXByRm9udCwgZ2x5cGhJZCk7XG5cbiAgICAgICAgICAgICAgICAvLyBCdWlsZCBwYXRoIHN0cmluZ1xuICAgICAgICAgICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgICAgICAgICAgbGV0IGNyZHNJZHggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjbWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBudW1BcmdzID0gY21kQXJnTGVuZ3Roc1tjbWRzW2ldXTtcbiAgICAgICAgICAgICAgICAgIHBhdGggKz0gY21kc1tpXTtcbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAxOyBqIDw9IG51bUFyZ3M7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBwYXRoICs9IChqID4gMSA/ICcsJyA6ICcnKSArIGNyZHNbY3Jkc0lkeCsrXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5kIGV4dGVudHMgLSBHbHlmIGdpdmVzIHRoaXMgaW4gbWV0YWRhdGEgYnV0IG5vdCBDRkYsIGFuZCBUeXByIGRvZXNuJ3RcbiAgICAgICAgICAgICAgICAvLyBub3JtYWxpemUgdGhlIHR3bywgc28gaXQncyBzaW1wbGVzdCBqdXN0IHRvIGl0ZXJhdGUgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICAgIGxldCB4TWluLCB5TWluLCB4TWF4LCB5TWF4O1xuICAgICAgICAgICAgICAgIGlmIChjcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgeE1pbiA9IHlNaW4gPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICAgIHhNYXggPSB5TWF4ID0gLUluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNyZHMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHggPSBjcmRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBsZXQgeSA9IGNyZHNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeCA8IHhNaW4pIHhNaW4gPSB4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoeSA8IHlNaW4pIHlNaW4gPSB5O1xuICAgICAgICAgICAgICAgICAgICBpZiAoeCA+IHhNYXgpIHhNYXggPSB4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoeSA+IHlNYXgpIHlNYXggPSB5O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB4TWluID0geE1heCA9IHlNaW4gPSB5TWF4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBnbHlwaE9iaiA9IGdseXBoTWFwW2dseXBoSWRdID0ge1xuICAgICAgICAgICAgICAgICAgaW5kZXg6IGdseXBoSWQsXG4gICAgICAgICAgICAgICAgICBhZHZhbmNlV2lkdGg6IHR5cHJGb250LmhtdHguYVdpZHRoW2dseXBoSWRdLFxuICAgICAgICAgICAgICAgICAgeE1pbixcbiAgICAgICAgICAgICAgICAgIHlNaW4sXG4gICAgICAgICAgICAgICAgICB4TWF4LFxuICAgICAgICAgICAgICAgICAgeU1heCxcbiAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBnbHlwaE9iaixcbiAgICAgICAgICAgICAgICBwZW5YICsgcG9zaXRpb25zW2kgKiAzXSAqIGZvbnRTY2FsZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnNbaSAqIDMgKyAxXSAqIGZvbnRTY2FsZSxcbiAgICAgICAgICAgICAgICBjaGFySW5kZXhcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBwZW5YICs9IHBvc2l0aW9uc1tpICogMyArIDJdICogZm9udFNjYWxlO1xuICAgICAgICAgICAgICBpZiAobGV0dGVyU3BhY2luZykge1xuICAgICAgICAgICAgICAgIHBlblggKz0gbGV0dGVyU3BhY2luZyAqIGZvbnRTaXplO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFySW5kZXggKz0gKHRleHQuY29kZVBvaW50QXQoY2hhckluZGV4KSA+IDB4ZmZmZiA/IDIgOiAxKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBwZW5YXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBmb250T2JqXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUgRm9udFBhcnNlclxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiBwYXJzZShidWZmZXIpIHtcbiAgICAgIC8vIExvb2sgdG8gc2VlIGlmIHdlIGhhdmUgYSBXT0ZGIGZpbGUgYW5kIGNvbnZlcnQgaXQgaWYgc286XG4gICAgICBjb25zdCBwZWVrID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCAwLCA0KTtcbiAgICAgIGNvbnN0IHRhZyA9IFR5cHIuX2Jpbi5yZWFkQVNDSUkocGVlaywgMCwgNCk7XG4gICAgICBpZiAodGFnID09PSAnd09GRicpIHtcbiAgICAgICAgYnVmZmVyID0gd29mZjJvdGYoYnVmZmVyKTtcbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSAnd09GMicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3b2ZmMiBmb250cyBub3Qgc3VwcG9ydGVkJylcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwRm9udE9iaihUeXByLnBhcnNlKGJ1ZmZlcilbMF0pXG4gICAgfVxuICB9XG5cblxuICBjb25zdCB3b3JrZXJNb2R1bGUgPSAvKiNfX1BVUkVfXyovdHJvaWthV29ya2VyVXRpbHMuZGVmaW5lV29ya2VyTW9kdWxlKHtcbiAgICBuYW1lOiAnVHlwciBGb250IFBhcnNlcicsXG4gICAgZGVwZW5kZW5jaWVzOiBbdHlwckZhY3RvcnksIHdvZmYyb3RmRmFjdG9yeSwgcGFyc2VyRmFjdG9yeV0sXG4gICAgaW5pdCh0eXByRmFjdG9yeSwgd29mZjJvdGZGYWN0b3J5LCBwYXJzZXJGYWN0b3J5KSB7XG4gICAgICBjb25zdCBUeXByID0gdHlwckZhY3RvcnkoKTtcbiAgICAgIGNvbnN0IHdvZmYyb3RmID0gd29mZjJvdGZGYWN0b3J5KCk7XG4gICAgICByZXR1cm4gcGFyc2VyRmFjdG9yeShUeXByLCB3b2ZmMm90ZilcbiAgICB9XG4gIH0pO1xuXG4gIC8qIVxuICBDdXN0b20gYnVuZGxlIG9mIEB1bmljb2RlLWZvbnQtcmVzb2x2ZXIvY2xpZW50IHYxLjAuMiAoaHR0cHM6Ly9naXRodWIuY29tL2xvamppYy91bmljb2RlLWZvbnQtcmVzb2x2ZXIpXG4gIGZvciB1c2UgaW4gVHJvaWthIHRleHQgcmVuZGVyaW5nLiBcbiAgT3JpZ2luYWwgTUlUIGxpY2Vuc2UgYXBwbGllc1xuICAqL1xuICBmdW5jdGlvbiB1bmljb2RlRm9udFJlc29sdmVyQ2xpZW50RmFjdG9yeSgpe3JldHVybiBmdW5jdGlvbih0KXt2YXIgbj1mdW5jdGlvbigpe3RoaXMuYnVja2V0cz1uZXcgTWFwO307bi5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3ZhciBuPXQ+PjU7dGhpcy5idWNrZXRzLnNldChuLCh0aGlzLmJ1Y2tldHMuZ2V0KG4pfHwwKXwxPDwoMzEmdCkpO30sbi5wcm90b3R5cGUuaGFzPWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXMuYnVja2V0cy5nZXQodD4+NSk7cmV0dXJuIHZvaWQgMCE9PW4mJjAhPShuJjE8PCgzMSZ0KSl9LG4ucHJvdG90eXBlLnNlcmlhbGl6ZT1mdW5jdGlvbigpe3ZhciB0PVtdO3JldHVybiB0aGlzLmJ1Y2tldHMuZm9yRWFjaCgoZnVuY3Rpb24obixyKXt0LnB1c2goKCtyKS50b1N0cmluZygzNikrXCI6XCIrbi50b1N0cmluZygzNikpO30pKSx0LmpvaW4oXCIsXCIpfSxuLnByb3RvdHlwZS5kZXNlcmlhbGl6ZT1mdW5jdGlvbih0KXt2YXIgbj10aGlzO3RoaXMuYnVja2V0cy5jbGVhcigpLHQuc3BsaXQoXCIsXCIpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciByPXQuc3BsaXQoXCI6XCIpO24uYnVja2V0cy5zZXQocGFyc2VJbnQoclswXSwzNikscGFyc2VJbnQoclsxXSwzNikpO30pKTt9O3ZhciByPU1hdGgucG93KDIsOCksZT1yLTEsbz1+ZTtmdW5jdGlvbiBhKHQpe3ZhciBuPWZ1bmN0aW9uKHQpe3JldHVybiB0Jm99KHQpLnRvU3RyaW5nKDE2KSxlPWZ1bmN0aW9uKHQpe3JldHVybiAodCZvKStyLTF9KHQpLnRvU3RyaW5nKDE2KTtyZXR1cm4gXCJjb2RlcG9pbnQtaW5kZXgvcGxhbmVcIisodD4+MTYpK1wiL1wiK24rXCItXCIrZStcIi5qc29uXCJ9ZnVuY3Rpb24gaSh0LG4pe3ZhciByPXQmZSxvPW4uY29kZVBvaW50QXQoci82fDApO3JldHVybiAwIT0oKG89KG98fDQ4KS00OCkmMTw8ciU2KX1mdW5jdGlvbiB1KHQsbil7dmFyIHI7KHI9dCxyLnJlcGxhY2UoL1VcXCsvZ2ksXCJcIikucmVwbGFjZSgvXiwrfCwrJC9nLFwiXCIpLnNwbGl0KC8sKy8pLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3BsaXQoXCItXCIpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHBhcnNlSW50KHQudHJpbSgpLDE2KX0pKX0pKSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIHI9dFswXSxlPXRbMV07dm9pZCAwPT09ZSYmKGU9ciksbihyLGUpO30pKTt9ZnVuY3Rpb24gYyh0LG4pe3UodCwoZnVuY3Rpb24odCxyKXtmb3IodmFyIGU9dDtlPD1yO2UrKyluKGUpO30pKTt9dmFyIHM9e30sZj17fSxsPW5ldyBXZWFrTWFwLHY9XCJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvZ2gvbG9qamljL3VuaWNvZGUtZm9udC1yZXNvbHZlckB2MS4wLjEvcGFja2FnZXMvZGF0YVwiO2Z1bmN0aW9uIGQodCl7dmFyIHI9bC5nZXQodCk7cmV0dXJuIHJ8fChyPW5ldyBuLGModC5yYW5nZXMsKGZ1bmN0aW9uKHQpe3JldHVybiByLmFkZCh0KX0pKSxsLnNldCh0LHIpKSxyfXZhciBoLHA9bmV3IE1hcDtmdW5jdGlvbiBnKHQsbixyKXtyZXR1cm4gdFtuXT9uOnRbcl0/cjpmdW5jdGlvbih0KXtmb3IodmFyIG4gaW4gdClyZXR1cm4gbn0odCl9ZnVuY3Rpb24gdyh0LG4pe3ZhciByPW47aWYoIXQuaW5jbHVkZXMocikpe3I9MS8wO2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKU1hdGguYWJzKHRbZV0tbik8TWF0aC5hYnMoci1uKSYmKHI9dFtlXSk7fXJldHVybiByfWZ1bmN0aW9uIGsodCl7cmV0dXJuIGh8fChoPW5ldyBTZXQsYyhcIjktRCwyMCw4NSxBMCwxNjgwLDIwMDAtMjAwQSwyMDI4LTIwMkYsMjA1RiwzMDAwXCIsKGZ1bmN0aW9uKHQpe2guYWRkKHQpO30pKSksaC5oYXModCl9cmV0dXJuIHQuQ29kZVBvaW50U2V0PW4sdC5jbGVhckNhY2hlPWZ1bmN0aW9uKCl7cz17fSxmPXt9O30sdC5nZXRGb250c0ZvclN0cmluZz1mdW5jdGlvbih0LG4pe3ZvaWQgMD09PW4mJihuPXt9KTt2YXIgcixlPW4ubGFuZzt2b2lkIDA9PT1lJiYoZT0vXFxwe1NjcmlwdD1IYW5ndWx9L3UudGVzdChyPXQpP1wia29cIjovXFxwe1NjcmlwdD1IaXJhZ2FuYX18XFxwe1NjcmlwdD1LYXRha2FuYX0vdS50ZXN0KHIpP1wiamFcIjpcImVuXCIpO3ZhciBvPW4uY2F0ZWdvcnk7dm9pZCAwPT09byYmKG89XCJzYW5zLXNlcmlmXCIpO3ZhciB1PW4uc3R5bGU7dm9pZCAwPT09dSYmKHU9XCJub3JtYWxcIik7dmFyIGM9bi53ZWlnaHQ7dm9pZCAwPT09YyYmKGM9NDAwKTt2YXIgbD0obi5kYXRhVXJsfHx2KS5yZXBsYWNlKC9cXC8kL2csXCJcIiksaD1uZXcgTWFwLHk9bmV3IFVpbnQ4QXJyYXkodC5sZW5ndGgpLGI9e30sbT17fSxBPW5ldyBBcnJheSh0Lmxlbmd0aCksUz1uZXcgTWFwLGo9ITE7ZnVuY3Rpb24gTSh0KXt2YXIgbj1wLmdldCh0KTtyZXR1cm4gbnx8KG49ZmV0Y2gobCtcIi9cIit0KS50aGVuKChmdW5jdGlvbih0KXtpZighdC5vayl0aHJvdyBuZXcgRXJyb3IodC5zdGF0dXNUZXh0KTtyZXR1cm4gdC5qc29uKCkudGhlbigoZnVuY3Rpb24odCl7aWYoIUFycmF5LmlzQXJyYXkodCl8fDEhPT10WzBdKXRocm93IG5ldyBFcnJvcihcIkluY29ycmVjdCBzY2hlbWEgdmVyc2lvbjsgbmVlZCAxLCBnb3QgXCIrdFswXSk7cmV0dXJuIHRbMV19KSl9KSkuY2F0Y2goKGZ1bmN0aW9uKG4pe2lmKGwhPT12KXJldHVybiBqfHwoY29uc29sZS5lcnJvcigndW5pY29kZS1mb250LXJlc29sdmVyOiBGYWlsZWQgbG9hZGluZyBmcm9tIGRhdGFVcmwgXCInK2wrJ1wiLCB0cnlpbmcgZGVmYXVsdCBDRE4uICcrbi5tZXNzYWdlKSxqPSEwKSxsPXYscC5kZWxldGUodCksTSh0KTt0aHJvdyBufSkpLHAuc2V0KHQsbikpLG59Zm9yKHZhciBQPWZ1bmN0aW9uKG4pe3ZhciByPXQuY29kZVBvaW50QXQobiksZT1hKHIpO0Fbbl09ZSxzW2VdfHxTLmhhcyhlKXx8Uy5zZXQoZSxNKGUpLnRoZW4oKGZ1bmN0aW9uKHQpe3NbZV09dDt9KSkpLHI+NjU1MzUmJihuKyssRT1uKTt9LEU9MDtFPHQubGVuZ3RoO0UrKylQKEUpO3JldHVybiBQcm9taXNlLmFsbChTLnZhbHVlcygpKS50aGVuKChmdW5jdGlvbigpe1MuY2xlYXIoKTtmb3IodmFyIG49ZnVuY3Rpb24obil7dmFyIG89dC5jb2RlUG9pbnRBdChuKSxhPW51bGwsdT1zW0Fbbl1dLGM9dm9pZCAwO2Zvcih2YXIgbCBpbiB1KXt2YXIgdj1tW2xdO2lmKHZvaWQgMD09PXYmJih2PW1bbF09bmV3IFJlZ0V4cChsKS50ZXN0KGV8fFwiZW5cIikpLHYpe2Zvcih2YXIgZCBpbiBjPWwsdVtsXSlpZihpKG8sdVtsXVtkXSkpe2E9ZDticmVha31icmVha319aWYoIWEpdDpmb3IodmFyIGggaW4gdSlpZihoIT09Yylmb3IodmFyIHAgaW4gdVtoXSlpZihpKG8sdVtoXVtwXSkpe2E9cDticmVhayB0fWF8fChjb25zb2xlLmRlYnVnKFwiTm8gZm9udCBjb3ZlcmFnZSBmb3IgVStcIitvLnRvU3RyaW5nKDE2KSksYT1cImxhdGluXCIpLEFbbl09YSxmW2FdfHxTLmhhcyhhKXx8Uy5zZXQoYSxNKFwiZm9udC1tZXRhL1wiK2ErXCIuanNvblwiKS50aGVuKChmdW5jdGlvbih0KXtmW2FdPXQ7fSkpKSxvPjY1NTM1JiYobisrLHI9bik7fSxyPTA7cjx0Lmxlbmd0aDtyKyspbihyKTtyZXR1cm4gUHJvbWlzZS5hbGwoUy52YWx1ZXMoKSl9KSkudGhlbigoZnVuY3Rpb24oKXtmb3IodmFyIG4scj1udWxsLGU9MDtlPHQubGVuZ3RoO2UrKyl7dmFyIGE9dC5jb2RlUG9pbnRBdChlKTtpZihyJiYoayhhKXx8ZChyKS5oYXMoYSkpKXlbZV09eVtlLTFdO2Vsc2Uge3I9ZltBW2VdXTt2YXIgaT1iW3IuaWRdO2lmKCFpKXt2YXIgcz1yLnR5cGVmb3Jtcyx2PWcocyxvLFwic2Fucy1zZXJpZlwiKSxwPWcoc1t2XSx1LFwibm9ybWFsXCIpLG09dyhudWxsPT09KG49c1t2XSl8fHZvaWQgMD09PW4/dm9pZCAwOm5bcF0sYyk7aT1iW3IuaWRdPWwrXCIvZm9udC1maWxlcy9cIityLmlkK1wiL1wiK3YrXCIuXCIrcCtcIi5cIittK1wiLndvZmZcIjt9dmFyIFM9aC5nZXQoaSk7bnVsbD09UyYmKFM9aC5zaXplLGguc2V0KGksUykpLHlbZV09Uzt9YT42NTUzNSYmKGUrKyx5W2VdPXlbZS0xXSk7fXJldHVybiB7Zm9udFVybHM6QXJyYXkuZnJvbShoLmtleXMoKSksY2hhcnM6eX19KSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHR9KHt9KX1cblxuICAvKipcbiAgICogQHR5cGVkZWYge3N0cmluZyB8IHtzcmM6c3RyaW5nLCBsYWJlbD86c3RyaW5nLCB1bmljb2RlUmFuZ2U/OnN0cmluZywgbGFuZz86c3RyaW5nfX0gVXNlckZvbnRcbiAgICovXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtDbGllbnRPcHRpb25zfSBGb250UmVzb2x2ZXJPcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8VXNlckZvbnQ+fFVzZXJGb250fSBbZm9udHNdXG4gICAqIEBwcm9wZXJ0eSB7J25vcm1hbCd8J2l0YWxpYyd9IFtzdHlsZV1cbiAgICogQHByb3BlcnR5IHsnbm9ybWFsJ3wnYm9sZCd8bnVtYmVyfSBbc3R5bGVdXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdW5pY29kZUZvbnRzVVJMXVxuICAgKi9cblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gRm9udFJlc29sdmVyUmVzdWx0XG4gICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gY2hhcnNcbiAgICogQHByb3BlcnR5IHtBcnJheTxQYXJzZWRGb250ICYge3NyYzpzdHJpbmd9Pn0gZm9udHNcbiAgICovXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtmdW5jdGlvbn0gRm9udFJlc29sdmVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7KEZvbnRSZXNvbHZlclJlc3VsdCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtGb250UmVzb2x2ZXJPcHRpb25zfSBbb3B0aW9uc11cbiAgICovXG5cbiAgLyoqXG4gICAqIEZhY3RvcnkgZm9yIHRoZSBGb250UmVzb2x2ZXIgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7Rm9udFBhcnNlcn0gZm9udFBhcnNlclxuICAgKiBAcGFyYW0ge3tnZXRGb250c0ZvclN0cmluZzogZnVuY3Rpb24sIENvZGVQb2ludFNldDogZnVuY3Rpb259fSB1bmljb2RlRm9udFJlc29sdmVyQ2xpZW50XG4gICAqIEByZXR1cm4ge0ZvbnRSZXNvbHZlcn1cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUZvbnRSZXNvbHZlcihmb250UGFyc2VyLCB1bmljb2RlRm9udFJlc29sdmVyQ2xpZW50KSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1JlY29yZDxzdHJpbmcsIFBhcnNlZEZvbnQ+fVxuICAgICAqL1xuICAgIGNvbnN0IHBhcnNlZEZvbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBBcnJheTwoUGFyc2VkRm9udCkgPT4gdm9pZD4+fVxuICAgICAqL1xuICAgIGNvbnN0IGxvYWRpbmdGb250cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGEgZ2l2ZW4gZm9udCB1cmxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0xvYWRGb250KHVybCwgY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IG9uRXJyb3IgPSBlcnIgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsdXJlIGxvYWRpbmcgZm9udCAke3VybH1gLCBlcnIpO1xuICAgICAgfTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgcmVxdWVzdC5vcGVuKCdnZXQnLCB1cmwsIHRydWUpO1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgICAgIG9uRXJyb3IobmV3IEVycm9yKHJlcXVlc3Quc3RhdHVzVGV4dCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChyZXF1ZXN0LnN0YXR1cyA+IDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZvbnRPYmogPSBmb250UGFyc2VyKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgICBmb250T2JqLnNyYyA9IHVybDtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZm9udE9iaik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBvbkVycm9yO1xuICAgICAgICByZXF1ZXN0LnNlbmQoKTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIExvYWQgYSBnaXZlbiBmb250IHVybCBpZiBuZWVkZWQsIGludm9raW5nIGEgY2FsbGJhY2sgd2hlbiBpdCdzIGxvYWRlZC4gSWYgYWxyZWFkeVxuICAgICAqIGxvYWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnRVcmxcbiAgICAgKiBAcGFyYW0geyhmb250OiBQYXJzZWRGb250KSA9PiB2b2lkfSBjYWxsYmFja1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvYWRGb250KGZvbnRVcmwsIGNhbGxiYWNrKSB7XG4gICAgICBsZXQgZm9udCA9IHBhcnNlZEZvbnRzW2ZvbnRVcmxdO1xuICAgICAgaWYgKGZvbnQpIHtcbiAgICAgICAgY2FsbGJhY2soZm9udCk7XG4gICAgICB9IGVsc2UgaWYgKGxvYWRpbmdGb250c1tmb250VXJsXSkge1xuICAgICAgICBsb2FkaW5nRm9udHNbZm9udFVybF0ucHVzaChjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkaW5nRm9udHNbZm9udFVybF0gPSBbY2FsbGJhY2tdO1xuICAgICAgICBkb0xvYWRGb250KGZvbnRVcmwsIGZvbnRPYmogPT4ge1xuICAgICAgICAgIGZvbnRPYmouc3JjID0gZm9udFVybDtcbiAgICAgICAgICBwYXJzZWRGb250c1tmb250VXJsXSA9IGZvbnRPYmo7XG4gICAgICAgICAgbG9hZGluZ0ZvbnRzW2ZvbnRVcmxdLmZvckVhY2goY2IgPT4gY2IoZm9udE9iaikpO1xuICAgICAgICAgIGRlbGV0ZSBsb2FkaW5nRm9udHNbZm9udFVybF07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvciBhIGdpdmVuIHN0cmluZyBvZiB0ZXh0LCBkZXRlcm1pbmUgd2hpY2ggZm9udHMgYXJlIHJlcXVpcmVkIHRvIGZ1bGx5IHJlbmRlciBpdCBhbmRcbiAgICAgKiBlbnN1cmUgdGhvc2UgZm9udHMgYXJlIGxvYWRlZC5cbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gKHRleHQsIGNhbGxiYWNrLCB7XG4gICAgICBsYW5nLFxuICAgICAgZm9udHM6IHVzZXJGb250cyA9IFtdLFxuICAgICAgc3R5bGUgPSAnbm9ybWFsJyxcbiAgICAgIHdlaWdodCA9ICdub3JtYWwnLFxuICAgICAgdW5pY29kZUZvbnRzVVJMXG4gICAgfSA9IHt9KSB7XG4gICAgICBjb25zdCBjaGFyUmVzb2x1dGlvbnMgPSBuZXcgVWludDhBcnJheSh0ZXh0Lmxlbmd0aCk7XG4gICAgICBjb25zdCBmb250UmVzb2x1dGlvbnMgPSBbXTtcbiAgICAgIGlmICghdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgYWxsRG9uZSgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmb250SW5kaWNlcyA9IG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrUmFuZ2VzID0gW107IC8vIFtbc3RhcnQsIGVuZF0sIC4uLl1cblxuICAgICAgaWYgKHN0eWxlICE9PSAnaXRhbGljJykgc3R5bGUgPSAnbm9ybWFsJztcbiAgICAgIGlmICh0eXBlb2Ygd2VpZ2h0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB3ZWlnaHQgPSB3ZWlnaHQgPT09ICdib2xkJyA/IDcwMCA6IDQwMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHVzZXJGb250cyAmJiAhQXJyYXkuaXNBcnJheSh1c2VyRm9udHMpKSB7XG4gICAgICAgIHVzZXJGb250cyA9IFt1c2VyRm9udHNdO1xuICAgICAgfVxuICAgICAgdXNlckZvbnRzID0gdXNlckZvbnRzLnNsaWNlKClcbiAgICAgICAgLy8gZmlsdGVyIGJ5IGxhbmd1YWdlXG4gICAgICAgIC5maWx0ZXIoZGVmID0+ICFkZWYubGFuZyB8fCBkZWYubGFuZy50ZXN0KGxhbmcpKVxuICAgICAgICAvLyBzd2l0Y2ggb3JkZXIgZm9yIGVhc2llciBpdGVyYXRpb25cbiAgICAgICAgLnJldmVyc2UoKTtcbiAgICAgIGlmICh1c2VyRm9udHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IFVOS05PV04gPSAwO1xuICAgICAgICBjb25zdCBSRVNPTFZFRCA9IDE7XG4gICAgICAgIGNvbnN0IE5FRURTX0ZBTExCQUNLID0gMjtcbiAgICAgICAgbGV0IHByZXZDaGFyUmVzdWx0ID0gVU5LTk9XTlxuXG4gICAgICAgIDsoZnVuY3Rpb24gcmVzb2x2ZVVzZXJGb250cyAoc3RhcnRJbmRleCA9IDApIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleCwgaUxlbiA9IHRleHQubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSB0ZXh0LmNvZGVQb2ludEF0KGkpO1xuICAgICAgICAgICAgLy8gQ2FycnkgcHJldmlvdXMgY2hhcmFjdGVyJ3MgcmVzdWx0IGZvcndhcmQgaWY6XG4gICAgICAgICAgICAvLyAtIGl0IHJlc29sdmVkIHRvIGEgZm9udCB0aGF0IGFsc28gY292ZXJzIHRoaXMgY2hhcmFjdGVyXG4gICAgICAgICAgICAvLyAtIHRoaXMgY2hhcmFjdGVyIGlzIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKHByZXZDaGFyUmVzdWx0ID09PSBSRVNPTFZFRCAmJiBmb250UmVzb2x1dGlvbnNbY2hhclJlc29sdXRpb25zW2kgLSAxXV0uc3VwcG9ydHNDb2RlUG9pbnQoY29kZVBvaW50KSkgfHxcbiAgICAgICAgICAgICAgKGkgPiAwICYmIC9cXHMvLnRlc3QodGV4dFtpXSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY2hhclJlc29sdXRpb25zW2ldID0gY2hhclJlc29sdXRpb25zW2kgLSAxXTtcbiAgICAgICAgICAgICAgaWYgKHByZXZDaGFyUmVzdWx0ID09PSBORUVEU19GQUxMQkFDSykge1xuICAgICAgICAgICAgICAgIGZhbGxiYWNrUmFuZ2VzW2ZhbGxiYWNrUmFuZ2VzLmxlbmd0aCAtIDFdWzFdID0gaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGNoYXJSZXNvbHV0aW9uc1tpXSwgakxlbiA9IHVzZXJGb250cy5sZW5ndGg7IGogPD0gakxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IGpMZW4pIHtcbiAgICAgICAgICAgICAgICAgIC8vIG5vbmUgb2YgdGhlIHVzZXIgZm9udHMgbWF0Y2hlZDsgbmVlZHMgZmFsbGJhY2tcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gcHJldkNoYXJSZXN1bHQgPT09IE5FRURTX0ZBTExCQUNLID9cbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tSYW5nZXNbZmFsbGJhY2tSYW5nZXMubGVuZ3RoIC0gMV0gOlxuICAgICAgICAgICAgICAgICAgICAoZmFsbGJhY2tSYW5nZXNbZmFsbGJhY2tSYW5nZXMubGVuZ3RoXSA9IFtpLCBpXSk7XG4gICAgICAgICAgICAgICAgICByYW5nZVsxXSA9IGk7XG4gICAgICAgICAgICAgICAgICBwcmV2Q2hhclJlc3VsdCA9IE5FRURTX0ZBTExCQUNLO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjaGFyUmVzb2x1dGlvbnNbaV0gPSBqO1xuICAgICAgICAgICAgICAgICAgY29uc3QgeyBzcmMsIHVuaWNvZGVSYW5nZSB9ID0gdXNlckZvbnRzW2pdO1xuICAgICAgICAgICAgICAgICAgLy8gZmlsdGVyIGJ5IG9wdGlvbmFsIGV4cGxpY2l0IHVuaWNvZGUgcmFuZ2VzXG4gICAgICAgICAgICAgICAgICBpZiAoIXVuaWNvZGVSYW5nZSB8fCBpc0NvZGVJblJhbmdlcyhjb2RlUG9pbnQsIHVuaWNvZGVSYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9udE9iaiA9IHBhcnNlZEZvbnRzW3NyY107XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvbnQgbm90IHlldCBsb2FkZWQsIGxvYWQgaXQgYW5kIHJlc3VtZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvbnRPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICBsb2FkRm9udChzcmMsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVVc2VyRm9udHMoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmb250IGFjdHVhbGx5IGNvbnRhaW5zIGEgZ2x5cGggZm9yIHRoaXMgY2hhciwgbG9jayBpdCBpblxuICAgICAgICAgICAgICAgICAgICBpZiAoZm9udE9iai5zdXBwb3J0c0NvZGVQb2ludChjb2RlUG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IGZvbnRJbmRleCA9IGZvbnRJbmRpY2VzLmdldChmb250T2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvbnRJbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRJbmRleCA9IGZvbnRSZXNvbHV0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb250UmVzb2x1dGlvbnMucHVzaChmb250T2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRJbmRpY2VzLnNldChmb250T2JqLCBmb250SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjaGFyUmVzb2x1dGlvbnNbaV0gPSBmb250SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgcHJldkNoYXJSZXN1bHQgPSBSRVNPTFZFRDtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhmZmZmICYmIGkgKyAxIDwgaUxlbikge1xuICAgICAgICAgICAgICBjaGFyUmVzb2x1dGlvbnNbaSArIDFdID0gY2hhclJlc29sdXRpb25zW2ldO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIGlmIChwcmV2Q2hhclJlc3VsdCA9PT0gTkVFRFNfRkFMTEJBQ0spIHtcbiAgICAgICAgICAgICAgICBmYWxsYmFja1Jhbmdlc1tmYWxsYmFja1Jhbmdlcy5sZW5ndGggLSAxXVsxXSA9IGk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZUZhbGxiYWNrcygpO1xuICAgICAgICB9KSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmFsbGJhY2tSYW5nZXMucHVzaChbMCwgdGV4dC5sZW5ndGggLSAxXSk7XG4gICAgICAgIHJlc29sdmVGYWxsYmFja3MoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVzb2x2ZUZhbGxiYWNrcygpIHtcbiAgICAgICAgaWYgKGZhbGxiYWNrUmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIENvbWJpbmUgYWxsIGZhbGxiYWNrIHN1YnN0cmluZ3MgaW50byBhIHNpbmdsZSBzdHJpbmcgZm9yIHF1ZXJ5aW5nXG4gICAgICAgICAgY29uc3QgZmFsbGJhY2tTdHJpbmcgPSBmYWxsYmFja1Jhbmdlcy5tYXAocmFuZ2UgPT4gdGV4dC5zdWJzdHJpbmcocmFuZ2VbMF0sIHJhbmdlWzFdICsgMSkpLmpvaW4oJ1xcbicpO1xuICAgICAgICAgIHVuaWNvZGVGb250UmVzb2x2ZXJDbGllbnQuZ2V0Rm9udHNGb3JTdHJpbmcoZmFsbGJhY2tTdHJpbmcsIHtcbiAgICAgICAgICAgIGxhbmc6IGxhbmcgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICB3ZWlnaHQsXG4gICAgICAgICAgICBkYXRhVXJsOiB1bmljb2RlRm9udHNVUkxcbiAgICAgICAgICB9KS50aGVuKCh7Zm9udFVybHMsIGNoYXJzfSkgPT4ge1xuICAgICAgICAgICAgLy8gRXh0cmFjdCByZXN1bHRzIGFuZCBwdXQgdGhlbSBiYWNrIGluIHRoZSBtYWluIGFycmF5XG4gICAgICAgICAgICBjb25zdCBmb250SW5kZXhPZmZzZXQgPSBmb250UmVzb2x1dGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGNoYXJJZHggPSAwO1xuICAgICAgICAgICAgZmFsbGJhY2tSYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBlbmRJZHggPSByYW5nZVsxXSAtIHJhbmdlWzBdOyBpIDw9IGVuZElkeDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hhclJlc29sdXRpb25zW3JhbmdlWzBdICsgaV0gPSBjaGFyc1tjaGFySWR4KytdICsgZm9udEluZGV4T2Zmc2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoYXJJZHgrKzsgLy9za2lwIHNlZ21lbnQgc2VwYXJhdG9yXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gTG9hZCBhbmQgcGFyc2UgdGhlIGZhbGxiYWNrIGZvbnRzIC0gYXZvaWRpbmcgUHJvbWlzZSBoZXJlIHRvIHByZXZlbnQgcG9seWZpbGxzIGluIHRoZSB3b3JrZXJcbiAgICAgICAgICAgIGxldCBsb2FkZWRDb3VudCA9IDA7XG4gICAgICAgICAgICBmb250VXJscy5mb3JFYWNoKCh1cmwsIGkpID0+IHtcbiAgICAgICAgICAgICAgbG9hZEZvbnQodXJsLCBmb250T2JqID0+IHtcbiAgICAgICAgICAgICAgICBmb250UmVzb2x1dGlvbnNbaSArIGZvbnRJbmRleE9mZnNldF0gPSBmb250T2JqO1xuICAgICAgICAgICAgICAgIGlmICgrK2xvYWRlZENvdW50ID09PSBmb250VXJscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGFsbERvbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxsRG9uZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFsbERvbmUoKSB7XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICBjaGFyczogY2hhclJlc29sdXRpb25zLFxuICAgICAgICAgIGZvbnRzOiBmb250UmVzb2x1dGlvbnNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzQ29kZUluUmFuZ2VzKGNvZGUsIHJhbmdlcykge1xuICAgICAgICAvLyB0b2RvIG9wdGltaXplIHNlYXJjaCAtIENvZGVQb2ludFNldCBmcm9tIHVuaWNvZGUtZm9udC1yZXNvbHZlcj9cbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByYW5nZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICBjb25zdCBbc3RhcnQsIGVuZCA9IHN0YXJ0XSA9IHJhbmdlc1trXTtcbiAgICAgICAgICBpZiAoc3RhcnQgPD0gY29kZSAmJiBjb2RlIDw9IGVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZm9udFJlc29sdmVyV29ya2VyTW9kdWxlID0gLyojX19QVVJFX18qL3Ryb2lrYVdvcmtlclV0aWxzLmRlZmluZVdvcmtlck1vZHVsZSh7XG4gICAgbmFtZTogJ0ZvbnRSZXNvbHZlcicsXG4gICAgZGVwZW5kZW5jaWVzOiBbXG4gICAgICBjcmVhdGVGb250UmVzb2x2ZXIsXG4gICAgICB3b3JrZXJNb2R1bGUsXG4gICAgICB1bmljb2RlRm9udFJlc29sdmVyQ2xpZW50RmFjdG9yeSxcbiAgICBdLFxuICAgIGluaXQoY3JlYXRlRm9udFJlc29sdmVyLCBmb250UGFyc2VyLCB1bmljb2RlRm9udFJlc29sdmVyQ2xpZW50RmFjdG9yeSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZvbnRSZXNvbHZlcihmb250UGFyc2VyLCB1bmljb2RlRm9udFJlc29sdmVyQ2xpZW50RmFjdG9yeSgpKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7bnVtYmVyfCdsZWZ0J3wnY2VudGVyJ3wncmlnaHQnfSBBbmNob3JYVmFsdWVcbiAgICovXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7bnVtYmVyfCd0b3AnfCd0b3AtYmFzZWxpbmUnfCd0b3AtY2FwJ3wndG9wLWV4J3wnbWlkZGxlJ3wnYm90dG9tLWJhc2VsaW5lJ3wnYm90dG9tJ30gQW5jaG9yWVZhbHVlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBUeXBlc2V0UGFyYW1zXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwcm9wZXJ0eSB7VXNlckZvbnR8VXNlckZvbnRbXX0gW2ZvbnRdXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGFuZ11cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtzZGZHbHlwaFNpemU9NjRdXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZm9udFNpemU9MV1cbiAgICogQHByb3BlcnR5IHtudW1iZXJ8J25vcm1hbCd8J2JvbGQnfSBbZm9udFdlaWdodD0nbm9ybWFsJ11cbiAgICogQHByb3BlcnR5IHsnbm9ybWFsJ3wnaXRhbGljJ30gW2ZvbnRTdHlsZT0nbm9ybWFsJ11cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtsZXR0ZXJTcGFjaW5nPTBdXG4gICAqIEBwcm9wZXJ0eSB7J25vcm1hbCd8bnVtYmVyfSBbbGluZUhlaWdodD0nbm9ybWFsJ11cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhXaWR0aF1cbiAgICogQHByb3BlcnR5IHsnbHRyJ3wncnRsJ30gW2RpcmVjdGlvbj0nbHRyJ11cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0ZXh0QWxpZ249J2xlZnQnXVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW3RleHRJbmRlbnQ9MF1cbiAgICogQHByb3BlcnR5IHsnbm9ybWFsJ3wnbm93cmFwJ30gW3doaXRlU3BhY2U9J25vcm1hbCddXG4gICAqIEBwcm9wZXJ0eSB7J25vcm1hbCd8J2JyZWFrLXdvcmQnfSBbb3ZlcmZsb3dXcmFwPSdub3JtYWwnXVxuICAgKiBAcHJvcGVydHkge0FuY2hvclhWYWx1ZX0gW2FuY2hvclg9MF1cbiAgICogQHByb3BlcnR5IHtBbmNob3JZVmFsdWV9IFthbmNob3JZPTBdXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21ldHJpY3NPbmx5PWZhbHNlXVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3VuaWNvZGVGb250c1VSTF1cbiAgICogQHByb3BlcnR5IHtGb250UmVzb2x2ZXJSZXN1bHR9IFtwcmVSZXNvbHZlZEZvbnRzXVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpbmNsdWRlQ2FyZXRQb3NpdGlvbnM9ZmFsc2VdXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2h1bmtlZEJvdW5kc1NpemU9ODE5Ml1cbiAgICogQHByb3BlcnR5IHt7W3JhbmdlU3RhcnRJbmRleF06IG51bWJlcn19IFtjb2xvclJhbmdlc11cbiAgICovXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtvYmplY3R9IFR5cGVzZXRSZXN1bHRcbiAgICogQHByb3BlcnR5IHtVaW50MTZBcnJheX0gZ2x5cGhJZHMgaWQgZm9yIGVhY2ggZ2x5cGgsIHNwZWNpZmljIHRvIHRoYXQgZ2x5cGgncyBmb250XG4gICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gZ2x5cGhGb250SW5kaWNlcyBpbmRleCBpbnRvIGZvbnREYXRhIGZvciBlYWNoIGdseXBoXG4gICAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBnbHlwaFBvc2l0aW9ucyB4LHkgb2YgZWFjaCBnbHlwaCdzIG9yaWdpbiBpbiBsYXlvdXRcbiAgICogQHByb3BlcnR5IHt7W2ZvbnRdOiB7W2dseXBoSWRdOiB7cGF0aDogc3RyaW5nLCBwYXRoQm91bmRzOiBudW1iZXJbXX19fX0gZ2x5cGhEYXRhIGRhdGEgYWJvdXQgZWFjaCBnbHlwaCBhcHBlYXJpbmcgaW4gdGhlIHRleHRcbiAgICogQHByb3BlcnR5IHtUeXBlc2V0Rm9udERhdGFbXX0gZm9udERhdGEgZGF0YSBhYm91dCBlYWNoIGZvbnQgdXNlZCBpbiB0aGUgdGV4dFxuICAgKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gW2NhcmV0UG9zaXRpb25zXSBzdGFydFgsZW5kWCxib3R0b21ZIGNhcmV0IHBvc2l0aW9ucyBmb3IgZWFjaCBjaGFyXG4gICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gW2dseXBoQ29sb3JzXSBjb2xvciBmb3IgZWFjaCBnbHlwaCwgaWYgY29sb3IgcmFuZ2VzIHN1cHBsaWVkXG4gICAqICAgICAgICAgY2h1bmtlZEJvdW5kcywgLy90b3RhbCByZWN0cyBwZXIgKG49Y2h1bmtlZEJvdW5kc1NpemUpIGNvbnNlY3V0aXZlIGdseXBoc1xuICAgKiAgICAgICAgIGZvbnRTaXplLCAvL2NhbGN1bGF0ZWQgZW0gaGVpZ2h0XG4gICAqICAgICAgICAgdG9wQmFzZWxpbmU6IGFuY2hvcllPZmZzZXQgKyBsaW5lc1swXS5iYXNlbGluZSwgLy95IGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBsaW5lJ3MgYmFzZWxpbmVcbiAgICogICAgICAgICBibG9ja0JvdW5kczogWyAvL2JvdW5kcyBmb3IgdGhlIHdob2xlIGJsb2NrIG9mIHRleHQsIGluY2x1ZGluZyB2ZXJ0aWNhbCBwYWRkaW5nIGZvciBsaW5lSGVpZ2h0XG4gICAqICAgICAgICAgICBhbmNob3JYT2Zmc2V0LFxuICAgKiAgICAgICAgICAgYW5jaG9yWU9mZnNldCAtIHRvdGFsSGVpZ2h0LFxuICAgKiAgICAgICAgICAgYW5jaG9yWE9mZnNldCArIG1heExpbmVXaWR0aCxcbiAgICogICAgICAgICAgIGFuY2hvcllPZmZzZXRcbiAgICogICAgICAgICBdLFxuICAgKiAgICAgICAgIHZpc2libGVCb3VuZHMsIC8vdG90YWwgYm91bmRzIG9mIHZpc2libGUgdGV4dCBwYXRocywgbWF5IGJlIGxhcmdlciBvciBzbWFsbGVyIHRoYW4gYmxvY2tCb3VuZHNcbiAgICogICAgICAgICB0aW1pbmdzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBUeXBlc2V0Rm9udERhdGFcbiAgICogQHByb3BlcnR5IHNyY1xuICAgKiBAcHJvcGVydHkgdW5pdHNQZXJFbVxuICAgKiBAcHJvcGVydHkgYXNjZW5kZXJcbiAgICogQHByb3BlcnR5IGRlc2NlbmRlclxuICAgKiBAcHJvcGVydHkgbGluZUhlaWdodFxuICAgKiBAcHJvcGVydHkgY2FwSGVpZ2h0XG4gICAqIEBwcm9wZXJ0eSB4SGVpZ2h0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7ZnVuY3Rpb259IFR5cGVzZXR0ZXJUeXBlc2V0RnVuY3Rpb24gLSBjb21wdXRlIGZvbnRzIGFuZCBsYXlvdXQgZm9yIHNvbWUgdGV4dC5cbiAgICogQHBhcmFtIHtUeXBlc2V0UGFyYW1zfSBwYXJhbXNcbiAgICogQHBhcmFtIHsoVHlwZXNldFJlc3VsdCkgPT4gdm9pZH0gY2FsbGJhY2sgLSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0eXBlc2V0dGluZyBpcyBjb21wbGV0ZS5cbiAgICogICAgSWYgdGhlIHBhcmFtcyBpbmNsdWRlZCBgcHJlUmVzb2x2ZWRGb250c2AsIHRoaXMgd2lsbCBiZSBjYWxsZWQgc3luY2hyb25vdXNseS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtmdW5jdGlvbn0gVHlwZXNldHRlck1lYXN1cmVGdW5jdGlvbiAtIGNvbXB1dGUgd2lkdGgvaGVpZ2h0IGZvciBzb21lIHRleHQuXG4gICAqIEBwYXJhbSB7VHlwZXNldFBhcmFtc30gcGFyYW1zXG4gICAqIEBwYXJhbSB7KHdpZHRoOm51bWJlciwgaGVpZ2h0Om51bWJlcikgPT4gdm9pZH0gY2FsbGJhY2sgLSBmdW5jdGlvbiBjYWxsZWQgd2hlbiBtZWFzdXJlbWVudCBpcyBjb21wbGV0ZS5cbiAgICogICAgSWYgdGhlIHBhcmFtcyBpbmNsdWRlZCBgcHJlUmVzb2x2ZWRGb250c2AsIHRoaXMgd2lsbCBiZSBjYWxsZWQgc3luY2hyb25vdXNseS5cbiAgICovXG5cblxuICAvKipcbiAgICogRmFjdG9yeSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBzZWxmLWNvbnRhaW5lZCBlbnZpcm9ubWVudCBmb3IgcHJvY2Vzc2luZyB0ZXh0IHR5cGVzZXR0aW5nIHJlcXVlc3RzLlxuICAgKlxuICAgKiBJdCBpcyBpbXBvcnRhbnQgdGhhdCB0aGlzIGZ1bmN0aW9uIGhhcyBubyBjbG9zdXJlIGRlcGVuZGVuY2llcywgc28gdGhhdCBpdCBjYW4gYmUgZWFzaWx5IGluamVjdGVkXG4gICAqIGludG8gdGhlIHNvdXJjZSBmb3IgYSBXb3JrZXIgd2l0aG91dCByZXF1aXJpbmcgYSBidWlsZCBzdGVwIG9yIGNvbXBsZXggZGVwZW5kZW5jeSBsb2FkaW5nLiBBbGwgaXRzXG4gICAqIGRlcGVuZGVuY2llcyBtdXN0IGJlIHBhc3NlZCBpbiBhdCBpbml0aWFsaXphdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtGb250UmVzb2x2ZXJ9IHJlc29sdmVGb250cyAtIGZ1bmN0aW9uIHRvIHJlc29sdmUgYSBzdHJpbmcgdG8gcGFyc2VkIGZvbnRzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBiaWRpIC0gdGhlIGJpZGkuanMgaW1wbGVtZW50YXRpb24gb2JqZWN0XG4gICAqIEByZXR1cm4ge3t0eXBlc2V0OiBUeXBlc2V0dGVyVHlwZXNldEZ1bmN0aW9uLCBtZWFzdXJlOiBUeXBlc2V0dGVyTWVhc3VyZUZ1bmN0aW9ufX1cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVR5cGVzZXR0ZXIocmVzb2x2ZUZvbnRzLCBiaWRpKSB7XG4gICAgY29uc3QgSU5GID0gSW5maW5pdHk7XG5cbiAgICAvLyBTZXQgb2YgVW5pY29kZSBEZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50IGNoYXJhY3RlcnMsIHRoZXNlIHdpbGwgbm90IHByb2R1Y2UgdmlzaWJsZSBnbHlwaHNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWlzbGVhZGluZy1jaGFyYWN0ZXItY2xhc3NcbiAgICBjb25zdCBERUZBVUxUX0lHTk9SQUJMRV9DSEFSUyA9IC9bXFx1MDBBRFxcdTAzNEZcXHUwNjFDXFx1MTE1Ri1cXHUxMTYwXFx1MTdCNC1cXHUxN0I1XFx1MTgwQi1cXHUxODBFXFx1MjAwQi1cXHUyMDBGXFx1MjAyQS1cXHUyMDJFXFx1MjA2MC1cXHUyMDZGXFx1MzE2NFxcdUZFMDAtXFx1RkUwRlxcdUZFRkZcXHVGRkEwXFx1RkZGMC1cXHVGRkY4XS87XG5cbiAgICAvLyBUaGlzIHJlZ2V4IChpbnN0ZWFkIG9mIC9cXHMvKSBhbGxvd3MgdXMgdG8gc2VsZWN0IGFsbCB3aGl0ZXNwYWNlIEVYQ0VQVCBmb3Igbm9uLWJyZWFraW5nIHdoaXRlIHNwYWNlc1xuICAgIGNvbnN0IGxpbmVCcmVha2luZ1doaXRlU3BhY2UgPSBgW15cXFxcU1xcXFx1MDBBMF1gO1xuXG4gICAgLy8gSW5jb21wbGV0ZSBzZXQgb2YgY2hhcmFjdGVycyB0aGF0IGFsbG93IGxpbmUgYnJlYWtpbmcgYWZ0ZXIgdGhlbVxuICAgIC8vIEluIHRoZSBmdXR1cmUgd2UgbWF5IGNvbnNpZGVyIGEgZnVsbCBVbmljb2RlIGxpbmUgYnJlYWtpbmcgYWxnb3JpdGhtIGltcGw6IGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIxNFxuICAgIGNvbnN0IEJSRUFLX0FGVEVSX0NIQVJTID0gbmV3IFJlZ0V4cChgJHtsaW5lQnJlYWtpbmdXaGl0ZVNwYWNlfXxbXFxcXC1cXFxcdTAwN0NcXFxcdTAwQURcXFxcdTIwMTBcXFxcdTIwMTItXFxcXHUyMDE0XFxcXHUyMDI3XFxcXHUyMDU2XFxcXHUyRTE3XFxcXHUyRTQwXWApO1xuXG4gICAgLyoqXG4gICAgICogTG9hZCBhbmQgcGFyc2UgYWxsIHRoZSBuZWNlc3NhcnkgZm9udHMgdG8gcmVuZGVyIGEgZ2l2ZW4gc3RyaW5nIG9mIHRleHQsIHRoZW4gZ3JvdXBcbiAgICAgKiB0aGVtIGludG8gY29uc2VjdXRpdmUgcnVucyBvZiBjaGFyYWN0ZXJzIHNoYXJpbmcgYSBmb250LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZUZvbnRSdW5zKHt0ZXh0LCBsYW5nLCBmb250cywgc3R5bGUsIHdlaWdodCwgcHJlUmVzb2x2ZWRGb250cywgdW5pY29kZUZvbnRzVVJMfSwgb25Eb25lKSB7XG4gICAgICBjb25zdCBvblJlc29sdmVkID0gKHtjaGFycywgZm9udHM6IHBhcnNlZEZvbnRzfSkgPT4ge1xuICAgICAgICBsZXQgY3VyUnVuLCBwcmV2VmFsO1xuICAgICAgICBjb25zdCBydW5zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoY2hhcnNbaV0gIT09IHByZXZWYWwpIHtcbiAgICAgICAgICAgIHByZXZWYWwgPSBjaGFyc1tpXTtcbiAgICAgICAgICAgIHJ1bnMucHVzaChjdXJSdW4gPSB7IHN0YXJ0OiBpLCBlbmQ6IGksIGZvbnRPYmo6IHBhcnNlZEZvbnRzW2NoYXJzW2ldXX0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJSdW4uZW5kID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb25Eb25lKHJ1bnMpO1xuICAgICAgfTtcbiAgICAgIGlmIChwcmVSZXNvbHZlZEZvbnRzKSB7XG4gICAgICAgIG9uUmVzb2x2ZWQocHJlUmVzb2x2ZWRGb250cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlRm9udHMoXG4gICAgICAgICAgdGV4dCxcbiAgICAgICAgICBvblJlc29sdmVkLFxuICAgICAgICAgIHsgbGFuZywgZm9udHMsIHN0eWxlLCB3ZWlnaHQsIHVuaWNvZGVGb250c1VSTCB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFpbiBlbnRyeSBwb2ludC5cbiAgICAgKiBQcm9jZXNzIGEgdGV4dCBzdHJpbmcgd2l0aCBnaXZlbiBmb250IGFuZCBmb3JtYXR0aW5nIHBhcmFtZXRlcnMsIGFuZCByZXR1cm4gYWxsIGluZm9cbiAgICAgKiBuZWNlc3NhcnkgdG8gcmVuZGVyIGFsbCBpdHMgZ2x5cGhzLlxuICAgICAqIEB0eXBlIFR5cGVzZXR0ZXJUeXBlc2V0RnVuY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0eXBlc2V0KFxuICAgICAge1xuICAgICAgICB0ZXh0PScnLFxuICAgICAgICBmb250LFxuICAgICAgICBsYW5nLFxuICAgICAgICBzZGZHbHlwaFNpemU9NjQsXG4gICAgICAgIGZvbnRTaXplPTQwMCxcbiAgICAgICAgZm9udFdlaWdodD0xLFxuICAgICAgICBmb250U3R5bGU9J25vcm1hbCcsXG4gICAgICAgIGxldHRlclNwYWNpbmc9MCxcbiAgICAgICAgbGluZUhlaWdodD0nbm9ybWFsJyxcbiAgICAgICAgbWF4V2lkdGg9SU5GLFxuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIHRleHRBbGlnbj0nbGVmdCcsXG4gICAgICAgIHRleHRJbmRlbnQ9MCxcbiAgICAgICAgd2hpdGVTcGFjZT0nbm9ybWFsJyxcbiAgICAgICAgb3ZlcmZsb3dXcmFwPSdub3JtYWwnLFxuICAgICAgICBhbmNob3JYID0gMCxcbiAgICAgICAgYW5jaG9yWSA9IDAsXG4gICAgICAgIG1ldHJpY3NPbmx5PWZhbHNlLFxuICAgICAgICB1bmljb2RlRm9udHNVUkwsXG4gICAgICAgIHByZVJlc29sdmVkRm9udHM9bnVsbCxcbiAgICAgICAgaW5jbHVkZUNhcmV0UG9zaXRpb25zPWZhbHNlLFxuICAgICAgICBjaHVua2VkQm91bmRzU2l6ZT04MTkyLFxuICAgICAgICBjb2xvclJhbmdlcz1udWxsXG4gICAgICB9LFxuICAgICAgY2FsbGJhY2tcbiAgICApIHtcbiAgICAgIGNvbnN0IG1haW5TdGFydCA9IG5vdygpO1xuICAgICAgY29uc3QgdGltaW5ncyA9IHtmb250TG9hZDogMCwgdHlwZXNldHRpbmc6IDB9O1xuXG4gICAgICAvLyBFbnN1cmUgbmV3bGluZXMgYXJlIG5vcm1hbGl6ZWRcbiAgICAgIGlmICh0ZXh0LmluZGV4T2YoJ1xccicpID4gLTEpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCdUeXBlc2V0dGVyOiBnb3QgdGV4dCB3aXRoIFxcXFxyIGNoYXJzOyBub3JtYWxpemluZyB0byBcXFxcbicpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpLnJlcGxhY2UoL1xcci9nLCAnXFxuJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEVuc3VyZSB3ZSd2ZSBnb3QgbnVtYmVycyBub3Qgc3RyaW5nc1xuICAgICAgZm9udFNpemUgPSArZm9udFNpemU7XG4gICAgICBsZXR0ZXJTcGFjaW5nID0gK2xldHRlclNwYWNpbmc7XG4gICAgICBtYXhXaWR0aCA9ICttYXhXaWR0aDtcbiAgICAgIGxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0IHx8ICdub3JtYWwnO1xuICAgICAgdGV4dEluZGVudCA9ICt0ZXh0SW5kZW50O1xuXG4gICAgICBjYWxjdWxhdGVGb250UnVucyh7XG4gICAgICAgIHRleHQsXG4gICAgICAgIGxhbmcsXG4gICAgICAgIHN0eWxlOiBmb250U3R5bGUsXG4gICAgICAgIHdlaWdodDogZm9udFdlaWdodCxcbiAgICAgICAgZm9udHM6IHR5cGVvZiBmb250ID09PSAnc3RyaW5nJyA/IFt7c3JjOiBmb250fV0gOiBmb250LFxuICAgICAgICB1bmljb2RlRm9udHNVUkwsXG4gICAgICAgIHByZVJlc29sdmVkRm9udHNcbiAgICAgIH0sIHJ1bnMgPT4ge1xuICAgICAgICB0aW1pbmdzLmZvbnRMb2FkID0gbm93KCkgLSBtYWluU3RhcnQ7XG4gICAgICAgIGNvbnN0IGhhc01heFdpZHRoID0gaXNGaW5pdGUobWF4V2lkdGgpO1xuICAgICAgICBsZXQgZ2x5cGhJZHMgPSBudWxsO1xuICAgICAgICBsZXQgZ2x5cGhGb250SW5kaWNlcyA9IG51bGw7XG4gICAgICAgIGxldCBnbHlwaFBvc2l0aW9ucyA9IG51bGw7XG4gICAgICAgIGxldCBnbHlwaERhdGEgPSBudWxsO1xuICAgICAgICBsZXQgZ2x5cGhDb2xvcnMgPSBudWxsO1xuICAgICAgICBsZXQgY2FyZXRQb3NpdGlvbnMgPSBudWxsO1xuICAgICAgICBsZXQgdmlzaWJsZUJvdW5kcyA9IG51bGw7XG4gICAgICAgIGxldCBjaHVua2VkQm91bmRzID0gbnVsbDtcbiAgICAgICAgbGV0IG1heExpbmVXaWR0aCA9IDA7XG4gICAgICAgIGxldCByZW5kZXJhYmxlR2x5cGhDb3VudCA9IDA7XG4gICAgICAgIGxldCBjYW5XcmFwID0gd2hpdGVTcGFjZSAhPT0gJ25vd3JhcCc7XG4gICAgICAgIGNvbnN0IG1ldHJpY3NCeUZvbnQgPSBuZXcgTWFwKCk7IC8vIGZvbnRPYmogLT4gbWV0cmljc1xuICAgICAgICBjb25zdCB0eXBlc2V0U3RhcnQgPSBub3coKTtcblxuICAgICAgICAvLyBEaXN0cmlidXRlIGdseXBocyBpbnRvIGxpbmVzIGJhc2VkIG9uIHdyYXBwaW5nXG4gICAgICAgIGxldCBsaW5lWE9mZnNldCA9IHRleHRJbmRlbnQ7XG4gICAgICAgIGxldCBwcmV2UnVuRW5kWCA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50TGluZSA9IG5ldyBUZXh0TGluZSgpO1xuICAgICAgICBjb25zdCBsaW5lcyA9IFtjdXJyZW50TGluZV07XG4gICAgICAgIHJ1bnMuZm9yRWFjaChydW4gPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZm9udE9iaiB9ID0gcnVuO1xuICAgICAgICAgIGNvbnN0IHsgYXNjZW5kZXIsIGRlc2NlbmRlciwgdW5pdHNQZXJFbSwgbGluZUdhcCwgY2FwSGVpZ2h0LCB4SGVpZ2h0IH0gPSBmb250T2JqO1xuXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG1ldHJpY3MgZm9yIGVhY2ggZm9udCB1c2VkXG4gICAgICAgICAgbGV0IGZvbnREYXRhID0gbWV0cmljc0J5Rm9udC5nZXQoZm9udE9iaik7XG4gICAgICAgICAgaWYgKCFmb250RGF0YSkge1xuICAgICAgICAgICAgLy8gRmluZCBjb252ZXJzaW9uIGJldHdlZW4gbmF0aXZlIGZvbnQgdW5pdHMgYW5kIGZvbnRTaXplIHVuaXRzXG4gICAgICAgICAgICBjb25zdCBmb250U2l6ZU11bHQgPSBmb250U2l6ZSAvIHVuaXRzUGVyRW07XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSBhcHByb3ByaWF0ZSB2YWx1ZSBmb3IgJ25vcm1hbCcgbGluZSBoZWlnaHQgYmFzZWQgb24gdGhlIGZvbnQncyBhY3R1YWwgbWV0cmljc1xuICAgICAgICAgICAgLy8gVGhpcyBkb2VzIG5vdCBndWFyYW50ZWUgaW5kaXZpZHVhbCBnbHlwaHMgd29uJ3QgZXhjZWVkIHRoZSBsaW5lIGhlaWdodCwgZS5nLiBSb2JvdG87IHNob3VsZCB3ZSB1c2UgeU1pbi9NYXggaW5zdGVhZD9cbiAgICAgICAgICAgIGNvbnN0IGNhbGNMaW5lSGVpZ2h0ID0gbGluZUhlaWdodCA9PT0gJ25vcm1hbCcgP1xuICAgICAgICAgICAgICAoYXNjZW5kZXIgLSBkZXNjZW5kZXIgKyBsaW5lR2FwKSAqIGZvbnRTaXplTXVsdCA6IGxpbmVIZWlnaHQgKiBmb250U2l6ZTtcblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGxpbmUgaGVpZ2h0IGFuZCBsZWFkaW5nIGFkanVzdG1lbnRzXG4gICAgICAgICAgICBjb25zdCBoYWxmTGVhZGluZyA9IChjYWxjTGluZUhlaWdodCAtIChhc2NlbmRlciAtIGRlc2NlbmRlcikgKiBmb250U2l6ZU11bHQpIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IGNhcmV0SGVpZ2h0ID0gTWF0aC5taW4oY2FsY0xpbmVIZWlnaHQsIChhc2NlbmRlciAtIGRlc2NlbmRlcikgKiBmb250U2l6ZU11bHQpO1xuICAgICAgICAgICAgY29uc3QgY2FyZXRUb3AgPSAoYXNjZW5kZXIgKyBkZXNjZW5kZXIpIC8gMiAqIGZvbnRTaXplTXVsdCArIGNhcmV0SGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIGZvbnREYXRhID0ge1xuICAgICAgICAgICAgICBpbmRleDogbWV0cmljc0J5Rm9udC5zaXplLFxuICAgICAgICAgICAgICBzcmM6IGZvbnRPYmouc3JjLFxuICAgICAgICAgICAgICBmb250T2JqLFxuICAgICAgICAgICAgICBmb250U2l6ZU11bHQsXG4gICAgICAgICAgICAgIHVuaXRzUGVyRW0sXG4gICAgICAgICAgICAgIGFzY2VuZGVyOiBhc2NlbmRlciAqIGZvbnRTaXplTXVsdCxcbiAgICAgICAgICAgICAgZGVzY2VuZGVyOiBkZXNjZW5kZXIgKiBmb250U2l6ZU11bHQsXG4gICAgICAgICAgICAgIGNhcEhlaWdodDogY2FwSGVpZ2h0ICogZm9udFNpemVNdWx0LFxuICAgICAgICAgICAgICB4SGVpZ2h0OiB4SGVpZ2h0ICogZm9udFNpemVNdWx0LFxuICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiBjYWxjTGluZUhlaWdodCxcbiAgICAgICAgICAgICAgYmFzZWxpbmU6IC1oYWxmTGVhZGluZyAtIGFzY2VuZGVyICogZm9udFNpemVNdWx0LCAvLyBiYXNlbGluZSBvZmZzZXQgZnJvbSB0b3Agb2YgbGluZSBoZWlnaHRcbiAgICAgICAgICAgICAgLy8gY2FwOiAtaGFsZkxlYWRpbmcgLSBjYXBIZWlnaHQgKiBmb250U2l6ZU11bHQsIC8vIGNhcCBmcm9tIHRvcCBvZiBsaW5lIGhlaWdodFxuICAgICAgICAgICAgICAvLyBleDogLWhhbGZMZWFkaW5nIC0geEhlaWdodCAqIGZvbnRTaXplTXVsdCwgLy8gZXggZnJvbSB0b3Agb2YgbGluZSBoZWlnaHRcbiAgICAgICAgICAgICAgY2FyZXRUb3AsXG4gICAgICAgICAgICAgIGNhcmV0Qm90dG9tOiBjYXJldFRvcCAtIGNhcmV0SGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWV0cmljc0J5Rm9udC5zZXQoZm9udE9iaiwgZm9udERhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7IGZvbnRTaXplTXVsdCB9ID0gZm9udERhdGE7XG5cbiAgICAgICAgICBjb25zdCBydW5UZXh0ID0gdGV4dC5zbGljZShydW4uc3RhcnQsIHJ1bi5lbmQgKyAxKTtcbiAgICAgICAgICBsZXQgcHJldkdseXBoWCwgcHJldkdseXBoT2JqO1xuICAgICAgICAgIGZvbnRPYmouZm9yRWFjaEdseXBoKHJ1blRleHQsIGZvbnRTaXplLCBsZXR0ZXJTcGFjaW5nLCAoZ2x5cGhPYmosIGdseXBoWCwgZ2x5cGhZLCBjaGFySW5kZXgpID0+IHtcbiAgICAgICAgICAgIGdseXBoWCArPSBwcmV2UnVuRW5kWDtcbiAgICAgICAgICAgIGNoYXJJbmRleCArPSBydW4uc3RhcnQ7XG4gICAgICAgICAgICBwcmV2R2x5cGhYID0gZ2x5cGhYO1xuICAgICAgICAgICAgcHJldkdseXBoT2JqID0gZ2x5cGhPYmo7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gdGV4dC5jaGFyQXQoY2hhckluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IGdseXBoV2lkdGggPSBnbHlwaE9iai5hZHZhbmNlV2lkdGggKiBmb250U2l6ZU11bHQ7XG4gICAgICAgICAgICBjb25zdCBjdXJMaW5lQ291bnQgPSBjdXJyZW50TGluZS5jb3VudDtcbiAgICAgICAgICAgIGxldCBuZXh0TGluZTtcblxuICAgICAgICAgICAgLy8gQ2FsYyBpc1doaXRlc3BhY2UgYW5kIGlzRW1wdHkgb25jZSBwZXIgZ2x5cGhPYmpcbiAgICAgICAgICAgIGlmICghKCdpc0VtcHR5JyBpbiBnbHlwaE9iaikpIHtcbiAgICAgICAgICAgICAgZ2x5cGhPYmouaXNXaGl0ZXNwYWNlID0gISFjaGFyICYmIG5ldyBSZWdFeHAobGluZUJyZWFraW5nV2hpdGVTcGFjZSkudGVzdChjaGFyKTtcbiAgICAgICAgICAgICAgZ2x5cGhPYmouY2FuQnJlYWtBZnRlciA9ICEhY2hhciAmJiBCUkVBS19BRlRFUl9DSEFSUy50ZXN0KGNoYXIpO1xuICAgICAgICAgICAgICBnbHlwaE9iai5pc0VtcHR5ID0gZ2x5cGhPYmoueE1pbiA9PT0gZ2x5cGhPYmoueE1heCB8fCBnbHlwaE9iai55TWluID09PSBnbHlwaE9iai55TWF4IHx8IERFRkFVTFRfSUdOT1JBQkxFX0NIQVJTLnRlc3QoY2hhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWdseXBoT2JqLmlzV2hpdGVzcGFjZSAmJiAhZ2x5cGhPYmouaXNFbXB0eSkge1xuICAgICAgICAgICAgICByZW5kZXJhYmxlR2x5cGhDb3VudCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBhIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlciBvdmVyZmxvd3MgdGhlIG1heCB3aWR0aCwgd2UgbmVlZCB0byBzb2Z0LXdyYXBcbiAgICAgICAgICAgIGlmIChjYW5XcmFwICYmIGhhc01heFdpZHRoICYmICFnbHlwaE9iai5pc1doaXRlc3BhY2UgJiYgZ2x5cGhYICsgZ2x5cGhXaWR0aCArIGxpbmVYT2Zmc2V0ID4gbWF4V2lkdGggJiYgY3VyTGluZUNvdW50KSB7XG4gICAgICAgICAgICAgIC8vIElmIGl0J3MgdGhlIGZpcnN0IGNoYXIgYWZ0ZXIgYSB3aGl0ZXNwYWNlLCBzdGFydCBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgIGlmIChjdXJyZW50TGluZS5nbHlwaEF0KGN1ckxpbmVDb3VudCAtIDEpLmdseXBoT2JqLmNhbkJyZWFrQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBuZXh0TGluZSA9IG5ldyBUZXh0TGluZSgpO1xuICAgICAgICAgICAgICAgIGxpbmVYT2Zmc2V0ID0gLWdseXBoWDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCYWNrIHVwIGxvb2tpbmcgZm9yIGEgd2hpdGVzcGFjZSBjaGFyYWN0ZXIgdG8gd3JhcCBhdFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBjdXJMaW5lQ291bnQ7IGktLTspIHtcbiAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGdvdCB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgdGhlcmUncyBubyBzb2Z0IGJyZWFrIHBvaW50OyBtYWtlIGhhcmQgYnJlYWsgaWYgb3ZlcmZsb3dXcmFwPSdicmVhay13b3JkJ1xuICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgJiYgb3ZlcmZsb3dXcmFwID09PSAnYnJlYWstd29yZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dExpbmUgPSBuZXcgVGV4dExpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgbGluZVhPZmZzZXQgPSAtZ2x5cGhYO1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gRm91bmQgYSBzb2Z0IGJyZWFrIHBvaW50OyBtb3ZlIGFsbCBjaGFycyBzaW5jZSBpdCB0byBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50TGluZS5nbHlwaEF0KGkpLmdseXBoT2JqLmNhbkJyZWFrQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dExpbmUgPSBjdXJyZW50TGluZS5zcGxpdEF0KGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRqdXN0WCA9IG5leHRMaW5lLmdseXBoQXQoMCkueDtcbiAgICAgICAgICAgICAgICAgICAgbGluZVhPZmZzZXQgLT0gYWRqdXN0WDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IG5leHRMaW5lLmNvdW50OyBqLS07KSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmV4dExpbmUuZ2x5cGhBdChqKS54IC09IGFkanVzdFg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG5leHRMaW5lKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudExpbmUuaXNTb2Z0V3JhcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY3VycmVudExpbmUgPSBuZXh0TGluZTtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGN1cnJlbnRMaW5lKTtcbiAgICAgICAgICAgICAgICBtYXhMaW5lV2lkdGggPSBtYXhXaWR0aDsgLy9hZnRlciBzb2Z0IHdyYXBwaW5nIHVzZSBtYXhXaWR0aCBhcyBjYWxjdWxhdGVkIHdpZHRoXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGZseSA9IGN1cnJlbnRMaW5lLmdseXBoQXQoY3VycmVudExpbmUuY291bnQpO1xuICAgICAgICAgICAgZmx5LmdseXBoT2JqID0gZ2x5cGhPYmo7XG4gICAgICAgICAgICBmbHkueCA9IGdseXBoWCArIGxpbmVYT2Zmc2V0O1xuICAgICAgICAgICAgZmx5LnkgPSBnbHlwaFk7XG4gICAgICAgICAgICBmbHkud2lkdGggPSBnbHlwaFdpZHRoO1xuICAgICAgICAgICAgZmx5LmNoYXJJbmRleCA9IGNoYXJJbmRleDtcbiAgICAgICAgICAgIGZseS5mb250RGF0YSA9IGZvbnREYXRhO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgaGFyZCBsaW5lIGJyZWFrc1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMaW5lID0gbmV3IFRleHRMaW5lKCk7XG4gICAgICAgICAgICAgIGxpbmVzLnB1c2goY3VycmVudExpbmUpO1xuICAgICAgICAgICAgICBsaW5lWE9mZnNldCA9IC0oZ2x5cGhYICsgZ2x5cGhXaWR0aCArIChsZXR0ZXJTcGFjaW5nICogZm9udFNpemUpKSArIHRleHRJbmRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gQXQgdGhlIGVuZCBvZiBhIHJ1biB3ZSBtdXN0IGNhcHR1cmUgdGhlIHggcG9zaXRpb24gYXMgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciB0aGUgbmV4dCBydW5cbiAgICAgICAgICBwcmV2UnVuRW5kWCA9IHByZXZHbHlwaFggKyBwcmV2R2x5cGhPYmouYWR2YW5jZVdpZHRoICogZm9udFNpemVNdWx0ICsgbGV0dGVyU3BhY2luZyAqIGZvbnRTaXplO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgd2lkdGgvaGVpZ2h0L2Jhc2VsaW5lIG9mIGVhY2ggbGluZSAoZXhjbHVkaW5nIHRyYWlsaW5nIHdoaXRlc3BhY2UpIGFuZCBtYXhpbXVtIGJsb2NrIHdpZHRoXG4gICAgICAgIGxldCB0b3RhbEhlaWdodCA9IDA7XG4gICAgICAgIGxpbmVzLmZvckVhY2gobGluZSA9PiB7XG4gICAgICAgICAgbGV0IGlzVHJhaWxpbmdXaGl0ZXNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gbGluZS5jb3VudDsgaS0tOykge1xuICAgICAgICAgICAgY29uc3QgZ2x5cGhJbmZvID0gbGluZS5nbHlwaEF0KGkpO1xuICAgICAgICAgICAgLy8gb21pdCB0cmFpbGluZyB3aGl0ZXNwYWNlIGZyb20gd2lkdGggY2FsY3VsYXRpb25cbiAgICAgICAgICAgIGlmIChpc1RyYWlsaW5nV2hpdGVzcGFjZSAmJiAhZ2x5cGhJbmZvLmdseXBoT2JqLmlzV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgICBsaW5lLndpZHRoID0gZ2x5cGhJbmZvLnggKyBnbHlwaEluZm8ud2lkdGg7XG4gICAgICAgICAgICAgIGlmIChsaW5lLndpZHRoID4gbWF4TGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gbGluZS53aWR0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpc1RyYWlsaW5nV2hpdGVzcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXNlIHRoZSB0YWxsZXN0IGxpbmUgaGVpZ2h0LCBsb3dlc3QgYmFzZWxpbmUsIGFuZCBoaWdoZXN0IGNhcC9leFxuICAgICAgICAgICAgbGV0IHtsaW5lSGVpZ2h0LCBjYXBIZWlnaHQsIHhIZWlnaHQsIGJhc2VsaW5lfSA9IGdseXBoSW5mby5mb250RGF0YTtcbiAgICAgICAgICAgIGlmIChsaW5lSGVpZ2h0ID4gbGluZS5saW5lSGVpZ2h0KSBsaW5lLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgYmFzZWxpbmVEaWZmID0gYmFzZWxpbmUgLSBsaW5lLmJhc2VsaW5lO1xuICAgICAgICAgICAgaWYgKGJhc2VsaW5lRGlmZiA8IDApIHsgLy9zaGlmdCBhbGwgbWV0cmljcyBkb3duXG4gICAgICAgICAgICAgIGxpbmUuYmFzZWxpbmUgKz0gYmFzZWxpbmVEaWZmO1xuICAgICAgICAgICAgICBsaW5lLmNhcCArPSBiYXNlbGluZURpZmY7XG4gICAgICAgICAgICAgIGxpbmUuZXggKz0gYmFzZWxpbmVEaWZmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29tcGFyZSBjYXAvZXggYmFzZWQgb24gbmV3IGxvd2VzdCBiYXNlbGluZVxuICAgICAgICAgICAgbGluZS5jYXAgPSBNYXRoLm1heChsaW5lLmNhcCwgbGluZS5iYXNlbGluZSArIGNhcEhlaWdodCk7XG4gICAgICAgICAgICBsaW5lLmV4ID0gTWF0aC5tYXgobGluZS5leCwgbGluZS5iYXNlbGluZSArIHhIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsaW5lLmJhc2VsaW5lIC09IHRvdGFsSGVpZ2h0O1xuICAgICAgICAgIGxpbmUuY2FwIC09IHRvdGFsSGVpZ2h0O1xuICAgICAgICAgIGxpbmUuZXggLT0gdG90YWxIZWlnaHQ7XG4gICAgICAgICAgdG90YWxIZWlnaHQgKz0gbGluZS5saW5lSGVpZ2h0O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBGaW5kIG92ZXJhbGwgcG9zaXRpb24gYWRqdXN0bWVudHMgZm9yIGFuY2hvcmluZ1xuICAgICAgICBsZXQgYW5jaG9yWE9mZnNldCA9IDA7XG4gICAgICAgIGxldCBhbmNob3JZT2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKGFuY2hvclgpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFuY2hvclggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBhbmNob3JYT2Zmc2V0ID0gLWFuY2hvclg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhbmNob3JYID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYW5jaG9yWE9mZnNldCA9IC1tYXhMaW5lV2lkdGggKiAoXG4gICAgICAgICAgICAgIGFuY2hvclggPT09ICdsZWZ0JyA/IDAgOlxuICAgICAgICAgICAgICBhbmNob3JYID09PSAnY2VudGVyJyA/IDAuNSA6XG4gICAgICAgICAgICAgIGFuY2hvclggPT09ICdyaWdodCcgPyAxIDpcbiAgICAgICAgICAgICAgcGFyc2VQZXJjZW50KGFuY2hvclgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5jaG9yWSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgYW5jaG9yWSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGFuY2hvcllPZmZzZXQgPSAtYW5jaG9yWTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFuY2hvclkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBhbmNob3JZT2Zmc2V0ID0gYW5jaG9yWSA9PT0gJ3RvcCcgPyAwIDpcbiAgICAgICAgICAgICAgYW5jaG9yWSA9PT0gJ3RvcC1iYXNlbGluZScgPyAtbGluZXNbMF0uYmFzZWxpbmUgOlxuICAgICAgICAgICAgICBhbmNob3JZID09PSAndG9wLWNhcCcgPyAtbGluZXNbMF0uY2FwIDpcbiAgICAgICAgICAgICAgYW5jaG9yWSA9PT0gJ3RvcC1leCcgPyAtbGluZXNbMF0uZXggOlxuICAgICAgICAgICAgICBhbmNob3JZID09PSAnbWlkZGxlJyA/IHRvdGFsSGVpZ2h0IC8gMiA6XG4gICAgICAgICAgICAgIGFuY2hvclkgPT09ICdib3R0b20nID8gdG90YWxIZWlnaHQgOlxuICAgICAgICAgICAgICBhbmNob3JZID09PSAnYm90dG9tLWJhc2VsaW5lJyA/IC1saW5lc1tsaW5lcy5sZW5ndGggLSAxXS5iYXNlbGluZSA6XG4gICAgICAgICAgICAgIHBhcnNlUGVyY2VudChhbmNob3JZKSAqIHRvdGFsSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbWV0cmljc09ubHkpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGJpZGkgbGV2ZWxzXG4gICAgICAgICAgY29uc3QgYmlkaUxldmVsc1Jlc3VsdCA9IGJpZGkuZ2V0RW1iZWRkaW5nTGV2ZWxzKHRleHQsIGRpcmVjdGlvbik7XG5cbiAgICAgICAgICAvLyBQcm9jZXNzIGVhY2ggbGluZSwgYXBwbHlpbmcgYWxpZ25tZW50IG9mZnNldHMsIGFkZGluZyBlYWNoIGdseXBoIHRvIHRoZSBhdGxhcywgYW5kXG4gICAgICAgICAgLy8gY29sbGVjdGluZyBhbGwgcmVuZGVyYWJsZSBnbHlwaHMgaW50byBhIHNpbmdsZSBjb2xsZWN0aW9uLlxuICAgICAgICAgIGdseXBoSWRzID0gbmV3IFVpbnQxNkFycmF5KHJlbmRlcmFibGVHbHlwaENvdW50KTtcbiAgICAgICAgICBnbHlwaEZvbnRJbmRpY2VzID0gbmV3IFVpbnQ4QXJyYXkocmVuZGVyYWJsZUdseXBoQ291bnQpO1xuICAgICAgICAgIGdseXBoUG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShyZW5kZXJhYmxlR2x5cGhDb3VudCAqIDIpO1xuICAgICAgICAgIGdseXBoRGF0YSA9IHt9O1xuICAgICAgICAgIHZpc2libGVCb3VuZHMgPSBbSU5GLCBJTkYsIC1JTkYsIC1JTkZdO1xuICAgICAgICAgIGNodW5rZWRCb3VuZHMgPSBbXTtcbiAgICAgICAgICBpZiAoaW5jbHVkZUNhcmV0UG9zaXRpb25zKSB7XG4gICAgICAgICAgICBjYXJldFBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkodGV4dC5sZW5ndGggKiA0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbG9yUmFuZ2VzKSB7XG4gICAgICAgICAgICBnbHlwaENvbG9ycyA9IG5ldyBVaW50OEFycmF5KHJlbmRlcmFibGVHbHlwaENvdW50ICogMyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCByZW5kZXJhYmxlR2x5cGhJbmRleCA9IDA7XG4gICAgICAgICAgbGV0IHByZXZDaGFySW5kZXggPSAtMTtcbiAgICAgICAgICBsZXQgY29sb3JDaGFySW5kZXggPSAtMTtcbiAgICAgICAgICBsZXQgY2h1bms7XG4gICAgICAgICAgbGV0IGN1cnJlbnRDb2xvcjtcbiAgICAgICAgICBsaW5lcy5mb3JFYWNoKChsaW5lLCBsaW5lSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCB7Y291bnQ6bGluZUdseXBoQ291bnQsIHdpZHRoOmxpbmVXaWR0aH0gPSBsaW5lO1xuXG4gICAgICAgICAgICAvLyBJZ25vcmUgZW1wdHkgbGluZXNcbiAgICAgICAgICAgIGlmIChsaW5lR2x5cGhDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgLy8gQ291bnQgdHJhaWxpbmcgd2hpdGVzcGFjZXMsIHdlIHdhbnQgdG8gaWdub3JlIHRoZXNlIGZvciBjZXJ0YWluIHRoaW5nc1xuICAgICAgICAgICAgICBsZXQgdHJhaWxpbmdXaGl0ZXNwYWNlQ291bnQgPSAwO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbGluZUdseXBoQ291bnQ7IGktLSAmJiBsaW5lLmdseXBoQXQoaSkuZ2x5cGhPYmouaXNXaGl0ZXNwYWNlOykge1xuICAgICAgICAgICAgICAgIHRyYWlsaW5nV2hpdGVzcGFjZUNvdW50Kys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBBcHBseSBob3Jpem9udGFsIGFsaWdubWVudCBhZGp1c3RtZW50c1xuICAgICAgICAgICAgICBsZXQgbGluZVhPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICBsZXQganVzdGlmeUFkanVzdCA9IDA7XG4gICAgICAgICAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgbGluZVhPZmZzZXQgPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoKSAvIDI7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgbGluZVhPZmZzZXQgPSBtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGg7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dEFsaWduID09PSAnanVzdGlmeScgJiYgbGluZS5pc1NvZnRXcmFwcGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gY291bnQgbm9uLXRyYWlsaW5nIHdoaXRlc3BhY2UgY2hhcmFjdGVycywgYW5kIHdlJ2xsIGFkanVzdCB0aGUgb2Zmc2V0cyBwZXIgY2hhcmFjdGVyIGluIHRoZSBuZXh0IGxvb3BcbiAgICAgICAgICAgICAgICBsZXQgd2hpdGVzcGFjZUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gbGluZUdseXBoQ291bnQgLSB0cmFpbGluZ1doaXRlc3BhY2VDb3VudDsgaS0tOykge1xuICAgICAgICAgICAgICAgICAgaWYgKGxpbmUuZ2x5cGhBdChpKS5nbHlwaE9iai5pc1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGVzcGFjZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGp1c3RpZnlBZGp1c3QgPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoKSAvIHdoaXRlc3BhY2VDb3VudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoanVzdGlmeUFkanVzdCB8fCBsaW5lWE9mZnNldCkge1xuICAgICAgICAgICAgICAgIGxldCBqdXN0aWZ5T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVHbHlwaENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGxldCBnbHlwaEluZm8gPSBsaW5lLmdseXBoQXQoaSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBnbHlwaE9iaiA9IGdseXBoSW5mby5nbHlwaE9iajtcbiAgICAgICAgICAgICAgICAgIGdseXBoSW5mby54ICs9IGxpbmVYT2Zmc2V0ICsganVzdGlmeU9mZnNldDtcbiAgICAgICAgICAgICAgICAgIC8vIEV4cGFuZCBub24tdHJhaWxpbmcgd2hpdGVzcGFjZXMgZm9yIGp1c3RpZnkgYWxpZ25tZW50XG4gICAgICAgICAgICAgICAgICBpZiAoanVzdGlmeUFkanVzdCAhPT0gMCAmJiBnbHlwaE9iai5pc1doaXRlc3BhY2UgJiYgaSA8IGxpbmVHbHlwaENvdW50IC0gdHJhaWxpbmdXaGl0ZXNwYWNlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAganVzdGlmeU9mZnNldCArPSBqdXN0aWZ5QWRqdXN0O1xuICAgICAgICAgICAgICAgICAgICBnbHlwaEluZm8ud2lkdGggKz0ganVzdGlmeUFkanVzdDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBQZXJmb3JtIGJpZGkgcmFuZ2UgZmxpcHBpbmdcbiAgICAgICAgICAgICAgY29uc3QgZmxpcHMgPSBiaWRpLmdldFJlb3JkZXJTZWdtZW50cyhcbiAgICAgICAgICAgICAgICB0ZXh0LCBiaWRpTGV2ZWxzUmVzdWx0LCBsaW5lLmdseXBoQXQoMCkuY2hhckluZGV4LCBsaW5lLmdseXBoQXQobGluZS5jb3VudCAtIDEpLmNoYXJJbmRleFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBmb3IgKGxldCBmaSA9IDA7IGZpIDwgZmxpcHMubGVuZ3RoOyBmaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gZmxpcHNbZmldO1xuICAgICAgICAgICAgICAgIC8vIE1hcCBzdGFydC9lbmQgc3RyaW5nIGluZGljZXMgdG8gaW5kaWNlcyBpbiB0aGUgbGluZVxuICAgICAgICAgICAgICAgIGxldCBsZWZ0ID0gSW5maW5pdHksIHJpZ2h0ID0gLUluZmluaXR5O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUdseXBoQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKGxpbmUuZ2x5cGhBdChpKS5jaGFySW5kZXggPj0gc3RhcnQpIHsgLy8gZ3RlIHRvIGhhbmRsZSByZW1vdmVkIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5MaW5lID0gaSwgZW5kSW5MaW5lID0gaTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGVuZEluTGluZSA8IGxpbmVHbHlwaENvdW50OyBlbmRJbkxpbmUrKykge1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBpbmZvID0gbGluZS5nbHlwaEF0KGVuZEluTGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8uY2hhckluZGV4ID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kSW5MaW5lIDwgbGluZUdseXBoQ291bnQgLSB0cmFpbGluZ1doaXRlc3BhY2VDb3VudCkgeyAvL2Rvbid0IGluY2x1ZGUgdHJhaWxpbmcgd3MgaW4gZmxpcCB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IE1hdGgubWluKGxlZnQsIGluZm8ueCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IE1hdGgubWF4KHJpZ2h0LCBpbmZvLnggKyBpbmZvLndpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IHN0YXJ0SW5MaW5lOyBqIDwgZW5kSW5MaW5lOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnbHlwaEluZm8gPSBsaW5lLmdseXBoQXQoaik7XG4gICAgICAgICAgICAgICAgICAgICAgZ2x5cGhJbmZvLnggPSByaWdodCAtIChnbHlwaEluZm8ueCArIGdseXBoSW5mby53aWR0aCAtIGxlZnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQXNzZW1ibGUgZmluYWwgZGF0YSBhcnJheXNcbiAgICAgICAgICAgICAgbGV0IGdseXBoT2JqO1xuICAgICAgICAgICAgICBjb25zdCBzZXRHbHlwaE9iaiA9IGcgPT4gZ2x5cGhPYmogPSBnO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVHbHlwaENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnbHlwaEluZm8gPSBsaW5lLmdseXBoQXQoaSk7XG4gICAgICAgICAgICAgICAgZ2x5cGhPYmogPSBnbHlwaEluZm8uZ2x5cGhPYmo7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2x5cGhJZCA9IGdseXBoT2JqLmluZGV4O1xuXG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBtaXJyb3JlZCBjaGFyYWN0ZXJzIGluIHJ0bFxuICAgICAgICAgICAgICAgIGNvbnN0IHJ0bCA9IGJpZGlMZXZlbHNSZXN1bHQubGV2ZWxzW2dseXBoSW5mby5jaGFySW5kZXhdICYgMTsgLy9vZGQgbGV2ZWwgbWVhbnMgcnRsXG4gICAgICAgICAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWlycm9yZWQgPSBiaWRpLmdldE1pcnJvcmVkQ2hhcmFjdGVyKHRleHRbZ2x5cGhJbmZvLmNoYXJJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgaWYgKG1pcnJvcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGdseXBoSW5mby5mb250RGF0YS5mb250T2JqLmZvckVhY2hHbHlwaChtaXJyb3JlZCwgMCwgMCwgc2V0R2x5cGhPYmopO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBjYXJldCBwb3NpdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZUNhcmV0UG9zaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB7Y2hhckluZGV4LCBmb250RGF0YX0gPSBnbHlwaEluZm87XG4gICAgICAgICAgICAgICAgICBjb25zdCBjYXJldExlZnQgPSBnbHlwaEluZm8ueCArIGFuY2hvclhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjYXJldFJpZ2h0ID0gZ2x5cGhJbmZvLnggKyBnbHlwaEluZm8ud2lkdGggKyBhbmNob3JYT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogNF0gPSBydGwgPyBjYXJldFJpZ2h0IDogY2FyZXRMZWZ0OyAvL3N0YXJ0IGVkZ2UgeFxuICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogNCArIDFdID0gcnRsID8gY2FyZXRMZWZ0IDogY2FyZXRSaWdodDsgLy9lbmQgZWRnZSB4XG4gICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uc1tjaGFySW5kZXggKiA0ICsgMl0gPSBsaW5lLmJhc2VsaW5lICsgZm9udERhdGEuY2FyZXRCb3R0b20gKyBhbmNob3JZT2Zmc2V0OyAvL2NvbW1vbiBib3R0b20geVxuICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnNbY2hhckluZGV4ICogNCArIDNdID0gbGluZS5iYXNlbGluZSArIGZvbnREYXRhLmNhcmV0VG9wICsgYW5jaG9yWU9mZnNldDsgLy9jb21tb24gdG9wIHlcblxuICAgICAgICAgICAgICAgICAgLy8gSWYgd2Ugc2tpcHBlZCBhbnkgY2hhcnMgZnJvbSB0aGUgcHJldmlvdXMgZ2x5cGggKGR1ZSB0byBsaWdhdHVyZSBzdWJzKSwgZmlsbCBpbiBjYXJldFxuICAgICAgICAgICAgICAgICAgLy8gcG9zaXRpb25zIGZvciB0aG9zZSBtaXNzaW5nIGNoYXIgaW5kaWNlczsgY3VycmVudGx5IHRoaXMgdXNlcyBhIGJlc3QtZ3Vlc3MgYnkgZGl2aWRpbmdcbiAgICAgICAgICAgICAgICAgIC8vIHRoZSBsaWdhdHVyZSdzIHdpZHRoIGV2ZW5seS4gSW4gdGhlIGZ1dHVyZSB3ZSBtYXkgdHJ5IHRvIHVzZSB0aGUgZm9udCdzIExpZ2F0dXJlQ2FyZXRMaXN0XG4gICAgICAgICAgICAgICAgICAvLyB0YWJsZSB0byBnZXQgYmV0dGVyIGludGVyaW9yIGNhcmV0IHBvc2l0aW9ucy5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGxpZ0NvdW50ID0gY2hhckluZGV4IC0gcHJldkNoYXJJbmRleDtcbiAgICAgICAgICAgICAgICAgIGlmIChsaWdDb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbExpZ2F0dXJlQ2FyZXRQb3NpdGlvbnMoY2FyZXRQb3NpdGlvbnMsIHByZXZDaGFySW5kZXgsIGxpZ0NvdW50KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHByZXZDaGFySW5kZXggPSBjaGFySW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVHJhY2sgY3VycmVudCBjb2xvciByYW5nZVxuICAgICAgICAgICAgICAgIGlmIChjb2xvclJhbmdlcykge1xuICAgICAgICAgICAgICAgICAgY29uc3Qge2NoYXJJbmRleH0gPSBnbHlwaEluZm87XG4gICAgICAgICAgICAgICAgICB3aGlsZShjaGFySW5kZXggPiBjb2xvckNoYXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvckNoYXJJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3JSYW5nZXMuaGFzT3duUHJvcGVydHkoY29sb3JDaGFySW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbG9yID0gY29sb3JSYW5nZXNbY29sb3JDaGFySW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR2V0IGF0bGFzIGRhdGEgZm9yIHJlbmRlcmFibGUgZ2x5cGhzXG4gICAgICAgICAgICAgICAgaWYgKCFnbHlwaE9iai5pc1doaXRlc3BhY2UgJiYgIWdseXBoT2JqLmlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IHJlbmRlcmFibGVHbHlwaEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICBjb25zdCB7Zm9udFNpemVNdWx0LCBzcmM6IGZvbnRTcmMsIGluZGV4OiBmb250SW5kZXh9ID0gZ2x5cGhJbmZvLmZvbnREYXRhO1xuXG4gICAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBnbHlwaCdzIHBhdGggZGF0YVxuICAgICAgICAgICAgICAgICAgY29uc3QgZm9udEdseXBoRGF0YSA9IGdseXBoRGF0YVtmb250U3JjXSB8fCAoZ2x5cGhEYXRhW2ZvbnRTcmNdID0ge30pO1xuICAgICAgICAgICAgICAgICAgaWYgKCFmb250R2x5cGhEYXRhW2dseXBoSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnRHbHlwaERhdGFbZ2x5cGhJZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGF0aDogZ2x5cGhPYmoucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICBwYXRoQm91bmRzOiBbZ2x5cGhPYmoueE1pbiwgZ2x5cGhPYmoueU1pbiwgZ2x5cGhPYmoueE1heCwgZ2x5cGhPYmoueU1heF1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGZpbmFsIGdseXBoIHBvc2l0aW9uIGFuZCBhZGQgdG8gZ2x5cGhQb3NpdGlvbnMgYXJyYXlcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGdseXBoWCA9IGdseXBoSW5mby54ICsgYW5jaG9yWE9mZnNldDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGdseXBoWSA9IGdseXBoSW5mby55ICsgbGluZS5iYXNlbGluZSArIGFuY2hvcllPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICBnbHlwaFBvc2l0aW9uc1tpZHggKiAyXSA9IGdseXBoWDtcbiAgICAgICAgICAgICAgICAgIGdseXBoUG9zaXRpb25zW2lkeCAqIDIgKyAxXSA9IGdseXBoWTtcblxuICAgICAgICAgICAgICAgICAgLy8gVHJhY2sgdG90YWwgdmlzaWJsZSBib3VuZHNcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHZpc1gwID0gZ2x5cGhYICsgZ2x5cGhPYmoueE1pbiAqIGZvbnRTaXplTXVsdDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHZpc1kwID0gZ2x5cGhZICsgZ2x5cGhPYmoueU1pbiAqIGZvbnRTaXplTXVsdDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHZpc1gxID0gZ2x5cGhYICsgZ2x5cGhPYmoueE1heCAqIGZvbnRTaXplTXVsdDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHZpc1kxID0gZ2x5cGhZICsgZ2x5cGhPYmoueU1heCAqIGZvbnRTaXplTXVsdDtcbiAgICAgICAgICAgICAgICAgIGlmICh2aXNYMCA8IHZpc2libGVCb3VuZHNbMF0pIHZpc2libGVCb3VuZHNbMF0gPSB2aXNYMDtcbiAgICAgICAgICAgICAgICAgIGlmICh2aXNZMCA8IHZpc2libGVCb3VuZHNbMV0pIHZpc2libGVCb3VuZHNbMV0gPSB2aXNZMDtcbiAgICAgICAgICAgICAgICAgIGlmICh2aXNYMSA+IHZpc2libGVCb3VuZHNbMl0pIHZpc2libGVCb3VuZHNbMl0gPSB2aXNYMTtcbiAgICAgICAgICAgICAgICAgIGlmICh2aXNZMSA+IHZpc2libGVCb3VuZHNbM10pIHZpc2libGVCb3VuZHNbM10gPSB2aXNZMTtcblxuICAgICAgICAgICAgICAgICAgLy8gVHJhY2sgYm91bmRpbmcgcmVjdHMgZm9yIGVhY2ggY2h1bmsgb2YgTiBnbHlwaHNcbiAgICAgICAgICAgICAgICAgIGlmIChpZHggJSBjaHVua2VkQm91bmRzU2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjaHVuayA9IHtzdGFydDogaWR4LCBlbmQ6IGlkeCwgcmVjdDogW0lORiwgSU5GLCAtSU5GLCAtSU5GXX07XG4gICAgICAgICAgICAgICAgICAgIGNodW5rZWRCb3VuZHMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjaHVuay5lbmQrKztcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rUmVjdCA9IGNodW5rLnJlY3Q7XG4gICAgICAgICAgICAgICAgICBpZiAodmlzWDAgPCBjaHVua1JlY3RbMF0pIGNodW5rUmVjdFswXSA9IHZpc1gwO1xuICAgICAgICAgICAgICAgICAgaWYgKHZpc1kwIDwgY2h1bmtSZWN0WzFdKSBjaHVua1JlY3RbMV0gPSB2aXNZMDtcbiAgICAgICAgICAgICAgICAgIGlmICh2aXNYMSA+IGNodW5rUmVjdFsyXSkgY2h1bmtSZWN0WzJdID0gdmlzWDE7XG4gICAgICAgICAgICAgICAgICBpZiAodmlzWTEgPiBjaHVua1JlY3RbM10pIGNodW5rUmVjdFszXSA9IHZpc1kxO1xuXG4gICAgICAgICAgICAgICAgICAvLyBBZGQgdG8gZ2x5cGggaWRzIGFuZCBmb250IGluZGljZXMgYXJyYXlzXG4gICAgICAgICAgICAgICAgICBnbHlwaElkc1tpZHhdID0gZ2x5cGhJZDtcbiAgICAgICAgICAgICAgICAgIGdseXBoRm9udEluZGljZXNbaWR4XSA9IGZvbnRJbmRleDtcblxuICAgICAgICAgICAgICAgICAgLy8gQWRkIGNvbG9yc1xuICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yUmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gaWR4ICogMztcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhDb2xvcnNbc3RhcnRdID0gY3VycmVudENvbG9yID4+IDE2ICYgMjU1O1xuICAgICAgICAgICAgICAgICAgICBnbHlwaENvbG9yc1tzdGFydCArIDFdID0gY3VycmVudENvbG9yID4+IDggJiAyNTU7XG4gICAgICAgICAgICAgICAgICAgIGdseXBoQ29sb3JzW3N0YXJ0ICsgMl0gPSBjdXJyZW50Q29sb3IgJiAyNTU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBGaWxsIGluIHJlbWFpbmluZyBjYXJldCBwb3NpdGlvbnMgaW4gY2FzZSB0aGUgZmluYWwgY2hhcmFjdGVyIHdhcyBhIGxpZ2F0dXJlXG4gICAgICAgICAgaWYgKGNhcmV0UG9zaXRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsaWdDb3VudCA9IHRleHQubGVuZ3RoIC0gcHJldkNoYXJJbmRleDtcbiAgICAgICAgICAgIGlmIChsaWdDb3VudCA+IDEpIHtcbiAgICAgICAgICAgICAgZmlsbExpZ2F0dXJlQ2FyZXRQb3NpdGlvbnMoY2FyZXRQb3NpdGlvbnMsIHByZXZDaGFySW5kZXgsIGxpZ0NvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBc3NlbWJsZSBmaW5hbCBkYXRhIGFib3V0IGVhY2ggZm9udCB1c2VkXG4gICAgICAgIGNvbnN0IGZvbnREYXRhID0gW107XG4gICAgICAgIG1ldHJpY3NCeUZvbnQuZm9yRWFjaCgoe2luZGV4LCBzcmMsIHVuaXRzUGVyRW0sIGFzY2VuZGVyLCBkZXNjZW5kZXIsIGxpbmVIZWlnaHQsIGNhcEhlaWdodCwgeEhlaWdodH0pID0+IHtcbiAgICAgICAgICBmb250RGF0YVtpbmRleF0gPSB7c3JjLCB1bml0c1BlckVtLCBhc2NlbmRlciwgZGVzY2VuZGVyLCBsaW5lSGVpZ2h0LCBjYXBIZWlnaHQsIHhIZWlnaHR9O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUaW1pbmcgc3RhdHNcbiAgICAgICAgdGltaW5ncy50eXBlc2V0dGluZyA9IG5vdygpIC0gdHlwZXNldFN0YXJ0O1xuXG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICBnbHlwaElkcywgLy9pZCBmb3IgZWFjaCBnbHlwaCwgc3BlY2lmaWMgdG8gdGhhdCBnbHlwaCdzIGZvbnRcbiAgICAgICAgICBnbHlwaEZvbnRJbmRpY2VzLCAvL2luZGV4IGludG8gZm9udERhdGEgZm9yIGVhY2ggZ2x5cGhcbiAgICAgICAgICBnbHlwaFBvc2l0aW9ucywgLy94LHkgb2YgZWFjaCBnbHlwaCdzIG9yaWdpbiBpbiBsYXlvdXRcbiAgICAgICAgICBnbHlwaERhdGEsIC8vZGljdCBob2xkaW5nIGRhdGEgYWJvdXQgZWFjaCBnbHlwaCBhcHBlYXJpbmcgaW4gdGhlIHRleHRcbiAgICAgICAgICBmb250RGF0YSwgLy9kYXRhIGFib3V0IGVhY2ggZm9udCB1c2VkIGluIHRoZSB0ZXh0XG4gICAgICAgICAgY2FyZXRQb3NpdGlvbnMsIC8vc3RhcnRYLGVuZFgsYm90dG9tWSBjYXJldCBwb3NpdGlvbnMgZm9yIGVhY2ggY2hhclxuICAgICAgICAgIC8vIGNhcmV0SGVpZ2h0LCAvL2hlaWdodCBvZiBjdXJzb3IgZnJvbSBib3R0b20gdG8gdG9wIC0gdG9kbyBwZXIgZ2x5cGg/XG4gICAgICAgICAgZ2x5cGhDb2xvcnMsIC8vY29sb3IgZm9yIGVhY2ggZ2x5cGgsIGlmIGNvbG9yIHJhbmdlcyBzdXBwbGllZFxuICAgICAgICAgIGNodW5rZWRCb3VuZHMsIC8vdG90YWwgcmVjdHMgcGVyIChuPWNodW5rZWRCb3VuZHNTaXplKSBjb25zZWN1dGl2ZSBnbHlwaHNcbiAgICAgICAgICBmb250U2l6ZSwgLy9jYWxjdWxhdGVkIGVtIGhlaWdodFxuICAgICAgICAgIHRvcEJhc2VsaW5lOiBhbmNob3JZT2Zmc2V0ICsgbGluZXNbMF0uYmFzZWxpbmUsIC8veSBjb29yZGluYXRlIG9mIHRoZSB0b3AgbGluZSdzIGJhc2VsaW5lXG4gICAgICAgICAgYmxvY2tCb3VuZHM6IFsgLy9ib3VuZHMgZm9yIHRoZSB3aG9sZSBibG9jayBvZiB0ZXh0LCBpbmNsdWRpbmcgdmVydGljYWwgcGFkZGluZyBmb3IgbGluZUhlaWdodFxuICAgICAgICAgICAgYW5jaG9yWE9mZnNldCxcbiAgICAgICAgICAgIGFuY2hvcllPZmZzZXQgLSB0b3RhbEhlaWdodCxcbiAgICAgICAgICAgIGFuY2hvclhPZmZzZXQgKyBtYXhMaW5lV2lkdGgsXG4gICAgICAgICAgICBhbmNob3JZT2Zmc2V0XG4gICAgICAgICAgXSxcbiAgICAgICAgICB2aXNpYmxlQm91bmRzLCAvL3RvdGFsIGJvdW5kcyBvZiB2aXNpYmxlIHRleHQgcGF0aHMsIG1heSBiZSBsYXJnZXIgb3Igc21hbGxlciB0aGFuIGJsb2NrQm91bmRzXG4gICAgICAgICAgdGltaW5nc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogRm9yIGEgZ2l2ZW4gdGV4dCBzdHJpbmcgYW5kIGZvbnQgcGFyYW1ldGVycywgZGV0ZXJtaW5lIHRoZSByZXN1bHRpbmcgYmxvY2sgZGltZW5zaW9uc1xuICAgICAqIGFmdGVyIHdyYXBwaW5nIGZvciB0aGUgZ2l2ZW4gbWF4V2lkdGguXG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFzdXJlKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgICB0eXBlc2V0KHsuLi5hcmdzLCBtZXRyaWNzT25seTogdHJ1ZX0sIChyZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IHJlc3VsdC5ibG9ja0JvdW5kcztcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgIHdpZHRoOiB4MSAtIHgwLFxuICAgICAgICAgIGhlaWdodDogeTEgLSB5MFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUGVyY2VudChzdHIpIHtcbiAgICAgIGxldCBtYXRjaCA9IHN0ci5tYXRjaCgvXihbXFxkLl0rKSUkLyk7XG4gICAgICBsZXQgcGN0ID0gbWF0Y2ggPyBwYXJzZUZsb2F0KG1hdGNoWzFdKSA6IE5hTjtcbiAgICAgIHJldHVybiBpc05hTihwY3QpID8gMCA6IHBjdCAvIDEwMFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbGxMaWdhdHVyZUNhcmV0UG9zaXRpb25zKGNhcmV0UG9zaXRpb25zLCBsaWdTdGFydEluZGV4LCBsaWdDb3VudCkge1xuICAgICAgY29uc3QgbGlnU3RhcnRYID0gY2FyZXRQb3NpdGlvbnNbbGlnU3RhcnRJbmRleCAqIDRdO1xuICAgICAgY29uc3QgbGlnRW5kWCA9IGNhcmV0UG9zaXRpb25zW2xpZ1N0YXJ0SW5kZXggKiA0ICsgMV07XG4gICAgICBjb25zdCBsaWdCb3R0b20gPSBjYXJldFBvc2l0aW9uc1tsaWdTdGFydEluZGV4ICogNCArIDJdO1xuICAgICAgY29uc3QgbGlnVG9wID0gY2FyZXRQb3NpdGlvbnNbbGlnU3RhcnRJbmRleCAqIDQgKyAzXTtcbiAgICAgIGNvbnN0IGd1ZXNzZWRBZHZhbmNlWCA9IChsaWdFbmRYIC0gbGlnU3RhcnRYKSAvIGxpZ0NvdW50O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaWdDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSAobGlnU3RhcnRJbmRleCArIGkpICogNDtcbiAgICAgICAgY2FyZXRQb3NpdGlvbnNbc3RhcnRJbmRleF0gPSBsaWdTdGFydFggKyBndWVzc2VkQWR2YW5jZVggKiBpO1xuICAgICAgICBjYXJldFBvc2l0aW9uc1tzdGFydEluZGV4ICsgMV0gPSBsaWdTdGFydFggKyBndWVzc2VkQWR2YW5jZVggKiAoaSArIDEpO1xuICAgICAgICBjYXJldFBvc2l0aW9uc1tzdGFydEluZGV4ICsgMl0gPSBsaWdCb3R0b207XG4gICAgICAgIGNhcmV0UG9zaXRpb25zW3N0YXJ0SW5kZXggKyAzXSA9IGxpZ1RvcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3coKSB7XG4gICAgICByZXR1cm4gKHNlbGYucGVyZm9ybWFuY2UgfHwgRGF0ZSkubm93KClcbiAgICB9XG5cbiAgICAvLyBBcnJheS1iYWNrZWQgc3RydWN0dXJlIGZvciBhIHNpbmdsZSBsaW5lJ3MgZ2x5cGhzIGRhdGFcbiAgICBmdW5jdGlvbiBUZXh0TGluZSgpIHtcbiAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0TGluZVByb3BzID0gWydnbHlwaE9iaicsICd4JywgJ3knLCAnd2lkdGgnLCAnY2hhckluZGV4JywgJ2ZvbnREYXRhJ107XG4gICAgVGV4dExpbmUucHJvdG90eXBlID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBsaW5lSGVpZ2h0OiAwLFxuICAgICAgYmFzZWxpbmU6IDAsXG4gICAgICBjYXA6IDAsXG4gICAgICBleDogMCxcbiAgICAgIGlzU29mdFdyYXBwZWQ6IGZhbHNlLFxuICAgICAgZ2V0IGNvdW50KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZGF0YS5sZW5ndGggLyB0ZXh0TGluZVByb3BzLmxlbmd0aClcbiAgICAgIH0sXG4gICAgICBnbHlwaEF0KGkpIHtcbiAgICAgICAgbGV0IGZseSA9IFRleHRMaW5lLmZseXdlaWdodDtcbiAgICAgICAgZmx5LmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGZseS5pbmRleCA9IGk7XG4gICAgICAgIHJldHVybiBmbHlcbiAgICAgIH0sXG4gICAgICBzcGxpdEF0KGkpIHtcbiAgICAgICAgbGV0IG5ld0xpbmUgPSBuZXcgVGV4dExpbmUoKTtcbiAgICAgICAgbmV3TGluZS5kYXRhID0gdGhpcy5kYXRhLnNwbGljZShpICogdGV4dExpbmVQcm9wcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbmV3TGluZVxuICAgICAgfVxuICAgIH07XG4gICAgVGV4dExpbmUuZmx5d2VpZ2h0ID0gdGV4dExpbmVQcm9wcy5yZWR1Y2UoKG9iaiwgcHJvcCwgaSwgYWxsKSA9PiB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3RoaXMuaW5kZXggKiB0ZXh0TGluZVByb3BzLmxlbmd0aCArIGldXG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWwpIHtcbiAgICAgICAgICB0aGlzLmRhdGFbdGhpcy5pbmRleCAqIHRleHRMaW5lUHJvcHMubGVuZ3RoICsgaV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9ialxuICAgIH0sIHtkYXRhOiBudWxsLCBpbmRleDogMH0pO1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZXNldCxcbiAgICAgIG1lYXN1cmUsXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgbm93ID0gKCkgPT4gKHNlbGYucGVyZm9ybWFuY2UgfHwgRGF0ZSkubm93KCk7XG5cbiAgY29uc3QgbWFpblRocmVhZEdlbmVyYXRvciA9IC8qI19fUFVSRV9fKi8gY3JlYXRlU0RGR2VuZXJhdG9yX19kZWZhdWx0WydkZWZhdWx0J10oKTtcblxuICBsZXQgd2FybmVkO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBTREYgdGV4dHVyZSBpbWFnZSBmb3IgYSBzaW5nbGUgZ2x5cGggcGF0aCwgcGxhY2luZyB0aGUgcmVzdWx0IGludG8gYSB3ZWJnbCBjYW52YXMgYXQgYVxuICAgKiBnaXZlbiBsb2NhdGlvbiBhbmQgY2hhbm5lbC4gVXRpbGl6ZXMgdGhlIHdlYmdsLXNkZi1nZW5lcmF0b3IgZXh0ZXJuYWwgcGFja2FnZSBmb3IgR1BVLWFjY2VsZXJhdGVkIFNERlxuICAgKiBnZW5lcmF0aW9uIHdoZW4gc3VwcG9ydGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2VuZXJhdGVTREYod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwsIHVzZVdlYkdMID0gdHJ1ZSkge1xuICAgIC8vIEFsbG93IG9wdC1vdXRcbiAgICBpZiAoIXVzZVdlYkdMKSB7XG4gICAgICByZXR1cm4gZ2VuZXJhdGVTREZfSlNfV29ya2VyKHdpZHRoLCBoZWlnaHQsIHBhdGgsIHZpZXdCb3gsIGRpc3RhbmNlLCBleHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKVxuICAgIH1cblxuICAgIC8vIEF0dGVtcHQgR1BVLWFjY2VsZXJhdGVkIGdlbmVyYXRpb24gZmlyc3RcbiAgICByZXR1cm4gZ2VuZXJhdGVTREZfR0wod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwpLnRoZW4oXG4gICAgICBudWxsLFxuICAgICAgZXJyID0+IHtcbiAgICAgICAgLy8gV2ViR0wgZmFpbGVkIGVpdGhlciBkdWUgdG8gYSBoYXJkIGVycm9yIG9yIHVuZXhwZWN0ZWQgcmVzdWx0czsgZmFsbCBiYWNrIHRvIEpTIGluIHdvcmtlcnNcbiAgICAgICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYFdlYkdMIFNERiBnZW5lcmF0aW9uIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIEpTYCwgZXJyKTtcbiAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZVNERl9KU19Xb3JrZXIod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwpXG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgY29uc3QgcXVldWUgPSBbXTtcbiAgY29uc3QgY2h1bmtUaW1lQnVkZ2V0ID0gNTsgLy8gbXNcbiAgbGV0IHRpbWVyID0gMDtcblxuICBmdW5jdGlvbiBuZXh0Q2h1bmsoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBub3coKTtcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoICYmIG5vdygpIC0gc3RhcnQgPCBjaHVua1RpbWVCdWRnZXQpIHtcbiAgICAgIHF1ZXVlLnNoaWZ0KCkoKTtcbiAgICB9XG4gICAgdGltZXIgPSBxdWV1ZS5sZW5ndGggPyBzZXRUaW1lb3V0KG5leHRDaHVuaywgMCkgOiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFdlYkdMLWJhc2VkIGltcGxlbWVudGF0aW9uIGV4ZWN1dGVkIG9uIHRoZSBtYWluIHRocmVhZC4gUmVxdWVzdHMgYXJlIGV4ZWN1dGVkIGluIHRpbWUtYm91bmRlZFxuICAgKiBtYWNyb3Rhc2sgY2h1bmtzIHRvIGFsbG93IHJlbmRlciBmcmFtZXMgdG8gZXhlY3V0ZSBpbiBiZXR3ZWVuLlxuICAgKi9cbiAgY29uc3QgZ2VuZXJhdGVTREZfR0wgPSAoLi4uYXJncykgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBxdWV1ZS5wdXNoKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBub3coKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtYWluVGhyZWFkR2VuZXJhdG9yLndlYmdsLmdlbmVyYXRlSW50b0NhbnZhcyguLi5hcmdzKTtcbiAgICAgICAgICByZXNvbHZlKHsgdGltaW5nOiBub3coKSAtIHN0YXJ0IH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXRpbWVyKSB7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChuZXh0Q2h1bmssIDApO1xuICAgICAgfVxuICAgIH0pXG4gIH07XG5cbiAgY29uc3QgdGhyZWFkQ291bnQgPSA0OyAvLyBob3cgbWFueSB3b3JrZXJzIHRvIHNwYXduXG4gIGNvbnN0IGlkbGVUaW1lb3V0ID0gMjAwMDsgLy8gd29ya2VycyB3aWxsIGJlIHRlcm1pbmF0ZWQgYWZ0ZXIgYmVpbmcgaWRsZSB0aGlzIG1hbnkgbWlsbGlzZWNvbmRzXG4gIGNvbnN0IHRocmVhZHMgPSB7fTtcbiAgbGV0IGNhbGxOdW0gPSAwO1xuXG4gIC8qKlxuICAgKiBGYWxsYmFjayBKUy1iYXNlZCBpbXBsZW1lbnRhdGlvbiwgZmFubmVkIG91dCB0byBhIG51bWJlciBvZiB3b3JrZXIgdGhyZWFkcyBmb3IgcGFyYWxsZWxpc21cbiAgICovXG4gIGZ1bmN0aW9uIGdlbmVyYXRlU0RGX0pTX1dvcmtlcih3aWR0aCwgaGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBkaXN0YW5jZSwgZXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbCkge1xuICAgIGNvbnN0IHdvcmtlcklkID0gJ1Ryb2lrYVRleHRTREZHZW5lcmF0b3JfSlNfJyArICgoY2FsbE51bSsrKSAlIHRocmVhZENvdW50KTtcbiAgICBsZXQgdGhyZWFkID0gdGhyZWFkc1t3b3JrZXJJZF07XG4gICAgaWYgKCF0aHJlYWQpIHtcbiAgICAgIHRocmVhZCA9IHRocmVhZHNbd29ya2VySWRdID0ge1xuICAgICAgICB3b3JrZXJNb2R1bGU6IHRyb2lrYVdvcmtlclV0aWxzLmRlZmluZVdvcmtlck1vZHVsZSh7XG4gICAgICAgICAgbmFtZTogd29ya2VySWQsXG4gICAgICAgICAgd29ya2VySWQsXG4gICAgICAgICAgZGVwZW5kZW5jaWVzOiBbXG4gICAgICAgICAgICBjcmVhdGVTREZHZW5lcmF0b3JfX2RlZmF1bHRbJ2RlZmF1bHQnXSxcbiAgICAgICAgICAgIG5vd1xuICAgICAgICAgIF0sXG4gICAgICAgICAgaW5pdChfY3JlYXRlU0RGR2VuZXJhdG9yLCBub3cpIHtcbiAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRlID0gX2NyZWF0ZVNERkdlbmVyYXRvcigpLmphdmFzY3JpcHQuZ2VuZXJhdGU7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBub3coKTtcbiAgICAgICAgICAgICAgY29uc3QgdGV4dHVyZURhdGEgPSBnZW5lcmF0ZSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlRGF0YSxcbiAgICAgICAgICAgICAgICB0aW1pbmc6IG5vdygpIC0gc3RhcnRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0VHJhbnNmZXJhYmxlcyhyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBbcmVzdWx0LnRleHR1cmVEYXRhLmJ1ZmZlcl1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICByZXF1ZXN0czogMCxcbiAgICAgICAgaWRsZVRpbWVyOiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRocmVhZC5yZXF1ZXN0cysrO1xuICAgIGNsZWFyVGltZW91dCh0aHJlYWQuaWRsZVRpbWVyKTtcbiAgICByZXR1cm4gdGhyZWFkLndvcmtlck1vZHVsZSh3aWR0aCwgaGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBkaXN0YW5jZSwgZXhwb25lbnQpXG4gICAgICAudGhlbigoeyB0ZXh0dXJlRGF0YSwgdGltaW5nIH0pID0+IHtcbiAgICAgICAgLy8gY29weSByZXN1bHQgZGF0YSBpbnRvIHRoZSBjYW52YXNcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBub3coKTtcbiAgICAgICAgLy8gZXhwYW5kIHNpbmdsZS1jaGFubmVsIGRhdGEgaW50byByZ2JhXG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KHRleHR1cmVEYXRhLmxlbmd0aCAqIDQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHR1cmVEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaW1hZ2VEYXRhW2kgKiA0ICsgY2hhbm5lbF0gPSB0ZXh0dXJlRGF0YVtpXTtcbiAgICAgICAgfVxuICAgICAgICBtYWluVGhyZWFkR2VuZXJhdG9yLndlYmdsVXRpbHMucmVuZGVySW1hZ2VEYXRhKGNhbnZhcywgaW1hZ2VEYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAxIDw8ICgzIC0gY2hhbm5lbCkpO1xuICAgICAgICB0aW1pbmcgKz0gbm93KCkgLSBzdGFydDtcblxuICAgICAgICAvLyBjbGVhbiB1cCB3b3JrZXJzIGFmdGVyIGEgd2hpbGVcbiAgICAgICAgaWYgKC0tdGhyZWFkLnJlcXVlc3RzID09PSAwKSB7XG4gICAgICAgICAgdGhyZWFkLmlkbGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4geyB0cm9pa2FXb3JrZXJVdGlscy50ZXJtaW5hdGVXb3JrZXIod29ya2VySWQpOyB9LCBpZGxlVGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdGltaW5nIH1cbiAgICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiB3YXJtVXBTREZDYW52YXMoY2FudmFzKSB7XG4gICAgaWYgKCFjYW52YXMuX3dhcm0pIHtcbiAgICAgIG1haW5UaHJlYWRHZW5lcmF0b3Iud2ViZ2wuaXNTdXBwb3J0ZWQoY2FudmFzKTtcbiAgICAgIGNhbnZhcy5fd2FybSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmVzaXplV2ViR0xDYW52YXNXaXRob3V0Q2xlYXJpbmcgPSBtYWluVGhyZWFkR2VuZXJhdG9yLndlYmdsVXRpbHMucmVzaXplV2ViR0xDYW52YXNXaXRob3V0Q2xlYXJpbmc7XG5cbiAgY29uc3QgQ09ORklHID0ge1xuICAgIGRlZmF1bHRGb250VVJMOiBudWxsLFxuICAgIHVuaWNvZGVGb250c1VSTDogbnVsbCxcbiAgICBzZGZHbHlwaFNpemU6IDY0LFxuICAgIHNkZk1hcmdpbjogMSAvIDE2LFxuICAgIHNkZkV4cG9uZW50OiA5LFxuICAgIHRleHR1cmVXaWR0aDogMjA0OCxcbiAgICB1c2VXb3JrZXI6IHRydWUsXG4gIH07XG4gIGNvbnN0IHRlbXBDb2xvciA9IC8qI19fUFVSRV9fKi9uZXcgdGhyZWUuQ29sb3IoKTtcbiAgbGV0IGhhc1JlcXVlc3RlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIG5vdyQxKCkge1xuICAgIHJldHVybiAoc2VsZi5wZXJmb3JtYW5jZSB8fCBEYXRlKS5ub3coKVxuICB9XG5cbiAgLyoqXG4gICAqIEN1c3RvbWl6ZXMgdGhlIHRleHQgYnVpbGRlciBjb25maWd1cmF0aW9uLiBUaGlzIG11c3QgYmUgY2FsbGVkIHByaW9yIHRvIHRoZSBmaXJzdCBmb250IHByb2Nlc3NpbmdcbiAgICogcmVxdWVzdCwgYW5kIGFwcGxpZXMgdG8gYWxsIGZvbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmRlZmF1bHRGb250VVJMIC0gVGhlIFVSTCBvZiB0aGUgZGVmYXVsdCBmb250IHRvIHVzZSBmb3IgdGV4dCBwcm9jZXNzaW5nXG4gICAqICAgICAgICAgICAgICAgICByZXF1ZXN0cywgaW4gY2FzZSBub25lIGlzIHNwZWNpZmllZCBvciB0aGUgc3BlY2lmaWVkZSBmb250IGZhaWxzIHRvIGxvYWQgb3IgcGFyc2UuXG4gICAqICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byBcIlJvYm90byBSZWd1bGFyXCIgZnJvbSBHb29nbGUgRm9udHMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcudW5pY29kZUZvbnRzVVJMIC0gQSBjdXN0b20gbG9jYXRpb24gZm9yIHRoZSBmYWxsYmFjayB1bmljb2RlLWZvbnQtcmVzb2x2ZXJcbiAgICogICAgICAgICAgICAgICAgIGRhdGEgYW5kIGZvbnQgZmlsZXMsIGlmIHlvdSBkb24ndCB3YW50IHRvIHVzZSB0aGUgZGVmYXVsdCBDRE4uIFNlZVxuICAgKiAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2xvamppYy91bmljb2RlLWZvbnQtcmVzb2x2ZXIgZm9yIGRldGFpbHMuIEl0IGNhbiBhbHNvIGJlXG4gICAqICAgICAgICAgICAgICAgICBjb25maWd1cmVkIHBlciB0ZXh0IGluc3RhbmNlLCBidXQgdGhpcyBsZXRzIHlvdSBkbyBpdCBvbmNlIGdsb2JhbGx5LlxuICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnNkZkdseXBoU2l6ZSAtIFRoZSBkZWZhdWx0IHNpemUgb2YgZWFjaCBnbHlwaCdzIFNERiAoc2lnbmVkIGRpc3RhbmNlIGZpZWxkKVxuICAgKiAgICAgICAgICAgICAgICAgdGV4dHVyZSB1c2VkIGZvciByZW5kZXJpbmcuIE11c3QgYmUgYSBwb3dlci1vZi10d28gbnVtYmVyLCBhbmQgYXBwbGllcyB0byBhbGwgZm9udHMsXG4gICAqICAgICAgICAgICAgICAgICBidXQgbm90ZSB0aGF0IHRoaXMgY2FuIGFsc28gYmUgb3ZlcnJpZGRlbiBwZXIgY2FsbCB0byBgZ2V0VGV4dFJlbmRlckluZm8oKWAuXG4gICAqICAgICAgICAgICAgICAgICBMYXJnZXIgc2l6ZXMgY2FuIGltcHJvdmUgdGhlIHF1YWxpdHkgb2YgZ2x5cGggcmVuZGVyaW5nIGJ5IGluY3JlYXNpbmcgdGhlIHNoYXJwbmVzc1xuICAgKiAgICAgICAgICAgICAgICAgb2YgY29ybmVycyBhbmQgcHJldmVudGluZyBsb3NzIG9mIHZlcnkgdGhpbiBsaW5lcywgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5LiBEZWZhdWx0c1xuICAgKiAgICAgICAgICAgICAgICAgdG8gNjQgd2hpY2ggaXMgZ2VuZXJhbGx5IGEgZ29vZCBiYWxhbmNlIG9mIHNpemUgYW5kIHF1YWxpdHkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuc2RmRXhwb25lbnQgLSBUaGUgZXhwb25lbnQgdXNlZCB3aGVuIGVuY29kaW5nIHRoZSBTREYgdmFsdWVzLiBBIGhpZ2hlciBleHBvbmVudFxuICAgKiAgICAgICAgICAgICAgICAgc2hpZnRzIHRoZSBlbmNvZGVkIDgtYml0IHZhbHVlcyB0byBhY2hpZXZlIGhpZ2hlciBwcmVjaXNpb24vYWNjdXJhY3kgYXQgdGV4ZWxzIG5lYXJlclxuICAgKiAgICAgICAgICAgICAgICAgdGhlIGdseXBoJ3MgcGF0aCwgd2l0aCBsb3dlciBwcmVjaXNpb24gZnVydGhlciBhd2F5LiBEZWZhdWx0cyB0byA5LlxuICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnNkZk1hcmdpbiAtIEhvdyBtdWNoIHNwYWNlIHRvIHJlc2VydmUgaW4gdGhlIFNERiBhcyBtYXJnaW4gb3V0c2lkZSB0aGUgZ2x5cGgnc1xuICAgKiAgICAgICAgICAgICAgICAgcGF0aCwgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBTREYgd2lkdGguIEEgbGFyZ2VyIG1hcmdpbiBpbmNyZWFzZXMgdGhlIHF1YWxpdHkgb2ZcbiAgICogICAgICAgICAgICAgICAgIGV4dHJ1ZGVkIGdseXBoIG91dGxpbmVzLCBidXQgZGVjcmVhc2VzIHRoZSBwcmVjaXNpb24gYXZhaWxhYmxlIGZvciB0aGUgZ2x5cGggaXRzZWxmLlxuICAgKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gMS8xNnRoIG9mIHRoZSBnbHlwaCBzaXplLlxuICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnRleHR1cmVXaWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgU0RGIHRleHR1cmU7IG11c3QgYmUgYSBwb3dlciBvZiAyLiBEZWZhdWx0cyB0b1xuICAgKiAgICAgICAgICAgICAgICAgMjA0OCB3aGljaCBpcyBhIHNhZmUgbWF4aW11bSB0ZXh0dXJlIGRpbWVuc2lvbiBhY2NvcmRpbmcgdG8gdGhlIHN0YXRzIGF0XG4gICAqICAgICAgICAgICAgICAgICBodHRwczovL3dlYmdsc3RhdHMuY29tL3dlYmdsL3BhcmFtZXRlci9NQVhfVEVYVFVSRV9TSVpFIGFuZCBzaG91bGQgYWxsb3cgZm9yIGFcbiAgICogICAgICAgICAgICAgICAgIHJlYXNvbmFibHkgbGFyZ2UgbnVtYmVyIG9mIGdseXBocyAoZGVmYXVsdCBnbHlwaCBzaXplIG9mIDY0XjIgYW5kIHNhZmUgdGV4dHVyZSBzaXplIG9mXG4gICAqICAgICAgICAgICAgICAgICAyMDQ4XjIsIHRpbWVzIDQgY2hhbm5lbHMsIGFsbG93cyBmb3IgNDA5NiBnbHlwaHMuKSBUaGlzIGNhbiBiZSBpbmNyZWFzZWQgaWYgeW91IG5lZWQgdG9cbiAgICogICAgICAgICAgICAgICAgIGluY3JlYXNlIHRoZSBnbHlwaCBzaXplIGFuZC9vciBoYXZlIGFuIGV4dHJhb3JkaW5hcnkgbnVtYmVyIG9mIGdseXBocy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBjb25maWcudXNlV29ya2VyIC0gV2hldGhlciB0byBydW4gdHlwZXNldHRpbmcgaW4gYSB3ZWIgd29ya2VyLiBEZWZhdWx0cyB0byB0cnVlLlxuICAgKi9cbiAgZnVuY3Rpb24gY29uZmlndXJlVGV4dEJ1aWxkZXIoY29uZmlnKSB7XG4gICAgaWYgKGhhc1JlcXVlc3RlZCkge1xuICAgICAgY29uc29sZS53YXJuKCdjb25maWd1cmVUZXh0QnVpbGRlciBjYWxsZWQgYWZ0ZXIgZmlyc3QgZm9udCByZXF1ZXN0OyB3aWxsIGJlIGlnbm9yZWQuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnbihDT05GSUcsIGNvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcG9zaXRvcnkgZm9yIGFsbCBmb250IFNERiBhdGxhcyB0ZXh0dXJlcyBhbmQgdGhlaXIgZ2x5cGggbWFwcGluZ3MuIFRoZXJlIGlzIGEgc2VwYXJhdGUgYXRsYXMgZm9yXG4gICAqIGVhY2ggc2RmR2x5cGhTaXplLiBFYWNoIGF0bGFzIGhhcyBhIHNpbmdsZSBUZXh0dXJlIHRoYXQgaG9sZHMgYWxsIGdseXBocyBmb3IgYWxsIGZvbnRzLlxuICAgKlxuICAgKiAgIHtcbiAgICogICAgIFtzZGZHbHlwaFNpemVdOiB7XG4gICAqICAgICAgIGdseXBoQ291bnQ6IG51bWJlcixcbiAgICogICAgICAgc2RmR2x5cGhTaXplOiBudW1iZXIsXG4gICAqICAgICAgIHNkZlRleHR1cmU6IFRleHR1cmUsXG4gICAqICAgICAgIHNkZkNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsXG4gICAqICAgICAgIGNvbnRleHRMb3N0OiBib29sZWFuLFxuICAgKiAgICAgICBnbHlwaHNCeUZvbnQ6IE1hcDxmb250VVJMLCBNYXA8Z2x5cGhJRCwge3BhdGgsIGF0bGFzSW5kZXgsIHNkZlZpZXdCb3h9Pj5cbiAgICogICAgIH1cbiAgICogICB9XG4gICAqL1xuICBjb25zdCBhdGxhc2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvKipcbiAgICogQHR5cGVkZWYge29iamVjdH0gVHJvaWthVGV4dFJlbmRlckluZm8gLSBGb3JtYXQgb2YgdGhlIHJlc3VsdCBmcm9tIGBnZXRUZXh0UmVuZGVySW5mb2AuXG4gICAqIEBwcm9wZXJ0eSB7VHlwZXNldFBhcmFtc30gcGFyYW1ldGVycyAtIFRoZSBub3JtYWxpemVkIGlucHV0IGFyZ3VtZW50cyB0byB0aGUgcmVuZGVyIGNhbGwuXG4gICAqIEBwcm9wZXJ0eSB7VGV4dHVyZX0gc2RmVGV4dHVyZSAtIFRoZSBTREYgYXRsYXMgdGV4dHVyZS5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNkZkdseXBoU2l6ZSAtIFRoZSBzaXplIG9mIGVhY2ggZ2x5cGgncyBTREY7IHNlZSBgY29uZmlndXJlVGV4dEJ1aWxkZXJgLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gc2RmRXhwb25lbnQgLSBUaGUgZXhwb25lbnQgdXNlZCBpbiBlbmNvZGluZyB0aGUgU0RGJ3MgdmFsdWVzOyBzZWUgYGNvbmZpZ3VyZVRleHRCdWlsZGVyYC5cbiAgICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IGdseXBoQm91bmRzIC0gTGlzdCBvZiBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gcXVhZCBib3VuZHMgZm9yIGVhY2ggZ2x5cGguXG4gICAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBnbHlwaEF0bGFzSW5kaWNlcyAtIExpc3QgaG9sZGluZyBlYWNoIGdseXBoJ3MgaW5kZXggaW4gdGhlIFNERiBhdGxhcy5cbiAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBbZ2x5cGhDb2xvcnNdIC0gTGlzdCBob2xkaW5nIGVhY2ggZ2x5cGgncyBbciwgZywgYl0gY29sb3IsIGlmIGBjb2xvclJhbmdlc2Agd2FzIHN1cHBsaWVkLlxuICAgKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gW2NhcmV0UG9zaXRpb25zXSAtIEEgbGlzdCBvZiBjYXJldCBwb3NpdGlvbnMgZm9yIGFsbCBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmc7IGVhY2ggaXNcbiAgICogICAgICAgICAgIGZvdXIgZWxlbWVudHM6IHRoZSBzdGFydGluZyBYLCB0aGUgZW5kaW5nIFgsIHRoZSBib3R0b20gWSwgYW5kIHRoZSB0b3AgWSBmb3IgdGhlIGNhcmV0LlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW2NhcmV0SGVpZ2h0XSAtIEFuIGFwcHJvcHJpYXRlIGhlaWdodCBmb3IgYWxsIHNlbGVjdGlvbiBjYXJldHMuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhc2NlbmRlciAtIFRoZSBmb250J3MgYXNjZW5kZXIgbWV0cmljLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gZGVzY2VuZGVyIC0gVGhlIGZvbnQncyBkZXNjZW5kZXIgbWV0cmljLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gY2FwSGVpZ2h0IC0gVGhlIGZvbnQncyBjYXAgaGVpZ2h0IG1ldHJpYywgYmFzZWQgb24gdGhlIGhlaWdodCBvZiBMYXRpbiBjYXBpdGFsIGxldHRlcnMuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4SGVpZ2h0IC0gVGhlIGZvbnQncyB4IGhlaWdodCBtZXRyaWMsIGJhc2VkIG9uIHRoZSBoZWlnaHQgb2YgTGF0aW4gbG93ZXJjYXNlIGxldHRlcnMuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lSGVpZ2h0IC0gVGhlIGZpbmFsIGNvbXB1dGVkIGxpbmVIZWlnaHQgbWVhc3VyZW1lbnQuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0b3BCYXNlbGluZSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSB0b3AgbGluZSdzIGJhc2VsaW5lLlxuICAgKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IGJsb2NrQm91bmRzIC0gVGhlIHRvdGFsIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSByZWN0IG9mIHRoZSB3aG9sZSB0ZXh0IGJsb2NrO1xuICAgKiAgICAgICAgICAgdGhpcyBjYW4gaW5jbHVkZSBleHRyYSB2ZXJ0aWNhbCBzcGFjZSBiZXlvbmQgdGhlIHZpc2libGUgZ2x5cGhzIGR1ZSB0byBsaW5lSGVpZ2h0LCBhbmQgaXNcbiAgICogICAgICAgICAgIGVxdWl2YWxlbnQgdG8gdGhlIGRpbWVuc2lvbnMgb2YgYSBibG9jay1sZXZlbCB0ZXh0IGVsZW1lbnQgaW4gQ1NTLlxuICAgKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IHZpc2libGVCb3VuZHMgLSBUaGUgdG90YWwgW21pblgsIG1pblksIG1heFgsIG1heFldIHJlY3Qgb2YgdGhlIHdob2xlIHRleHQgYmxvY2s7XG4gICAqICAgICAgICAgICB1bmxpa2UgYGJsb2NrQm91bmRzYCB0aGlzIGlzIHRpZ2h0bHkgd3JhcHBlZCB0byB0aGUgdmlzaWJsZSBnbHlwaCBwYXRocy5cbiAgICogQHByb3BlcnR5IHtBcnJheTxvYmplY3Q+fSBjaHVua2VkQm91bmRzIC0gTGlzdCBvZiBib3VuZGluZyByZWN0cyBmb3IgZWFjaCBjb25zZWN1dGl2ZSBzZXQgb2YgTiBnbHlwaHMsXG4gICAqICAgICAgICAgICBpbiB0aGUgZm9ybWF0IGB7c3RhcnQ6TiwgZW5kOk4sIHJlY3Q6W21pblgsIG1pblksIG1heFgsIG1heFldfWAuXG4gICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB0aW1pbmdzIC0gVGltaW5nIGluZm8gZm9yIHZhcmlvdXMgcGFydHMgb2YgdGhlIHJlbmRlcmluZyBsb2dpYyBpbmNsdWRpbmcgU0RGXG4gICAqICAgICAgICAgICBnZW5lcmF0aW9uLCB0eXBlc2V0dGluZywgZXRjLlxuICAgKiBAZnJvemVuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAY2FsbGJhY2sgZ2V0VGV4dFJlbmRlckluZm9+Y2FsbGJhY2tcbiAgICogQHBhcmFtIHtUcm9pa2FUZXh0UmVuZGVySW5mb30gdGV4dFJlbmRlckluZm9cbiAgICovXG5cbiAgLyoqXG4gICAqIE1haW4gZW50cnkgcG9pbnQgZm9yIHJlcXVlc3RpbmcgdGhlIGRhdGEgbmVlZGVkIHRvIHJlbmRlciBhIHRleHQgc3RyaW5nIHdpdGggZ2l2ZW4gZm9udCBwYXJhbWV0ZXJzLlxuICAgKiBUaGlzIGlzIGFuIGFzeW5jaHJvbm91cyBjYWxsLCBwZXJmb3JtaW5nIG1vc3Qgb2YgdGhlIGxvZ2ljIGluIGEgd2ViIHdvcmtlciB0aHJlYWQuXG4gICAqIEBwYXJhbSB7VHlwZXNldFBhcmFtc30gYXJnc1xuICAgKiBAcGFyYW0ge2dldFRleHRSZW5kZXJJbmZvfmNhbGxiYWNrfSBjYWxsYmFja1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VGV4dFJlbmRlckluZm8oYXJncywgY2FsbGJhY2spIHtcbiAgICBoYXNSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgIGFyZ3MgPSBhc3NpZ24oe30sIGFyZ3MpO1xuICAgIGNvbnN0IHRvdGFsU3RhcnQgPSBub3ckMSgpO1xuXG4gICAgLy8gQ29udmVydCByZWxhdGl2ZSBVUkwgdG8gYWJzb2x1dGUgc28gaXQgY2FuIGJlIHJlc29sdmVkIGluIHRoZSB3b3JrZXIsIGFuZCBhZGQgZmFsbGJhY2tzLlxuICAgIC8vIEluIHRoZSBmdXR1cmUgd2UnbGwgYWxsb3cgYXJncy5mb250IHRvIGJlIGEgbGlzdCB3aXRoIHVuaWNvZGUgcmFuZ2VzIHRvby5cbiAgICBjb25zdCB7IGRlZmF1bHRGb250VVJMIH0gPSBDT05GSUc7XG4gICAgY29uc3QgZm9udHMgPSBbXTtcbiAgICBpZiAoZGVmYXVsdEZvbnRVUkwpIHtcbiAgICAgIGZvbnRzLnB1c2goe2xhYmVsOiAnZGVmYXVsdCcsIHNyYzogdG9BYnNvbHV0ZVVSTChkZWZhdWx0Rm9udFVSTCl9KTtcbiAgICB9XG4gICAgaWYgKGFyZ3MuZm9udCkge1xuICAgICAgZm9udHMucHVzaCh7bGFiZWw6ICd1c2VyJywgc3JjOiB0b0Fic29sdXRlVVJMKGFyZ3MuZm9udCl9KTtcbiAgICB9XG4gICAgYXJncy5mb250ID0gZm9udHM7XG5cbiAgICAvLyBOb3JtYWxpemUgdGV4dCB0byBhIHN0cmluZ1xuICAgIGFyZ3MudGV4dCA9ICcnICsgYXJncy50ZXh0O1xuXG4gICAgYXJncy5zZGZHbHlwaFNpemUgPSBhcmdzLnNkZkdseXBoU2l6ZSB8fCBDT05GSUcuc2RmR2x5cGhTaXplO1xuICAgIGFyZ3MudW5pY29kZUZvbnRzVVJMID0gYXJncy51bmljb2RlRm9udHNVUkwgfHwgQ09ORklHLnVuaWNvZGVGb250c1VSTDtcblxuICAgIC8vIE5vcm1hbGl6ZSBjb2xvcnNcbiAgICBpZiAoYXJncy5jb2xvclJhbmdlcyAhPSBudWxsKSB7XG4gICAgICBsZXQgY29sb3JzID0ge307XG4gICAgICBmb3IgKGxldCBrZXkgaW4gYXJncy5jb2xvclJhbmdlcykge1xuICAgICAgICBpZiAoYXJncy5jb2xvclJhbmdlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgbGV0IHZhbCA9IGFyZ3MuY29sb3JSYW5nZXNba2V5XTtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhbCA9IHRlbXBDb2xvci5zZXQodmFsKS5nZXRIZXgoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29sb3JzW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFyZ3MuY29sb3JSYW5nZXMgPSBjb2xvcnM7XG4gICAgfVxuXG4gICAgT2JqZWN0LmZyZWV6ZShhcmdzKTtcblxuICAgIC8vIEluaXQgdGhlIGF0bGFzIGlmIG5lZWRlZFxuICAgIGNvbnN0IHt0ZXh0dXJlV2lkdGgsIHNkZkV4cG9uZW50fSA9IENPTkZJRztcbiAgICBjb25zdCB7c2RmR2x5cGhTaXplfSA9IGFyZ3M7XG4gICAgY29uc3QgZ2x5cGhzUGVyUm93ID0gKHRleHR1cmVXaWR0aCAvIHNkZkdseXBoU2l6ZSAqIDQpO1xuICAgIGxldCBhdGxhcyA9IGF0bGFzZXNbc2RmR2x5cGhTaXplXTtcbiAgICBpZiAoIWF0bGFzKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHRleHR1cmVXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBzZGZHbHlwaFNpemUgKiAyNTYgLyBnbHlwaHNQZXJSb3c7IC8vIHN0YXJ0IHRhbGwgZW5vdWdoIHRvIGZpdCAyNTYgZ2x5cGhzXG4gICAgICBhdGxhcyA9IGF0bGFzZXNbc2RmR2x5cGhTaXplXSA9IHtcbiAgICAgICAgZ2x5cGhDb3VudDogMCxcbiAgICAgICAgc2RmR2x5cGhTaXplLFxuICAgICAgICBzZGZDYW52YXM6IGNhbnZhcyxcbiAgICAgICAgc2RmVGV4dHVyZTogbmV3IHRocmVlLlRleHR1cmUoXG4gICAgICAgICAgY2FudmFzLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHRocmVlLkxpbmVhckZpbHRlcixcbiAgICAgICAgICB0aHJlZS5MaW5lYXJGaWx0ZXJcbiAgICAgICAgKSxcbiAgICAgICAgY29udGV4dExvc3Q6IGZhbHNlLFxuICAgICAgICBnbHlwaHNCeUZvbnQ6IG5ldyBNYXAoKVxuICAgICAgfTtcbiAgICAgIGF0bGFzLnNkZlRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgICBpbml0Q29udGV4dExvc3NIYW5kbGluZyhhdGxhcyk7XG4gICAgfVxuXG4gICAgY29uc3Qge3NkZlRleHR1cmUsIHNkZkNhbnZhc30gPSBhdGxhcztcblxuICAgIC8vIElzc3VlIHJlcXVlc3QgdG8gdGhlIHR5cGVzZXR0aW5nIGVuZ2luZSBpbiB0aGUgd29ya2VyXG4gICAgY29uc3QgdHlwZXNldCA9IENPTkZJRy51c2VXb3JrZXIgPyB0eXBlc2V0SW5Xb3JrZXIgOiB0eXBlc2V0T25NYWluVGhyZWFkO1xuICAgIHR5cGVzZXQoYXJncykudGhlbihyZXN1bHQgPT4ge1xuICAgICAgY29uc3Qge2dseXBoSWRzLCBnbHlwaEZvbnRJbmRpY2VzLCBmb250RGF0YSwgZ2x5cGhQb3NpdGlvbnMsIGZvbnRTaXplLCB0aW1pbmdzfSA9IHJlc3VsdDtcbiAgICAgIGNvbnN0IG5lZWRlZFNERnMgPSBbXTtcbiAgICAgIGNvbnN0IGdseXBoQm91bmRzID0gbmV3IEZsb2F0MzJBcnJheShnbHlwaElkcy5sZW5ndGggKiA0KTtcbiAgICAgIGxldCBib3VuZHNJZHggPSAwO1xuICAgICAgbGV0IHBvc2l0aW9uc0lkeCA9IDA7XG4gICAgICBjb25zdCBxdWFkc1N0YXJ0ID0gbm93JDEoKTtcblxuICAgICAgY29uc3QgZm9udEdseXBoTWFwcyA9IGZvbnREYXRhLm1hcChmb250ID0+IHtcbiAgICAgICAgbGV0IG1hcCA9IGF0bGFzLmdseXBoc0J5Rm9udC5nZXQoZm9udC5zcmMpO1xuICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgIGF0bGFzLmdseXBoc0J5Rm9udC5zZXQoZm9udC5zcmMsIG1hcCA9IG5ldyBNYXAoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcFxuICAgICAgfSk7XG5cbiAgICAgIGdseXBoSWRzLmZvckVhY2goKGdseXBoSWQsIGkpID0+IHtcbiAgICAgICAgY29uc3QgZm9udEluZGV4ID0gZ2x5cGhGb250SW5kaWNlc1tpXTtcbiAgICAgICAgY29uc3Qge3NyYzogZm9udFNyYywgdW5pdHNQZXJFbX0gPSBmb250RGF0YVtmb250SW5kZXhdO1xuICAgICAgICBsZXQgZ2x5cGhJbmZvID0gZm9udEdseXBoTWFwc1tmb250SW5kZXhdLmdldChnbHlwaElkKTtcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIGEgZ2x5cGhJZCBub3Qgc2VlbiBiZWZvcmUsIGFkZCBpdCB0byB0aGUgYXRsYXNcbiAgICAgICAgaWYgKCFnbHlwaEluZm8pIHtcbiAgICAgICAgICBjb25zdCB7cGF0aCwgcGF0aEJvdW5kc30gPSByZXN1bHQuZ2x5cGhEYXRhW2ZvbnRTcmNdW2dseXBoSWRdO1xuXG4gICAgICAgICAgLy8gTWFyZ2luIGFyb3VuZCBwYXRoIGVkZ2VzIGluIFNERiwgYmFzZWQgb24gYSBwZXJjZW50YWdlIG9mIHRoZSBnbHlwaCdzIG1heCBkaW1lbnNpb24uXG4gICAgICAgICAgLy8gTm90ZSB3ZSBhZGQgYW4gZXh0cmEgMC41IHB4IG92ZXIgdGhlIGNvbmZpZ3VyZWQgdmFsdWUgYmVjYXVzZSB0aGUgb3V0ZXIgMC41IGRvZXNuJ3QgY29udGFpblxuICAgICAgICAgIC8vIHVzZWZ1bCBpbnRlcnBvbGF0ZWQgdmFsdWVzIGFuZCB3aWxsIGJlIGlnbm9yZWQgYW55d2F5LlxuICAgICAgICAgIGNvbnN0IGZvbnRVbml0c01hcmdpbiA9IE1hdGgubWF4KHBhdGhCb3VuZHNbMl0gLSBwYXRoQm91bmRzWzBdLCBwYXRoQm91bmRzWzNdIC0gcGF0aEJvdW5kc1sxXSlcbiAgICAgICAgICAgIC8gc2RmR2x5cGhTaXplICogKENPTkZJRy5zZGZNYXJnaW4gKiBzZGZHbHlwaFNpemUgKyAwLjUpO1xuXG4gICAgICAgICAgY29uc3QgYXRsYXNJbmRleCA9IGF0bGFzLmdseXBoQ291bnQrKztcbiAgICAgICAgICBjb25zdCBzZGZWaWV3Qm94ID0gW1xuICAgICAgICAgICAgcGF0aEJvdW5kc1swXSAtIGZvbnRVbml0c01hcmdpbixcbiAgICAgICAgICAgIHBhdGhCb3VuZHNbMV0gLSBmb250VW5pdHNNYXJnaW4sXG4gICAgICAgICAgICBwYXRoQm91bmRzWzJdICsgZm9udFVuaXRzTWFyZ2luLFxuICAgICAgICAgICAgcGF0aEJvdW5kc1szXSArIGZvbnRVbml0c01hcmdpbixcbiAgICAgICAgICBdO1xuICAgICAgICAgIGZvbnRHbHlwaE1hcHNbZm9udEluZGV4XS5zZXQoZ2x5cGhJZCwgKGdseXBoSW5mbyA9IHsgcGF0aCwgYXRsYXNJbmRleCwgc2RmVmlld0JveCB9KSk7XG5cbiAgICAgICAgICAvLyBDb2xsZWN0IHRob3NlIHRoYXQgbmVlZCBTREYgZ2VuZXJhdGlvblxuICAgICAgICAgIG5lZWRlZFNERnMucHVzaChnbHlwaEluZm8pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGJvdW5kcyBmb3IgcmVuZGVyYWJsZSBxdWFkc1xuICAgICAgICAvLyBUT0RPIGNhbiB3ZSBnZXQgdGhpcyBiYWNrIG9mZiB0aGUgbWFpbiB0aHJlYWQ/XG4gICAgICAgIGNvbnN0IHtzZGZWaWV3Qm94fSA9IGdseXBoSW5mbztcbiAgICAgICAgY29uc3QgcG9zWCA9IGdseXBoUG9zaXRpb25zW3Bvc2l0aW9uc0lkeCsrXTtcbiAgICAgICAgY29uc3QgcG9zWSA9IGdseXBoUG9zaXRpb25zW3Bvc2l0aW9uc0lkeCsrXTtcbiAgICAgICAgY29uc3QgZm9udFNpemVNdWx0ID0gZm9udFNpemUgLyB1bml0c1BlckVtO1xuICAgICAgICBnbHlwaEJvdW5kc1tib3VuZHNJZHgrK10gPSBwb3NYICsgc2RmVmlld0JveFswXSAqIGZvbnRTaXplTXVsdDtcbiAgICAgICAgZ2x5cGhCb3VuZHNbYm91bmRzSWR4KytdID0gcG9zWSArIHNkZlZpZXdCb3hbMV0gKiBmb250U2l6ZU11bHQ7XG4gICAgICAgIGdseXBoQm91bmRzW2JvdW5kc0lkeCsrXSA9IHBvc1ggKyBzZGZWaWV3Qm94WzJdICogZm9udFNpemVNdWx0O1xuICAgICAgICBnbHlwaEJvdW5kc1tib3VuZHNJZHgrK10gPSBwb3NZICsgc2RmVmlld0JveFszXSAqIGZvbnRTaXplTXVsdDtcblxuICAgICAgICAvLyBDb252ZXJ0IGdseXBoSWQgdG8gU0RGIGluZGV4IGZvciB0aGUgc2hhZGVyXG4gICAgICAgIGdseXBoSWRzW2ldID0gZ2x5cGhJbmZvLmF0bGFzSW5kZXg7XG4gICAgICB9KTtcbiAgICAgIHRpbWluZ3MucXVhZHMgPSAodGltaW5ncy5xdWFkcyB8fCAwKSArIChub3ckMSgpIC0gcXVhZHNTdGFydCk7XG5cbiAgICAgIGNvbnN0IHNkZlN0YXJ0ID0gbm93JDEoKTtcbiAgICAgIHRpbWluZ3Muc2RmID0ge307XG5cbiAgICAgIC8vIEdyb3cgdGhlIHRleHR1cmUgaGVpZ2h0IGJ5IHBvd2VyIG9mIDIgaWYgbmVlZGVkXG4gICAgICBjb25zdCBjdXJyZW50SGVpZ2h0ID0gc2RmQ2FudmFzLmhlaWdodDtcbiAgICAgIGNvbnN0IG5lZWRlZFJvd3MgPSBNYXRoLmNlaWwoYXRsYXMuZ2x5cGhDb3VudCAvIGdseXBoc1BlclJvdyk7XG4gICAgICBjb25zdCBuZWVkZWRIZWlnaHQgPSBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2cyKG5lZWRlZFJvd3MgKiBzZGZHbHlwaFNpemUpKSk7XG4gICAgICBpZiAobmVlZGVkSGVpZ2h0ID4gY3VycmVudEhlaWdodCkge1xuICAgICAgICAvLyBTaW5jZSByZXNpemluZyB0aGUgY2FudmFzIGNsZWFycyBpdHMgcmVuZGVyIGJ1ZmZlciwgaXQgbmVlZHMgc3BlY2lhbCBoYW5kbGluZyB0byBjb3B5IHRoZSBvbGQgY29udGVudHMgb3ZlclxuICAgICAgICBjb25zb2xlLmluZm8oYEluY3JlYXNpbmcgU0RGIHRleHR1cmUgc2l6ZSAke2N1cnJlbnRIZWlnaHR9LT4ke25lZWRlZEhlaWdodH1gKTtcbiAgICAgICAgcmVzaXplV2ViR0xDYW52YXNXaXRob3V0Q2xlYXJpbmcoc2RmQ2FudmFzLCB0ZXh0dXJlV2lkdGgsIG5lZWRlZEhlaWdodCk7XG4gICAgICAgIC8vIEFzIG9mIFRocmVlIHIxMzYgdGV4dHVyZXMgY2Fubm90IGJlIHJlc2l6ZWQgb25jZSB0aGV5J3JlIGFsbG9jYXRlZCBvbiB0aGUgR1BVLCB3ZSBtdXN0IGRpc3Bvc2UgdG8gcmVhbGxvY2F0ZSBpdFxuICAgICAgICBzZGZUZXh0dXJlLmRpc3Bvc2UoKTtcbiAgICAgIH1cblxuICAgICAgUHJvbWlzZS5hbGwobmVlZGVkU0RGcy5tYXAoZ2x5cGhJbmZvID0+XG4gICAgICAgIGdlbmVyYXRlR2x5cGhTREYoZ2x5cGhJbmZvLCBhdGxhcywgYXJncy5ncHVBY2NlbGVyYXRlU0RGKS50aGVuKCh7dGltaW5nfSkgPT4ge1xuICAgICAgICAgIHRpbWluZ3Muc2RmW2dseXBoSW5mby5hdGxhc0luZGV4XSA9IHRpbWluZztcbiAgICAgICAgfSlcbiAgICAgICkpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAobmVlZGVkU0RGcy5sZW5ndGggJiYgIWF0bGFzLmNvbnRleHRMb3N0KSB7XG4gICAgICAgICAgc2FmYXJpUHJlMTVXb3JrYXJvdW5kKGF0bGFzKTtcbiAgICAgICAgICBzZGZUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aW1pbmdzLnNkZlRvdGFsID0gbm93JDEoKSAtIHNkZlN0YXJ0O1xuICAgICAgICB0aW1pbmdzLnRvdGFsID0gbm93JDEoKSAtIHRvdGFsU3RhcnQ7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBTREYgLSAke3RpbWluZ3Muc2RmVG90YWx9LCBUb3RhbCAtICR7dGltaW5ncy50b3RhbCAtIHRpbWluZ3MuZm9udExvYWR9YClcblxuICAgICAgICAvLyBJbnZva2UgY2FsbGJhY2sgd2l0aCB0aGUgdGV4dCBsYXlvdXQgYXJyYXlzIGFuZCB1cGRhdGVkIHRleHR1cmVcbiAgICAgICAgY2FsbGJhY2soT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgcGFyYW1ldGVyczogYXJncyxcbiAgICAgICAgICBzZGZUZXh0dXJlLFxuICAgICAgICAgIHNkZkdseXBoU2l6ZSxcbiAgICAgICAgICBzZGZFeHBvbmVudCxcbiAgICAgICAgICBnbHlwaEJvdW5kcyxcbiAgICAgICAgICBnbHlwaEF0bGFzSW5kaWNlczogZ2x5cGhJZHMsXG4gICAgICAgICAgZ2x5cGhDb2xvcnM6IHJlc3VsdC5nbHlwaENvbG9ycyxcbiAgICAgICAgICBjYXJldFBvc2l0aW9uczogcmVzdWx0LmNhcmV0UG9zaXRpb25zLFxuICAgICAgICAgIGNodW5rZWRCb3VuZHM6IHJlc3VsdC5jaHVua2VkQm91bmRzLFxuICAgICAgICAgIGFzY2VuZGVyOiByZXN1bHQuYXNjZW5kZXIsXG4gICAgICAgICAgZGVzY2VuZGVyOiByZXN1bHQuZGVzY2VuZGVyLFxuICAgICAgICAgIGxpbmVIZWlnaHQ6IHJlc3VsdC5saW5lSGVpZ2h0LFxuICAgICAgICAgIGNhcEhlaWdodDogcmVzdWx0LmNhcEhlaWdodCxcbiAgICAgICAgICB4SGVpZ2h0OiByZXN1bHQueEhlaWdodCxcbiAgICAgICAgICB0b3BCYXNlbGluZTogcmVzdWx0LnRvcEJhc2VsaW5lLFxuICAgICAgICAgIGJsb2NrQm91bmRzOiByZXN1bHQuYmxvY2tCb3VuZHMsXG4gICAgICAgICAgdmlzaWJsZUJvdW5kczogcmVzdWx0LnZpc2libGVCb3VuZHMsXG4gICAgICAgICAgdGltaW5nczogcmVzdWx0LnRpbWluZ3MsXG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gV2hpbGUgdGhlIHR5cGVzZXR0aW5nIHJlcXVlc3QgaXMgYmVpbmcgaGFuZGxlZCwgZ28gYWhlYWQgYW5kIG1ha2Ugc3VyZSB0aGUgYXRsYXMgY2FudmFzIGNvbnRleHQgaXNcbiAgICAvLyBcIndhcm1lZCB1cFwiOyB0aGUgZmlyc3QgcmVxdWVzdCB3aWxsIGJlIHRoZSBsb25nZXN0IGR1ZSB0byBzaGFkZXIgcHJvZ3JhbSBjb21waWxhdGlvbiBzbyB0aGlzIGdldHNcbiAgICAvLyBhIGhlYWQgc3RhcnQgb24gdGhhdCBwcm9jZXNzIGJlZm9yZSBTREZzIGFjdHVhbGx5IHN0YXJ0IGdldHRpbmcgcHJvY2Vzc2VkLlxuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKCFhdGxhcy5jb250ZXh0TG9zdCkge1xuICAgICAgICB3YXJtVXBTREZDYW52YXMoc2RmQ2FudmFzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlR2x5cGhTREYoe3BhdGgsIGF0bGFzSW5kZXgsIHNkZlZpZXdCb3h9LCB7c2RmR2x5cGhTaXplLCBzZGZDYW52YXMsIGNvbnRleHRMb3N0fSwgdXNlR1BVKSB7XG4gICAgaWYgKGNvbnRleHRMb3N0KSB7XG4gICAgICAvLyBJZiB0aGUgY29udGV4dCBpcyBsb3N0IHRoZXJlJ3Mgbm90aGluZyB3ZSBjYW4gZG8sIGp1c3QgcXVpdCBzaWxlbnRseSBhbmQgbGV0IGl0XG4gICAgICAvLyBnZXQgcmVnZW5lcmF0ZWQgd2hlbiB0aGUgY29udGV4dCBpcyByZXN0b3JlZFxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7dGltaW5nOiAtMX0pXG4gICAgfVxuICAgIGNvbnN0IHt0ZXh0dXJlV2lkdGgsIHNkZkV4cG9uZW50fSA9IENPTkZJRztcbiAgICBjb25zdCBtYXhEaXN0ID0gTWF0aC5tYXgoc2RmVmlld0JveFsyXSAtIHNkZlZpZXdCb3hbMF0sIHNkZlZpZXdCb3hbM10gLSBzZGZWaWV3Qm94WzFdKTtcbiAgICBjb25zdCBzcXVhcmVJbmRleCA9IE1hdGguZmxvb3IoYXRsYXNJbmRleCAvIDQpO1xuICAgIGNvbnN0IHggPSBzcXVhcmVJbmRleCAlICh0ZXh0dXJlV2lkdGggLyBzZGZHbHlwaFNpemUpICogc2RmR2x5cGhTaXplO1xuICAgIGNvbnN0IHkgPSBNYXRoLmZsb29yKHNxdWFyZUluZGV4IC8gKHRleHR1cmVXaWR0aCAvIHNkZkdseXBoU2l6ZSkpICogc2RmR2x5cGhTaXplO1xuICAgIGNvbnN0IGNoYW5uZWwgPSBhdGxhc0luZGV4ICUgNDtcbiAgICByZXR1cm4gZ2VuZXJhdGVTREYoc2RmR2x5cGhTaXplLCBzZGZHbHlwaFNpemUsIHBhdGgsIHNkZlZpZXdCb3gsIG1heERpc3QsIHNkZkV4cG9uZW50LCBzZGZDYW52YXMsIHgsIHksIGNoYW5uZWwsIHVzZUdQVSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb250ZXh0TG9zc0hhbmRsaW5nKGF0bGFzKSB7XG4gICAgY29uc3QgY2FudmFzID0gYXRsYXMuc2RmQ2FudmFzO1xuXG4gICAgLypcbiAgICAvLyBCZWdpbiBjb250ZXh0IGxvc3Mgc2ltdWxhdGlvblxuICAgIGlmICghd2luZG93LldlYkdMRGVidWdVdGlscykge1xuICAgICAgbGV0IHNjcmlwdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdXZWJHTERlYnVnVXRpbHNTY3JpcHQnKVxuICAgICAgaWYgKCFzY3JpcHQpIHtcbiAgICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgICAgICAgc2NyaXB0LmlkID0gJ1dlYkdMRGVidWdVdGlscydcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpXG4gICAgICAgIHNjcmlwdC5zcmMgPSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0tocm9ub3NHcm91cC9XZWJHTERldmVsb3BlclRvb2xzQGI0MmU3MDIvc3JjL2RlYnVnL3dlYmdsLWRlYnVnLmpzJ1xuICAgICAgfVxuICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgIGluaXRDb250ZXh0TG9zc0hhbmRsaW5nKGF0bGFzKVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB3aW5kb3cuV2ViR0xEZWJ1Z1V0aWxzLm1ha2VMb3N0Q29udGV4dFNpbXVsYXRpbmdDYW52YXMoY2FudmFzKVxuICAgIGNhbnZhcy5sb3NlQ29udGV4dEluTkNhbGxzKDUwMClcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNhbnZhcy5sb3NlQ29udGV4dEluTkNhbGxzKDUwMDApXG4gICAgfSlcbiAgICAvLyBFbmQgY29udGV4dCBsb3NzIHNpbXVsYXRpb25cbiAgICAqL1xuXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdDb250ZXh0IExvc3QnLCBldmVudCk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgYXRsYXMuY29udGV4dExvc3QgPSB0cnVlO1xuICAgIH0pO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIChldmVudCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ0NvbnRleHQgUmVzdG9yZWQnLCBldmVudCk7XG4gICAgICBhdGxhcy5jb250ZXh0TG9zdCA9IGZhbHNlO1xuICAgICAgLy8gUmVnZW5lcmF0ZSBhbGwgZ2x5cGhzIGludG8gdGhlIHJlc3RvcmVkIGNhbnZhczpcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICBhdGxhcy5nbHlwaHNCeUZvbnQuZm9yRWFjaChnbHlwaE1hcCA9PiB7XG4gICAgICAgIGdseXBoTWFwLmZvckVhY2goZ2x5cGggPT4ge1xuICAgICAgICAgIHByb21pc2VzLnB1c2goZ2VuZXJhdGVHbHlwaFNERihnbHlwaCwgYXRsYXMsIHRydWUpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgICAgc2FmYXJpUHJlMTVXb3JrYXJvdW5kKGF0bGFzKTtcbiAgICAgICAgYXRsYXMuc2RmVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVsb2FkIGEgZ2l2ZW4gZm9udCBhbmQgb3B0aW9uYWxseSBwcmUtZ2VuZXJhdGUgZ2x5cGggU0RGcyBmb3Igb25lIG9yIG1vcmUgY2hhcmFjdGVyIHNlcXVlbmNlcy5cbiAgICogVGhpcyBjYW4gYmUgdXNlZnVsIHRvIGF2b2lkIGxvbmcgcGF1c2VzIHdoZW4gZmlyc3Qgc2hvd2luZyB0ZXh0IGluIGEgc2NlbmUsIGJ5IHByZWxvYWRpbmcgdGhlXG4gICAqIG5lZWRlZCBmb250cyBhbmQgZ2x5cGhzIHVwIGZyb250IGFsb25nIHdpdGggb3RoZXIgYXNzZXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5mb250IC0gVVJMIG9mIHRoZSBmb250IGZpbGUgdG8gcHJlbG9hZC4gSWYgbm90IGdpdmVuLCB0aGUgZGVmYXVsdCBmb250IHdpbGxcbiAgICogICAgICAgIGJlIGxvYWRlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IG9wdGlvbnMuY2hhcmFjdGVycyAtIE9uZSBvciBtb3JlIGNoYXJhY3RlciBzZXF1ZW5jZXMgZm9yIHdoaWNoIHRvIHByZS1cbiAgICogICAgICAgIGdlbmVyYXRlIGdseXBoIFNERnMuIE5vdGUgdGhhdCB0aGlzIHdpbGwgaG9ub3IgbGlnYXR1cmUgc3Vic3RpdHV0aW9uLCBzbyB5b3UgbWF5IG5lZWRcbiAgICogICAgICAgIHRvIHNwZWNpZnkgbGlnYXR1cmUgc2VxdWVuY2VzIGluIGFkZGl0aW9uIHRvIHRoZWlyIGluZGl2aWR1YWwgY2hhcmFjdGVycyB0byBnZXQgYWxsXG4gICAqICAgICAgICBwb3NzaWJsZSBnbHlwaHMsIGUuZy4gYFtcInRcIiwgXCJoXCIsIFwidGhcIl1gIHRvIGdldCB0aGUgXCJ0XCIgYW5kIFwiaFwiIGdseXBocyBwbHVzIHRoZSBcInRoXCIgbGlnYXR1cmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnNkZkdseXBoU2l6ZSAtIFRoZSBzaXplIGF0IHdoaWNoIHRvIHByZXJlbmRlciB0aGUgU0RGIHRleHR1cmVzIGZvciB0aGVcbiAgICogICAgICAgIHNwZWNpZmllZCBgY2hhcmFjdGVyc2AuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHByZWxvYWRpbmcgaXMgY29tcGxldGUuXG4gICAqL1xuICBmdW5jdGlvbiBwcmVsb2FkRm9udCh7Zm9udCwgY2hhcmFjdGVycywgc2RmR2x5cGhTaXplfSwgY2FsbGJhY2spIHtcbiAgICBsZXQgdGV4dCA9IEFycmF5LmlzQXJyYXkoY2hhcmFjdGVycykgPyBjaGFyYWN0ZXJzLmpvaW4oJ1xcbicpIDogJycgKyBjaGFyYWN0ZXJzO1xuICAgIGdldFRleHRSZW5kZXJJbmZvKHsgZm9udCwgc2RmR2x5cGhTaXplLCB0ZXh0IH0sIGNhbGxiYWNrKTtcbiAgfVxuXG5cbiAgLy8gTG9jYWwgYXNzaWduIGltcGwgc28gd2UgZG9uJ3QgaGF2ZSB0byBpbXBvcnQgdHJvaWthLWNvcmVcbiAgZnVuY3Rpb24gYXNzaWduKHRvT2JqLCBmcm9tT2JqKSB7XG4gICAgZm9yIChsZXQga2V5IGluIGZyb21PYmopIHtcbiAgICAgIGlmIChmcm9tT2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdG9PYmpba2V5XSA9IGZyb21PYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqXG4gIH1cblxuICAvLyBVdGlsaXR5IGZvciBtYWtpbmcgVVJMcyBhYnNvbHV0ZVxuICBsZXQgbGlua0VsO1xuICBmdW5jdGlvbiB0b0Fic29sdXRlVVJMKHBhdGgpIHtcbiAgICBpZiAoIWxpbmtFbCkge1xuICAgICAgbGlua0VsID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyA/IHt9IDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIH1cbiAgICBsaW5rRWwuaHJlZiA9IHBhdGg7XG4gICAgcmV0dXJuIGxpbmtFbC5ocmVmXG4gIH1cblxuICAvKipcbiAgICogU2FmYXJpIDwgdjE1IHNlZW1zIHVuYWJsZSB0byB1c2UgdGhlIFNERiB3ZWJnbCBjYW52YXMgYXMgYSB0ZXh0dXJlLiBUaGlzIGFwcGxpZXMgYSB3b3JrYXJvdW5kXG4gICAqIHdoZXJlIGl0IHJlYWRzIHRoZSBwaXhlbHMgb3V0IG9mIHRoYXQgY2FudmFzIGFuZCB1cGxvYWRzIHRoZW0gYXMgYSBkYXRhIHRleHR1cmUgaW5zdGVhZCwgYXRcbiAgICogYSBzbGlnaHQgcGVyZm9ybWFuY2UgY29zdC5cbiAgICovXG4gIGZ1bmN0aW9uIHNhZmFyaVByZTE1V29ya2Fyb3VuZChhdGxhcykge1xuICAgIC8vIFVzZSBjcmVhdGVJbWFnZUJpdG1hcCBzdXBwb3J0IGFzIGEgcHJveHkgZm9yIFNhZmFyaTwxNSwgYWxsIG90aGVyIG1haW5zdHJlYW0gYnJvd3NlcnNcbiAgICAvLyBoYXZlIHN1cHBvcnRlZCBpdCBmb3IgYSBsb25nIHdoaWxlIHNvIGFueSBmYWxzZSBwb3NpdGl2ZXMgc2hvdWxkIGJlIG1pbmltYWwuXG4gICAgaWYgKHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc29sZS5pbmZvKCdTYWZhcmk8MTU6IGFwcGx5aW5nIFNERiBjYW52YXMgd29ya2Fyb3VuZCcpO1xuICAgICAgY29uc3Qge3NkZkNhbnZhcywgc2RmVGV4dHVyZX0gPSBhdGxhcztcbiAgICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHNkZkNhbnZhcztcbiAgICAgIGNvbnN0IGdsID0gYXRsYXMuc2RmQ2FudmFzLmdldENvbnRleHQoJ3dlYmdsJyk7XG4gICAgICBsZXQgcGl4ZWxzID0gc2RmVGV4dHVyZS5pbWFnZS5kYXRhO1xuICAgICAgaWYgKCFwaXhlbHMgfHwgcGl4ZWxzLmxlbmd0aCAhPT0gd2lkdGggKiBoZWlnaHQgKiA0KSB7XG4gICAgICAgIHBpeGVscyA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgIHNkZlRleHR1cmUuaW1hZ2UgPSB7d2lkdGgsIGhlaWdodCwgZGF0YTogcGl4ZWxzfTtcbiAgICAgICAgc2RmVGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuICAgICAgICBzZGZUZXh0dXJlLmlzRGF0YVRleHR1cmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZ2wucmVhZFBpeGVscygwLCAwLCB3aWR0aCwgaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBwaXhlbHMpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHR5cGVzZXR0ZXJXb3JrZXJNb2R1bGUgPSAvKiNfX1BVUkVfXyovdHJvaWthV29ya2VyVXRpbHMuZGVmaW5lV29ya2VyTW9kdWxlKHtcbiAgICBuYW1lOiAnVHlwZXNldHRlcicsXG4gICAgZGVwZW5kZW5jaWVzOiBbXG4gICAgICBjcmVhdGVUeXBlc2V0dGVyLFxuICAgICAgZm9udFJlc29sdmVyV29ya2VyTW9kdWxlLFxuICAgICAgYmlkaUZhY3RvcnlfX2RlZmF1bHRbJ2RlZmF1bHQnXSxcbiAgICBdLFxuICAgIGluaXQoY3JlYXRlVHlwZXNldHRlciwgZm9udFJlc29sdmVyLCBiaWRpRmFjdG9yeSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVR5cGVzZXR0ZXIoZm9udFJlc29sdmVyLCBiaWRpRmFjdG9yeSgpKVxuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgdHlwZXNldEluV29ya2VyID0gLyojX19QVVJFX18qL3Ryb2lrYVdvcmtlclV0aWxzLmRlZmluZVdvcmtlck1vZHVsZSh7XG4gICAgbmFtZTogJ1R5cGVzZXR0ZXInLFxuICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgdHlwZXNldHRlcldvcmtlck1vZHVsZSxcbiAgICBdLFxuICAgIGluaXQodHlwZXNldHRlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIHR5cGVzZXR0ZXIudHlwZXNldChhcmdzLCByZXNvbHZlKTtcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFRyYW5zZmVyYWJsZXMocmVzdWx0KSB7XG4gICAgICAvLyBNYXJrIGFycmF5IGJ1ZmZlcnMgYXMgdHJhbnNmZXJhYmxlIHRvIGF2b2lkIGNsb25pbmcgZHVyaW5nIHBvc3RNZXNzYWdlXG4gICAgICBjb25zdCB0cmFuc2ZlcmFibGVzID0gW107XG4gICAgICBmb3IgKGxldCBwIGluIHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0W3BdICYmIHJlc3VsdFtwXS5idWZmZXIpIHtcbiAgICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2gocmVzdWx0W3BdLmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2ZlcmFibGVzXG4gICAgfVxuICB9KTtcblxuICBjb25zdCB0eXBlc2V0T25NYWluVGhyZWFkID0gdHlwZXNldEluV29ya2VyLm9uTWFpblRocmVhZDtcblxuICBmdW5jdGlvbiBkdW1wU0RGVGV4dHVyZXMoKSB7XG4gICAgT2JqZWN0LmtleXMoYXRsYXNlcykuZm9yRWFjaChzaXplID0+IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGF0bGFzZXNbc2l6ZV0uc2RmQ2FudmFzO1xuICAgICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gY2FudmFzO1xuICAgICAgY29uc29sZS5sb2coXCIlYy5cIiwgYFxuICAgICAgYmFja2dyb3VuZDogdXJsKCR7Y2FudmFzLnRvRGF0YVVSTCgpfSk7XG4gICAgICBiYWNrZ3JvdW5kLXNpemU6ICR7d2lkdGh9cHggJHtoZWlnaHR9cHg7XG4gICAgICBjb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICBmb250LXNpemU6IDA7XG4gICAgICBsaW5lLWhlaWdodDogJHtoZWlnaHR9cHg7XG4gICAgICBwYWRkaW5nLWxlZnQ6ICR7d2lkdGh9cHg7XG4gICAgYCk7XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCB0ZW1wbGF0ZUdlb21ldHJpZXMgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRUZW1wbGF0ZUdlb21ldHJ5KGRldGFpbCkge1xuICAgIGxldCBnZW9tID0gdGVtcGxhdGVHZW9tZXRyaWVzW2RldGFpbF07XG4gICAgaWYgKCFnZW9tKSB7XG4gICAgICBnZW9tID0gdGVtcGxhdGVHZW9tZXRyaWVzW2RldGFpbF0gPSBuZXcgdGhyZWUuUGxhbmVHZW9tZXRyeSgxLCAxLCBkZXRhaWwsIGRldGFpbCkudHJhbnNsYXRlKDAuNSwgMC41LCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlb21cbiAgfVxuXG4gIGNvbnN0IGdseXBoQm91bmRzQXR0ck5hbWUgPSAnYVRyb2lrYUdseXBoQm91bmRzJztcbiAgY29uc3QgZ2x5cGhJbmRleEF0dHJOYW1lID0gJ2FUcm9pa2FHbHlwaEluZGV4JztcbiAgY29uc3QgZ2x5cGhDb2xvckF0dHJOYW1lID0gJ2FUcm9pa2FHbHlwaENvbG9yJztcblxuICAvKipcbiAgQGNsYXNzIEdseXBoc0dlb21ldHJ5XG5cbiAgQSBzcGVjaWFsaXplZCBHZW9tZXRyeSBmb3IgcmVuZGVyaW5nIGEgc2V0IG9mIHRleHQgZ2x5cGhzLiBVc2VzIEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IHRvXG4gIHJlbmRlciB0aGUgZ2x5cGhzIHVzaW5nIEdQVSBpbnN0YW5jaW5nIG9mIGEgc2luZ2xlIHF1YWQsIHJhdGhlciB0aGFuIGNvbnN0cnVjdGluZyBhIHdob2xlXG4gIGdlb21ldHJ5IHdpdGggdmVydGljZXMsIGZvciBtdWNoIHNtYWxsZXIgYXR0cmlidXRlIGFycmF5YnVmZmVycyBhY2NvcmRpbmcgdG8gdGhpcyBtYXRoOlxuXG4gICAgV2hlcmUgTiA9IG51bWJlciBvZiBnbHlwaHMuLi5cblxuICAgIEluc3RhbmNlZDpcbiAgICAtIHBvc2l0aW9uOiA0ICogM1xuICAgIC0gaW5kZXg6IDIgKiAzXG4gICAgLSBub3JtYWw6IDQgKiAzXG4gICAgLSB1djogNCAqIDJcbiAgICAtIGdseXBoIHgveSBib3VuZHM6IE4gKiA0XG4gICAgLSBnbHlwaCBpbmRpY2VzOiBOICogMVxuICAgID0gNU4gKyAzOFxuXG4gICAgTm9uLWluc3RhbmNlZDpcbiAgICAtIHBvc2l0aW9uOiBOICogNCAqIDNcbiAgICAtIGluZGV4OiBOICogMiAqIDNcbiAgICAtIG5vcm1hbDogTiAqIDQgKiAzXG4gICAgLSB1djogTiAqIDQgKiAyXG4gICAgLSBnbHlwaCBpbmRpY2VzOiBOICogMVxuICAgID0gMzlOXG5cbiAgQSBkb3duc2lkZSBvZiB0aGlzIGlzIHRoZSByYXJlLWJ1dC1wb3NzaWJsZSBsYWNrIG9mIHRoZSBpbnN0YW5jZWQgYXJyYXlzIGV4dGVuc2lvbixcbiAgd2hpY2ggd2UgY291bGQgcG90ZW50aWFsbHkgd29yayBhcm91bmQgd2l0aCBhIGZhbGxiYWNrIG5vbi1pbnN0YW5jZWQgaW1wbGVtZW50YXRpb24uXG5cbiAgKi9cbiAgY2xhc3MgR2x5cGhzR2VvbWV0cnkgZXh0ZW5kcyB0aHJlZS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuXG4gICAgICB0aGlzLmRldGFpbCA9IDE7XG4gICAgICB0aGlzLmN1cnZlUmFkaXVzID0gMDtcblxuICAgICAgLy8gRGVmaW5lIGdyb3VwcyBmb3IgcmVuZGVyaW5nIHRleHQgb3V0bGluZSBhcyBhIHNlcGFyYXRlIHBhc3M7IHRoZXNlIHdpbGwgb25seVxuICAgICAgLy8gYmUgdXNlZCB3aGVuIHRoZSBgbWF0ZXJpYWxgIGdldHRlciByZXR1cm5zIGFuIGFycmF5LCBpLmUuIG91dGxpbmVXaWR0aCA+IDAuXG4gICAgICB0aGlzLmdyb3VwcyA9IFtcbiAgICAgICAge3N0YXJ0OiAwLCBjb3VudDogSW5maW5pdHksIG1hdGVyaWFsSW5kZXg6IDB9LFxuICAgICAgICB7c3RhcnQ6IDAsIGNvdW50OiBJbmZpbml0eSwgbWF0ZXJpYWxJbmRleDogMX1cbiAgICAgIF07XG5cbiAgICAgIC8vIFByZWFsbG9jYXRlIGVtcHR5IGJvdW5kaW5nIG9iamVjdHNcbiAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgdGhyZWUuU3BoZXJlKCk7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94ID0gbmV3IHRocmVlLkJveDMoKTtcbiAgICB9XG5cbiAgICBjb21wdXRlQm91bmRpbmdTcGhlcmUgKCkge1xuICAgICAgLy8gTm8tb3A7IHdlJ2xsIHN5bmMgdGhlIGJvdW5kaW5nU3BoZXJlIHByb2FjdGl2ZWx5IHdoZW4gbmVlZGVkLlxuICAgIH1cblxuICAgIGNvbXB1dGVCb3VuZGluZ0JveCgpIHtcbiAgICAgIC8vIE5vLW9wOyB3ZSdsbCBzeW5jIHRoZSBib3VuZGluZ0JveCBwcm9hY3RpdmVseSB3aGVuIG5lZWRlZC5cbiAgICB9XG5cbiAgICBzZXQgZGV0YWlsKGRldGFpbCkge1xuICAgICAgaWYgKGRldGFpbCAhPT0gdGhpcy5fZGV0YWlsKSB7XG4gICAgICAgIHRoaXMuX2RldGFpbCA9IGRldGFpbDtcbiAgICAgICAgaWYgKHR5cGVvZiBkZXRhaWwgIT09ICdudW1iZXInIHx8IGRldGFpbCA8IDEpIHtcbiAgICAgICAgICBkZXRhaWwgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0cGwgPSBnZXRUZW1wbGF0ZUdlb21ldHJ5KGRldGFpbClcbiAgICAgICAgO1sncG9zaXRpb24nLCAnbm9ybWFsJywgJ3V2J10uZm9yRWFjaChhdHRyID0+IHtcbiAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0gPSB0cGwuYXR0cmlidXRlc1thdHRyXS5jbG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRJbmRleCh0cGwuZ2V0SW5kZXgoKS5jbG9uZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRldGFpbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZXRhaWxcbiAgICB9XG5cbiAgICBzZXQgY3VydmVSYWRpdXMocikge1xuICAgICAgaWYgKHIgIT09IHRoaXMuX2N1cnZlUmFkaXVzKSB7XG4gICAgICAgIHRoaXMuX2N1cnZlUmFkaXVzID0gcjtcbiAgICAgICAgdGhpcy5fdXBkYXRlQm91bmRzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGdldCBjdXJ2ZVJhZGl1cygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jdXJ2ZVJhZGl1c1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZ2VvbWV0cnkgZm9yIGEgbmV3IHNldCBvZiBnbHlwaHMuXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGdseXBoQm91bmRzIC0gQW4gYXJyYXkgaG9sZGluZyB0aGUgcGxhbmFyIGJvdW5kcyBmb3IgYWxsIGdseXBoc1xuICAgICAqICAgICAgICB0byBiZSByZW5kZXJlZCwgNCBlbnRyaWVzIGZvciBlYWNoIGdseXBoOiB4MSx4Mix5MSx5MVxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBnbHlwaEF0bGFzSW5kaWNlcyAtIEFuIGFycmF5IGhvbGRpbmcgdGhlIGluZGV4IG9mIGVhY2ggZ2x5cGggd2l0aGluXG4gICAgICogICAgICAgIHRoZSBTREYgYXRsYXMgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBibG9ja0JvdW5kcyAtIEFuIGFycmF5IGhvbGRpbmcgdGhlIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBhY3Jvc3MgYWxsIGdseXBoc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjaHVua2VkQm91bmRzXSAtIEFuIGFycmF5IG9mIG9iamVjdHMgZGVzY3JpYmluZyBib3VuZHMgZm9yIGVhY2ggY2h1bmsgb2YgTlxuICAgICAqICAgICAgICBjb25zZWN1dGl2ZSBnbHlwaHM6IGB7c3RhcnQ6TiwgZW5kOk4sIHJlY3Q6W21pblgsIG1pblksIG1heFgsIG1heFldfWAuIFRoaXMgY2FuIGJlXG4gICAgICogICAgICAgIHVzZWQgd2l0aCBgYXBwbHlDbGlwUmVjdGAgdG8gY2hvb3NlIGFuIG9wdGltaXplZCBgaW5zdGFuY2VDb3VudGAuXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBbZ2x5cGhDb2xvcnNdIC0gQW4gYXJyYXkgaG9sZGluZyByLGcsYiB2YWx1ZXMgZm9yIGVhY2ggZ2x5cGguXG4gICAgICovXG4gICAgdXBkYXRlR2x5cGhzKGdseXBoQm91bmRzLCBnbHlwaEF0bGFzSW5kaWNlcywgYmxvY2tCb3VuZHMsIGNodW5rZWRCb3VuZHMsIGdseXBoQ29sb3JzKSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIGluc3RhbmNlIGF0dHJpYnV0ZXNcbiAgICAgIHRoaXMudXBkYXRlQXR0cmlidXRlRGF0YShnbHlwaEJvdW5kc0F0dHJOYW1lLCBnbHlwaEJvdW5kcywgNCk7XG4gICAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZURhdGEoZ2x5cGhJbmRleEF0dHJOYW1lLCBnbHlwaEF0bGFzSW5kaWNlcywgMSk7XG4gICAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZURhdGEoZ2x5cGhDb2xvckF0dHJOYW1lLCBnbHlwaENvbG9ycywgMyk7XG4gICAgICB0aGlzLl9ibG9ja0JvdW5kcyA9IGJsb2NrQm91bmRzO1xuICAgICAgdGhpcy5fY2h1bmtlZEJvdW5kcyA9IGNodW5rZWRCb3VuZHM7XG4gICAgICB0aGlzLmluc3RhbmNlQ291bnQgPSBnbHlwaEF0bGFzSW5kaWNlcy5sZW5ndGg7XG4gICAgICB0aGlzLl91cGRhdGVCb3VuZHMoKTtcbiAgICB9XG5cbiAgICBfdXBkYXRlQm91bmRzKCkge1xuICAgICAgY29uc3QgYm91bmRzID0gdGhpcy5fYmxvY2tCb3VuZHM7XG4gICAgICBpZiAoYm91bmRzKSB7XG4gICAgICAgIGNvbnN0IHsgY3VydmVSYWRpdXMsIGJvdW5kaW5nQm94OiBiYm94IH0gPSB0aGlzO1xuICAgICAgICBpZiAoY3VydmVSYWRpdXMpIHtcbiAgICAgICAgICBjb25zdCB7IFBJLCBmbG9vciwgbWluLCBtYXgsIHNpbiwgY29zIH0gPSBNYXRoO1xuICAgICAgICAgIGNvbnN0IGhhbGZQaSA9IFBJIC8gMjtcbiAgICAgICAgICBjb25zdCB0d29QaSA9IFBJICogMjtcbiAgICAgICAgICBjb25zdCBhYnNSID0gTWF0aC5hYnMoY3VydmVSYWRpdXMpO1xuICAgICAgICAgIGNvbnN0IGxlZnRBbmdsZSA9IGJvdW5kc1swXSAvIGFic1I7XG4gICAgICAgICAgY29uc3QgcmlnaHRBbmdsZSA9IGJvdW5kc1syXSAvIGFic1I7XG4gICAgICAgICAgY29uc3QgbWluWCA9IGZsb29yKChsZWZ0QW5nbGUgKyBoYWxmUGkpIC8gdHdvUGkpICE9PSBmbG9vcigocmlnaHRBbmdsZSArIGhhbGZQaSkgLyB0d29QaSlcbiAgICAgICAgICAgID8gLWFic1IgOiBtaW4oc2luKGxlZnRBbmdsZSkgKiBhYnNSLCBzaW4ocmlnaHRBbmdsZSkgKiBhYnNSKTtcbiAgICAgICAgICBjb25zdCBtYXhYID0gZmxvb3IoKGxlZnRBbmdsZSAtIGhhbGZQaSkgLyB0d29QaSkgIT09IGZsb29yKChyaWdodEFuZ2xlIC0gaGFsZlBpKSAvIHR3b1BpKVxuICAgICAgICAgICAgPyBhYnNSIDogbWF4KHNpbihsZWZ0QW5nbGUpICogYWJzUiwgc2luKHJpZ2h0QW5nbGUpICogYWJzUik7XG4gICAgICAgICAgY29uc3QgbWF4WiA9IGZsb29yKChsZWZ0QW5nbGUgKyBQSSkgLyB0d29QaSkgIT09IGZsb29yKChyaWdodEFuZ2xlICsgUEkpIC8gdHdvUGkpXG4gICAgICAgICAgICA/IGFic1IgKiAyIDogbWF4KGFic1IgLSBjb3MobGVmdEFuZ2xlKSAqIGFic1IsIGFic1IgLSBjb3MocmlnaHRBbmdsZSkgKiBhYnNSKTtcbiAgICAgICAgICBiYm94Lm1pbi5zZXQobWluWCwgYm91bmRzWzFdLCBjdXJ2ZVJhZGl1cyA8IDAgPyAtbWF4WiA6IDApO1xuICAgICAgICAgIGJib3gubWF4LnNldChtYXhYLCBib3VuZHNbM10sIGN1cnZlUmFkaXVzIDwgMCA/IDAgOiBtYXhaKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYm94Lm1pbi5zZXQoYm91bmRzWzBdLCBib3VuZHNbMV0sIDApO1xuICAgICAgICAgIGJib3gubWF4LnNldChib3VuZHNbMl0sIGJvdW5kc1szXSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgYmJveC5nZXRCb3VuZGluZ1NwaGVyZSh0aGlzLmJvdW5kaW5nU3BoZXJlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGNsaXBwaW5nIHJlY3QsIGFuZCB0aGUgY2h1bmtlZEJvdW5kcyBmcm9tIHRoZSBsYXN0IHVwZGF0ZUdseXBocyBjYWxsLCBjaG9vc2UgdGhlIGxvd2VzdFxuICAgICAqIGBpbnN0YW5jZUNvdW50YCB0aGF0IHdpbGwgc2hvdyBhbGwgZ2x5cGhzIHdpdGhpbiB0aGUgY2xpcHBlZCB2aWV3LiBUaGlzIGlzIGFuIG9wdGltaXphdGlvblxuICAgICAqIGZvciBsb25nIGJsb2NrcyBvZiB0ZXh0IHRoYXQgYXJlIGNsaXBwZWQsIHRvIHNraXAgdmVydGV4IHNoYWRlciBldmFsdWF0aW9uIGZvciBnbHlwaHMgdGhhdCB3b3VsZFxuICAgICAqIGJlIGNsaXBwZWQgYW55d2F5LlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHNpbmNlIGBkcmF3RWxlbWVudHNJbnN0YW5jZWRbQU5HTEVdYCBvbmx5IGFjY2VwdHMgYW4gaW5zdGFuY2UgY291bnQgYW5kIG5vdCBhIHN0YXJ0aW5nXG4gICAgICogb2Zmc2V0LCB0aGlzIG9wdGltaXphdGlvbiBiZWNvbWVzIGxlc3MgZWZmZWN0aXZlIGFzIHRoZSBjbGlwUmVjdCBtb3ZlcyBjbG9zZXIgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICAgKiB0ZXh0IGJsb2NrLiBXZSBjb3VsZCBmaXggdGhhdCBieSBzd2l0Y2hpbmcgZnJvbSBpbnN0YW5jaW5nIHRvIGEgZnVsbCBnZW9tZXRyeSB3aXRoIGEgZHJhd1JhbmdlLFxuICAgICAqIGJ1dCBhdCB0aGUgZXhwZW5zZSBvZiBtdWNoIGxhcmdlciBhdHRyaWJ1dGUgYnVmZmVycyAoc2VlIGNsYXNzZG9jIGFib3ZlLilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VmVjdG9yNH0gY2xpcFJlY3RcbiAgICAgKi9cbiAgICBhcHBseUNsaXBSZWN0KGNsaXBSZWN0KSB7XG4gICAgICBsZXQgY291bnQgPSB0aGlzLmdldEF0dHJpYnV0ZShnbHlwaEluZGV4QXR0ck5hbWUpLmNvdW50O1xuICAgICAgbGV0IGNodW5rcyA9IHRoaXMuX2NodW5rZWRCb3VuZHM7XG4gICAgICBpZiAoY2h1bmtzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBjaHVua3MubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgY291bnQgPSBjaHVua3NbaV0uZW5kO1xuICAgICAgICAgIGxldCByZWN0ID0gY2h1bmtzW2ldLnJlY3Q7XG4gICAgICAgICAgLy8gbm90ZTogYm90aCByZWN0cyBhcmUgbC1iLXItdFxuICAgICAgICAgIGlmIChyZWN0WzFdIDwgY2xpcFJlY3QudyAmJiByZWN0WzNdID4gY2xpcFJlY3QueSAmJiByZWN0WzBdIDwgY2xpcFJlY3QueiAmJiByZWN0WzJdID4gY2xpcFJlY3QueCkge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuaW5zdGFuY2VDb3VudCA9IGNvdW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgZm9yIHVwZGF0aW5nIGluc3RhbmNlIGF0dHJpYnV0ZXMgd2l0aCBhdXRvbWF0aWMgcmVzaXppbmdcbiAgICAgKi9cbiAgICB1cGRhdGVBdHRyaWJ1dGVEYXRhKGF0dHJOYW1lLCBuZXdBcnJheSwgaXRlbVNpemUpIHtcbiAgICAgIGNvbnN0IGF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICBpZiAobmV3QXJyYXkpIHtcbiAgICAgICAgLy8gSWYgbGVuZ3RoIGlzbid0IGNoYW5naW5nLCBqdXN0IHVwZGF0ZSB0aGUgYXR0cmlidXRlJ3MgYXJyYXkgZGF0YVxuICAgICAgICBpZiAoYXR0ciAmJiBhdHRyLmFycmF5Lmxlbmd0aCA9PT0gbmV3QXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgYXR0ci5hcnJheS5zZXQobmV3QXJyYXkpO1xuICAgICAgICAgIGF0dHIubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBuZXcgdGhyZWUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKG5ld0FycmF5LCBpdGVtU2l6ZSkpO1xuICAgICAgICAgIC8vIElmIHRoZSBuZXcgYXR0cmlidXRlIGhhcyBhIGRpZmZlcmVudCBzaXplLCB3ZSBhbHNvIGhhdmUgdG8gKGFzIG9mIHIxMTcpIG1hbnVhbGx5IGNsZWFyIHRoZVxuICAgICAgICAgIC8vIGludGVybmFsIGNhY2hlZCBtYXggaW5zdGFuY2UgY291bnQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8xOTcwNlxuICAgICAgICAgIC8vIEl0J3MgdW5jbGVhciBpZiB0aGlzIGlzIGEgdGhyZWVqcyBidWcgb3IgYSB0cnVseSB1bnN1cHBvcnRlZCBzY2VuYXJpbzsgZGlzY3Vzc2lvbiBpblxuICAgICAgICAgIC8vIHRoYXQgdGlja2V0IGlzIGFtYmlndW91cyBhcyB0byB3aGV0aGVyIHJlcGxhY2luZyBhIEJ1ZmZlckF0dHJpYnV0ZSB3aXRoIG9uZSBvZiBhXG4gICAgICAgICAgLy8gZGlmZmVyZW50IHNpemUgaXMgc3VwcG9ydGVkLCBidXQgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzE3NDE4IHN0cm9uZ2x5XG4gICAgICAgICAgLy8gaW1wbGllcyBpdCBzaG91bGQgYmUgc3VwcG9ydGVkLiBJdCdzIHBvc3NpYmxlIHdlIG5lZWQgdG9cbiAgICAgICAgICBkZWxldGUgdGhpcy5fbWF4SW5zdGFuY2VDb3VudDsgLy9mb3IgcjExNyssIGNvdWxkIGJlIGZyYWdpbGVcbiAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTsgLy9mb3IgcjExOCssIG1vcmUgcm9idXN0IGZlZWxpbmcsIGJ1dCBtb3JlIGhlYXZ5LWhhbmRlZCB0aGFuIEknZCBsaWtlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXR0cikge1xuICAgICAgICB0aGlzLmRlbGV0ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbGFuZ3VhZ2U9R0xTTFxuICBjb25zdCBWRVJURVhfREVGUyA9IGBcbnVuaWZvcm0gdmVjMiB1VHJvaWthU0RGVGV4dHVyZVNpemU7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTREZHbHlwaFNpemU7XG51bmlmb3JtIHZlYzQgdVRyb2lrYVRvdGFsQm91bmRzO1xudW5pZm9ybSB2ZWM0IHVUcm9pa2FDbGlwUmVjdDtcbnVuaWZvcm0gbWF0MyB1VHJvaWthT3JpZW50O1xudW5pZm9ybSBib29sIHVUcm9pa2FVc2VHbHlwaENvbG9ycztcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYUVkZ2VPZmZzZXQ7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FCbHVyUmFkaXVzO1xudW5pZm9ybSB2ZWMyIHVUcm9pa2FQb3NpdGlvbk9mZnNldDtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYUN1cnZlUmFkaXVzO1xuYXR0cmlidXRlIHZlYzQgYVRyb2lrYUdseXBoQm91bmRzO1xuYXR0cmlidXRlIGZsb2F0IGFUcm9pa2FHbHlwaEluZGV4O1xuYXR0cmlidXRlIHZlYzMgYVRyb2lrYUdseXBoQ29sb3I7XG52YXJ5aW5nIHZlYzIgdlRyb2lrYUdseXBoVVY7XG52YXJ5aW5nIHZlYzQgdlRyb2lrYVRleHR1cmVVVkJvdW5kcztcbnZhcnlpbmcgZmxvYXQgdlRyb2lrYVRleHR1cmVDaGFubmVsO1xudmFyeWluZyB2ZWMzIHZUcm9pa2FHbHlwaENvbG9yO1xudmFyeWluZyB2ZWMyIHZUcm9pa2FHbHlwaERpbWVuc2lvbnM7XG5gO1xuXG4gIC8vIGxhbmd1YWdlPUdMU0wgcHJlZml4PVwidm9pZCBtYWluKCkge1wiIHN1ZmZpeD1cIn1cIlxuICBjb25zdCBWRVJURVhfVFJBTlNGT1JNID0gYFxudmVjNCBib3VuZHMgPSBhVHJvaWthR2x5cGhCb3VuZHM7XG5ib3VuZHMueHogKz0gdVRyb2lrYVBvc2l0aW9uT2Zmc2V0Lng7XG5ib3VuZHMueXcgLT0gdVRyb2lrYVBvc2l0aW9uT2Zmc2V0Lnk7XG5cbnZlYzQgb3V0bGluZUJvdW5kcyA9IHZlYzQoXG4gIGJvdW5kcy54eSAtIHVUcm9pa2FFZGdlT2Zmc2V0IC0gdVRyb2lrYUJsdXJSYWRpdXMsXG4gIGJvdW5kcy56dyArIHVUcm9pa2FFZGdlT2Zmc2V0ICsgdVRyb2lrYUJsdXJSYWRpdXNcbik7XG52ZWM0IGNsaXBwZWRCb3VuZHMgPSB2ZWM0KFxuICBjbGFtcChvdXRsaW5lQm91bmRzLnh5LCB1VHJvaWthQ2xpcFJlY3QueHksIHVUcm9pa2FDbGlwUmVjdC56dyksXG4gIGNsYW1wKG91dGxpbmVCb3VuZHMuencsIHVUcm9pa2FDbGlwUmVjdC54eSwgdVRyb2lrYUNsaXBSZWN0Lnp3KVxuKTtcblxudmVjMiBjbGlwcGVkWFkgPSAobWl4KGNsaXBwZWRCb3VuZHMueHksIGNsaXBwZWRCb3VuZHMuencsIHBvc2l0aW9uLnh5KSAtIGJvdW5kcy54eSkgLyAoYm91bmRzLnp3IC0gYm91bmRzLnh5KTtcblxucG9zaXRpb24ueHkgPSBtaXgoYm91bmRzLnh5LCBib3VuZHMuencsIGNsaXBwZWRYWSk7XG5cbnV2ID0gKHBvc2l0aW9uLnh5IC0gdVRyb2lrYVRvdGFsQm91bmRzLnh5KSAvICh1VHJvaWthVG90YWxCb3VuZHMuencgLSB1VHJvaWthVG90YWxCb3VuZHMueHkpO1xuXG5mbG9hdCByYWQgPSB1VHJvaWthQ3VydmVSYWRpdXM7XG5pZiAocmFkICE9IDAuMCkge1xuICBmbG9hdCBhbmdsZSA9IHBvc2l0aW9uLnggLyByYWQ7XG4gIHBvc2l0aW9uLnh6ID0gdmVjMihzaW4oYW5nbGUpICogcmFkLCByYWQgLSBjb3MoYW5nbGUpICogcmFkKTtcbiAgbm9ybWFsLnh6ID0gdmVjMihzaW4oYW5nbGUpLCBjb3MoYW5nbGUpKTtcbn1cbiAgXG5wb3NpdGlvbiA9IHVUcm9pa2FPcmllbnQgKiBwb3NpdGlvbjtcbm5vcm1hbCA9IHVUcm9pa2FPcmllbnQgKiBub3JtYWw7XG5cbnZUcm9pa2FHbHlwaFVWID0gY2xpcHBlZFhZLnh5O1xudlRyb2lrYUdseXBoRGltZW5zaW9ucyA9IHZlYzIoYm91bmRzWzJdIC0gYm91bmRzWzBdLCBib3VuZHNbM10gLSBib3VuZHNbMV0pO1xuXG4keycnLyogTk9URTogaXQgc2VlbXMgaW1wb3J0YW50IHRvIGNhbGN1bGF0ZSB0aGUgZ2x5cGgncyBib3VuZGluZyB0ZXh0dXJlIFVWcyBoZXJlIGluIHRoZVxuICB2ZXJ0ZXggc2hhZGVyLCByYXRoZXIgdGhhbiBpbiB0aGUgZnJhZ21lbnQgc2hhZGVyLCBhcyB0aGUgbGF0dGVyIGdpdmVzIHN0cmFuZ2UgYXJ0aWZhY3RzXG4gIG9uIHNvbWUgZ2x5cGhzICh0aG9zZSBpbiB0aGUgbGVmdG1vc3QgdGV4dHVyZSBjb2x1bW4pIG9uIHNvbWUgc3lzdGVtcy4gVGhlIGV4YWN0IHJlYXNvblxuICBpc24ndCB1bmRlcnN0b29kIGJ1dCBkb2luZyB0aGlzIGhlcmUsIHRoZW4gbWl4KCktaW5nIGluIHRoZSBmcmFnbWVudCBzaGFkZXIsIHNlZW1zIHRvIHdvcmsuICovfVxuZmxvYXQgdHhDb2xzID0gdVRyb2lrYVNERlRleHR1cmVTaXplLnggLyB1VHJvaWthU0RGR2x5cGhTaXplO1xudmVjMiB0eFV2UGVyU3F1YXJlID0gdVRyb2lrYVNERkdseXBoU2l6ZSAvIHVUcm9pa2FTREZUZXh0dXJlU2l6ZTtcbnZlYzIgdHhTdGFydFVWID0gdHhVdlBlclNxdWFyZSAqIHZlYzIoXG4gIG1vZChmbG9vcihhVHJvaWthR2x5cGhJbmRleCAvIDQuMCksIHR4Q29scyksXG4gIGZsb29yKGZsb29yKGFUcm9pa2FHbHlwaEluZGV4IC8gNC4wKSAvIHR4Q29scylcbik7XG52VHJvaWthVGV4dHVyZVVWQm91bmRzID0gdmVjNCh0eFN0YXJ0VVYsIHZlYzIodHhTdGFydFVWKSArIHR4VXZQZXJTcXVhcmUpO1xudlRyb2lrYVRleHR1cmVDaGFubmVsID0gbW9kKGFUcm9pa2FHbHlwaEluZGV4LCA0LjApO1xuYDtcblxuICAvLyBsYW5ndWFnZT1HTFNMXG4gIGNvbnN0IEZSQUdNRU5UX0RFRlMgPSBgXG51bmlmb3JtIHNhbXBsZXIyRCB1VHJvaWthU0RGVGV4dHVyZTtcbnVuaWZvcm0gdmVjMiB1VHJvaWthU0RGVGV4dHVyZVNpemU7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTREZHbHlwaFNpemU7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTREZFeHBvbmVudDtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYUVkZ2VPZmZzZXQ7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FGaWxsT3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYUJsdXJSYWRpdXM7XG51bmlmb3JtIHZlYzMgdVRyb2lrYVN0cm9rZUNvbG9yO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthU3Ryb2tlV2lkdGg7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTdHJva2VPcGFjaXR5O1xudW5pZm9ybSBib29sIHVUcm9pa2FTREZEZWJ1ZztcbnZhcnlpbmcgdmVjMiB2VHJvaWthR2x5cGhVVjtcbnZhcnlpbmcgdmVjNCB2VHJvaWthVGV4dHVyZVVWQm91bmRzO1xudmFyeWluZyBmbG9hdCB2VHJvaWthVGV4dHVyZUNoYW5uZWw7XG52YXJ5aW5nIHZlYzIgdlRyb2lrYUdseXBoRGltZW5zaW9ucztcblxuZmxvYXQgdHJvaWthU2RmVmFsdWVUb1NpZ25lZERpc3RhbmNlKGZsb2F0IGFscGhhKSB7XG4gIC8vIEludmVyc2Ugb2YgZXhwb25lbnRpYWwgZW5jb2RpbmcgaW4gd2ViZ2wtc2RmLWdlbmVyYXRvclxuICAkeycnLyogVE9ETyAtIHRoZXJlJ3Mgc29tZSBzbGlnaHQgaW5hY2N1cmFjeSBoZXJlIHdoZW4gZGVhbGluZyB3aXRoIGludGVycG9sYXRlZCBhbHBoYSB2YWx1ZXM7IHRob3NlXG4gICAgYXJlIGxpbmVhcmx5IGludGVycG9sYXRlZCB3aGVyZSB0aGUgZW5jb2RpbmcgaXMgZXhwb25lbnRpYWwuIExvb2sgaW50byBpbXByb3ZpbmcgdGhpcyBieSByb3VuZGluZ1xuICAgIHRvIG5lYXJlc3QgMiB3aG9sZSB0ZXhlbHMsIGRlY29kaW5nIHRob3NlIGV4cG9uZW50aWFsIHZhbHVlcywgYW5kIGxpbmVhcmx5IGludGVycG9sYXRpbmcgdGhlIHJlc3VsdC5cbiAgKi99XG4gIGZsb2F0IG1heERpbWVuc2lvbiA9IG1heCh2VHJvaWthR2x5cGhEaW1lbnNpb25zLngsIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMueSk7XG4gIGZsb2F0IGFic0Rpc3QgPSAoMS4wIC0gcG93KDIuMCAqIChhbHBoYSA+IDAuNSA/IDEuMCAtIGFscGhhIDogYWxwaGEpLCAxLjAgLyB1VHJvaWthU0RGRXhwb25lbnQpKSAqIG1heERpbWVuc2lvbjtcbiAgZmxvYXQgc2lnbmVkRGlzdCA9IGFic0Rpc3QgKiAoYWxwaGEgPiAwLjUgPyAtMS4wIDogMS4wKTtcbiAgcmV0dXJuIHNpZ25lZERpc3Q7XG59XG5cbmZsb2F0IHRyb2lrYUdseXBoVXZUb1NkZlZhbHVlKHZlYzIgZ2x5cGhVVikge1xuICB2ZWMyIHRleHR1cmVVViA9IG1peCh2VHJvaWthVGV4dHVyZVVWQm91bmRzLnh5LCB2VHJvaWthVGV4dHVyZVVWQm91bmRzLnp3LCBnbHlwaFVWKTtcbiAgdmVjNCByZ2JhID0gdGV4dHVyZTJEKHVUcm9pa2FTREZUZXh0dXJlLCB0ZXh0dXJlVVYpO1xuICBmbG9hdCBjaCA9IGZsb29yKHZUcm9pa2FUZXh0dXJlQ2hhbm5lbCArIDAuNSk7IC8vTk9URTogY2FuJ3QgdXNlIHJvdW5kKCkgaW4gV2ViR0wxXG4gIHJldHVybiBjaCA9PSAwLjAgPyByZ2JhLnIgOiBjaCA9PSAxLjAgPyByZ2JhLmcgOiBjaCA9PSAyLjAgPyByZ2JhLmIgOiByZ2JhLmE7XG59XG5cbmZsb2F0IHRyb2lrYUdseXBoVXZUb0Rpc3RhbmNlKHZlYzIgdXYpIHtcbiAgcmV0dXJuIHRyb2lrYVNkZlZhbHVlVG9TaWduZWREaXN0YW5jZSh0cm9pa2FHbHlwaFV2VG9TZGZWYWx1ZSh1dikpO1xufVxuXG5mbG9hdCB0cm9pa2FHZXRBQURpc3QoKSB7XG4gICR7JycvKlxuICAgIFdoZW4gdGhlIHN0YW5kYXJkIGRlcml2YXRpdmVzIGV4dGVuc2lvbiBpcyBhdmFpbGFibGUsIHdlIGNob29zZSBhbiBhbnRpYWxpYXNpbmcgYWxwaGEgdGhyZXNob2xkIGJhc2VkXG4gICAgb24gdGhlIHBvdGVudGlhbCBjaGFuZ2UgaW4gdGhlIFNERidzIGFscGhhIGZyb20gdGhpcyBmcmFnbWVudCB0byBpdHMgbmVpZ2hib3IuIFRoaXMgc3RyYXRlZ3kgbWF4aW1pemVzIFxuICAgIHJlYWRhYmlsaXR5IGFuZCBlZGdlIGNyaXNwbmVzcyBhdCBhbGwgc2l6ZXMgYW5kIHNjcmVlbiByZXNvbHV0aW9ucy5cbiAgKi99XG4gICNpZiBkZWZpbmVkKEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcykgfHwgX19WRVJTSU9OX18gPj0gMzAwXG4gIHJldHVybiBsZW5ndGgoZndpZHRoKHZUcm9pa2FHbHlwaFVWICogdlRyb2lrYUdseXBoRGltZW5zaW9ucykpICogMC41O1xuICAjZWxzZVxuICByZXR1cm4gdlRyb2lrYUdseXBoRGltZW5zaW9ucy54IC8gNjQuMDtcbiAgI2VuZGlmXG59XG5cbmZsb2F0IHRyb2lrYUdldEZyYWdEaXN0VmFsdWUoKSB7XG4gIHZlYzIgY2xhbXBlZEdseXBoVVYgPSBjbGFtcCh2VHJvaWthR2x5cGhVViwgMC41IC8gdVRyb2lrYVNERkdseXBoU2l6ZSwgMS4wIC0gMC41IC8gdVRyb2lrYVNERkdseXBoU2l6ZSk7XG4gIGZsb2F0IGRpc3RhbmNlID0gdHJvaWthR2x5cGhVdlRvRGlzdGFuY2UoY2xhbXBlZEdseXBoVVYpO1xuIFxuICAvLyBFeHRyYXBvbGF0ZSBkaXN0YW5jZSB3aGVuIG91dHNpZGUgYm91bmRzOlxuICBkaXN0YW5jZSArPSBjbGFtcGVkR2x5cGhVViA9PSB2VHJvaWthR2x5cGhVViA/IDAuMCA6IFxuICAgIGxlbmd0aCgodlRyb2lrYUdseXBoVVYgLSBjbGFtcGVkR2x5cGhVVikgKiB2VHJvaWthR2x5cGhEaW1lbnNpb25zKTtcblxuICAkeycnLyogXG4gIC8vIFRPRE8gbW9yZSByZWZpbmVkIGV4dHJhcG9sYXRlZCBkaXN0YW5jZSBieSBhZGp1c3RpbmcgZm9yIGFuZ2xlIG9mIGdyYWRpZW50IGF0IGVkZ2UuLi5cbiAgLy8gVGhpcyBoYXMgcG90ZW50aWFsIGJ1dCBjdXJyZW50bHkgZ2l2ZXMgdmVyeSBqYWdnZWQgZXh0ZW5zaW9ucywgbWF5YmUgZHVlIHRvIHByZWNpc2lvbiBpc3N1ZXM/XG4gIGZsb2F0IHV2U3RlcCA9IDEuMCAvIHVUcm9pa2FTREZHbHlwaFNpemU7XG4gIHZlYzIgbmVpZ2hib3IxVVYgPSBjbGFtcGVkR2x5cGhVViArIChcbiAgICB2VHJvaWthR2x5cGhVVi54ICE9IGNsYW1wZWRHbHlwaFVWLnggPyB2ZWMyKDAuMCwgdXZTdGVwICogc2lnbigwLjUgLSB2VHJvaWthR2x5cGhVVi55KSkgOlxuICAgIHZUcm9pa2FHbHlwaFVWLnkgIT0gY2xhbXBlZEdseXBoVVYueSA/IHZlYzIodXZTdGVwICogc2lnbigwLjUgLSB2VHJvaWthR2x5cGhVVi54KSwgMC4wKSA6XG4gICAgdmVjMigwLjApXG4gICk7XG4gIHZlYzIgbmVpZ2hib3IyVVYgPSBjbGFtcGVkR2x5cGhVViArIChcbiAgICB2VHJvaWthR2x5cGhVVi54ICE9IGNsYW1wZWRHbHlwaFVWLnggPyB2ZWMyKDAuMCwgdXZTdGVwICogLXNpZ24oMC41IC0gdlRyb2lrYUdseXBoVVYueSkpIDpcbiAgICB2VHJvaWthR2x5cGhVVi55ICE9IGNsYW1wZWRHbHlwaFVWLnkgPyB2ZWMyKHV2U3RlcCAqIC1zaWduKDAuNSAtIHZUcm9pa2FHbHlwaFVWLngpLCAwLjApIDpcbiAgICB2ZWMyKDAuMClcbiAgKTtcbiAgZmxvYXQgbmVpZ2hib3IxRGlzdGFuY2UgPSB0cm9pa2FHbHlwaFV2VG9EaXN0YW5jZShuZWlnaGJvcjFVVik7XG4gIGZsb2F0IG5laWdoYm9yMkRpc3RhbmNlID0gdHJvaWthR2x5cGhVdlRvRGlzdGFuY2UobmVpZ2hib3IyVVYpO1xuICBmbG9hdCBkaXN0VG9VbmNsYW1wZWQgPSBsZW5ndGgoKHZUcm9pa2FHbHlwaFVWIC0gY2xhbXBlZEdseXBoVVYpICogdlRyb2lrYUdseXBoRGltZW5zaW9ucyk7XG4gIGZsb2F0IGRpc3RUb05laWdoYm9yID0gbGVuZ3RoKChjbGFtcGVkR2x5cGhVViAtIG5laWdoYm9yMVVWKSAqIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMpO1xuICBmbG9hdCBncmFkaWVudEFuZ2xlMSA9IG1pbihhc2luKGFicyhuZWlnaGJvcjFEaXN0YW5jZSAtIGRpc3RhbmNlKSAvIGRpc3RUb05laWdoYm9yKSwgUEkgLyAyLjApO1xuICBmbG9hdCBncmFkaWVudEFuZ2xlMiA9IG1pbihhc2luKGFicyhuZWlnaGJvcjJEaXN0YW5jZSAtIGRpc3RhbmNlKSAvIGRpc3RUb05laWdoYm9yKSwgUEkgLyAyLjApO1xuICBkaXN0YW5jZSArPSAoY29zKGdyYWRpZW50QW5nbGUxKSArIGNvcyhncmFkaWVudEFuZ2xlMikpIC8gMi4wICogZGlzdFRvVW5jbGFtcGVkO1xuICAqL31cblxuICByZXR1cm4gZGlzdGFuY2U7XG59XG5cbmZsb2F0IHRyb2lrYUdldEVkZ2VBbHBoYShmbG9hdCBkaXN0YW5jZSwgZmxvYXQgZGlzdGFuY2VPZmZzZXQsIGZsb2F0IGFhRGlzdCkge1xuICAjaWYgZGVmaW5lZChJU19ERVBUSF9NQVRFUklBTCkgfHwgZGVmaW5lZChJU19ESVNUQU5DRV9NQVRFUklBTClcbiAgZmxvYXQgYWxwaGEgPSBzdGVwKC1kaXN0YW5jZU9mZnNldCwgLWRpc3RhbmNlKTtcbiAgI2Vsc2VcblxuICBmbG9hdCBhbHBoYSA9IHNtb290aHN0ZXAoXG4gICAgZGlzdGFuY2VPZmZzZXQgKyBhYURpc3QsXG4gICAgZGlzdGFuY2VPZmZzZXQgLSBhYURpc3QsXG4gICAgZGlzdGFuY2VcbiAgKTtcbiAgI2VuZGlmXG5cbiAgcmV0dXJuIGFscGhhO1xufVxuYDtcblxuICAvLyBsYW5ndWFnZT1HTFNMIHByZWZpeD1cInZvaWQgbWFpbigpIHtcIiBzdWZmaXg9XCJ9XCJcbiAgY29uc3QgRlJBR01FTlRfVFJBTlNGT1JNID0gYFxuZmxvYXQgYWFEaXN0ID0gdHJvaWthR2V0QUFEaXN0KCk7XG5mbG9hdCBmcmFnRGlzdGFuY2UgPSB0cm9pa2FHZXRGcmFnRGlzdFZhbHVlKCk7XG5mbG9hdCBlZGdlQWxwaGEgPSB1VHJvaWthU0RGRGVidWcgP1xuICB0cm9pa2FHbHlwaFV2VG9TZGZWYWx1ZSh2VHJvaWthR2x5cGhVVikgOlxuICB0cm9pa2FHZXRFZGdlQWxwaGEoZnJhZ0Rpc3RhbmNlLCB1VHJvaWthRWRnZU9mZnNldCwgbWF4KGFhRGlzdCwgdVRyb2lrYUJsdXJSYWRpdXMpKTtcblxuI2lmICFkZWZpbmVkKElTX0RFUFRIX01BVEVSSUFMKSAmJiAhZGVmaW5lZChJU19ESVNUQU5DRV9NQVRFUklBTClcbnZlYzQgZmlsbFJHQkEgPSBnbF9GcmFnQ29sb3I7XG5maWxsUkdCQS5hICo9IHVUcm9pa2FGaWxsT3BhY2l0eTtcbnZlYzQgc3Ryb2tlUkdCQSA9IHVUcm9pa2FTdHJva2VXaWR0aCA9PSAwLjAgPyBmaWxsUkdCQSA6IHZlYzQodVRyb2lrYVN0cm9rZUNvbG9yLCB1VHJvaWthU3Ryb2tlT3BhY2l0eSk7XG5pZiAoZmlsbFJHQkEuYSA9PSAwLjApIGZpbGxSR0JBLnJnYiA9IHN0cm9rZVJHQkEucmdiO1xuZ2xfRnJhZ0NvbG9yID0gbWl4KGZpbGxSR0JBLCBzdHJva2VSR0JBLCBzbW9vdGhzdGVwKFxuICAtdVRyb2lrYVN0cm9rZVdpZHRoIC0gYWFEaXN0LFxuICAtdVRyb2lrYVN0cm9rZVdpZHRoICsgYWFEaXN0LFxuICBmcmFnRGlzdGFuY2VcbikpO1xuZ2xfRnJhZ0NvbG9yLmEgKj0gZWRnZUFscGhhO1xuI2VuZGlmXG5cbmlmIChlZGdlQWxwaGEgPT0gMC4wKSB7XG4gIGRpc2NhcmQ7XG59XG5gO1xuXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1hdGVyaWFsIGZvciByZW5kZXJpbmcgdGV4dCwgZGVyaXZlZCBmcm9tIGEgYmFzZU1hdGVyaWFsXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVUZXh0RGVyaXZlZE1hdGVyaWFsKGJhc2VNYXRlcmlhbCkge1xuICAgIGNvbnN0IHRleHRNYXRlcmlhbCA9IHRyb2lrYVRocmVlVXRpbHMuY3JlYXRlRGVyaXZlZE1hdGVyaWFsKGJhc2VNYXRlcmlhbCwge1xuICAgICAgY2hhaW5lZDogdHJ1ZSxcbiAgICAgIGV4dGVuc2lvbnM6IHtcbiAgICAgICAgZGVyaXZhdGl2ZXM6IHRydWVcbiAgICAgIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICB1VHJvaWthU0RGVGV4dHVyZToge3ZhbHVlOiBudWxsfSxcbiAgICAgICAgdVRyb2lrYVNERlRleHR1cmVTaXplOiB7dmFsdWU6IG5ldyB0aHJlZS5WZWN0b3IyKCl9LFxuICAgICAgICB1VHJvaWthU0RGR2x5cGhTaXplOiB7dmFsdWU6IDB9LFxuICAgICAgICB1VHJvaWthU0RGRXhwb25lbnQ6IHt2YWx1ZTogMH0sXG4gICAgICAgIHVUcm9pa2FUb3RhbEJvdW5kczoge3ZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yNCgwLDAsMCwwKX0sXG4gICAgICAgIHVUcm9pa2FDbGlwUmVjdDoge3ZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yNCgwLDAsMCwwKX0sXG4gICAgICAgIHVUcm9pa2FFZGdlT2Zmc2V0OiB7dmFsdWU6IDB9LFxuICAgICAgICB1VHJvaWthRmlsbE9wYWNpdHk6IHt2YWx1ZTogMX0sXG4gICAgICAgIHVUcm9pa2FQb3NpdGlvbk9mZnNldDoge3ZhbHVlOiBuZXcgdGhyZWUuVmVjdG9yMigpfSxcbiAgICAgICAgdVRyb2lrYUN1cnZlUmFkaXVzOiB7dmFsdWU6IDB9LFxuICAgICAgICB1VHJvaWthQmx1clJhZGl1czoge3ZhbHVlOiAwfSxcbiAgICAgICAgdVRyb2lrYVN0cm9rZVdpZHRoOiB7dmFsdWU6IDB9LFxuICAgICAgICB1VHJvaWthU3Ryb2tlQ29sb3I6IHt2YWx1ZTogbmV3IHRocmVlLkNvbG9yKCl9LFxuICAgICAgICB1VHJvaWthU3Ryb2tlT3BhY2l0eToge3ZhbHVlOiAxfSxcbiAgICAgICAgdVRyb2lrYU9yaWVudDoge3ZhbHVlOiBuZXcgdGhyZWUuTWF0cml4MygpfSxcbiAgICAgICAgdVRyb2lrYVVzZUdseXBoQ29sb3JzOiB7dmFsdWU6IHRydWV9LFxuICAgICAgICB1VHJvaWthU0RGRGVidWc6IHt2YWx1ZTogZmFsc2V9XG4gICAgICB9LFxuICAgICAgdmVydGV4RGVmczogVkVSVEVYX0RFRlMsXG4gICAgICB2ZXJ0ZXhUcmFuc2Zvcm06IFZFUlRFWF9UUkFOU0ZPUk0sXG4gICAgICBmcmFnbWVudERlZnM6IEZSQUdNRU5UX0RFRlMsXG4gICAgICBmcmFnbWVudENvbG9yVHJhbnNmb3JtOiBGUkFHTUVOVF9UUkFOU0ZPUk0sXG4gICAgICBjdXN0b21SZXdyaXRlcih7dmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcn0pIHtcbiAgICAgICAgbGV0IHVEaWZmdXNlUkUgPSAvXFxidW5pZm9ybVxccyt2ZWMzXFxzK2RpZmZ1c2VcXGIvO1xuICAgICAgICBpZiAodURpZmZ1c2VSRS50ZXN0KGZyYWdtZW50U2hhZGVyKSkge1xuICAgICAgICAgIC8vIFJlcGxhY2UgYWxsIGluc3RhbmNlcyBvZiBgZGlmZnVzZWAgd2l0aCBvdXIgdmFyeWluZ1xuICAgICAgICAgIGZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXJcbiAgICAgICAgICAgIC5yZXBsYWNlKHVEaWZmdXNlUkUsICd2YXJ5aW5nIHZlYzMgdlRyb2lrYUdseXBoQ29sb3InKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcYmRpZmZ1c2VcXGIvZywgJ3ZUcm9pa2FHbHlwaENvbG9yJyk7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB2ZXJ0ZXggc2hhZGVyIGRlY2xhcmVzIHRoZSB1bmlmb3JtIHNvIHdlIGNhbiBncmFiIGl0IGFzIGEgZmFsbGJhY2tcbiAgICAgICAgICBpZiAoIXVEaWZmdXNlUkUudGVzdCh2ZXJ0ZXhTaGFkZXIpKSB7XG4gICAgICAgICAgICB2ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXIucmVwbGFjZShcbiAgICAgICAgICAgICAgdHJvaWthVGhyZWVVdGlscy52b2lkTWFpblJlZ0V4cCxcbiAgICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbiQmXFxudlRyb2lrYUdseXBoQ29sb3IgPSB1VHJvaWthVXNlR2x5cGhDb2xvcnMgPyBhVHJvaWthR2x5cGhDb2xvciAvIDI1NS4wIDogZGlmZnVzZTtcXG4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEZvcmNlIHRyYW5zcGFyZW5jeSAtIFRPRE8gaXMgdGhpcyByZWFzb25hYmxlP1xuICAgIHRleHRNYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG5cbiAgICAvLyBGb3JjZSBzaW5nbGUgZHJhdyBjYWxsIHdoZW4gZG91YmxlLXNpZGVkXG4gICAgdGV4dE1hdGVyaWFsLmZvcmNlU2luZ2xlUGFzcyA9IHRydWU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0ZXh0TWF0ZXJpYWwsIHtcbiAgICAgIGlzVHJvaWthVGV4dE1hdGVyaWFsOiB7dmFsdWU6IHRydWV9LFxuXG4gICAgICAvLyBXZWJHTFNoYWRvd01hcCByZXZlcnNlcyB0aGUgc2lkZSBvZiB0aGUgc2hhZG93IG1hdGVyaWFsIGJ5IGRlZmF1bHQsIHdoaWNoIGZhaWxzXG4gICAgICAvLyBmb3IgcGxhbmVzLCBzbyBoZXJlIHdlIGZvcmNlIHRoZSBgc2hhZG93U2lkZWAgdG8gYWx3YXlzIG1hdGNoIHRoZSBtYWluIHNpZGUuXG4gICAgICBzaGFkb3dTaWRlOiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zaWRlXG4gICAgICAgIH0sXG4gICAgICAgIHNldCgpIHtcbiAgICAgICAgICAvL25vLW9wXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0ZXh0TWF0ZXJpYWxcbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRNYXRlcmlhbCA9IC8qI19fUFVSRV9fKi8gbmV3IHRocmVlLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICBjb2xvcjogMHhmZmZmZmYsXG4gICAgc2lkZTogdGhyZWUuRG91YmxlU2lkZSxcbiAgICB0cmFuc3BhcmVudDogdHJ1ZVxuICB9KTtcbiAgY29uc3QgZGVmYXVsdFN0cm9rZUNvbG9yID0gMHg4MDgwODA7XG5cbiAgY29uc3QgdGVtcE1hdDQgPSAvKiNfX1BVUkVfXyovIG5ldyB0aHJlZS5NYXRyaXg0KCk7XG4gIGNvbnN0IHRlbXBWZWMzYSA9IC8qI19fUFVSRV9fKi8gbmV3IHRocmVlLlZlY3RvcjMoKTtcbiAgY29uc3QgdGVtcFZlYzNiID0gLyojX19QVVJFX18qLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuICBjb25zdCB0ZW1wQXJyYXkgPSBbXTtcbiAgY29uc3Qgb3JpZ2luID0gLyojX19QVVJFX18qLyBuZXcgdGhyZWUuVmVjdG9yMygpO1xuICBjb25zdCBkZWZhdWx0T3JpZW50ID0gJyt4K3knO1xuXG4gIGZ1bmN0aW9uIGZpcnN0KG8pIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvKSA/IG9bMF0gOiBvXG4gIH1cblxuICBsZXQgZ2V0RmxhdFJheWNhc3RNZXNoID0gKCkgPT4ge1xuICAgIGNvbnN0IG1lc2ggPSBuZXcgdGhyZWUuTWVzaChcbiAgICAgIG5ldyB0aHJlZS5QbGFuZUdlb21ldHJ5KDEsIDEpLFxuICAgICAgZGVmYXVsdE1hdGVyaWFsXG4gICAgKTtcbiAgICBnZXRGbGF0UmF5Y2FzdE1lc2ggPSAoKSA9PiBtZXNoO1xuICAgIHJldHVybiBtZXNoXG4gIH07XG4gIGxldCBnZXRDdXJ2ZWRSYXljYXN0TWVzaCA9ICgpID0+IHtcbiAgICBjb25zdCBtZXNoID0gbmV3IHRocmVlLk1lc2goXG4gICAgICBuZXcgdGhyZWUuUGxhbmVHZW9tZXRyeSgxLCAxLCAzMiwgMSksXG4gICAgICBkZWZhdWx0TWF0ZXJpYWxcbiAgICApO1xuICAgIGdldEN1cnZlZFJheWNhc3RNZXNoID0gKCkgPT4gbWVzaDtcbiAgICByZXR1cm4gbWVzaFxuICB9O1xuXG4gIGNvbnN0IHN5bmNTdGFydEV2ZW50ID0geyB0eXBlOiAnc3luY3N0YXJ0JyB9O1xuICBjb25zdCBzeW5jQ29tcGxldGVFdmVudCA9IHsgdHlwZTogJ3N5bmNjb21wbGV0ZScgfTtcblxuICBjb25zdCBTWU5DQUJMRV9QUk9QUyA9IFtcbiAgICAnZm9udCcsXG4gICAgJ2ZvbnRTaXplJyxcbiAgICAnZm9udFN0eWxlJyxcbiAgICAnZm9udFdlaWdodCcsXG4gICAgJ2xhbmcnLFxuICAgICdsZXR0ZXJTcGFjaW5nJyxcbiAgICAnbGluZUhlaWdodCcsXG4gICAgJ21heFdpZHRoJyxcbiAgICAnb3ZlcmZsb3dXcmFwJyxcbiAgICAndGV4dCcsXG4gICAgJ2RpcmVjdGlvbicsXG4gICAgJ3RleHRBbGlnbicsXG4gICAgJ3RleHRJbmRlbnQnLFxuICAgICd3aGl0ZVNwYWNlJyxcbiAgICAnYW5jaG9yWCcsXG4gICAgJ2FuY2hvclknLFxuICAgICdjb2xvclJhbmdlcycsXG4gICAgJ3NkZkdseXBoU2l6ZSdcbiAgXTtcblxuICBjb25zdCBDT1BZQUJMRV9QUk9QUyA9IFNZTkNBQkxFX1BST1BTLmNvbmNhdChcbiAgICAnbWF0ZXJpYWwnLFxuICAgICdjb2xvcicsXG4gICAgJ2RlcHRoT2Zmc2V0JyxcbiAgICAnY2xpcFJlY3QnLFxuICAgICdjdXJ2ZVJhZGl1cycsXG4gICAgJ29yaWVudGF0aW9uJyxcbiAgICAnZ2x5cGhHZW9tZXRyeURldGFpbCdcbiAgKTtcblxuICAvKipcbiAgICogQGNsYXNzIFRleHRcbiAgICpcbiAgICogQSBUaHJlZUpTIE1lc2ggdGhhdCByZW5kZXJzIGEgc3RyaW5nIG9mIHRleHQgb24gYSBwbGFuZSBpbiAzRCBzcGFjZSB1c2luZyBzaWduZWQgZGlzdGFuY2VcbiAgICogZmllbGRzIChTREYpLlxuICAgKi9cbiAgY2xhc3MgVGV4dCBleHRlbmRzIHRocmVlLk1lc2gge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgR2x5cGhzR2VvbWV0cnkoKTtcbiAgICAgIHN1cGVyKGdlb21ldHJ5LCBudWxsKTtcblxuICAgICAgLy8gPT09IFRleHQgbGF5b3V0IHByb3BlcnRpZXM6ID09PSAvL1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gdGV4dFxuICAgICAgICogVGhlIHN0cmluZyBvZiB0ZXh0IHRvIGJlIHJlbmRlcmVkLlxuICAgICAgICovXG4gICAgICB0aGlzLnRleHQgPSAnJztcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBhbmNob3JYXG4gICAgICAgKiBEZWZpbmVzIHRoZSBob3Jpem9udGFsIHBvc2l0aW9uIGluIHRoZSB0ZXh0IGJsb2NrIHRoYXQgc2hvdWxkIGxpbmUgdXAgd2l0aCB0aGUgbG9jYWwgb3JpZ2luLlxuICAgICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBhIG51bWVyaWMgeCBwb3NpdGlvbiBpbiBsb2NhbCB1bml0cywgYSBzdHJpbmcgcGVyY2VudGFnZSBvZiB0aGUgdG90YWxcbiAgICAgICAqIHRleHQgYmxvY2sgd2lkdGggZS5nLiBgJzI1JSdgLCBvciBvbmUgb2YgdGhlIGZvbGxvd2luZyBrZXl3b3JkIHN0cmluZ3M6ICdsZWZ0JywgJ2NlbnRlcicsXG4gICAgICAgKiBvciAncmlnaHQnLlxuICAgICAgICovXG4gICAgICB0aGlzLmFuY2hvclggPSAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IGFuY2hvcllcbiAgICAgICAqIERlZmluZXMgdGhlIHZlcnRpY2FsIHBvc2l0aW9uIGluIHRoZSB0ZXh0IGJsb2NrIHRoYXQgc2hvdWxkIGxpbmUgdXAgd2l0aCB0aGUgbG9jYWwgb3JpZ2luLlxuICAgICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBhIG51bWVyaWMgeSBwb3NpdGlvbiBpbiBsb2NhbCB1bml0cyAobm90ZTogZG93biBpcyBuZWdhdGl2ZSB5KSwgYSBzdHJpbmdcbiAgICAgICAqIHBlcmNlbnRhZ2Ugb2YgdGhlIHRvdGFsIHRleHQgYmxvY2sgaGVpZ2h0IGUuZy4gYCcyNSUnYCwgb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcga2V5d29yZCBzdHJpbmdzOlxuICAgICAgICogJ3RvcCcsICd0b3AtYmFzZWxpbmUnLCAndG9wLWNhcCcsICd0b3AtZXgnLCAnbWlkZGxlJywgJ2JvdHRvbS1iYXNlbGluZScsIG9yICdib3R0b20nLlxuICAgICAgICovXG4gICAgICB0aGlzLmFuY2hvclkgPSAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gY3VydmVSYWRpdXNcbiAgICAgICAqIERlZmluZXMgYSBjeWxpbmRyaWNhbCByYWRpdXMgYWxvbmcgd2hpY2ggdGhlIHRleHQncyBwbGFuZSB3aWxsIGJlIGN1cnZlZC4gUG9zaXRpdmUgbnVtYmVycyBwdXRcbiAgICAgICAqIHRoZSBjeWxpbmRlcidzIGNlbnRlcmxpbmUgKG9yaWVudGVkIHZlcnRpY2FsbHkpIHRoYXQgZGlzdGFuY2UgaW4gZnJvbnQgb2YgdGhlIHRleHQsIGZvciBhIGNvbmNhdmVcbiAgICAgICAqIGN1cnZhdHVyZSwgd2hpbGUgbmVnYXRpdmUgbnVtYmVycyBwdXQgaXQgYmVoaW5kIHRoZSB0ZXh0IGZvciBhIGNvbnZleCBjdXJ2YXR1cmUuIFRoZSBjZW50ZXJsaW5lXG4gICAgICAgKiB3aWxsIGJlIGFsaWduZWQgd2l0aCB0aGUgdGV4dCdzIGxvY2FsIG9yaWdpbjsgeW91IGNhbiB1c2UgYGFuY2hvclhgIHRvIG9mZnNldCBpdC5cbiAgICAgICAqXG4gICAgICAgKiBTaW5jZSBlYWNoIGdseXBoIGlzIGJ5IGRlZmF1bHQgcmVuZGVyZWQgd2l0aCBhIHNpbXBsZSBxdWFkLCBlYWNoIGdseXBoIHJlbWFpbnMgYSBmbGF0IHBsYW5lXG4gICAgICAgKiBpbnRlcm5hbGx5LiBZb3UgY2FuIHVzZSBgZ2x5cGhHZW9tZXRyeURldGFpbGAgdG8gYWRkIG1vcmUgdmVydGljZXMgZm9yIGN1cnZhdHVyZSBpbnNpZGUgZ2x5cGhzLlxuICAgICAgICovXG4gICAgICB0aGlzLmN1cnZlUmFkaXVzID0gMDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRpcmVjdGlvblxuICAgICAgICogU2V0cyB0aGUgYmFzZSBkaXJlY3Rpb24gZm9yIHRoZSB0ZXh0LiBUaGUgZGVmYXVsdCB2YWx1ZSBvZiBcImF1dG9cIiB3aWxsIGNob29zZSBhIGRpcmVjdGlvbiBiYXNlZFxuICAgICAgICogb24gdGhlIHRleHQncyBjb250ZW50IGFjY29yZGluZyB0byB0aGUgYmlkaSBzcGVjLiBBIHZhbHVlIG9mIFwibHRyXCIgb3IgXCJydGxcIiB3aWxsIGZvcmNlIHRoZSBkaXJlY3Rpb24uXG4gICAgICAgKi9cbiAgICAgIHRoaXMuZGlyZWN0aW9uID0gJ2F1dG8nO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ3xudWxsfSBmb250XG4gICAgICAgKiBVUkwgb2YgYSBjdXN0b20gZm9udCB0byBiZSB1c2VkLiBGb250IGZpbGVzIGNhbiBiZSBpbiAudHRmLCAub3RmLCBvciAud29mZiAobm90IC53b2ZmMikgZm9ybWF0cy5cbiAgICAgICAqIERlZmF1bHRzIHRvIE5vdG8gU2Fucy5cbiAgICAgICAqL1xuICAgICAgdGhpcy5mb250ID0gbnVsbDsgLy93aWxsIHVzZSBkZWZhdWx0IGZyb20gVGV4dEJ1aWxkZXJcblxuICAgICAgdGhpcy51bmljb2RlRm9udHNVUkwgPSBudWxsOyAvL2RlZmF1bHRzIHRvIENETlxuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gZm9udFNpemVcbiAgICAgICAqIFRoZSBzaXplIGF0IHdoaWNoIHRvIHJlbmRlciB0aGUgZm9udCBpbiBsb2NhbCB1bml0czsgY29ycmVzcG9uZHMgdG8gdGhlIGVtLWJveCBoZWlnaHRcbiAgICAgICAqIG9mIHRoZSBjaG9zZW4gYGZvbnRgLlxuICAgICAgICovXG4gICAgICB0aGlzLmZvbnRTaXplID0gMC4xO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcnwnbm9ybWFsJ3wnYm9sZCd9XG4gICAgICAgKiBUaGUgd2VpZ2h0IG9mIHRoZSBmb250LiBDdXJyZW50bHkgb25seSB1c2VkIGZvciBmYWxsYmFjayBOb3RvIGZvbnRzLlxuICAgICAgICovXG4gICAgICB0aGlzLmZvbnRXZWlnaHQgPSAnbm9ybWFsJztcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHsnbm9ybWFsJ3wnaXRhbGljJ31cbiAgICAgICAqIFRoZSBzdHlsZSBvZiB0aGUgZm9udC4gQ3VycmVudGx5IG9ubHkgdXNlZCBmb3IgZmFsbGJhY2sgTm90byBmb250cy5cbiAgICAgICAqL1xuICAgICAgdGhpcy5mb250U3R5bGUgPSAnbm9ybWFsJztcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVsbH0gbGFuZ1xuICAgICAgICogVGhlIGxhbmd1YWdlIGNvZGUgb2YgdGhpcyB0ZXh0OyBjYW4gYmUgdXNlZCBmb3IgZXhwbGljaXRseSBzZWxlY3RpbmcgY2VydGFpbiBDSksgZm9udHMuXG4gICAgICAgKi9cbiAgICAgIHRoaXMubGFuZyA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGxldHRlclNwYWNpbmdcbiAgICAgICAqIFNldHMgYSB1bmlmb3JtIGFkanVzdG1lbnQgdG8gc3BhY2luZyBiZXR3ZWVuIGxldHRlcnMgYWZ0ZXIga2VybmluZyBpcyBhcHBsaWVkLiBQb3NpdGl2ZVxuICAgICAgICogbnVtYmVycyBpbmNyZWFzZSBzcGFjaW5nIGFuZCBuZWdhdGl2ZSBudW1iZXJzIGRlY3JlYXNlIGl0LlxuICAgICAgICovXG4gICAgICB0aGlzLmxldHRlclNwYWNpbmcgPSAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IGxpbmVIZWlnaHRcbiAgICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiBlYWNoIGxpbmUgb2YgdGV4dCwgYXMgYSBtdWx0aXBsZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gJ25vcm1hbCdcbiAgICAgICAqIHdoaWNoIGNob29zZXMgYSByZWFzb25hYmxlIGhlaWdodCBiYXNlZCBvbiB0aGUgY2hvc2VuIGZvbnQncyBhc2NlbmRlci9kZXNjZW5kZXIgbWV0cmljcy5cbiAgICAgICAqL1xuICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gJ25vcm1hbCc7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBtYXhXaWR0aFxuICAgICAgICogVGhlIG1heGltdW0gd2lkdGggb2YgdGhlIHRleHQgYmxvY2ssIGFib3ZlIHdoaWNoIHRleHQgbWF5IHN0YXJ0IHdyYXBwaW5nIGFjY29yZGluZyB0byB0aGVcbiAgICAgICAqIGB3aGl0ZVNwYWNlYCBhbmQgYG92ZXJmbG93V3JhcGAgcHJvcGVydGllcy5cbiAgICAgICAqL1xuICAgICAgdGhpcy5tYXhXaWR0aCA9IEluZmluaXR5O1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gb3ZlcmZsb3dXcmFwXG4gICAgICAgKiBEZWZpbmVzIGhvdyB0ZXh0IHdyYXBzIGlmIHRoZSBgd2hpdGVTcGFjZWAgcHJvcGVydHkgaXMgYG5vcm1hbGAuIENhbiBiZSBlaXRoZXIgYCdub3JtYWwnYFxuICAgICAgICogdG8gYnJlYWsgYXQgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLCBvciBgJ2JyZWFrLXdvcmQnYCB0byBhbGxvdyBicmVha2luZyB3aXRoaW4gd29yZHMuXG4gICAgICAgKiBEZWZhdWx0cyB0byBgJ25vcm1hbCdgLlxuICAgICAgICovXG4gICAgICB0aGlzLm92ZXJmbG93V3JhcCA9ICdub3JtYWwnO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gdGV4dEFsaWduXG4gICAgICAgKiBUaGUgaG9yaXpvbnRhbCBhbGlnbm1lbnQgb2YgZWFjaCBsaW5lIG9mIHRleHQgd2l0aGluIHRoZSBvdmVyYWxsIHRleHQgYm91bmRpbmcgYm94LlxuICAgICAgICovXG4gICAgICB0aGlzLnRleHRBbGlnbiA9ICdsZWZ0JztcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHRleHRJbmRlbnRcbiAgICAgICAqIEluZGVudGF0aW9uIGZvciB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgbGluZTsgc2VlIENTUyBgdGV4dC1pbmRlbnRgLlxuICAgICAgICovXG4gICAgICB0aGlzLnRleHRJbmRlbnQgPSAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gd2hpdGVTcGFjZVxuICAgICAgICogRGVmaW5lcyB3aGV0aGVyIHRleHQgc2hvdWxkIHdyYXAgd2hlbiBhIGxpbmUgcmVhY2hlcyB0aGUgYG1heFdpZHRoYC4gQ2FuXG4gICAgICAgKiBiZSBlaXRoZXIgYCdub3JtYWwnYCAodGhlIGRlZmF1bHQpLCB0byBhbGxvdyB3cmFwcGluZyBhY2NvcmRpbmcgdG8gdGhlIGBvdmVyZmxvd1dyYXBgIHByb3BlcnR5LFxuICAgICAgICogb3IgYCdub3dyYXAnYCB0byBwcmV2ZW50IHdyYXBwaW5nLiBOb3RlIHRoYXQgYCdub3JtYWwnYCBoZXJlIGhvbm9ycyBuZXdsaW5lIGNoYXJhY3RlcnMgdG9cbiAgICAgICAqIG1hbnVhbGx5IGJyZWFrIGxpbmVzLCBtYWtpbmcgaXQgYmVoYXZlIG1vcmUgbGlrZSBgJ3ByZS13cmFwJ2AgZG9lcyBpbiBDU1MuXG4gICAgICAgKi9cbiAgICAgIHRoaXMud2hpdGVTcGFjZSA9ICdub3JtYWwnO1xuXG5cbiAgICAgIC8vID09PSBQcmVzZW50YXRpb24gcHJvcGVydGllczogPT09IC8vXG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7VEhSRUUuTWF0ZXJpYWx9IG1hdGVyaWFsXG4gICAgICAgKiBEZWZpbmVzIGEgX2Jhc2VfIG1hdGVyaWFsIHRvIGJlIHVzZWQgd2hlbiByZW5kZXJpbmcgdGhlIHRleHQuIFRoaXMgbWF0ZXJpYWwgd2lsbCBiZVxuICAgICAgICogYXV0b21hdGljYWxseSByZXBsYWNlZCB3aXRoIGEgbWF0ZXJpYWwgZGVyaXZlZCBmcm9tIGl0LCB0aGF0IGFkZHMgc2hhZGVyIGNvZGUgdG9cbiAgICAgICAqIGRlY3JlYXNlIHRoZSBhbHBoYSBmb3IgZWFjaCBmcmFnbWVudCAocGl4ZWwpIG91dHNpZGUgdGhlIHRleHQgZ2x5cGhzLCB3aXRoIGFudGlhbGlhc2luZy5cbiAgICAgICAqIEJ5IGRlZmF1bHQgaXQgd2lsbCBkZXJpdmUgZnJvbSBhIHNpbXBsZSB3aGl0ZSBNZXNoQmFzaWNNYXRlcmlhbCwgYnV0IHlvdSBjYW4gdXNlIGFueVxuICAgICAgICogb2YgdGhlIG90aGVyIG1lc2ggbWF0ZXJpYWxzIHRvIGdhaW4gb3RoZXIgZmVhdHVyZXMgbGlrZSBsaWdodGluZywgdGV4dHVyZSBtYXBzLCBldGMuXG4gICAgICAgKlxuICAgICAgICogQWxzbyBzZWUgdGhlIGBjb2xvcmAgc2hvcnRjdXQgcHJvcGVydHkuXG4gICAgICAgKi9cbiAgICAgIHRoaXMubWF0ZXJpYWwgPSBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ3xudW1iZXJ8VEhSRUUuQ29sb3J9IGNvbG9yXG4gICAgICAgKiBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yIHNldHRpbmcgdGhlIGBjb2xvcmAgb2YgdGhlIHRleHQncyBtYXRlcmlhbC4gWW91IGNhbiB1c2UgdGhpc1xuICAgICAgICogaWYgeW91IGRvbid0IHdhbnQgdG8gc3BlY2lmeSBhIHdob2xlIGN1c3RvbSBgbWF0ZXJpYWxgLiBBbHNvLCBpZiB5b3UgZG8gdXNlIGEgY3VzdG9tXG4gICAgICAgKiBgbWF0ZXJpYWxgLCB0aGlzIGNvbG9yIHdpbGwgb25seSBiZSB1c2VkIGZvciB0aGlzIHBhcnRpY3VhciBUZXh0IGluc3RhbmNlLCBldmVuIGlmXG4gICAgICAgKiB0aGF0IHNhbWUgbWF0ZXJpYWwgaW5zdGFuY2UgaXMgc2hhcmVkIGFjcm9zcyBtdWx0aXBsZSBUZXh0IG9iamVjdHMuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuY29sb3IgPSBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge29iamVjdHxudWxsfSBjb2xvclJhbmdlc1xuICAgICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAgICogVGhpcyBhbGxvd3MgbW9yZSBmaW5lLWdyYWluZWQgY29udHJvbCBvZiBjb2xvcnMgZm9yIGluZGl2aWR1YWwgb3IgcmFuZ2VzIG9mIGNoYXJhY3RlcnMsXG4gICAgICAgKiB0YWtpbmcgcHJlY2VkZW5jZSBvdmVyIHRoZSBtYXRlcmlhbCdzIGBjb2xvcmAuIEl0cyBmb3JtYXQgaXMgYW4gT2JqZWN0IHdob3NlIGtleXMgZWFjaFxuICAgICAgICogZGVmaW5lIGEgc3RhcnRpbmcgY2hhcmFjdGVyIGluZGV4IGZvciBhIHJhbmdlLCBhbmQgd2hvc2UgdmFsdWVzIGFyZSB0aGUgY29sb3IgZm9yIGVhY2hcbiAgICAgICAqIHJhbmdlLiBUaGUgY29sb3IgdmFsdWUgY2FuIGJlIGEgbnVtZXJpYyBoZXggY29sb3IgdmFsdWUsIGEgYFRIUkVFLkNvbG9yYCBvYmplY3QsIG9yXG4gICAgICAgKiBhbnkgb2YgdGhlIHN0cmluZ3MgYWNjZXB0ZWQgYnkgYFRIUkVFLkNvbG9yYC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5jb2xvclJhbmdlcyA9IG51bGw7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gb3V0bGluZVdpZHRoXG4gICAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICAgKiBUaGUgd2lkdGggb2YgYW4gb3V0bGluZS9oYWxvIHRvIGJlIGRyYXduIGFyb3VuZCBlYWNoIHRleHQgZ2x5cGggdXNpbmcgdGhlIGBvdXRsaW5lQ29sb3JgIGFuZCBgb3V0bGluZU9wYWNpdHlgLlxuICAgICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBlaXRoZXIgYW4gYWJzb2x1dGUgbnVtYmVyIGluIGxvY2FsIHVuaXRzLCBvciBhcyBhIHBlcmNlbnRhZ2Ugc3RyaW5nIGUuZy5cbiAgICAgICAqIGBcIjEyJVwiYCB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gYDBgLCB3aGljaCBtZWFuc1xuICAgICAgICogbm8gb3V0bGluZSB3aWxsIGJlIGRyYXduIHVubGVzcyBhbiBgb3V0bGluZU9mZnNldFgvWWAgb3IgYG91dGxpbmVCbHVyYCBpcyBzZXQuXG4gICAgICAgKi9cbiAgICAgIHRoaXMub3V0bGluZVdpZHRoID0gMDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVtYmVyfFRIUkVFLkNvbG9yfSBvdXRsaW5lQ29sb3JcbiAgICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgICAqIFRoZSBjb2xvciBvZiB0aGUgdGV4dCBvdXRsaW5lLCBpZiBgb3V0bGluZVdpZHRoYC9gb3V0bGluZUJsdXJgL2BvdXRsaW5lT2Zmc2V0WC9ZYCBhcmUgc2V0LlxuICAgICAgICogRGVmYXVsdHMgdG8gYmxhY2suXG4gICAgICAgKi9cbiAgICAgIHRoaXMub3V0bGluZUNvbG9yID0gMHgwMDAwMDA7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBvdXRsaW5lT3BhY2l0eVxuICAgICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAgICogVGhlIG9wYWNpdHkgb2YgdGhlIG91dGxpbmUsIGlmIGBvdXRsaW5lV2lkdGhgL2BvdXRsaW5lQmx1cmAvYG91dGxpbmVPZmZzZXRYL1lgIGFyZSBzZXQuXG4gICAgICAgKiBEZWZhdWx0cyB0byBgMWAuXG4gICAgICAgKi9cbiAgICAgIHRoaXMub3V0bGluZU9wYWNpdHkgPSAxO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IG91dGxpbmVCbHVyXG4gICAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICAgKiBBIGJsdXIgcmFkaXVzIGFwcGxpZWQgdG8gdGhlIG91dGVyIGVkZ2Ugb2YgdGhlIHRleHQncyBvdXRsaW5lLiBJZiB0aGUgYG91dGxpbmVXaWR0aGAgaXNcbiAgICAgICAqIHplcm8sIHRoZSBibHVyIHdpbGwgYmUgYXBwbGllZCBhdCB0aGUgZ2x5cGggZWRnZSwgbGlrZSBDU1MncyBgdGV4dC1zaGFkb3dgIGJsdXIgcmFkaXVzLlxuICAgICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBlaXRoZXIgYW4gYWJzb2x1dGUgbnVtYmVyIGluIGxvY2FsIHVuaXRzLCBvciBhcyBhIHBlcmNlbnRhZ2Ugc3RyaW5nIGUuZy5cbiAgICAgICAqIGBcIjEyJVwiYCB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gYDBgLlxuICAgICAgICovXG4gICAgICB0aGlzLm91dGxpbmVCbHVyID0gMDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBvdXRsaW5lT2Zmc2V0WFxuICAgICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAgICogQSBob3Jpem9udGFsIG9mZnNldCBmb3IgdGhlIHRleHQgb3V0bGluZS5cbiAgICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgZWl0aGVyIGFuIGFic29sdXRlIG51bWJlciBpbiBsb2NhbCB1bml0cywgb3IgYXMgYSBwZXJjZW50YWdlIHN0cmluZyBlLmcuIGBcIjEyJVwiYFxuICAgICAgICogd2hpY2ggaXMgdHJlYXRlZCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGBmb250U2l6ZWAuIERlZmF1bHRzIHRvIGAwYC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5vdXRsaW5lT2Zmc2V0WCA9IDA7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gb3V0bGluZU9mZnNldFlcbiAgICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgICAqIEEgdmVydGljYWwgb2Zmc2V0IGZvciB0aGUgdGV4dCBvdXRsaW5lLlxuICAgICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBlaXRoZXIgYW4gYWJzb2x1dGUgbnVtYmVyIGluIGxvY2FsIHVuaXRzLCBvciBhcyBhIHBlcmNlbnRhZ2Ugc3RyaW5nIGUuZy4gYFwiMTIlXCJgXG4gICAgICAgKiB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gYDBgLlxuICAgICAgICovXG4gICAgICB0aGlzLm91dGxpbmVPZmZzZXRZID0gMDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBzdHJva2VXaWR0aFxuICAgICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAgICogVGhlIHdpZHRoIG9mIGFuIGlubmVyIHN0cm9rZSBkcmF3biBpbnNpZGUgZWFjaCB0ZXh0IGdseXBoIHVzaW5nIHRoZSBgc3Ryb2tlQ29sb3JgIGFuZCBgc3Ryb2tlT3BhY2l0eWAuXG4gICAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhbiBhYnNvbHV0ZSBudW1iZXIgaW4gbG9jYWwgdW5pdHMsIG9yIGFzIGEgcGVyY2VudGFnZSBzdHJpbmcgZS5nLiBgXCIxMiVcImBcbiAgICAgICAqIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byBgMGAuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ3xudW1iZXJ8VEhSRUUuQ29sb3J9IHN0cm9rZUNvbG9yXG4gICAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICAgKiBUaGUgY29sb3Igb2YgdGhlIHRleHQgc3Ryb2tlLCBpZiBgc3Ryb2tlV2lkdGhgIGlzIGdyZWF0ZXIgdGhhbiB6ZXJvLiBEZWZhdWx0cyB0byBncmF5LlxuICAgICAgICovXG4gICAgICB0aGlzLnN0cm9rZUNvbG9yID0gZGVmYXVsdFN0cm9rZUNvbG9yO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gc3Ryb2tlT3BhY2l0eVxuICAgICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAgICogVGhlIG9wYWNpdHkgb2YgdGhlIHN0cm9rZSwgaWYgYHN0cm9rZVdpZHRoYCBpcyBncmVhdGVyIHRoYW4gemVyby4gRGVmYXVsdHMgdG8gYDFgLlxuICAgICAgICovXG4gICAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gZmlsbE9wYWNpdHlcbiAgICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgICAqIFRoZSBvcGFjaXR5IG9mIHRoZSBnbHlwaCdzIGZpbGwgZnJvbSAwIHRvIDEuIFRoaXMgYmVoYXZlcyBsaWtlIHRoZSBtYXRlcmlhbCdzIGBvcGFjaXR5YCBidXQgYWxsb3dzXG4gICAgICAgKiBnaXZpbmcgdGhlIGZpbGwgYSBkaWZmZXJlbnQgb3BhY2l0eSB0aGFuIHRoZSBgc3Ryb2tlT3BhY2l0eWAuIEEgZmlsbE9wYWNpdHkgb2YgYDBgIG1ha2VzIHRoZVxuICAgICAgICogaW50ZXJpb3Igb2YgdGhlIGdseXBoIGludmlzaWJsZSwgbGVhdmluZyBqdXN0IHRoZSBgc3Ryb2tlV2lkdGhgLiBEZWZhdWx0cyB0byBgMWAuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcn0gZGVwdGhPZmZzZXRcbiAgICAgICAqIFRoaXMgaXMgYSBzaG9ydGN1dCBmb3Igc2V0dGluZyB0aGUgbWF0ZXJpYWwncyBgcG9seWdvbk9mZnNldGAgYW5kIHJlbGF0ZWQgcHJvcGVydGllcyxcbiAgICAgICAqIHdoaWNoIGNhbiBiZSB1c2VmdWwgaW4gcHJldmVudGluZyB6LWZpZ2h0aW5nIHdoZW4gdGhpcyB0ZXh0IGlzIGxhaWQgb24gdG9wIG9mIGFub3RoZXJcbiAgICAgICAqIHBsYW5lIGluIHRoZSBzY2VuZS4gUG9zaXRpdmUgbnVtYmVycyBhcmUgZnVydGhlciBmcm9tIHRoZSBjYW1lcmEsIG5lZ2F0aXZlcyBjbG9zZXIuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuZGVwdGhPZmZzZXQgPSAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge0FycmF5PG51bWJlcj59IGNsaXBSZWN0XG4gICAgICAgKiBJZiBzcGVjaWZpZWQsIGRlZmluZXMgYSBgW21pblgsIG1pblksIG1heFgsIG1heFldYCBvZiBhIHJlY3RhbmdsZSBvdXRzaWRlIG9mIHdoaWNoIGFsbFxuICAgICAgICogcGl4ZWxzIHdpbGwgYmUgZGlzY2FyZGVkLiBUaGlzIGNhbiBiZSB1c2VkIGZvciBleGFtcGxlIHRvIGNsaXAgb3ZlcmZsb3dpbmcgdGV4dCB3aGVuXG4gICAgICAgKiBgd2hpdGVTcGFjZT0nbm93cmFwJ2AuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuY2xpcFJlY3QgPSBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gb3JpZW50YXRpb25cbiAgICAgICAqIERlZmluZXMgdGhlIGF4aXMgcGxhbmUgb24gd2hpY2ggdGhlIHRleHQgc2hvdWxkIGJlIGxhaWQgb3V0IHdoZW4gdGhlIG1lc2ggaGFzIG5vIGV4dHJhXG4gICAgICAgKiByb3RhdGlvbiB0cmFuc2Zvcm0uIEl0IGlzIHNwZWNpZmllZCBhcyBhIHN0cmluZyB3aXRoIHR3byBheGVzOiB0aGUgaG9yaXpvbnRhbCBheGlzIHdpdGhcbiAgICAgICAqIHBvc2l0aXZlIHBvaW50aW5nIHJpZ2h0LCBhbmQgdGhlIHZlcnRpY2FsIGF4aXMgd2l0aCBwb3NpdGl2ZSBwb2ludGluZyB1cC4gQnkgZGVmYXVsdCB0aGlzXG4gICAgICAgKiBpcyAnK3greScsIG1lYW5pbmcgdGhlIHRleHQgc2l0cyBvbiB0aGUgeHkgcGxhbmUgd2l0aCB0aGUgdGV4dCdzIHRvcCB0b3dhcmQgcG9zaXRpdmUgeVxuICAgICAgICogYW5kIGZhY2luZyBwb3NpdGl2ZSB6LiBBIHZhbHVlIG9mICcreC16JyB3b3VsZCBwbGFjZSBpdCBvbiB0aGUgeHogcGxhbmUgd2l0aCB0aGUgdGV4dCdzXG4gICAgICAgKiB0b3AgdG93YXJkIG5lZ2F0aXZlIHogYW5kIGZhY2luZyBwb3NpdGl2ZSB5LlxuICAgICAgICovXG4gICAgICB0aGlzLm9yaWVudGF0aW9uID0gZGVmYXVsdE9yaWVudDtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGdseXBoR2VvbWV0cnlEZXRhaWxcbiAgICAgICAqIENvbnRyb2xzIG51bWJlciBvZiB2ZXJ0aWNhbC9ob3Jpem9udGFsIHNlZ21lbnRzIHRoYXQgbWFrZSB1cCBlYWNoIGdseXBoJ3MgcmVjdGFuZ3VsYXJcbiAgICAgICAqIHBsYW5lLiBEZWZhdWx0cyB0byAxLiBUaGlzIGNhbiBiZSBpbmNyZWFzZWQgdG8gcHJvdmlkZSBtb3JlIGdlb21ldHJpY2FsIGRldGFpbCBmb3IgY3VzdG9tXG4gICAgICAgKiB2ZXJ0ZXggc2hhZGVyIGVmZmVjdHMsIGZvciBleGFtcGxlLlxuICAgICAgICovXG4gICAgICB0aGlzLmdseXBoR2VvbWV0cnlEZXRhaWwgPSAxO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge251bWJlcnxudWxsfSBzZGZHbHlwaFNpemVcbiAgICAgICAqIFRoZSBzaXplIG9mIGVhY2ggZ2x5cGgncyBTREYgKHNpZ25lZCBkaXN0YW5jZSBmaWVsZCkgdXNlZCBmb3IgcmVuZGVyaW5nLiBUaGlzIG11c3QgYmUgYVxuICAgICAgICogcG93ZXItb2YtdHdvIG51bWJlci4gRGVmYXVsdHMgdG8gNjQgd2hpY2ggaXMgZ2VuZXJhbGx5IGEgZ29vZCBiYWxhbmNlIG9mIHNpemUgYW5kIHF1YWxpdHlcbiAgICAgICAqIGZvciBtb3N0IGZvbnRzLiBMYXJnZXIgc2l6ZXMgY2FuIGltcHJvdmUgdGhlIHF1YWxpdHkgb2YgZ2x5cGggcmVuZGVyaW5nIGJ5IGluY3JlYXNpbmdcbiAgICAgICAqIHRoZSBzaGFycG5lc3Mgb2YgY29ybmVycyBhbmQgcHJldmVudGluZyBsb3NzIG9mIHZlcnkgdGhpbiBsaW5lcywgYXQgdGhlIGV4cGVuc2Ugb2ZcbiAgICAgICAqIGluY3JlYXNlZCBtZW1vcnkgZm9vdHByaW50IGFuZCBsb25nZXIgU0RGIGdlbmVyYXRpb24gdGltZS5cbiAgICAgICAqL1xuICAgICAgdGhpcy5zZGZHbHlwaFNpemUgPSBudWxsO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IGdwdUFjY2VsZXJhdGVTREZcbiAgICAgICAqIFdoZW4gYHRydWVgLCB0aGUgU0RGIGdlbmVyYXRpb24gcHJvY2VzcyB3aWxsIGJlIEdQVS1hY2NlbGVyYXRlZCB3aXRoIFdlYkdMIHdoZW4gcG9zc2libGUsXG4gICAgICAgKiBtYWtpbmcgaXQgbXVjaCBmYXN0ZXIgZXNwZWNpYWxseSBmb3IgY29tcGxleCBnbHlwaHMsIGFuZCBmYWxsaW5nIGJhY2sgdG8gYSBKYXZhU2NyaXB0IHZlcnNpb25cbiAgICAgICAqIGV4ZWN1dGVkIGluIHdlYiB3b3JrZXJzIHdoZW4gc3VwcG9ydCBpc24ndCBhdmFpbGFibGUuIEl0IHNob3VsZCBhdXRvbWF0aWNhbGx5IGRldGVjdCBzdXBwb3J0LFxuICAgICAgICogYnV0IGl0J3Mgc3RpbGwgc29tZXdoYXQgZXhwZXJpbWVudGFsLCBzbyB5b3UgY2FuIHNldCBpdCB0byBgZmFsc2VgIHRvIGZvcmNlIGl0IHRvIHVzZSB0aGUgSlNcbiAgICAgICAqIHZlcnNpb24gaWYgeW91IGVuY291bnRlciBpc3N1ZXMgd2l0aCBpdC5cbiAgICAgICAqL1xuICAgICAgdGhpcy5ncHVBY2NlbGVyYXRlU0RGID0gdHJ1ZTtcblxuICAgICAgdGhpcy5kZWJ1Z1NERiA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHRleHQgcmVuZGVyaW5nIGFjY29yZGluZyB0byB0aGUgY3VycmVudCB0ZXh0LXJlbGF0ZWQgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzLlxuICAgICAqIFRoaXMgaXMgYW4gYXN5bmMgcHJvY2Vzcywgc28geW91IGNhbiBwYXNzIGluIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBpdFxuICAgICAqIGZpbmlzaGVzLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja11cbiAgICAgKi9cbiAgICBzeW5jKGNhbGxiYWNrKSB7XG4gICAgICBpZiAodGhpcy5fbmVlZHNTeW5jKSB7XG4gICAgICAgIHRoaXMuX25lZWRzU3luYyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIElmIHRoZXJlJ3MgYW5vdGhlciBzeW5jIHN0aWxsIGluIHByb2dyZXNzLCBxdWV1ZVxuICAgICAgICBpZiAodGhpcy5faXNTeW5jaW5nKSB7XG4gICAgICAgICAgKHRoaXMuX3F1ZXVlZFN5bmNzIHx8ICh0aGlzLl9xdWV1ZWRTeW5jcyA9IFtdKSkucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5faXNTeW5jaW5nID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoc3luY1N0YXJ0RXZlbnQpO1xuXG4gICAgICAgICAgZ2V0VGV4dFJlbmRlckluZm8oe1xuICAgICAgICAgICAgdGV4dDogdGhpcy50ZXh0LFxuICAgICAgICAgICAgZm9udDogdGhpcy5mb250LFxuICAgICAgICAgICAgbGFuZzogdGhpcy5sYW5nLFxuICAgICAgICAgICAgZm9udFNpemU6IHRoaXMuZm9udFNpemUgfHwgMC4xLFxuICAgICAgICAgICAgZm9udFdlaWdodDogdGhpcy5mb250V2VpZ2h0IHx8ICdub3JtYWwnLFxuICAgICAgICAgICAgZm9udFN0eWxlOiB0aGlzLmZvbnRTdHlsZSB8fCAnbm9ybWFsJyxcbiAgICAgICAgICAgIGxldHRlclNwYWNpbmc6IHRoaXMubGV0dGVyU3BhY2luZyB8fCAwLFxuICAgICAgICAgICAgbGluZUhlaWdodDogdGhpcy5saW5lSGVpZ2h0IHx8ICdub3JtYWwnLFxuICAgICAgICAgICAgbWF4V2lkdGg6IHRoaXMubWF4V2lkdGgsXG4gICAgICAgICAgICBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uIHx8ICdhdXRvJyxcbiAgICAgICAgICAgIHRleHRBbGlnbjogdGhpcy50ZXh0QWxpZ24sXG4gICAgICAgICAgICB0ZXh0SW5kZW50OiB0aGlzLnRleHRJbmRlbnQsXG4gICAgICAgICAgICB3aGl0ZVNwYWNlOiB0aGlzLndoaXRlU3BhY2UsXG4gICAgICAgICAgICBvdmVyZmxvd1dyYXA6IHRoaXMub3ZlcmZsb3dXcmFwLFxuICAgICAgICAgICAgYW5jaG9yWDogdGhpcy5hbmNob3JYLFxuICAgICAgICAgICAgYW5jaG9yWTogdGhpcy5hbmNob3JZLFxuICAgICAgICAgICAgY29sb3JSYW5nZXM6IHRoaXMuY29sb3JSYW5nZXMsXG4gICAgICAgICAgICBpbmNsdWRlQ2FyZXRQb3NpdGlvbnM6IHRydWUsIC8vVE9ETyBwYXJhbWV0ZXJpemVcbiAgICAgICAgICAgIHNkZkdseXBoU2l6ZTogdGhpcy5zZGZHbHlwaFNpemUsXG4gICAgICAgICAgICBncHVBY2NlbGVyYXRlU0RGOiB0aGlzLmdwdUFjY2VsZXJhdGVTREYsXG4gICAgICAgICAgICB1bmljb2RlRm9udHNVUkw6IHRoaXMudW5pY29kZUZvbnRzVVJMLFxuICAgICAgICAgIH0sIHRleHRSZW5kZXJJbmZvID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2lzU3luY2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBTYXZlIHJlc3VsdCBmb3IgbGF0ZXIgdXNlIGluIG9uQmVmb3JlUmVuZGVyXG4gICAgICAgICAgICB0aGlzLl90ZXh0UmVuZGVySW5mbyA9IHRleHRSZW5kZXJJbmZvO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGdlb21ldHJ5IGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIHRoaXMuZ2VvbWV0cnkudXBkYXRlR2x5cGhzKFxuICAgICAgICAgICAgICB0ZXh0UmVuZGVySW5mby5nbHlwaEJvdW5kcyxcbiAgICAgICAgICAgICAgdGV4dFJlbmRlckluZm8uZ2x5cGhBdGxhc0luZGljZXMsXG4gICAgICAgICAgICAgIHRleHRSZW5kZXJJbmZvLmJsb2NrQm91bmRzLFxuICAgICAgICAgICAgICB0ZXh0UmVuZGVySW5mby5jaHVua2VkQm91bmRzLFxuICAgICAgICAgICAgICB0ZXh0UmVuZGVySW5mby5nbHlwaENvbG9yc1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gSWYgd2UgaGFkIGV4dHJhIHN5bmMgcmVxdWVzdHMgcXVldWVkIHVwLCBraWNrIGl0IG9mZlxuICAgICAgICAgICAgY29uc3QgcXVldWVkID0gdGhpcy5fcXVldWVkU3luY3M7XG4gICAgICAgICAgICBpZiAocXVldWVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3F1ZXVlZFN5bmNzID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhpcy5fbmVlZHNTeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5zeW5jKCgpID0+IHtcbiAgICAgICAgICAgICAgICBxdWV1ZWQuZm9yRWFjaChmbiA9PiBmbiAmJiBmbigpKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChzeW5jQ29tcGxldGVFdmVudCk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIGEgc3luYyBpZiBuZWVkZWQgLSBub3RlIGl0IHdvbid0IGNvbXBsZXRlIHVudGlsIG5leHQgZnJhbWUgYXQgdGhlXG4gICAgICogZWFybGllc3Qgc28gaWYgcG9zc2libGUgaXQncyBhIGdvb2QgaWRlYSB0byBjYWxsIHN5bmMoKSBtYW51YWxseSBhcyBzb29uIGFzXG4gICAgICogYWxsIHRoZSBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBzZXQuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgb25CZWZvcmVSZW5kZXIocmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXApIHtcbiAgICAgIHRoaXMuc3luYygpO1xuXG4gICAgICAvLyBUaGlzIG1heSBub3QgYWx3YXlzIGJlIGEgdGV4dCBtYXRlcmlhbCwgZS5nLiBpZiB0aGVyZSdzIGEgc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCBwcmVzZW50XG4gICAgICBpZiAobWF0ZXJpYWwuaXNUcm9pa2FUZXh0TWF0ZXJpYWwpIHtcbiAgICAgICAgdGhpcy5fcHJlcGFyZUZvclJlbmRlcihtYXRlcmlhbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvcnRjdXQgdG8gZGlzcG9zZSB0aGUgZ2VvbWV0cnkgc3BlY2lmaWMgdG8gdGhpcyBpbnN0YW5jZS5cbiAgICAgKiBOb3RlOiB3ZSBkb24ndCBhbHNvIGRpc3Bvc2UgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgaGVyZSBiZWNhdXNlIGlmIGFueXRoaW5nIGVsc2UgaXNcbiAgICAgKiBzaGFyaW5nIHRoZSBzYW1lIGJhc2UgbWF0ZXJpYWwgaXQgd2lsbCByZXN1bHQgaW4gYSBwYXVzZSBuZXh0IGZyYW1lIGFzIHRoZSBwcm9ncmFtXG4gICAgICogaXMgcmVjb21waWxlZC4gSW5zdGVhZCB1c2VycyBjYW4gZGlzcG9zZSB0aGUgYmFzZSBtYXRlcmlhbCBtYW51YWxseSwgbGlrZSBub3JtYWwsXG4gICAgICogYW5kIHdlJ2xsIGFsc28gZGlzcG9zZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCBhdCB0aGF0IHRpbWUuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VHJvaWthVGV4dFJlbmRlckluZm98bnVsbH0gdGV4dFJlbmRlckluZm9cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBUaGUgY3VycmVudCBwcm9jZXNzZWQgcmVuZGVyaW5nIGRhdGEgZm9yIHRoaXMgVGV4dE1lc2gsIHJldHVybmVkIGJ5IHRoZSBUZXh0QnVpbGRlciBhZnRlclxuICAgICAqIGEgYHN5bmMoKWAgY2FsbC4gVGhpcyB3aWxsIGJlIGBudWxsYCBpbml0aWFsbHksIGFuZCBtYXkgYmUgc3RhbGUgZm9yIGEgc2hvcnQgcGVyaW9kIHVudGlsXG4gICAgICogdGhlIGFzeW5jaHJvdXMgYHN5bmMoKWAgcHJvY2VzcyBjb21wbGV0ZXMuXG4gICAgICovXG4gICAgZ2V0IHRleHRSZW5kZXJJbmZvKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RleHRSZW5kZXJJbmZvIHx8IG51bGxcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIHRleHQgZGVyaXZlZCBtYXRlcmlhbCBmcm9tIHRoZSBiYXNlIG1hdGVyaWFsLiBDYW4gYmUgb3ZlcnJpZGRlbiB0byB1c2UgYSBjdXN0b21cbiAgICAgKiBkZXJpdmVkIG1hdGVyaWFsLlxuICAgICAqL1xuICAgIGNyZWF0ZURlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgICAgIHJldHVybiBjcmVhdGVUZXh0RGVyaXZlZE1hdGVyaWFsKGJhc2VNYXRlcmlhbClcbiAgICB9XG5cbiAgICAvLyBIYW5kbGVyIGZvciBhdXRvbWF0aWNhbGx5IHdyYXBwaW5nIHRoZSBiYXNlIG1hdGVyaWFsIHdpdGggb3VyIHVwZ3JhZGVzLiBXZSBkbyB0aGUgd3JhcHBpbmdcbiAgICAvLyBsYXppbHkgb24gX3JlYWRfIHJhdGhlciB0aGFuIHdyaXRlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdyYXBwaW5nIG9uIHRyYW5zaWVudCB2YWx1ZXMuXG4gICAgZ2V0IG1hdGVyaWFsKCkge1xuICAgICAgbGV0IGRlcml2ZWRNYXRlcmlhbCA9IHRoaXMuX2Rlcml2ZWRNYXRlcmlhbDtcbiAgICAgIGNvbnN0IGJhc2VNYXRlcmlhbCA9IHRoaXMuX2Jhc2VNYXRlcmlhbCB8fCB0aGlzLl9kZWZhdWx0TWF0ZXJpYWwgfHwgKHRoaXMuX2RlZmF1bHRNYXRlcmlhbCA9IGRlZmF1bHRNYXRlcmlhbC5jbG9uZSgpKTtcbiAgICAgIGlmICghZGVyaXZlZE1hdGVyaWFsIHx8ICFkZXJpdmVkTWF0ZXJpYWwuaXNEZXJpdmVkRnJvbShiYXNlTWF0ZXJpYWwpKSB7XG4gICAgICAgIGRlcml2ZWRNYXRlcmlhbCA9IHRoaXMuX2Rlcml2ZWRNYXRlcmlhbCA9IHRoaXMuY3JlYXRlRGVyaXZlZE1hdGVyaWFsKGJhc2VNYXRlcmlhbCk7XG4gICAgICAgIC8vIGRpc3Bvc2UgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgd2hlbiBpdHMgYmFzZSBtYXRlcmlhbCBpcyBkaXNwb3NlZDpcbiAgICAgICAgYmFzZU1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBmdW5jdGlvbiBvbkRpc3Bvc2UoKSB7XG4gICAgICAgICAgYmFzZU1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbkRpc3Bvc2UpO1xuICAgICAgICAgIGRlcml2ZWRNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gSWYgdGV4dCBvdXRsaW5lIGlzIGNvbmZpZ3VyZWQsIHJlbmRlciBpdCBhcyBhIHByZWxpbWluYXJ5IGRyYXcgdXNpbmcgVGhyZWUncyBtdWx0aS1tYXRlcmlhbFxuICAgICAgLy8gZmVhdHVyZSAoc2VlIEdseXBoc0dlb21ldHJ5IHdoaWNoIHNldHMgdXAgYGdyb3Vwc2AgZm9yIHRoaXMgcHVycG9zZSkgRG9pbmcgaXQgd2l0aCBtdWx0aVxuICAgICAgLy8gbWF0ZXJpYWxzIGVuc3VyZXMgdGhlIGxheWVycyBhcmUgYWx3YXlzIHJlbmRlcmVkIGNvbnNlY3V0aXZlbHkgaW4gYSBjb25zaXN0ZW50IG9yZGVyLlxuICAgICAgLy8gRWFjaCBsYXllciB3aWxsIHRyaWdnZXIgb25CZWZvcmVSZW5kZXIgd2l0aCB0aGUgYXBwcm9wcmlhdGUgbWF0ZXJpYWwuXG4gICAgICBpZiAodGhpcy5oYXNPdXRsaW5lKCkpIHtcbiAgICAgICAgbGV0IG91dGxpbmVNYXRlcmlhbCA9IGRlcml2ZWRNYXRlcmlhbC5fb3V0bGluZU10bDtcbiAgICAgICAgaWYgKCFvdXRsaW5lTWF0ZXJpYWwpIHtcbiAgICAgICAgICBvdXRsaW5lTWF0ZXJpYWwgPSBkZXJpdmVkTWF0ZXJpYWwuX291dGxpbmVNdGwgPSBPYmplY3QuY3JlYXRlKGRlcml2ZWRNYXRlcmlhbCwge1xuICAgICAgICAgICAgaWQ6IHt2YWx1ZTogZGVyaXZlZE1hdGVyaWFsLmlkICsgMC4xfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG91dGxpbmVNYXRlcmlhbC5pc1RleHRPdXRsaW5lTWF0ZXJpYWwgPSB0cnVlO1xuICAgICAgICAgIG91dGxpbmVNYXRlcmlhbC5kZXB0aFdyaXRlID0gZmFsc2U7XG4gICAgICAgICAgb3V0bGluZU1hdGVyaWFsLm1hcCA9IG51bGw7IC8vPz8/XG4gICAgICAgICAgZGVyaXZlZE1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBmdW5jdGlvbiBvbkRpc3Bvc2UoKSB7XG4gICAgICAgICAgICBkZXJpdmVkTWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uRGlzcG9zZSk7XG4gICAgICAgICAgICBvdXRsaW5lTWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgb3V0bGluZU1hdGVyaWFsLFxuICAgICAgICAgIGRlcml2ZWRNYXRlcmlhbFxuICAgICAgICBdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVyaXZlZE1hdGVyaWFsXG4gICAgICB9XG4gICAgfVxuICAgIHNldCBtYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgICAgIGlmIChiYXNlTWF0ZXJpYWwgJiYgYmFzZU1hdGVyaWFsLmlzVHJvaWthVGV4dE1hdGVyaWFsKSB7IC8vcHJldmVudCBkb3VibGUtZGVyaXZhdGlvblxuICAgICAgICB0aGlzLl9kZXJpdmVkTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWw7XG4gICAgICAgIHRoaXMuX2Jhc2VNYXRlcmlhbCA9IGJhc2VNYXRlcmlhbC5iYXNlTWF0ZXJpYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9iYXNlTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFzT3V0bGluZSgpIHtcbiAgICAgIHJldHVybiAhISh0aGlzLm91dGxpbmVXaWR0aCB8fCB0aGlzLm91dGxpbmVCbHVyIHx8IHRoaXMub3V0bGluZU9mZnNldFggfHwgdGhpcy5vdXRsaW5lT2Zmc2V0WSlcbiAgICB9XG5cbiAgICBnZXQgZ2x5cGhHZW9tZXRyeURldGFpbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmRldGFpbFxuICAgIH1cbiAgICBzZXQgZ2x5cGhHZW9tZXRyeURldGFpbChkZXRhaWwpIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuZGV0YWlsID0gZGV0YWlsO1xuICAgIH1cblxuICAgIGdldCBjdXJ2ZVJhZGl1cygpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmN1cnZlUmFkaXVzXG4gICAgfVxuICAgIHNldCBjdXJ2ZVJhZGl1cyhyKSB7XG4gICAgICB0aGlzLmdlb21ldHJ5LmN1cnZlUmFkaXVzID0gcjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYW5kIHVwZGF0ZSBtYXRlcmlhbCBmb3Igc2hhZG93cyB1cG9uIHJlcXVlc3Q6XG4gICAgZ2V0IGN1c3RvbURlcHRoTWF0ZXJpYWwoKSB7XG4gICAgICByZXR1cm4gZmlyc3QodGhpcy5tYXRlcmlhbCkuZ2V0RGVwdGhNYXRlcmlhbCgpXG4gICAgfVxuICAgIGdldCBjdXN0b21EaXN0YW5jZU1hdGVyaWFsKCkge1xuICAgICAgcmV0dXJuIGZpcnN0KHRoaXMubWF0ZXJpYWwpLmdldERpc3RhbmNlTWF0ZXJpYWwoKVxuICAgIH1cblxuICAgIF9wcmVwYXJlRm9yUmVuZGVyKG1hdGVyaWFsKSB7XG4gICAgICBjb25zdCBpc091dGxpbmUgPSBtYXRlcmlhbC5pc1RleHRPdXRsaW5lTWF0ZXJpYWw7XG4gICAgICBjb25zdCB1bmlmb3JtcyA9IG1hdGVyaWFsLnVuaWZvcm1zO1xuICAgICAgY29uc3QgdGV4dEluZm8gPSB0aGlzLnRleHRSZW5kZXJJbmZvO1xuICAgICAgaWYgKHRleHRJbmZvKSB7XG4gICAgICAgIGNvbnN0IHtzZGZUZXh0dXJlLCBibG9ja0JvdW5kc30gPSB0ZXh0SW5mbztcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYVNERlRleHR1cmUudmFsdWUgPSBzZGZUZXh0dXJlO1xuICAgICAgICB1bmlmb3Jtcy51VHJvaWthU0RGVGV4dHVyZVNpemUudmFsdWUuc2V0KHNkZlRleHR1cmUuaW1hZ2Uud2lkdGgsIHNkZlRleHR1cmUuaW1hZ2UuaGVpZ2h0KTtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYVNERkdseXBoU2l6ZS52YWx1ZSA9IHRleHRJbmZvLnNkZkdseXBoU2l6ZTtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYVNERkV4cG9uZW50LnZhbHVlID0gdGV4dEluZm8uc2RmRXhwb25lbnQ7XG4gICAgICAgIHVuaWZvcm1zLnVUcm9pa2FUb3RhbEJvdW5kcy52YWx1ZS5mcm9tQXJyYXkoYmxvY2tCb3VuZHMpO1xuICAgICAgICB1bmlmb3Jtcy51VHJvaWthVXNlR2x5cGhDb2xvcnMudmFsdWUgPSAhaXNPdXRsaW5lICYmICEhdGV4dEluZm8uZ2x5cGhDb2xvcnM7XG5cbiAgICAgICAgbGV0IGRpc3RhbmNlT2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IGJsdXJSYWRpdXMgPSAwO1xuICAgICAgICBsZXQgc3Ryb2tlV2lkdGggPSAwO1xuICAgICAgICBsZXQgZmlsbE9wYWNpdHk7XG4gICAgICAgIGxldCBzdHJva2VPcGFjaXR5O1xuICAgICAgICBsZXQgc3Ryb2tlQ29sb3I7XG4gICAgICAgIGxldCBvZmZzZXRYID0gMDtcbiAgICAgICAgbGV0IG9mZnNldFkgPSAwO1xuXG4gICAgICAgIGlmIChpc091dGxpbmUpIHtcbiAgICAgICAgICBsZXQge291dGxpbmVXaWR0aCwgb3V0bGluZU9mZnNldFgsIG91dGxpbmVPZmZzZXRZLCBvdXRsaW5lQmx1ciwgb3V0bGluZU9wYWNpdHl9ID0gdGhpcztcbiAgICAgICAgICBkaXN0YW5jZU9mZnNldCA9IHRoaXMuX3BhcnNlUGVyY2VudChvdXRsaW5lV2lkdGgpIHx8IDA7XG4gICAgICAgICAgYmx1clJhZGl1cyA9IE1hdGgubWF4KDAsIHRoaXMuX3BhcnNlUGVyY2VudChvdXRsaW5lQmx1cikgfHwgMCk7XG4gICAgICAgICAgZmlsbE9wYWNpdHkgPSBvdXRsaW5lT3BhY2l0eTtcbiAgICAgICAgICBvZmZzZXRYID0gdGhpcy5fcGFyc2VQZXJjZW50KG91dGxpbmVPZmZzZXRYKSB8fCAwO1xuICAgICAgICAgIG9mZnNldFkgPSB0aGlzLl9wYXJzZVBlcmNlbnQob3V0bGluZU9mZnNldFkpIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3Ryb2tlV2lkdGggPSBNYXRoLm1heCgwLCB0aGlzLl9wYXJzZVBlcmNlbnQodGhpcy5zdHJva2VXaWR0aCkgfHwgMCk7XG4gICAgICAgICAgaWYgKHN0cm9rZVdpZHRoKSB7XG4gICAgICAgICAgICBzdHJva2VDb2xvciA9IHRoaXMuc3Ryb2tlQ29sb3I7XG4gICAgICAgICAgICB1bmlmb3Jtcy51VHJvaWthU3Ryb2tlQ29sb3IudmFsdWUuc2V0KHN0cm9rZUNvbG9yID09IG51bGwgPyBkZWZhdWx0U3Ryb2tlQ29sb3IgOiBzdHJva2VDb2xvcik7XG4gICAgICAgICAgICBzdHJva2VPcGFjaXR5ID0gdGhpcy5zdHJva2VPcGFjaXR5O1xuICAgICAgICAgICAgaWYgKHN0cm9rZU9wYWNpdHkgPT0gbnVsbCkgc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbGxPcGFjaXR5ID0gdGhpcy5maWxsT3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVuaWZvcm1zLnVUcm9pa2FFZGdlT2Zmc2V0LnZhbHVlID0gZGlzdGFuY2VPZmZzZXQ7XG4gICAgICAgIHVuaWZvcm1zLnVUcm9pa2FQb3NpdGlvbk9mZnNldC52YWx1ZS5zZXQob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICAgIHVuaWZvcm1zLnVUcm9pa2FCbHVyUmFkaXVzLnZhbHVlID0gYmx1clJhZGl1cztcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYVN0cm9rZVdpZHRoLnZhbHVlID0gc3Ryb2tlV2lkdGg7XG4gICAgICAgIHVuaWZvcm1zLnVUcm9pa2FTdHJva2VPcGFjaXR5LnZhbHVlID0gc3Ryb2tlT3BhY2l0eTtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYUZpbGxPcGFjaXR5LnZhbHVlID0gZmlsbE9wYWNpdHkgPT0gbnVsbCA/IDEgOiBmaWxsT3BhY2l0eTtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYUN1cnZlUmFkaXVzLnZhbHVlID0gdGhpcy5jdXJ2ZVJhZGl1cyB8fCAwO1xuXG4gICAgICAgIGxldCBjbGlwUmVjdCA9IHRoaXMuY2xpcFJlY3Q7XG4gICAgICAgIGlmIChjbGlwUmVjdCAmJiBBcnJheS5pc0FycmF5KGNsaXBSZWN0KSAmJiBjbGlwUmVjdC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICB1bmlmb3Jtcy51VHJvaWthQ2xpcFJlY3QudmFsdWUuZnJvbUFycmF5KGNsaXBSZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBubyBjbGlwcGluZyAtIGNob29zZSBhIGZpbml0ZSByZWN0IHRoYXQgc2hvdWxkbid0IGV2ZXIgYmUgcmVhY2hlZCBieSBvdmVyZmxvd2luZyBnbHlwaHMgb3Igb3V0bGluZXNcbiAgICAgICAgICBjb25zdCBwYWQgPSAodGhpcy5mb250U2l6ZSB8fCAwLjEpICogMTAwO1xuICAgICAgICAgIHVuaWZvcm1zLnVUcm9pa2FDbGlwUmVjdC52YWx1ZS5zZXQoXG4gICAgICAgICAgICBibG9ja0JvdW5kc1swXSAtIHBhZCxcbiAgICAgICAgICAgIGJsb2NrQm91bmRzWzFdIC0gcGFkLFxuICAgICAgICAgICAgYmxvY2tCb3VuZHNbMl0gKyBwYWQsXG4gICAgICAgICAgICBibG9ja0JvdW5kc1szXSArIHBhZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZW9tZXRyeS5hcHBseUNsaXBSZWN0KHVuaWZvcm1zLnVUcm9pa2FDbGlwUmVjdC52YWx1ZSk7XG4gICAgICB9XG4gICAgICB1bmlmb3Jtcy51VHJvaWthU0RGRGVidWcudmFsdWUgPSAhIXRoaXMuZGVidWdTREY7XG4gICAgICBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0ID0gISF0aGlzLmRlcHRoT2Zmc2V0O1xuICAgICAgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciA9IG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyA9IHRoaXMuZGVwdGhPZmZzZXQgfHwgMDtcblxuICAgICAgLy8gU2hvcnRjdXQgZm9yIHNldHRpbmcgbWF0ZXJpYWwgY29sb3IgdmlhIGBjb2xvcmAgcHJvcCBvbiB0aGUgbWVzaDsgdGhpcyBpc1xuICAgICAgLy8gYXBwbGllZCBvbmx5IHRvIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHRvIGF2b2lkIG11dGF0aW5nIGEgc2hhcmVkIGJhc2UgbWF0ZXJpYWwuXG4gICAgICBjb25zdCBjb2xvciA9IGlzT3V0bGluZSA/ICh0aGlzLm91dGxpbmVDb2xvciB8fCAwKSA6IHRoaXMuY29sb3I7XG5cbiAgICAgIGlmIChjb2xvciA9PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBtYXRlcmlhbC5jb2xvcjsgLy9pbmhlcml0IGZyb20gYmFzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29sb3JPYmogPSBtYXRlcmlhbC5oYXNPd25Qcm9wZXJ0eSgnY29sb3InKSA/IG1hdGVyaWFsLmNvbG9yIDogKG1hdGVyaWFsLmNvbG9yID0gbmV3IHRocmVlLkNvbG9yKCkpO1xuICAgICAgICBpZiAoY29sb3IgIT09IGNvbG9yT2JqLl9pbnB1dCB8fCB0eXBlb2YgY29sb3IgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgY29sb3JPYmouc2V0KGNvbG9yT2JqLl9pbnB1dCA9IGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBiYXNlIG9yaWVudGF0aW9uXG4gICAgICBsZXQgb3JpZW50ID0gdGhpcy5vcmllbnRhdGlvbiB8fCBkZWZhdWx0T3JpZW50O1xuICAgICAgaWYgKG9yaWVudCAhPT0gbWF0ZXJpYWwuX29yaWVudGF0aW9uKSB7XG4gICAgICAgIGxldCByb3RNYXQgPSB1bmlmb3Jtcy51VHJvaWthT3JpZW50LnZhbHVlO1xuICAgICAgICBvcmllbnQgPSBvcmllbnQucmVwbGFjZSgvW14tK3h5el0vZywgJycpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBvcmllbnQgIT09IGRlZmF1bHRPcmllbnQgJiYgb3JpZW50Lm1hdGNoKC9eKFstK10pKFt4eXpdKShbLStdKShbeHl6XSkkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGxldCBbLCBoU2lnbiwgaEF4aXMsIHZTaWduLCB2QXhpc10gPSBtYXRjaDtcbiAgICAgICAgICB0ZW1wVmVjM2Euc2V0KDAsIDAsIDApW2hBeGlzXSA9IGhTaWduID09PSAnLScgPyAxIDogLTE7XG4gICAgICAgICAgdGVtcFZlYzNiLnNldCgwLCAwLCAwKVt2QXhpc10gPSB2U2lnbiA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgICAgIHRlbXBNYXQ0Lmxvb2tBdChvcmlnaW4sIHRlbXBWZWMzYS5jcm9zcyh0ZW1wVmVjM2IpLCB0ZW1wVmVjM2IpO1xuICAgICAgICAgIHJvdE1hdC5zZXRGcm9tTWF0cml4NCh0ZW1wTWF0NCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm90TWF0LmlkZW50aXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0ZXJpYWwuX29yaWVudGF0aW9uID0gb3JpZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIF9wYXJzZVBlcmNlbnQodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHZhbHVlLm1hdGNoKC9eKC0/W1xcZC5dKyklJC8pO1xuICAgICAgICBsZXQgcGN0ID0gbWF0Y2ggPyBwYXJzZUZsb2F0KG1hdGNoWzFdKSA6IE5hTjtcbiAgICAgICAgdmFsdWUgPSAoaXNOYU4ocGN0KSA/IDAgOiBwY3QgLyAxMDApICogdGhpcy5mb250U2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYW5zbGF0ZSBhIHBvaW50IGluIGxvY2FsIHNwYWNlIHRvIGFuIHgveSBpbiB0aGUgdGV4dCBwbGFuZS5cbiAgICAgKi9cbiAgICBsb2NhbFBvc2l0aW9uVG9UZXh0Q29vcmRzKHBvc2l0aW9uLCB0YXJnZXQgPSBuZXcgdGhyZWUuVmVjdG9yMigpKSB7XG4gICAgICB0YXJnZXQuY29weShwb3NpdGlvbik7IC8vc2ltcGxlIG5vbi1jdXJ2ZWQgY2FzZSBpcyAxOjFcbiAgICAgIGNvbnN0IHIgPSB0aGlzLmN1cnZlUmFkaXVzO1xuICAgICAgaWYgKHIpIHsgLy9mbGF0dGVuIHRoZSBjdXJ2ZVxuICAgICAgICB0YXJnZXQueCA9IE1hdGguYXRhbjIocG9zaXRpb24ueCwgTWF0aC5hYnMocikgLSBNYXRoLmFicyhwb3NpdGlvbi56KSkgKiBNYXRoLmFicyhyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGUgYSBwb2ludCBpbiB3b3JsZCBzcGFjZSB0byBhbiB4L3kgaW4gdGhlIHRleHQgcGxhbmUuXG4gICAgICovXG4gICAgd29ybGRQb3NpdGlvblRvVGV4dENvb3Jkcyhwb3NpdGlvbiwgdGFyZ2V0ID0gbmV3IHRocmVlLlZlY3RvcjIoKSkge1xuICAgICAgdGVtcFZlYzNhLmNvcHkocG9zaXRpb24pO1xuICAgICAgcmV0dXJuIHRoaXMubG9jYWxQb3NpdGlvblRvVGV4dENvb3Jkcyh0aGlzLndvcmxkVG9Mb2NhbCh0ZW1wVmVjM2EpLCB0YXJnZXQpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlIEN1c3RvbSByYXljYXN0aW5nIHRvIHRlc3QgYWdhaW5zdCB0aGUgd2hvbGUgdGV4dCBibG9jaydzIG1heCByZWN0YW5ndWxhciBib3VuZHNcbiAgICAgKiBUT0RPIGlzIHRoZXJlIGFueSByZWFzb24gdG8gbWFrZSB0aGlzIG1vcmUgZ3JhbnVsYXIsIGxpa2Ugd2l0aGluIGluZGl2aWR1YWwgbGluZSBvciBnbHlwaCByZWN0cz9cbiAgICAgKi9cbiAgICByYXljYXN0KHJheWNhc3RlciwgaW50ZXJzZWN0cykge1xuICAgICAgY29uc3Qge3RleHRSZW5kZXJJbmZvLCBjdXJ2ZVJhZGl1c30gPSB0aGlzO1xuICAgICAgaWYgKHRleHRSZW5kZXJJbmZvKSB7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IHRleHRSZW5kZXJJbmZvLmJsb2NrQm91bmRzO1xuICAgICAgICBjb25zdCByYXljYXN0TWVzaCA9IGN1cnZlUmFkaXVzID8gZ2V0Q3VydmVkUmF5Y2FzdE1lc2goKSA6IGdldEZsYXRSYXljYXN0TWVzaCgpO1xuICAgICAgICBjb25zdCBnZW9tID0gcmF5Y2FzdE1lc2guZ2VvbWV0cnk7XG4gICAgICAgIGNvbnN0IHtwb3NpdGlvbiwgdXZ9ID0gZ2VvbS5hdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHV2LmNvdW50OyBpKyspIHtcbiAgICAgICAgICBsZXQgeCA9IGJvdW5kc1swXSArICh1di5nZXRYKGkpICogKGJvdW5kc1syXSAtIGJvdW5kc1swXSkpO1xuICAgICAgICAgIGNvbnN0IHkgPSBib3VuZHNbMV0gKyAodXYuZ2V0WShpKSAqIChib3VuZHNbM10gLSBib3VuZHNbMV0pKTtcbiAgICAgICAgICBsZXQgeiA9IDA7XG4gICAgICAgICAgaWYgKGN1cnZlUmFkaXVzKSB7XG4gICAgICAgICAgICB6ID0gY3VydmVSYWRpdXMgLSBNYXRoLmNvcyh4IC8gY3VydmVSYWRpdXMpICogY3VydmVSYWRpdXM7XG4gICAgICAgICAgICB4ID0gTWF0aC5zaW4oeCAvIGN1cnZlUmFkaXVzKSAqIGN1cnZlUmFkaXVzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3NpdGlvbi5zZXRYWVooaSwgeCwgeSwgeik7XG4gICAgICAgIH1cbiAgICAgICAgZ2VvbS5ib3VuZGluZ1NwaGVyZSA9IHRoaXMuZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmU7XG4gICAgICAgIGdlb20uYm91bmRpbmdCb3ggPSB0aGlzLmdlb21ldHJ5LmJvdW5kaW5nQm94O1xuICAgICAgICByYXljYXN0TWVzaC5tYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG4gICAgICAgIHJheWNhc3RNZXNoLm1hdGVyaWFsLnNpZGUgPSB0aGlzLm1hdGVyaWFsLnNpZGU7XG4gICAgICAgIHRlbXBBcnJheS5sZW5ndGggPSAwO1xuICAgICAgICByYXljYXN0TWVzaC5yYXljYXN0KHJheWNhc3RlciwgdGVtcEFycmF5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0ZW1wQXJyYXlbaV0ub2JqZWN0ID0gdGhpcztcbiAgICAgICAgICBpbnRlcnNlY3RzLnB1c2godGVtcEFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvcHkoc291cmNlKSB7XG4gICAgICAvLyBQcmV2ZW50IGNvcHlpbmcgdGhlIGdlb21ldHJ5IHJlZmVyZW5jZSBzbyB3ZSBkb24ndCBlbmQgdXAgc2hhcmluZyBhdHRyaWJ1dGVzIGJldHdlZW4gaW5zdGFuY2VzXG4gICAgICBjb25zdCBnZW9tID0gdGhpcy5nZW9tZXRyeTtcbiAgICAgIHN1cGVyLmNvcHkoc291cmNlKTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tO1xuXG4gICAgICBDT1BZQUJMRV9QUk9QUy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICB0aGlzW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gQ3JlYXRlIHNldHRlcnMgZm9yIHByb3BlcnRpZXMgdGhhdCBhZmZlY3QgdGV4dCBsYXlvdXQ6XG4gIFNZTkNBQkxFX1BST1BTLmZvckVhY2gocHJvcCA9PiB7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9ICdfcHJpdmF0ZV8nICsgcHJvcDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4dC5wcm90b3R5cGUsIHByb3AsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbcHJpdmF0ZUtleV1cbiAgICAgIH0sXG4gICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzW3ByaXZhdGVLZXldKSB7XG4gICAgICAgICAgdGhpc1twcml2YXRlS2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMuX25lZWRzU3luYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgY29uc3Qgc3luY1N0YXJ0RXZlbnQkMSA9IHsgdHlwZTogXCJzeW5jc3RhcnRcIiB9O1xuICBjb25zdCBzeW5jQ29tcGxldGVFdmVudCQxID0geyB0eXBlOiBcInN5bmNjb21wbGV0ZVwiIH07XG4gIGNvbnN0IG1lbWJlckluZGV4QXR0ck5hbWUgPSBcImFUcm9pa2FUZXh0QmF0Y2hNZW1iZXJJbmRleFwiO1xuXG5cbiAgLypcbiAgRGF0YSB0ZXh0dXJlIHBhY2tpbmcgc3RyYXRlZ3k6XG5cbiAgIyBDb21tb246XG4gIDAtMTU6IG1hdHJpeFxuICAxNi0xOTogdVRyb2lrYVRvdGFsQm91bmRzXG4gIDIwLTIzOiB1VHJvaWthQ2xpcFJlY3RcbiAgMjQ6IGRpZmZ1c2UgKGNvbG9yL291dGxpbmVDb2xvcilcbiAgMjU6IHVUcm9pa2FGaWxsT3BhY2l0eSAoZmlsbE9wYWNpdHkvb3V0bGluZU9wYWNpdHkpXG4gIDI2OiB1VHJvaWthQ3VydmVSYWRpdXNcbiAgMjc6IDxibGFuaz5cblxuICAjIE1haW46XG4gIDI4OiB1VHJvaWthU3Ryb2tlV2lkdGhcbiAgMjk6IHVUcm9pa2FTdHJva2VDb2xvclxuICAzMDogdVRyb2lrYVN0cm9rZU9wYWNpdHlcblxuICAjIE91dGxpbmU6XG4gIDI4LTI5OiB1VHJvaWthUG9zaXRpb25PZmZzZXRcbiAgMzA6IHVUcm9pa2FFZGdlT2Zmc2V0XG4gIDMxOiB1VHJvaWthQmx1clJhZGl1c1xuICAqL1xuICBjb25zdCBmbG9hdHNQZXJNZW1iZXIgPSAzMjtcblxuICBjb25zdCB0ZW1wQm94MyA9IG5ldyB0aHJlZS5Cb3gzKCk7XG4gIGNvbnN0IHRlbXBDb2xvciQxID0gbmV3IHRocmVlLkNvbG9yKCk7XG5cbiAgLyoqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICpcbiAgICogQSBzcGVjaWFsaXplZCBgVGV4dGAgaW1wbGVtZW50YXRpb24gdGhhdCBhY2NlcHRzIGFueSBudW1iZXIgb2YgYFRleHRgIGNoaWxkcmVuXG4gICAqIGFuZCBhdXRvbWF0aWNhbGx5IGJhdGNoZXMgdGhlbSB0b2dldGhlciB0byByZW5kZXIgaW4gYSBzaW5nbGUgZHJhdyBjYWxsLlxuICAgKlxuICAgKiBUaGUgYG1hdGVyaWFsYCBvZiBlYWNoIGNoaWxkIGBUZXh0YCB3aWxsIGJlIGlnbm9yZWQsIGFuZCB0aGUgYG1hdGVyaWFsYCBvZiB0aGVcbiAgICogYEJhdGNoZWRUZXh0YCB3aWxsIGJlIHVzZWQgZm9yIGFsbCBvZiB0aGVtIGluc3RlYWQuXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgb25seSB3b3JrcyBpbiBXZWJHTDIgb3Igd2hlcmUgdGhlIE9FU190ZXh0dXJlX2Zsb2F0IGV4dGVuc2lvbiBpcyBhdmFpbGFibGUuXG4gICAqL1xuICBjbGFzcyBCYXRjaGVkVGV4dCBleHRlbmRzIFRleHQge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHN1cGVyKCk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGVkZWYge09iamVjdH0gUGFja2luZ0luZm9cbiAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbmRleCAtIHRoZSBwYWNraW5nIG9yZGVyIGluZGV4IHdoZW4gbGFzdCBwYWNrZWQsIG9yIC0xXG4gICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGRpcnR5IC0gd2hldGhlciBpdCBoYXMgc3luY2VkIHNpbmNlIGxhc3QgcGFja1xuICAgICAgICovXG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge01hcDxUZXh0LCBQYWNraW5nSW5mbz59XG4gICAgICAgKi9cbiAgICAgIHRoaXMuX21lbWJlcnMgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLl9kYXRhVGV4dHVyZXMgPSB7fTtcblxuICAgICAgdGhpcy5fb25NZW1iZXJTeW5jZWQgPSAoZSkgPT4ge1xuICAgICAgICB0aGlzLl9tZW1iZXJzLmdldChlLnRhcmdldCkuZGlydHkgPSB0cnVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBCYXRjaCBhbnkgVGV4dCBvYmplY3RzIGFkZGVkIGFzIGNoaWxkcmVuXG4gICAgICovXG4gICAgYWRkICguLi5vYmplY3RzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG9iamVjdHNbaV0gaW5zdGFuY2VvZiBUZXh0KSB7XG4gICAgICAgICAgdGhpcy5hZGRUZXh0KG9iamVjdHNbaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1cGVyLmFkZChvYmplY3RzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgcmVtb3ZlICguLi5vYmplY3RzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKG9iamVjdHNbaV0gaW5zdGFuY2VvZiBUZXh0KSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVUZXh0KG9iamVjdHNbaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1cGVyLnJlbW92ZShvYmplY3RzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUZXh0fSB0ZXh0XG4gICAgICovXG4gICAgYWRkVGV4dCAodGV4dCkge1xuICAgICAgaWYgKCF0aGlzLl9tZW1iZXJzLmhhcyh0ZXh0KSkge1xuICAgICAgICB0aGlzLl9tZW1iZXJzLnNldCh0ZXh0LCB7XG4gICAgICAgICAgaW5kZXg6IC0xLFxuICAgICAgICAgIGdseXBoQ291bnQ6IC0xLFxuICAgICAgICAgIGRpcnR5OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0ZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJzeW5jY29tcGxldGVcIiwgdGhpcy5fb25NZW1iZXJTeW5jZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICAgICAqL1xuICAgIHJlbW92ZVRleHQgKHRleHQpIHtcbiAgICAgIHRoaXMuX25lZWRzUmVwYWNrID0gdHJ1ZTtcbiAgICAgIHRleHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN5bmNjb21wbGV0ZVwiLCB0aGlzLl9vbk1lbWJlclN5bmNlZCk7XG4gICAgICB0aGlzLl9tZW1iZXJzLmRlbGV0ZSh0ZXh0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhlIGN1c3RvbSBkZXJpdmF0aW9uIHdpdGggZXh0cmEgYmF0Y2hpbmcgbG9naWNcbiAgICAgKi9cbiAgICBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwgKGJhc2VNYXRlcmlhbCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJhdGNoZWRUZXh0TWF0ZXJpYWwoYmFzZU1hdGVyaWFsKTtcbiAgICB9XG5cbiAgICB1cGRhdGVNYXRyaXhXb3JsZCAoZm9yY2UpIHtcbiAgICAgIHN1cGVyLnVwZGF0ZU1hdHJpeFdvcmxkKGZvcmNlKTtcbiAgICAgIHRoaXMudXBkYXRlQm91bmRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBiYXRjaGVkIGdlb21ldHJ5IGJvdW5kcyB0byBob2xkIGFsbCBtZW1iZXJzXG4gICAgICovXG4gICAgdXBkYXRlQm91bmRzICgpIHtcbiAgICAgIC8vIFVwZGF0ZSBtZW1iZXIgbG9jYWwgbWF0cmljZXMgYW5kIHRoZSBvdmVyYWxsIGJvdW5kc1xuICAgICAgY29uc3QgYmJveCA9IHRoaXMuZ2VvbWV0cnkuYm91bmRpbmdCb3gubWFrZUVtcHR5KCk7XG4gICAgICB0aGlzLl9tZW1iZXJzLmZvckVhY2goKF8sIHRleHQpID0+IHtcbiAgICAgICAgaWYgKHRleHQubWF0cml4QXV0b1VwZGF0ZSkgdGV4dC51cGRhdGVNYXRyaXgoKTsgLy8gaWdub3JlIHdvcmxkIG1hdHJpeFxuICAgICAgICB0ZW1wQm94My5jb3B5KHRleHQuZ2VvbWV0cnkuYm91bmRpbmdCb3gpLmFwcGx5TWF0cml4NCh0ZXh0Lm1hdHJpeCk7XG4gICAgICAgIGJib3gudW5pb24odGVtcEJveDMpO1xuICAgICAgfSk7XG4gICAgICBiYm94LmdldEJvdW5kaW5nU3BoZXJlKHRoaXMuZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUpO1xuICAgIH1cblxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBoYXNPdXRsaW5lKCkge1xuICAgICAgLy8gSXRlcmF0b3Iuc29tZSgpIG5vdCBzdXBwb3J0ZWQgaW4gU2FmYXJpXG4gICAgICBmb3IgKGxldCBtZW1iZXIgb2YgdGhpcy5fbWVtYmVycy5rZXlzKCkpIHtcbiAgICAgICAgaWYgKG1lbWJlci5oYXNPdXRsaW5lKCkpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIENvcHkgbWVtYmVyIG1hdHJpY2VzIGFuZCB1bmlmb3JtIHZhbHVlcyBpbnRvIHRoZSBkYXRhIHRleHR1cmVcbiAgICAgKi9cbiAgICBfcHJlcGFyZUZvclJlbmRlciAobWF0ZXJpYWwpIHtcbiAgICAgIGNvbnN0IGlzT3V0bGluZSA9IG1hdGVyaWFsLmlzVGV4dE91dGxpbmVNYXRlcmlhbDtcbiAgICAgIG1hdGVyaWFsLnVuaWZvcm1zLnVUcm9pa2FJc091dGxpbmUudmFsdWUgPSBpc091dGxpbmU7XG5cbiAgICAgIC8vIFJlc2l6ZSB0aGUgdGV4dHVyZSB0byBmaXQgaW4gcG93ZXJzIG9mIDJcbiAgICAgIGxldCB0ZXh0dXJlID0gdGhpcy5fZGF0YVRleHR1cmVzW2lzT3V0bGluZSA/ICdvdXRsaW5lJyA6ICdtYWluJ107XG4gICAgICBjb25zdCBkYXRhTGVuZ3RoID0gTWF0aC5wb3coMiwgTWF0aC5jZWlsKE1hdGgubG9nMih0aGlzLl9tZW1iZXJzLnNpemUgKiBmbG9hdHNQZXJNZW1iZXIpKSk7XG4gICAgICBpZiAoIXRleHR1cmUgfHwgZGF0YUxlbmd0aCAhPT0gdGV4dHVyZS5pbWFnZS5kYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhgcmVzaXppbmc6ICR7ZGF0YUxlbmd0aH1gKTtcbiAgICAgICAgaWYgKHRleHR1cmUpIHRleHR1cmUuZGlzcG9zZSgpO1xuICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGgubWluKGRhdGFMZW5ndGggLyA0LCAxMDI0KTtcbiAgICAgICAgdGV4dHVyZSA9IHRoaXMuX2RhdGFUZXh0dXJlc1tpc091dGxpbmUgPyAnb3V0bGluZScgOiAnbWFpbiddID0gbmV3IHRocmVlLkRhdGFUZXh0dXJlKFxuICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoZGF0YUxlbmd0aCksXG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgZGF0YUxlbmd0aCAvIDQgLyB3aWR0aCxcbiAgICAgICAgICB0aHJlZS5SR0JBRm9ybWF0LFxuICAgICAgICAgIHRocmVlLkZsb2F0VHlwZVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0ZXhEYXRhID0gdGV4dHVyZS5pbWFnZS5kYXRhO1xuICAgICAgY29uc3Qgc2V0VGV4RGF0YSA9IChpbmRleCwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0ZXhEYXRhW2luZGV4XSkge1xuICAgICAgICAgIHRleERhdGFbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLl9tZW1iZXJzLmZvckVhY2goKHsgaW5kZXgsIGRpcnR5IH0sIHRleHQpID0+IHtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gaW5kZXggKiBmbG9hdHNQZXJNZW1iZXI7XG5cbiAgICAgICAgICAvLyBNYXRyaXhcbiAgICAgICAgICBjb25zdCBtYXRyaXggPSB0ZXh0Lm1hdHJpeC5lbGVtZW50cztcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgIHNldFRleERhdGEoc3RhcnRJbmRleCArIGksIG1hdHJpeFtpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTGV0IHRoZSBtZW1iZXIgcG9wdWxhdGUgdGhlIHVuaWZvcm1zLCBzaW5jZSB0aGF0IGRvZXMgYWxsIHRoZSBhcHByb3ByaWF0ZVxuICAgICAgICAgIC8vIGxvZ2ljIGFuZCBoYW5kbGluZyBvZiBkZWZhdWx0cywgYW5kIHdlJ2xsIGp1c3QgZ3JhYiB0aGUgcmVzdWx0cyBmcm9tIHRoZXJlXG4gICAgICAgICAgdGV4dC5fcHJlcGFyZUZvclJlbmRlcihtYXRlcmlhbCk7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdVRyb2lrYVRvdGFsQm91bmRzLFxuICAgICAgICAgICAgdVRyb2lrYUNsaXBSZWN0LFxuICAgICAgICAgICAgdVRyb2lrYVBvc2l0aW9uT2Zmc2V0LFxuICAgICAgICAgICAgdVRyb2lrYUVkZ2VPZmZzZXQsXG4gICAgICAgICAgICB1VHJvaWthQmx1clJhZGl1cyxcbiAgICAgICAgICAgIHVUcm9pa2FTdHJva2VXaWR0aCxcbiAgICAgICAgICAgIHVUcm9pa2FTdHJva2VDb2xvcixcbiAgICAgICAgICAgIHVUcm9pa2FTdHJva2VPcGFjaXR5LFxuICAgICAgICAgICAgdVRyb2lrYUZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgdVRyb2lrYUN1cnZlUmFkaXVzLFxuICAgICAgICAgIH0gPSBtYXRlcmlhbC51bmlmb3JtcztcblxuICAgICAgICAgIC8vIFRvdGFsIGJvdW5kcyBmb3IgdXZcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgc2V0VGV4RGF0YShzdGFydEluZGV4ICsgMTYgKyBpLCB1VHJvaWthVG90YWxCb3VuZHMudmFsdWUuZ2V0Q29tcG9uZW50KGkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDbGlwIHJlY3RcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgc2V0VGV4RGF0YShzdGFydEluZGV4ICsgMjAgKyBpLCB1VHJvaWthQ2xpcFJlY3QudmFsdWUuZ2V0Q29tcG9uZW50KGkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb2xvclxuICAgICAgICAgIGxldCBjb2xvciA9IGlzT3V0bGluZSA/ICh0ZXh0Lm91dGxpbmVDb2xvciB8fCAwKSA6IHRleHQuY29sb3I7XG4gICAgICAgICAgaWYgKGNvbG9yID09IG51bGwpIGNvbG9yID0gdGhpcy5jb2xvcjtcbiAgICAgICAgICBpZiAoY29sb3IgPT0gbnVsbCkgY29sb3IgPSB0aGlzLm1hdGVyaWFsLmNvbG9yO1xuICAgICAgICAgIGlmIChjb2xvciA9PSBudWxsKSBjb2xvciA9IDB4ZmZmZmZmO1xuICAgICAgICAgIHNldFRleERhdGEoc3RhcnRJbmRleCArIDI0LCB0ZW1wQ29sb3IkMS5zZXQoY29sb3IpLmdldEhleCgpKTtcblxuICAgICAgICAgIC8vIEZpbGwgb3BhY2l0eSAvIG91dGxpbmUgb3BhY2l0eVxuICAgICAgICAgIHNldFRleERhdGEoc3RhcnRJbmRleCArIDI1LCB1VHJvaWthRmlsbE9wYWNpdHkudmFsdWUpO1xuXG4gICAgICAgICAgLy8gQ3VydmUgcmFkaXVzXG4gICAgICAgICAgc2V0VGV4RGF0YShzdGFydEluZGV4ICsgMjYsIHVUcm9pa2FDdXJ2ZVJhZGl1cy52YWx1ZSk7XG5cbiAgICAgICAgICBpZiAoaXNPdXRsaW5lKSB7XG4gICAgICAgICAgICAvLyBPdXRsaW5lIHByb3BlcnRpZXNcbiAgICAgICAgICAgIHNldFRleERhdGEoc3RhcnRJbmRleCArIDI4LCB1VHJvaWthUG9zaXRpb25PZmZzZXQudmFsdWUueCk7XG4gICAgICAgICAgICBzZXRUZXhEYXRhKHN0YXJ0SW5kZXggKyAyOSwgdVRyb2lrYVBvc2l0aW9uT2Zmc2V0LnZhbHVlLnkpO1xuICAgICAgICAgICAgc2V0VGV4RGF0YShzdGFydEluZGV4ICsgMzAsIHVUcm9pa2FFZGdlT2Zmc2V0LnZhbHVlKTtcbiAgICAgICAgICAgIHNldFRleERhdGEoc3RhcnRJbmRleCArIDMxLCB1VHJvaWthQmx1clJhZGl1cy52YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFN0cm9rZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBzZXRUZXhEYXRhKHN0YXJ0SW5kZXggKyAyOCwgdVRyb2lrYVN0cm9rZVdpZHRoLnZhbHVlKTtcbiAgICAgICAgICAgIHNldFRleERhdGEoc3RhcnRJbmRleCArIDI5LCB0ZW1wQ29sb3IkMS5zZXQodVRyb2lrYVN0cm9rZUNvbG9yLnZhbHVlKS5nZXRIZXgoKSk7XG4gICAgICAgICAgICBzZXRUZXhEYXRhKHN0YXJ0SW5kZXggKyAzMCwgdVRyb2lrYVN0cm9rZU9wYWNpdHkudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBtYXRlcmlhbC5zZXRNYXRyaXhUZXh0dXJlKHRleHR1cmUpO1xuXG4gICAgICAvLyBGb3IgdGhlIG5vbi1tZW1iZXItc3BlY2lmaWMgdW5pZm9ybXM6XG4gICAgICBzdXBlci5fcHJlcGFyZUZvclJlbmRlcihtYXRlcmlhbCk7XG4gICAgfVxuXG4gICAgc3luYyAoY2FsbGJhY2spIHtcbiAgICAgIC8vIFRPRE86IHNraXAgbWVtYmVycyB1cGRhdGluZyB0aGVpciBnZW9tZXRyaWVzLCBqdXN0IHVzZSB0ZXh0UmVuZGVySW5mbyBkaXJlY3RseVxuXG4gICAgICAvLyBUcmlnZ2VyIHN5bmMgb24gYWxsIG1lbWJlcnMgdGhhdCBuZWVkIGl0XG4gICAgICBsZXQgc3luY1Byb21pc2VzID0gdGhpcy5fbmVlZHNSZXBhY2sgPyBbXSA6IG51bGw7XG4gICAgICB0aGlzLl9uZWVkc1JlcGFjayA9IGZhbHNlO1xuICAgICAgdGhpcy5fbWVtYmVycy5mb3JFYWNoKChwYWNraW5nSW5mbywgdGV4dCkgPT4ge1xuICAgICAgICBpZiAocGFja2luZ0luZm8uZGlydHkgfHwgdGV4dC5fbmVlZHNTeW5jKSB7XG4gICAgICAgICAgcGFja2luZ0luZm8uZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAoc3luY1Byb21pc2VzIHx8IChzeW5jUHJvbWlzZXMgPSBbXSkpLnB1c2gobmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBpZiAodGV4dC5fbmVlZHNTeW5jKSB7XG4gICAgICAgICAgICAgIHRleHQuc3luYyhyZXNvbHZlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBJZiBhbnkgbmVlZGVkIHN5bmNpbmcsIHdhaXQgZm9yIHRoZW0gYW5kIHRoZW4gcmVwYWNrIHRoZSBiYXRjaGVkIGdlb21ldHJ5XG4gICAgICBpZiAoc3luY1Byb21pc2VzKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChzeW5jU3RhcnRFdmVudCQxKTtcblxuICAgICAgICBQcm9taXNlLmFsbChzeW5jUHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZ2VvbWV0cnkgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3QgYmF0Y2hlZEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuICAgICAgICAgIGxldCBtZW1iZXJJbmRleGVzID0gYmF0Y2hlZEF0dHJpYnV0ZXNbbWVtYmVySW5kZXhBdHRyTmFtZV0gJiYgYmF0Y2hlZEF0dHJpYnV0ZXNbbWVtYmVySW5kZXhBdHRyTmFtZV0uYXJyYXkgfHwgbmV3IFVpbnQxNkFycmF5KDApO1xuICAgICAgICAgIGxldCBiYXRjaGVkR2x5cGhJbmRleGVzID0gYmF0Y2hlZEF0dHJpYnV0ZXNbZ2x5cGhJbmRleEF0dHJOYW1lXSAmJiBiYXRjaGVkQXR0cmlidXRlc1tnbHlwaEluZGV4QXR0ck5hbWVdLmFycmF5IHx8IG5ldyBGbG9hdDMyQXJyYXkoMCk7XG4gICAgICAgICAgbGV0IGJhdGNoZWRHbHlwaEJvdW5kcyA9IGJhdGNoZWRBdHRyaWJ1dGVzW2dseXBoQm91bmRzQXR0ck5hbWVdICYmIGJhdGNoZWRBdHRyaWJ1dGVzW2dseXBoQm91bmRzQXR0ck5hbWVdLmFycmF5IHx8IG5ldyBGbG9hdDMyQXJyYXkoMCk7XG5cbiAgICAgICAgICAvLyBJbml0aWFsIHBhc3MgdG8gY29sbGVjdCB0b3RhbCBnbHlwaCBjb3VudCBhbmQgcmVzaXplIHRoZSBhcnJheXMgaWYgbmVlZGVkXG4gICAgICAgICAgbGV0IHRvdGFsR2x5cGhDb3VudCA9IDA7XG4gICAgICAgICAgdGhpcy5fbWVtYmVycy5mb3JFYWNoKChwYWNraW5nSW5mbywgeyB0ZXh0UmVuZGVySW5mbyB9KSA9PiB7XG4gICAgICAgICAgICBpZiAodGV4dFJlbmRlckluZm8pIHtcbiAgICAgICAgICAgICAgdG90YWxHbHlwaENvdW50ICs9IHRleHRSZW5kZXJJbmZvLmdseXBoQXRsYXNJbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgdGhpcy5fdGV4dFJlbmRlckluZm8gPSB0ZXh0UmVuZGVySW5mbzsgLy8gVE9ETyAtIG5lZWQgdGhpcywgYnV0IGJlIHNtYXJ0ZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodG90YWxHbHlwaENvdW50ICE9PSBtZW1iZXJJbmRleGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbWVtYmVySW5kZXhlcyA9IGNsb25lQW5kUmVzaXplKG1lbWJlckluZGV4ZXMsIHRvdGFsR2x5cGhDb3VudCk7XG4gICAgICAgICAgICBiYXRjaGVkR2x5cGhJbmRleGVzID0gY2xvbmVBbmRSZXNpemUoYmF0Y2hlZEdseXBoSW5kZXhlcywgdG90YWxHbHlwaENvdW50KTtcbiAgICAgICAgICAgIGJhdGNoZWRHbHlwaEJvdW5kcyA9IGNsb25lQW5kUmVzaXplKGJhdGNoZWRHbHlwaEJvdW5kcywgdG90YWxHbHlwaENvdW50ICogNCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUG9wdWxhdGUgYmF0Y2ggYXJyYXlzXG4gICAgICAgICAgbGV0IG1lbWJlckluZGV4ID0gMDtcbiAgICAgICAgICBsZXQgZ2x5cGhJbmRleCA9IDA7XG4gICAgICAgICAgdGhpcy5fbWVtYmVycy5mb3JFYWNoKChwYWNraW5nSW5mbywgeyB0ZXh0UmVuZGVySW5mbyB9KSA9PiB7XG4gICAgICAgICAgICBpZiAodGV4dFJlbmRlckluZm8pIHtcbiAgICAgICAgICAgICAgY29uc3QgZ2x5cGhDb3VudCA9IHRleHRSZW5kZXJJbmZvLmdseXBoQXRsYXNJbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgbWVtYmVySW5kZXhlcy5maWxsKG1lbWJlckluZGV4LCBnbHlwaEluZGV4LCBnbHlwaEluZGV4ICsgZ2x5cGhDb3VudCk7XG5cbiAgICAgICAgICAgICAgLy8gVE9ETyBjYW4gc2tpcCB0aGVzZSBmb3IgbWVtYmVycyB0aGF0IGFyZSBub3QgZGlydHkgb3Igc2hpZnRpbmcgb3ZlcmFsbCBwb3NpdGlvbjpcbiAgICAgICAgICAgICAgYmF0Y2hlZEdseXBoSW5kZXhlcy5zZXQodGV4dFJlbmRlckluZm8uZ2x5cGhBdGxhc0luZGljZXMsIGdseXBoSW5kZXgsIGdseXBoSW5kZXggKyBnbHlwaENvdW50KTtcbiAgICAgICAgICAgICAgYmF0Y2hlZEdseXBoQm91bmRzLnNldCh0ZXh0UmVuZGVySW5mby5nbHlwaEJvdW5kcywgZ2x5cGhJbmRleCAqIDQsIChnbHlwaEluZGV4ICsgZ2x5cGhDb3VudCkgKiA0KTtcblxuICAgICAgICAgICAgICBnbHlwaEluZGV4ICs9IGdseXBoQ291bnQ7XG4gICAgICAgICAgICAgIHBhY2tpbmdJbmZvLmluZGV4ID0gbWVtYmVySW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZ2VvbWV0cnkgYXR0cmlidXRlc1xuICAgICAgICAgIGdlb21ldHJ5LnVwZGF0ZUF0dHJpYnV0ZURhdGEobWVtYmVySW5kZXhBdHRyTmFtZSwgbWVtYmVySW5kZXhlcywgMSk7XG4gICAgICAgICAgZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG1lbWJlckluZGV4QXR0ck5hbWUpLnNldFVzYWdlKHRocmVlLkR5bmFtaWNEcmF3VXNhZ2UpO1xuICAgICAgICAgIGdlb21ldHJ5LnVwZGF0ZUF0dHJpYnV0ZURhdGEoZ2x5cGhJbmRleEF0dHJOYW1lLCBiYXRjaGVkR2x5cGhJbmRleGVzLCAxKTtcbiAgICAgICAgICBnZW9tZXRyeS51cGRhdGVBdHRyaWJ1dGVEYXRhKGdseXBoQm91bmRzQXR0ck5hbWUsIGJhdGNoZWRHbHlwaEJvdW5kcywgNCk7XG5cbiAgICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kcygpO1xuXG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHN5bmNDb21wbGV0ZUV2ZW50JDEpO1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvcHkgKHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEJhdGNoZWRUZXh0KSB7XG4gICAgICAgIHN1cGVyLmNvcHkoc291cmNlKTtcbiAgICAgICAgdGhpcy5fbWVtYmVycy5mb3JFYWNoKChfLCB0ZXh0KSA9PiB0aGlzLnJlbW92ZVRleHQodGV4dCkpO1xuICAgICAgICBzb3VyY2UuX21lbWJlcnMuZm9yRWFjaCgoXywgdGV4dCkgPT4gdGhpcy5hZGRUZXh0KHRleHQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGRpc3Bvc2UgKCkge1xuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLl9kYXRhVGV4dHVyZXMpLmZvckVhY2godGV4ID0+IHRleC5kaXNwb3NlKCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lQW5kUmVzaXplIChzb3VyY2UsIG5ld0xlbmd0aCkge1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgc291cmNlLmNvbnN0cnVjdG9yKG5ld0xlbmd0aCk7XG4gICAgY29weS5zZXQoc291cmNlLnN1YmFycmF5KDAsIG5ld0xlbmd0aCkpO1xuICAgIHJldHVybiBjb3B5O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQmF0Y2hlZFRleHRNYXRlcmlhbCAoYmFzZU1hdGVyaWFsKSB7XG4gICAgY29uc3QgdGV4VW5pZm9ybU5hbWUgPSBcInVUcm9pa2FNYXRyaWNlc1RleHR1cmVcIjtcbiAgICBjb25zdCB0ZXhTaXplVW5pZm9ybU5hbWUgPSBcInVUcm9pa2FNYXRyaWNlc1RleHR1cmVTaXplXCI7XG5cbiAgICAvLyBEdWUgdG8gaG93IHZlcnRleFRyYW5zZm9ybSBnZXRzIGluamVjdGVkLCB0aGUgbWF0cml4IHRyYW5zZm9ybXMgbXVzdCBoYXBwZW5cbiAgICAvLyBpbiB0aGUgYmFzZSBtYXRlcmlhbCBvZiBUZXh0RGVyaXZlZE1hdGVyaWFsLCBidXQgb3RoZXIgdHJhbnNmb3JtcyB0byBpdHNcbiAgICAvLyBzaGFkZXIgbXVzdCBjb21lIGFmdGVyLCBzbyB3ZSBzYW5kd2ljaCBpdCBiZXR3ZWVuIHR3byBkZXJpdmF0aW9ucy5cblxuICAgIC8vIFRyYW5zZm9ybSB0aGUgdmVydGV4IHBvc2l0aW9uXG4gICAgbGV0IGJhdGNoTWF0ZXJpYWwgPSB0cm9pa2FUaHJlZVV0aWxzLmNyZWF0ZURlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwsIHtcbiAgICAgIGNoYWluZWQ6IHRydWUsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBbdGV4U2l6ZVVuaWZvcm1OYW1lXTogeyB2YWx1ZTogbmV3IHRocmVlLlZlY3RvcjIoKSB9LFxuICAgICAgICBbdGV4VW5pZm9ybU5hbWVdOiB7IHZhbHVlOiBudWxsIH1cbiAgICAgIH0sXG4gICAgICAvLyBsYW5ndWFnZT1HTFNMXG4gICAgICB2ZXJ0ZXhEZWZzOiBgXG4gICAgICB1bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCAke3RleFVuaWZvcm1OYW1lfTtcbiAgICAgIHVuaWZvcm0gdmVjMiAke3RleFNpemVVbmlmb3JtTmFtZX07XG4gICAgICBhdHRyaWJ1dGUgZmxvYXQgJHttZW1iZXJJbmRleEF0dHJOYW1lfTtcblxuICAgICAgdmVjNCB0cm9pa2FCYXRjaFRleGVsKGZsb2F0IG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgKz0gJHttZW1iZXJJbmRleEF0dHJOYW1lfSAqICR7ZmxvYXRzUGVyTWVtYmVyLnRvRml4ZWQoMSl9IC8gNC4wO1xuICAgICAgICBmbG9hdCB3ID0gJHt0ZXhTaXplVW5pZm9ybU5hbWV9Lng7XG4gICAgICAgIHZlYzIgdXYgPSAodmVjMihtb2Qob2Zmc2V0LCB3KSwgZmxvb3Iob2Zmc2V0IC8gdykpICsgMC41KSAvICR7dGV4U2l6ZVVuaWZvcm1OYW1lfTtcbiAgICAgICAgcmV0dXJuIHRleHR1cmUyRCgke3RleFVuaWZvcm1OYW1lfSwgdXYpO1xuICAgICAgfVxuICAgIGAsXG4gICAgICAvLyBsYW5ndWFnZT1HTFNMIHByZWZpeD1cInZvaWQgbWFpbigpIHtcIiBzdWZmaXg9XCJ9XCJcbiAgICAgIHZlcnRleFRyYW5zZm9ybTogYFxuICAgICAgbWF0NCBtYXRyaXggPSBtYXQ0KFxuICAgICAgICB0cm9pa2FCYXRjaFRleGVsKDAuMCksXG4gICAgICAgIHRyb2lrYUJhdGNoVGV4ZWwoMS4wKSxcbiAgICAgICAgdHJvaWthQmF0Y2hUZXhlbCgyLjApLFxuICAgICAgICB0cm9pa2FCYXRjaFRleGVsKDMuMClcbiAgICAgICk7XG4gICAgICBwb3NpdGlvbi54eXogPSAobWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKSkueHl6O1xuICAgIGAsXG4gICAgfSk7XG5cbiAgICAvLyBBZGQgdGhlIHRleHQgc2hhZGVyc1xuICAgIGJhdGNoTWF0ZXJpYWwgPSBjcmVhdGVUZXh0RGVyaXZlZE1hdGVyaWFsKGJhdGNoTWF0ZXJpYWwpO1xuXG4gICAgLy8gTm93IG1ha2Ugb3RoZXIgY2hhbmdlcyB0byB0aGUgZGVyaXZlZCB0ZXh0IHNoYWRlciBjb2RlXG4gICAgYmF0Y2hNYXRlcmlhbCA9IHRyb2lrYVRocmVlVXRpbHMuY3JlYXRlRGVyaXZlZE1hdGVyaWFsKGJhdGNoTWF0ZXJpYWwsIHtcbiAgICAgIGNoYWluZWQ6IHRydWUsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICB1VHJvaWthSXNPdXRsaW5lOiB7dmFsdWU6IGZhbHNlfSxcbiAgICAgIH0sXG4gICAgICBjdXN0b21SZXdyaXRlcihzaGFkZXJzKSB7XG4gICAgICAgIC8vIENvbnZlcnQgc29tZSB0ZXh0IHNoYWRlciB1bmlmb3JtcyB0byB2YXJ5aW5nc1xuICAgICAgICBjb25zdCB2YXJ5aW5nVW5pZm9ybXMgPSBbXG4gICAgICAgICAgJ3VUcm9pa2FUb3RhbEJvdW5kcycsXG4gICAgICAgICAgJ3VUcm9pa2FDbGlwUmVjdCcsXG4gICAgICAgICAgJ3VUcm9pa2FQb3NpdGlvbk9mZnNldCcsXG4gICAgICAgICAgJ3VUcm9pa2FFZGdlT2Zmc2V0JyxcbiAgICAgICAgICAndVRyb2lrYUJsdXJSYWRpdXMnLFxuICAgICAgICAgICd1VHJvaWthU3Ryb2tlV2lkdGgnLFxuICAgICAgICAgICd1VHJvaWthU3Ryb2tlQ29sb3InLFxuICAgICAgICAgICd1VHJvaWthU3Ryb2tlT3BhY2l0eScsXG4gICAgICAgICAgJ3VUcm9pa2FGaWxsT3BhY2l0eScsXG4gICAgICAgICAgJ3VUcm9pa2FDdXJ2ZVJhZGl1cycsXG4gICAgICAgICAgJ2RpZmZ1c2UnXG4gICAgICAgIF07XG4gICAgICAgIHZhcnlpbmdVbmlmb3Jtcy5mb3JFYWNoKHVuaWZvcm1OYW1lID0+IHtcbiAgICAgICAgICBzaGFkZXJzID0gdW5pZm9ybVRvVmFyeWluZyhzaGFkZXJzLCB1bmlmb3JtTmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2hhZGVyc1xuICAgICAgfSxcbiAgICAgIC8vIGxhbmd1YWdlPUdMU0xcbiAgICAgIHZlcnRleERlZnM6IGBcbiAgICAgIHVuaWZvcm0gYm9vbCB1VHJvaWthSXNPdXRsaW5lO1xuICAgICAgdmVjMyB0cm9pa2FGbG9hdFRvQ29sb3IoZmxvYXQgdikge1xuICAgICAgICByZXR1cm4gbW9kKGZsb29yKHZlYzModiAvIDY1NTM2LjAsIHYgLyAyNTYuMCwgdikpLCAyNTYuMCkgLyAyNTYuMDtcbiAgICAgIH1cbiAgICBgLFxuICAgICAgLy8gbGFuZ3VhZ2U9R0xTTCBwcmVmaXg9XCJ2b2lkIG1haW4oKSB7XCIgc3VmZml4PVwifVwiXG4gICAgICB2ZXJ0ZXhUcmFuc2Zvcm06IGBcbiAgICAgIHVUcm9pa2FUb3RhbEJvdW5kcyA9IHRyb2lrYUJhdGNoVGV4ZWwoNC4wKTtcbiAgICAgIHVUcm9pa2FDbGlwUmVjdCA9IHRyb2lrYUJhdGNoVGV4ZWwoNS4wKTtcbiAgICAgIFxuICAgICAgdmVjNCBkYXRhID0gdHJvaWthQmF0Y2hUZXhlbCg2LjApO1xuICAgICAgZGlmZnVzZSA9IHRyb2lrYUZsb2F0VG9Db2xvcihkYXRhLngpO1xuICAgICAgdVRyb2lrYUZpbGxPcGFjaXR5ID0gZGF0YS55O1xuICAgICAgdVRyb2lrYUN1cnZlUmFkaXVzID0gZGF0YS56O1xuICAgICAgXG4gICAgICBkYXRhID0gdHJvaWthQmF0Y2hUZXhlbCg3LjApO1xuICAgICAgaWYgKHVUcm9pa2FJc091dGxpbmUpIHtcbiAgICAgICAgaWYgKGRhdGEgPT0gdmVjNCgwLjApKSB7IC8vIGRlZ2VuZXJhdGUgaWYgemVybyBvdXRsaW5lXG4gICAgICAgICAgcG9zaXRpb24gPSB2ZWMzKDAuMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdVRyb2lrYVBvc2l0aW9uT2Zmc2V0ID0gZGF0YS54eTtcbiAgICAgICAgICB1VHJvaWthRWRnZU9mZnNldCA9IGRhdGEuejtcbiAgICAgICAgICB1VHJvaWthQmx1clJhZGl1cyA9IGRhdGEudztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdVRyb2lrYVN0cm9rZVdpZHRoID0gZGF0YS54O1xuICAgICAgICB1VHJvaWthU3Ryb2tlQ29sb3IgPSB0cm9pa2FGbG9hdFRvQ29sb3IoZGF0YS55KTtcbiAgICAgICAgdVRyb2lrYVN0cm9rZU9wYWNpdHkgPSBkYXRhLno7XG4gICAgICB9XG4gICAgYCxcbiAgICB9KTtcblxuICAgIGJhdGNoTWF0ZXJpYWwuc2V0TWF0cml4VGV4dHVyZSA9ICh0ZXh0dXJlKSA9PiB7XG4gICAgICBiYXRjaE1hdGVyaWFsLnVuaWZvcm1zW3RleFVuaWZvcm1OYW1lXS52YWx1ZSA9IHRleHR1cmU7XG4gICAgICBiYXRjaE1hdGVyaWFsLnVuaWZvcm1zW3RleFNpemVVbmlmb3JtTmFtZV0udmFsdWUuc2V0KHRleHR1cmUuaW1hZ2Uud2lkdGgsIHRleHR1cmUuaW1hZ2UuaGVpZ2h0KTtcbiAgICB9O1xuICAgIHJldHVybiBiYXRjaE1hdGVyaWFsO1xuICB9XG5cbiAgLyoqXG4gICAqIFR1cm4gYSB1bmlmb3JtIGludG8gYSB2YXJ5aW5nL3dyaXRlYWJsZSB2YWx1ZS5cbiAgICogLSBJZiB0aGUgdW5pZm9ybSB3YXMgdXNlZCBpbiB0aGUgZnJhZ21lbnQgc2hhZGVyLCBpdCB3aWxsIGJlY29tZSBhIHZhcnlpbmcgaW4gYm90aCBzaGFkZXJzLlxuICAgKiAtIElmIHRoZSB1bmlmb3JtIHdhcyBvbmx5IHVzZWQgaW4gdGhlIHZlcnRleCBzaGFkZXIsIGl0IHdpbGwgYmVjb21lIGEgd3JpdGVhYmxlIHZhci5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWZvcm1Ub1Zhcnlpbmcoe3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJ9LCB1bmlmb3JtTmFtZSwgdmFyeWluZ05hbWUgPSB1bmlmb3JtTmFtZSkge1xuICAgIGNvbnN0IHVuaWZvcm1SRSA9IG5ldyBSZWdFeHAoYHVuaWZvcm1cXFxccysoYm9vbHxmbG9hdHx2ZWNbMjM0XXxtYXRbMzRdKVxcXFxzKyR7dW5pZm9ybU5hbWV9XFxcXGJgKTtcblxuICAgIGxldCB0eXBlO1xuICAgIGxldCBoYWRGcmFnbWVudFVuaWZvcm0gPSBmYWxzZTtcbiAgICBmcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyLnJlcGxhY2UodW5pZm9ybVJFLCAoJDAsICQxKSA9PiB7XG4gICAgICBoYWRGcmFnbWVudFVuaWZvcm0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGB2YXJ5aW5nICR7dHlwZSA9ICQxfSAke3ZhcnlpbmdOYW1lfWBcbiAgICB9KTtcblxuICAgIGxldCBoYWRWZXJ0ZXhVbmlmb3JtID0gZmFsc2U7XG4gICAgdmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyLnJlcGxhY2UodW5pZm9ybVJFLCAoXywgJDEpID0+IHtcbiAgICAgIGhhZFZlcnRleFVuaWZvcm0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGAke2hhZEZyYWdtZW50VW5pZm9ybSA/ICd2YXJ5aW5nJyA6ICcnfSAke3R5cGUgPSAkMX0gJHt2YXJ5aW5nTmFtZX1gXG4gICAgfSk7XG4gICAgaWYgKCFoYWRWZXJ0ZXhVbmlmb3JtKSB7XG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBgJHtoYWRGcmFnbWVudFVuaWZvcm0gPyAndmFyeWluZycgOiAnJ30gJHt0eXBlfSAke3ZhcnlpbmdOYW1lfTtcXG4ke3ZlcnRleFNoYWRlcn1gO1xuICAgIH1cbiAgICByZXR1cm4ge3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJ9XG4gIH1cblxuICAvLz09PSBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgZGVhbGluZyB3aXRoIGNhcmV0cyBhbmQgc2VsZWN0aW9uIHJhbmdlcyA9PT0vL1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBUZXh0Q2FyZXRcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHggLSB4IHBvc2l0aW9uIG9mIHRoZSBjYXJldFxuICAgKiBAcHJvcGVydHkge251bWJlcn0geSAtIHkgcG9zaXRpb24gb2YgdGhlIGNhcmV0J3MgYm90dG9tXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSBoZWlnaHQgb2YgdGhlIGNhcmV0XG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjaGFySW5kZXggLSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsIGlucHV0IHN0cmluZyBvZiB0aGlzIGNhcmV0J3MgdGFyZ2V0XG4gICAqICAgY2hhcmFjdGVyOyB0aGUgY2FyZXQgd2lsbCBiZSBmb3IgdGhlIHBvc2l0aW9uIF9iZWZvcmVfIHRoYXQgY2hhcmFjdGVyLlxuICAgKi9cblxuICAvKipcbiAgICogR2l2ZW4gYSBsb2NhbCB4L3kgY29vcmRpbmF0ZSBpbiB0aGUgdGV4dCBibG9jayBwbGFuZSwgZmluZCB0aGUgbmVhcmVzdCBjYXJldCBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtUcm9pa2FUZXh0UmVuZGVySW5mb30gdGV4dFJlbmRlckluZm8gLSBhIHJlc3VsdCBvYmplY3QgZnJvbSBUZXh0QnVpbGRlciNnZXRUZXh0UmVuZGVySW5mb1xuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHtUZXh0Q2FyZXQgfCBudWxsfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0Q2FyZXRBdFBvaW50KHRleHRSZW5kZXJJbmZvLCB4LCB5KSB7XG4gICAgbGV0IGNsb3Nlc3RDYXJldCA9IG51bGw7XG4gICAgY29uc3Qgcm93cyA9IGdyb3VwQ2FyZXRzQnlSb3codGV4dFJlbmRlckluZm8pO1xuXG4gICAgLy8gRmluZCBuZWFyZXN0IHJvdyBieSB5IGZpcnN0XG4gICAgbGV0IGNsb3Nlc3RSb3cgPSBudWxsO1xuICAgIHJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgaWYgKCFjbG9zZXN0Um93IHx8IE1hdGguYWJzKHkgLSAocm93LnRvcCArIHJvdy5ib3R0b20pIC8gMikgPCBNYXRoLmFicyh5IC0gKGNsb3Nlc3RSb3cudG9wICsgY2xvc2VzdFJvdy5ib3R0b20pIC8gMikpIHtcbiAgICAgICAgY2xvc2VzdFJvdyA9IHJvdztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRoZW4gZmluZCBjbG9zZXN0IGNhcmV0IGJ5IHggd2l0aGluIHRoYXQgcm93XG4gICAgY2xvc2VzdFJvdy5jYXJldHMuZm9yRWFjaChjYXJldCA9PiB7XG4gICAgICBpZiAoIWNsb3Nlc3RDYXJldCB8fCBNYXRoLmFicyh4IC0gY2FyZXQueCkgPCBNYXRoLmFicyh4IC0gY2xvc2VzdENhcmV0LngpKSB7XG4gICAgICAgIGNsb3Nlc3RDYXJldCA9IGNhcmV0O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjbG9zZXN0Q2FyZXRcbiAgfVxuXG5cbiAgY29uc3QgX3JlY3RzQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4gIC8qKlxuICAgKiBHaXZlbiBzdGFydCBhbmQgZW5kIGNoYXJhY3RlciBpbmRleGVzLCByZXR1cm4gYSBsaXN0IG9mIHJlY3RhbmdsZXMgY292ZXJpbmcgYWxsIHRoZVxuICAgKiBjaGFyYWN0ZXJzIHdpdGhpbiB0aGF0IHNlbGVjdGlvbi5cbiAgICogQHBhcmFtIHtUcm9pa2FUZXh0UmVuZGVySW5mb30gdGV4dFJlbmRlckluZm9cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gaW5kZXggb2YgdGhlIGZpcnN0IGNoYXIgaW4gdGhlIHNlbGVjdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIC0gaW5kZXggb2YgdGhlIGZpcnN0IGNoYXIgYWZ0ZXIgdGhlIHNlbGVjdGlvblxuICAgKiBAcmV0dXJuIHtBcnJheTx7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfT4gfCBudWxsfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U2VsZWN0aW9uUmVjdHModGV4dFJlbmRlckluZm8sIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgcmVjdHM7XG4gICAgaWYgKHRleHRSZW5kZXJJbmZvKSB7XG4gICAgICAvLyBDaGVjayBjYWNoZSAtIHRleHRSZW5kZXJJbmZvIGlzIGZyb3plbiBzbyBpdCdzIHNhZmUgdG8gY2FjaGUgYmFzZWQgb24gaXRcbiAgICAgIGxldCBwcmV2UmVzdWx0ID0gX3JlY3RzQ2FjaGUuZ2V0KHRleHRSZW5kZXJJbmZvKTtcbiAgICAgIGlmIChwcmV2UmVzdWx0ICYmIHByZXZSZXN1bHQuc3RhcnQgPT09IHN0YXJ0ICYmIHByZXZSZXN1bHQuZW5kID09PSBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHByZXZSZXN1bHQucmVjdHNcbiAgICAgIH1cblxuICAgICAgY29uc3Qge2NhcmV0UG9zaXRpb25zfSA9IHRleHRSZW5kZXJJbmZvO1xuXG4gICAgICAvLyBOb3JtYWxpemVcbiAgICAgIGlmIChlbmQgPCBzdGFydCkge1xuICAgICAgICBjb25zdCBzID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICBlbmQgPSBzO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBNYXRoLm1heChzdGFydCwgMCk7XG4gICAgICBlbmQgPSBNYXRoLm1pbihlbmQsIGNhcmV0UG9zaXRpb25zLmxlbmd0aCArIDEpO1xuXG4gICAgICAvLyBCdWlsZCBsaXN0IG9mIHJlY3RzLCBleHBhbmRpbmcgdGhlIGN1cnJlbnQgcmVjdCBmb3IgYWxsIGNoYXJhY3RlcnMgaW4gYSBydW4gYW5kIHN0YXJ0aW5nXG4gICAgICAvLyBhIG5ldyByZWN0IHdoZW5ldmVyIHJlYWNoaW5nIGEgbmV3IGxpbmUgb3IgYSBuZXcgYmlkaSBkaXJlY3Rpb25cbiAgICAgIHJlY3RzID0gW107XG4gICAgICBsZXQgY3VycmVudFJlY3QgPSBudWxsO1xuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgY29uc3QgeDEgPSBjYXJldFBvc2l0aW9uc1tpICogNF07XG4gICAgICAgIGNvbnN0IHgyID0gY2FyZXRQb3NpdGlvbnNbaSAqIDQgKyAxXTtcbiAgICAgICAgY29uc3QgbGVmdCA9IE1hdGgubWluKHgxLCB4Mik7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gTWF0aC5tYXgoeDEsIHgyKTtcbiAgICAgICAgY29uc3QgYm90dG9tID0gY2FyZXRQb3NpdGlvbnNbaSAqIDQgKyAyXTtcbiAgICAgICAgY29uc3QgdG9wID0gY2FyZXRQb3NpdGlvbnNbaSAqIDQgKyAzXTtcbiAgICAgICAgaWYgKCFjdXJyZW50UmVjdCB8fCBib3R0b20gIT09IGN1cnJlbnRSZWN0LmJvdHRvbSB8fCB0b3AgIT09IGN1cnJlbnRSZWN0LnRvcCB8fCBsZWZ0ID4gY3VycmVudFJlY3QucmlnaHQgfHwgcmlnaHQgPCBjdXJyZW50UmVjdC5sZWZ0KSB7XG4gICAgICAgICAgY3VycmVudFJlY3QgPSB7XG4gICAgICAgICAgICBsZWZ0OiBJbmZpbml0eSxcbiAgICAgICAgICAgIHJpZ2h0OiAtSW5maW5pdHksXG4gICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICB0b3AsXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZWN0cy5wdXNoKGN1cnJlbnRSZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UmVjdC5sZWZ0ID0gTWF0aC5taW4obGVmdCwgY3VycmVudFJlY3QubGVmdCk7XG4gICAgICAgIGN1cnJlbnRSZWN0LnJpZ2h0ID0gTWF0aC5tYXgocmlnaHQsIGN1cnJlbnRSZWN0LnJpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgLy8gTWVyZ2UgYW55IG92ZXJsYXBwaW5nIHJlY3RzLCBlLmcuIHRob3NlIGZvcm1lZCBieSBhZGphY2VudCBiaWRpIHJ1bnNcbiAgICAgIHJlY3RzLnNvcnQoKGEsIGIpID0+IGIuYm90dG9tIC0gYS5ib3R0b20gfHwgYS5sZWZ0IC0gYi5sZWZ0KTtcbiAgICAgIGZvciAobGV0IGkgPSByZWN0cy5sZW5ndGggLSAxOyBpLS0gPiAwOykge1xuICAgICAgICBjb25zdCByZWN0QSA9IHJlY3RzW2ldO1xuICAgICAgICBjb25zdCByZWN0QiA9IHJlY3RzW2kgKyAxXTtcbiAgICAgICAgaWYgKHJlY3RBLmJvdHRvbSA9PT0gcmVjdEIuYm90dG9tICYmIHJlY3RBLnRvcCA9PT0gcmVjdEIudG9wICYmIHJlY3RBLmxlZnQgPD0gcmVjdEIucmlnaHQgJiYgcmVjdEEucmlnaHQgPj0gcmVjdEIubGVmdCkge1xuICAgICAgICAgIHJlY3RCLmxlZnQgPSBNYXRoLm1pbihyZWN0Qi5sZWZ0LCByZWN0QS5sZWZ0KTtcbiAgICAgICAgICByZWN0Qi5yaWdodCA9IE1hdGgubWF4KHJlY3RCLnJpZ2h0LCByZWN0QS5yaWdodCk7XG4gICAgICAgICAgcmVjdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9yZWN0c0NhY2hlLnNldCh0ZXh0UmVuZGVySW5mbywge3N0YXJ0LCBlbmQsIHJlY3RzfSk7XG4gICAgfVxuICAgIHJldHVybiByZWN0c1xuICB9XG5cbiAgY29uc3QgX2NhcmV0c0J5Um93Q2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4gIC8qKlxuICAgKiBHcm91cCBhIHNldCBvZiBjYXJldHMgYnkgcm93IG9mIHRleHQsIGNhY2hpbmcgdGhlIHJlc3VsdC4gQSBzaW5nbGUgcm93IG9mIHRleHQgbWF5IGNvbnRhaW4gY2FyZXRzIG9mXG4gICAqIGRpZmZlcmluZyBwb3NpdGlvbnMvaGVpZ2h0cyBpZiBpdCBoYXMgbXVsdGlwbGUgZm9udHMsIGFuZCB0aGV5IG1heSBvdmVybGFwIHNsaWdodGx5IGFjcm9zcyByb3dzLCBzbyB0aGlzXG4gICAqIHVzZXMgYW4gYXNzdW1wdGlvbiBvZiBcImF0IGxlYXN0IG92ZXJsYXBwaW5nIGJ5IGhhbGZcIiB0byBwdXQgdGhlbSBpbiB0aGUgc2FtZSByb3cuXG4gICAqIEByZXR1cm4gQXJyYXk8e2JvdHRvbTogbnVtYmVyLCB0b3A6IG51bWJlciwgY2FyZXRzOiBUZXh0Q2FyZXRbXX0+XG4gICAqL1xuICBmdW5jdGlvbiBncm91cENhcmV0c0J5Um93KHRleHRSZW5kZXJJbmZvKSB7XG4gICAgLy8gdGV4dFJlbmRlckluZm8gaXMgZnJvemVuIHNvIGl0J3Mgc2FmZSB0byBjYWNoZSBiYXNlZCBvbiBpdFxuICAgIGxldCByb3dzID0gX2NhcmV0c0J5Um93Q2FjaGUuZ2V0KHRleHRSZW5kZXJJbmZvKTtcbiAgICBpZiAoIXJvd3MpIHtcbiAgICAgIHJvd3MgPSBbXTtcbiAgICAgIGNvbnN0IHtjYXJldFBvc2l0aW9uc30gPSB0ZXh0UmVuZGVySW5mbztcbiAgICAgIGxldCBjdXJSb3c7XG5cbiAgICAgIGNvbnN0IHZpc2l0Q2FyZXQgPSAoeCwgYm90dG9tLCB0b3AsIGNoYXJJbmRleCkgPT4ge1xuICAgICAgICAvLyBuZXcgcm93IGlmIG5vdCBvdmVybGFwcGluZyBieSBhdCBsZWFzdCBoYWxmXG4gICAgICAgIGlmICghY3VyUm93IHx8ICh0b3AgPCAoY3VyUm93LnRvcCArIGN1clJvdy5ib3R0b20pIC8gMikpIHtcbiAgICAgICAgICByb3dzLnB1c2goY3VyUm93ID0ge2JvdHRvbSwgdG9wLCBjYXJldHM6IFtdfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXhwYW5kIHZlcnRpY2FsIGxpbWl0cyBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKHRvcCA+IGN1clJvdy50b3ApIGN1clJvdy50b3AgPSB0b3A7XG4gICAgICAgIGlmIChib3R0b20gPCBjdXJSb3cuYm90dG9tKSBjdXJSb3cuYm90dG9tID0gYm90dG9tO1xuICAgICAgICBjdXJSb3cuY2FyZXRzLnB1c2goe1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeTogYm90dG9tLFxuICAgICAgICAgIGhlaWdodDogdG9wIC0gYm90dG9tLFxuICAgICAgICAgIGNoYXJJbmRleCxcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKDsgaSA8IGNhcmV0UG9zaXRpb25zLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHZpc2l0Q2FyZXQoY2FyZXRQb3NpdGlvbnNbaV0sIGNhcmV0UG9zaXRpb25zW2kgKyAyXSwgY2FyZXRQb3NpdGlvbnNbaSArIDNdLCBpIC8gNCk7XG4gICAgICB9XG4gICAgICAvLyBBZGQgb25lIG1vcmUgY2FyZXQgYWZ0ZXIgdGhlIGZpbmFsIGNoYXJcbiAgICAgIHZpc2l0Q2FyZXQoY2FyZXRQb3NpdGlvbnNbaSAtIDNdLCBjYXJldFBvc2l0aW9uc1tpIC0gMl0sIGNhcmV0UG9zaXRpb25zW2kgLSAxXSwgaSAvIDQpO1xuICAgIH1cbiAgICBfY2FyZXRzQnlSb3dDYWNoZS5zZXQodGV4dFJlbmRlckluZm8sIHJvd3MpO1xuICAgIHJldHVybiByb3dzXG4gIH1cblxuICBleHBvcnRzLkJhdGNoZWRUZXh0ID0gQmF0Y2hlZFRleHQ7XG4gIGV4cG9ydHMuR2x5cGhzR2VvbWV0cnkgPSBHbHlwaHNHZW9tZXRyeTtcbiAgZXhwb3J0cy5UZXh0ID0gVGV4dDtcbiAgZXhwb3J0cy5jb25maWd1cmVUZXh0QnVpbGRlciA9IGNvbmZpZ3VyZVRleHRCdWlsZGVyO1xuICBleHBvcnRzLmNyZWF0ZVRleHREZXJpdmVkTWF0ZXJpYWwgPSBjcmVhdGVUZXh0RGVyaXZlZE1hdGVyaWFsO1xuICBleHBvcnRzLmR1bXBTREZUZXh0dXJlcyA9IGR1bXBTREZUZXh0dXJlcztcbiAgZXhwb3J0cy5mb250UmVzb2x2ZXJXb3JrZXJNb2R1bGUgPSBmb250UmVzb2x2ZXJXb3JrZXJNb2R1bGU7XG4gIGV4cG9ydHMuZ2V0Q2FyZXRBdFBvaW50ID0gZ2V0Q2FyZXRBdFBvaW50O1xuICBleHBvcnRzLmdldFNlbGVjdGlvblJlY3RzID0gZ2V0U2VsZWN0aW9uUmVjdHM7XG4gIGV4cG9ydHMuZ2V0VGV4dFJlbmRlckluZm8gPSBnZXRUZXh0UmVuZGVySW5mbztcbiAgZXhwb3J0cy5wcmVsb2FkRm9udCA9IHByZWxvYWRGb250O1xuICBleHBvcnRzLnR5cGVzZXR0ZXJXb3JrZXJNb2R1bGUgPSB0eXBlc2V0dGVyV29ya2VyTW9kdWxlO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/troika-three-text/dist/troika-three-text.umd.js\n");

/***/ })

};
;